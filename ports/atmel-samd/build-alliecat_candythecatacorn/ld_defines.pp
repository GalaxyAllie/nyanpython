# 1 "ld_defines.c"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 201112L
#define __STDC_UTF_16__ 1
#define __STDC_UTF_32__ 1
#define __STDC_HOSTED__ 1
#define __GNUC__ 9
#define __GNUC_MINOR__ 2
#define __GNUC_PATCHLEVEL__ 0
#define __VERSION__ "9.2.0"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __OPTIMIZE_SIZE__ 1
#define __OPTIMIZE__ 1
#define __FINITE_MATH_ONLY__ 0
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 8
#define __SIZEOF_SIZE_T__ 4
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 8
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 4
#define __SIZE_TYPE__ unsigned int
#define __PTRDIFF_TYPE__ int
#define __WCHAR_TYPE__ unsigned int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long long int
#define __UINTMAX_TYPE__ long long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ long unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ long int
#define __INT64_TYPE__ long long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ long unsigned int
#define __UINT64_TYPE__ long long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ long int
#define __INT_LEAST64_TYPE__ long long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ long unsigned int
#define __UINT_LEAST64_TYPE__ long long unsigned int
#define __INT_FAST8_TYPE__ int
#define __INT_FAST16_TYPE__ int
#define __INT_FAST32_TYPE__ int
#define __INT_FAST64_TYPE__ long long int
#define __UINT_FAST8_TYPE__ unsigned int
#define __UINT_FAST16_TYPE__ unsigned int
#define __UINT_FAST32_TYPE__ unsigned int
#define __UINT_FAST64_TYPE__ long long unsigned int
#define __INTPTR_TYPE__ int
#define __UINTPTR_TYPE__ unsigned int
#define __has_include(STR) __has_include__(STR)
#define __has_include_next(STR) __has_include_next__(STR)
#define __GXX_ABI_VERSION 1013
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0xffffffffU
#define __WCHAR_MIN__ 0U
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffff
#define __SIZE_MAX__ 0xffffffffU
#define __SCHAR_WIDTH__ 8
#define __SHRT_WIDTH__ 16
#define __INT_WIDTH__ 32
#define __LONG_WIDTH__ 32
#define __LONG_LONG_WIDTH__ 64
#define __WCHAR_WIDTH__ 32
#define __WINT_WIDTH__ 32
#define __PTRDIFF_WIDTH__ 32
#define __SIZE_WIDTH__ 32
#define __INTMAX_MAX__ 0x7fffffffffffffffLL
#define __INTMAX_C(c) c ## LL
#define __UINTMAX_MAX__ 0xffffffffffffffffULL
#define __UINTMAX_C(c) c ## ULL
#define __INTMAX_WIDTH__ 64
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffffL
#define __INT64_MAX__ 0x7fffffffffffffffLL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffUL
#define __UINT64_MAX__ 0xffffffffffffffffULL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST8_WIDTH__ 8
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST16_WIDTH__ 16
#define __INT_LEAST32_MAX__ 0x7fffffffL
#define __INT32_C(c) c ## L
#define __INT_LEAST32_WIDTH__ 32
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
#define __INT64_C(c) c ## LL
#define __INT_LEAST64_WIDTH__ 64
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffUL
#define __UINT32_C(c) c ## UL
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
#define __UINT64_C(c) c ## ULL
#define __INT_FAST8_MAX__ 0x7fffffff
#define __INT_FAST8_WIDTH__ 32
#define __INT_FAST16_MAX__ 0x7fffffff
#define __INT_FAST16_WIDTH__ 32
#define __INT_FAST32_MAX__ 0x7fffffff
#define __INT_FAST32_WIDTH__ 32
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
#define __INT_FAST64_WIDTH__ 64
#define __UINT_FAST8_MAX__ 0xffffffffU
#define __UINT_FAST16_MAX__ 0xffffffffU
#define __UINT_FAST32_MAX__ 0xffffffffU
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
#define __INTPTR_MAX__ 0x7fffffff
#define __INTPTR_WIDTH__ 32
#define __UINTPTR_MAX__ 0xffffffffU
#define __GCC_IEC_559 0
#define __GCC_IEC_559_COMPLEX 0
#define __FLT_EVAL_METHOD__ 0
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.4028234663852886e+38F
#define __FLT_MIN__ 1.1754943508222875e-38F
#define __FLT_EPSILON__ 1.1920928955078125e-7F
#define __FLT_DENORM_MIN__ 1.4012984643248171e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ ((double)1.7976931348623157e+308L)
#define __DBL_MIN__ ((double)2.2250738585072014e-308L)
#define __DBL_EPSILON__ ((double)2.2204460492503131e-16L)
#define __DBL_DENORM_MIN__ ((double)4.9406564584124654e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 53
#define __LDBL_DIG__ 15
#define __LDBL_MIN_EXP__ (-1021)
#define __LDBL_MIN_10_EXP__ (-307)
#define __LDBL_MAX_EXP__ 1024
#define __LDBL_MAX_10_EXP__ 308
#define __DECIMAL_DIG__ 17
#define __LDBL_DECIMAL_DIG__ 17
#define __LDBL_MAX__ 1.7976931348623157e+308L
#define __LDBL_MIN__ 2.2250738585072014e-308L
#define __LDBL_EPSILON__ 2.2204460492503131e-16L
#define __LDBL_DENORM_MIN__ 4.9406564584124654e-324L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __FLT32_MANT_DIG__ 24
#define __FLT32_DIG__ 6
#define __FLT32_MIN_EXP__ (-125)
#define __FLT32_MIN_10_EXP__ (-37)
#define __FLT32_MAX_EXP__ 128
#define __FLT32_MAX_10_EXP__ 38
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT32_MAX__ 3.4028234663852886e+38F32
#define __FLT32_MIN__ 1.1754943508222875e-38F32
#define __FLT32_EPSILON__ 1.1920928955078125e-7F32
#define __FLT32_DENORM_MIN__ 1.4012984643248171e-45F32
#define __FLT32_HAS_DENORM__ 1
#define __FLT32_HAS_INFINITY__ 1
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT64_MANT_DIG__ 53
#define __FLT64_DIG__ 15
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT64_MAX_EXP__ 1024
#define __FLT64_MAX_10_EXP__ 308
#define __FLT64_DECIMAL_DIG__ 17
#define __FLT64_MAX__ 1.7976931348623157e+308F64
#define __FLT64_MIN__ 2.2250738585072014e-308F64
#define __FLT64_EPSILON__ 2.2204460492503131e-16F64
#define __FLT64_DENORM_MIN__ 4.9406564584124654e-324F64
#define __FLT64_HAS_DENORM__ 1
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT32X_MANT_DIG__ 53
#define __FLT32X_DIG__ 15
#define __FLT32X_MIN_EXP__ (-1021)
#define __FLT32X_MIN_10_EXP__ (-307)
#define __FLT32X_MAX_EXP__ 1024
#define __FLT32X_MAX_10_EXP__ 308
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT32X_MAX__ 1.7976931348623157e+308F32x
#define __FLT32X_MIN__ 2.2250738585072014e-308F32x
#define __FLT32X_EPSILON__ 2.2204460492503131e-16F32x
#define __FLT32X_DENORM_MIN__ 4.9406564584124654e-324F32x
#define __FLT32X_HAS_DENORM__ 1
#define __FLT32X_HAS_INFINITY__ 1
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __SFRACT_FBIT__ 7
#define __SFRACT_IBIT__ 0
#define __SFRACT_MIN__ (-0.5HR-0.5HR)
#define __SFRACT_MAX__ 0X7FP-7HR
#define __SFRACT_EPSILON__ 0x1P-7HR
#define __USFRACT_FBIT__ 8
#define __USFRACT_IBIT__ 0
#define __USFRACT_MIN__ 0.0UHR
#define __USFRACT_MAX__ 0XFFP-8UHR
#define __USFRACT_EPSILON__ 0x1P-8UHR
#define __FRACT_FBIT__ 15
#define __FRACT_IBIT__ 0
#define __FRACT_MIN__ (-0.5R-0.5R)
#define __FRACT_MAX__ 0X7FFFP-15R
#define __FRACT_EPSILON__ 0x1P-15R
#define __UFRACT_FBIT__ 16
#define __UFRACT_IBIT__ 0
#define __UFRACT_MIN__ 0.0UR
#define __UFRACT_MAX__ 0XFFFFP-16UR
#define __UFRACT_EPSILON__ 0x1P-16UR
#define __LFRACT_FBIT__ 31
#define __LFRACT_IBIT__ 0
#define __LFRACT_MIN__ (-0.5LR-0.5LR)
#define __LFRACT_MAX__ 0X7FFFFFFFP-31LR
#define __LFRACT_EPSILON__ 0x1P-31LR
#define __ULFRACT_FBIT__ 32
#define __ULFRACT_IBIT__ 0
#define __ULFRACT_MIN__ 0.0ULR
#define __ULFRACT_MAX__ 0XFFFFFFFFP-32ULR
#define __ULFRACT_EPSILON__ 0x1P-32ULR
#define __LLFRACT_FBIT__ 63
#define __LLFRACT_IBIT__ 0
#define __LLFRACT_MIN__ (-0.5LLR-0.5LLR)
#define __LLFRACT_MAX__ 0X7FFFFFFFFFFFFFFFP-63LLR
#define __LLFRACT_EPSILON__ 0x1P-63LLR
#define __ULLFRACT_FBIT__ 64
#define __ULLFRACT_IBIT__ 0
#define __ULLFRACT_MIN__ 0.0ULLR
#define __ULLFRACT_MAX__ 0XFFFFFFFFFFFFFFFFP-64ULLR
#define __ULLFRACT_EPSILON__ 0x1P-64ULLR
#define __SACCUM_FBIT__ 7
#define __SACCUM_IBIT__ 8
#define __SACCUM_MIN__ (-0X1P7HK-0X1P7HK)
#define __SACCUM_MAX__ 0X7FFFP-7HK
#define __SACCUM_EPSILON__ 0x1P-7HK
#define __USACCUM_FBIT__ 8
#define __USACCUM_IBIT__ 8
#define __USACCUM_MIN__ 0.0UHK
#define __USACCUM_MAX__ 0XFFFFP-8UHK
#define __USACCUM_EPSILON__ 0x1P-8UHK
#define __ACCUM_FBIT__ 15
#define __ACCUM_IBIT__ 16
#define __ACCUM_MIN__ (-0X1P15K-0X1P15K)
#define __ACCUM_MAX__ 0X7FFFFFFFP-15K
#define __ACCUM_EPSILON__ 0x1P-15K
#define __UACCUM_FBIT__ 16
#define __UACCUM_IBIT__ 16
#define __UACCUM_MIN__ 0.0UK
#define __UACCUM_MAX__ 0XFFFFFFFFP-16UK
#define __UACCUM_EPSILON__ 0x1P-16UK
#define __LACCUM_FBIT__ 31
#define __LACCUM_IBIT__ 32
#define __LACCUM_MIN__ (-0X1P31LK-0X1P31LK)
#define __LACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LK
#define __LACCUM_EPSILON__ 0x1P-31LK
#define __ULACCUM_FBIT__ 32
#define __ULACCUM_IBIT__ 32
#define __ULACCUM_MIN__ 0.0ULK
#define __ULACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULK
#define __ULACCUM_EPSILON__ 0x1P-32ULK
#define __LLACCUM_FBIT__ 31
#define __LLACCUM_IBIT__ 32
#define __LLACCUM_MIN__ (-0X1P31LLK-0X1P31LLK)
#define __LLACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LLK
#define __LLACCUM_EPSILON__ 0x1P-31LLK
#define __ULLACCUM_FBIT__ 32
#define __ULLACCUM_IBIT__ 32
#define __ULLACCUM_MIN__ 0.0ULLK
#define __ULLACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULLK
#define __ULLACCUM_EPSILON__ 0x1P-32ULLK
#define __QQ_FBIT__ 7
#define __QQ_IBIT__ 0
#define __HQ_FBIT__ 15
#define __HQ_IBIT__ 0
#define __SQ_FBIT__ 31
#define __SQ_IBIT__ 0
#define __DQ_FBIT__ 63
#define __DQ_IBIT__ 0
#define __TQ_FBIT__ 127
#define __TQ_IBIT__ 0
#define __UQQ_FBIT__ 8
#define __UQQ_IBIT__ 0
#define __UHQ_FBIT__ 16
#define __UHQ_IBIT__ 0
#define __USQ_FBIT__ 32
#define __USQ_IBIT__ 0
#define __UDQ_FBIT__ 64
#define __UDQ_IBIT__ 0
#define __UTQ_FBIT__ 128
#define __UTQ_IBIT__ 0
#define __HA_FBIT__ 7
#define __HA_IBIT__ 8
#define __SA_FBIT__ 15
#define __SA_IBIT__ 16
#define __DA_FBIT__ 31
#define __DA_IBIT__ 32
#define __TA_FBIT__ 63
#define __TA_IBIT__ 64
#define __UHA_FBIT__ 8
#define __UHA_IBIT__ 8
#define __USA_FBIT__ 16
#define __USA_IBIT__ 16
#define __UDA_FBIT__ 32
#define __UDA_IBIT__ 32
#define __UTA_FBIT__ 64
#define __UTA_IBIT__ 64
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __CHAR_UNSIGNED__ 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 1
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 1
#define __GCC_ATOMIC_SHORT_LOCK_FREE 1
#define __GCC_ATOMIC_INT_LOCK_FREE 1
#define __GCC_ATOMIC_LONG_LOCK_FREE 1
#define __GCC_ATOMIC_LLONG_LOCK_FREE 1
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 1
#define __HAVE_SPECULATION_SAFE_VALUE 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 4
#undef __ARM_FEATURE_DSP
# 1 "<built-in>"
#undef __ARM_FEATURE_QBIT
# 1 "<built-in>"
#undef __ARM_FEATURE_SAT
# 1 "<built-in>"
#undef __ARM_FEATURE_CRYPTO
# 1 "<built-in>"
#undef __ARM_FEATURE_UNALIGNED
# 1 "<built-in>"
#undef __ARM_FEATURE_QRDMX
# 1 "<built-in>"
#undef __ARM_FEATURE_CRC32
# 1 "<built-in>"
#undef __ARM_FEATURE_DOTPROD
# 1 "<built-in>"
#undef __ARM_FEATURE_COMPLEX
# 1 "<built-in>"
#undef __ARM_32BIT_STATE
# 1 "<built-in>"
#undef __ARM_FEATURE_CMSE
# 1 "<built-in>"
#undef __ARM_FEATURE_LDREX
# 1 "<built-in>"
#undef __ARM_FEATURE_CLZ
# 1 "<built-in>"
#undef __ARM_FEATURE_NUMERIC_MAXMIN
# 1 "<built-in>"
#undef __ARM_FEATURE_SIMD32
# 1 "<built-in>"
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 4
#undef __ARM_ARCH_PROFILE
# 1 "<built-in>"
#define __ARM_ARCH_PROFILE 77
#define __arm__ 1
#undef __ARM_ARCH
# 1 "<built-in>"
#define __ARM_ARCH 6
#define __APCS_32__ 1
#define __thumb__ 1
#undef __thumb2__
# 1 "<built-in>"
#define __THUMBEL__ 1
#undef __ARM_ARCH_ISA_THUMB
# 1 "<built-in>"
#define __ARM_ARCH_ISA_THUMB 1
#define __ARMEL__ 1
#define __SOFTFP__ 1
#define __VFP_FP__ 1
#undef __ARM_FP
# 1 "<built-in>"
#undef __ARM_FP16_FORMAT_IEEE
# 1 "<built-in>"
#undef __ARM_FP16_FORMAT_ALTERNATIVE
# 1 "<built-in>"
#undef __ARM_FP16_ARGS
# 1 "<built-in>"
#undef __ARM_FEATURE_FP16_SCALAR_ARITHMETIC
# 1 "<built-in>"
#undef __ARM_FEATURE_FP16_VECTOR_ARITHMETIC
# 1 "<built-in>"
#undef __ARM_FEATURE_FP16_FML
# 1 "<built-in>"
#undef __ARM_FEATURE_FMA
# 1 "<built-in>"
#undef __ARM_NEON__
# 1 "<built-in>"
#undef __ARM_NEON
# 1 "<built-in>"
#undef __ARM_NEON_FP
# 1 "<built-in>"
#define __THUMB_INTERWORK__ 1
#define __ARM_ARCH_6M__ 1
#define __ARM_PCS 1
#define __ARM_EABI__ 1
#undef __ARM_ARCH_EXT_IDIV__
# 1 "<built-in>"
#undef __ARM_FEATURE_IDIV
# 1 "<built-in>"
#undef __ARM_ASM_SYNTAX_UNIFIED__
# 1 "<built-in>"
#undef __ARM_FEATURE_COPROC
# 1 "<built-in>"
#define __GXX_TYPEINFO_EQUALITY_INLINE 0
#define __ELF__ 1
# 1 "<command-line>"
#define __USES_INITFINI__ 1
#define CIRCUITPY_FULL_BUILD 0
#define CIRCUITPY_MINIMAL_BUILD 0
#define CIRCUITPY_DEFAULT_BUILD 1
#define CIRCUITPY_ALWAYS_BUILD 1
#define CIRCUITPY_ANALOGIO 1
#define CIRCUITPY_AUDIOBUSIO 0
#define CIRCUITPY_AUDIOIO 0
#define CIRCUITPY_AUDIOIO_COMPAT 0
#define CIRCUITPY_AUDIOPWMIO 0
#define CIRCUITPY_AUDIOCORE 0
#define CIRCUITPY_AUDIOMIXER 0
#define CIRCUITPY_AUDIOMP3 0
#define CIRCUITPY_BITBANGIO 0
#define CIRCUITPY_BLEIO 0
#define CIRCUITPY_BOARD 1
#define CIRCUITPY_BUSIO 1
#define CIRCUITPY_DIGITALIO 1
#define CIRCUITPY_DISPLAYIO 0
#define CIRCUITPY_FREQUENCYIO 0
#define CIRCUITPY_GAMEPAD 0
#define CIRCUITPY_GAMEPADSHIFT 0
#define CIRCUITPY_I2CSLAVE 0
#define CIRCUITPY_MATH 1
#define CIRCUITPY__EVE 0
#define CIRCUITPY_MICROCONTROLLER 1
#define CIRCUITPY_NEOPIXEL_WRITE 1
#define CIRCUITPY_NETWORK 0
#define CIRCUITPY_NVM 1
#define CIRCUITPY_OS 1
#define CIRCUITPY_PIXELBUF 0
#define CIRCUITPY_PULSEIO 1
#define CIRCUITPY_PS2IO 0
#define CIRCUITPY_RANDOM 1
#define CIRCUITPY_ROTARYIO 1
#define CIRCUITPY_RTC 1
#define CIRCUITPY_SAMD 0
#define CIRCUITPY_STAGE 0
#define CIRCUITPY_STORAGE 1
#define CIRCUITPY_STRUCT 1
#define CIRCUITPY_SUPERVISOR 1
#define CIRCUITPY_TIME 1
#define CIRCUITPY_TOUCHIO_USE_NATIVE 1
#define CIRCUITPY_TOUCHIO 1
#define CIRCUITPY_UHEAP 0
#define CIRCUITPY_USB_HID 1
#define CIRCUITPY_USB_MIDI 1
#define CIRCUITPY_PEW 0
#define CIRCUITPY_USTACK 0
#define CIRCUITPY_BITBANG_APA102 0
#define CIRCUITPY_REQUIRE_I2C_PULLUPS 1
#define CIRCUITPY_SERIAL_BLE 0
#define CIRCUITPY_BLE_FILE_SERVICE 0
#define CIRCUITPY_SERIAL_UART 0
#define CIRCUITPY_ENABLE_MPY_NATIVE 0
#define INTERNAL_FLASH_FILESYSTEM 1
#define QSPI_FLASH_FILESYSTEM 0
#define SPI_FLASH_FILESYSTEM 0
#define USB_AVAILABLE 1
#define LONGINT_IMPL_NONE 1
#define NDEBUG 1
#define CFG_TUSB_MCU OPT_MCU_SAMD21
#define CFG_TUD_MIDI_RX_BUFSIZE 128
#define CFG_TUD_CDC_RX_BUFSIZE 128
#define CFG_TUD_MIDI_TX_BUFSIZE 128
#define CFG_TUD_CDC_TX_BUFSIZE 128
#define CFG_TUD_MSC_BUFSIZE 512
#define __SAMD21E18A__ 1
#define CIRCUITPY_SOFTWARE_SAFE_MODE 0x0ADABEEF
#define CIRCUITPY_CANARY_WORD 0xADAF00
#define CIRCUITPY_SAFE_RESTART_WORD 0xDEADBEEF
#define FFCONF_H "lib/oofatfs/ffconf.h"
#define SAMD21 1
# 1 "ld_defines.c"
// Fake source file used only to capture #define values for use in ld template files.
#include "mpconfigport.h"
# 2 "ld_defines.c"
# 1 "mpconfigport.h" 1
/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Dan Halbert for Adafruit Industries
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#define __INCLUDED_MPCONFIGPORT_H 

// Definitions for which SAMD chip we're using.
#include "include/sam.h"
# 31 "mpconfigport.h"
# 1 "asf4/samd21/include/sam.h" 1
/**
 * \file
 *
 * \brief Top level header file
 *
 * Copyright (c) 2017 Atmel Corporation, a wholly owned subsidiary of Microchip Technology Inc.
 *
 * \license_start
 *
 * \page License
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \license_stop
 *
 */


#define _SAM_ 
# 38 "asf4/samd21/include/sam.h"
#include "samd21e18a.h"
# 38 "asf4/samd21/include/sam.h"
# 1 "asf4/samd21/include/samd21e18a.h" 1
/**
 * \file
 *
 * \brief Header file for SAMD21E18A
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21E18A_ 

/**
 * \ingroup SAMD21_definitions
 * \addtogroup SAMD21E18A_definitions SAMD21E18A definitions
 * This file defines all structures and symbols for SAMD21E18A:
 *   - registers and bitfields
 *   - peripheral base address
 *   - peripheral ID
 *   - PIO definitions
*/
/*@{*/






#include <stdint.h>
# 49 "asf4/samd21/include/samd21e18a.h"
# 1 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdint.h" 3 4
#include_next <stdint.h>
# 9 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdint.h" 3 4
# 1 "/usr/arm-none-eabi/include/stdint.h" 1 3 4

# 1 "/usr/arm-none-eabi/include/stdint.h" 3 4
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */


#define _STDINT_H 

#include <machine/_default_types.h>
# 12 "/usr/arm-none-eabi/include/stdint.h" 3 4
# 1 "/usr/arm-none-eabi/include/machine/_default_types.h" 1 3 4
/*
 *  $Id$
 */


#define _MACHINE__DEFAULT_TYPES_H 

#include <sys/features.h>
# 8 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
# 1 "/usr/arm-none-eabi/include/sys/features.h" 1 3 4
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */


#define _SYS_FEATURES_H 





#include <_newlib_version.h>
# 28 "/usr/arm-none-eabi/include/sys/features.h" 3 4
# 1 "/usr/arm-none-eabi/include/_newlib_version.h" 1 3 4
/* _newlib_version.h.  Generated from _newlib_version.hin by configure.  */
/* Version macros for internal and downstream use. */

#define _NEWLIB_VERSION_H__ 1

#define _NEWLIB_VERSION "3.1.0"
#define __NEWLIB__ 3
#define __NEWLIB_MINOR__ 1
#define __NEWLIB_PATCHLEVEL__ 0
# 29 "/usr/arm-none-eabi/include/sys/features.h" 2 3 4

/* Macro to test version of GCC.  Returns 0 for non-GCC or too old GCC. */


#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))





/* Version with trailing underscores for BSD compatibility. */
#define __GNUC_PREREQ__(ma,mi) __GNUC_PREREQ(ma, mi)


/*
 * Feature test macros control which symbols are exposed by the system
 * headers.  Any of these must be defined before including any headers.
 *
 * __STRICT_ANSI__ (defined by gcc -ansi, -std=c90, -std=c99, or -std=c11)
 *	ISO C
 *
 * _POSIX_SOURCE (deprecated by _POSIX_C_SOURCE=1)
 * _POSIX_C_SOURCE >= 1
 * 	POSIX.1-1990
 *
 * _POSIX_C_SOURCE >= 2
 * 	POSIX.2-1992
 *
 * _POSIX_C_SOURCE >= 199309L
 * 	POSIX.1b-1993 Real-time extensions
 *
 * _POSIX_C_SOURCE >= 199506L
 * 	POSIX.1c-1995 Threads extensions
 *
 * _POSIX_C_SOURCE >= 200112L
 * 	POSIX.1-2001 and C99
 *
 * _POSIX_C_SOURCE >= 200809L
 * 	POSIX.1-2008
 *
 * _XOPEN_SOURCE
 *	POSIX.1-1990 and XPG4
 *
 * _XOPEN_SOURCE_EXTENDED
 *	SUSv1 (POSIX.2-1992 plus XPG4v2)
 *
 * _XOPEN_SOURCE >= 500
 *	SUSv2 (POSIX.1c-1995 plus XSI)
 *
 * _XOPEN_SOURCE >= 600
 *	SUSv3 (POSIX.1-2001 plus XSI) and C99
 *
 * _XOPEN_SOURCE >= 700
 *	SUSv4 (POSIX.1-2008 plus XSI)
 *
 * _ISOC99_SOURCE or gcc -std=c99 or g++
 * 	ISO C99
 *
 * _ISOC11_SOURCE or gcc -std=c11 or g++ -std=c++11
 * 	ISO C11
 *
 * _ATFILE_SOURCE (implied by _POSIX_C_SOURCE >= 200809L)
 *	"at" functions
 *
 * _LARGEFILE_SOURCE (deprecated by _XOPEN_SOURCE >= 500)
 *	fseeko, ftello
 *
 * _GNU_SOURCE
 * 	All of the above plus GNU extensions
 *
 * _BSD_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _SVID_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _DEFAULT_SOURCE (or none of the above)
 * 	POSIX-1.2008 with BSD and SVr4 extensions
 *
 * _FORTIFY_SOURCE = 1 or 2
 * 	Object Size Checking function wrappers
 */
# 131 "/usr/arm-none-eabi/include/sys/features.h" 3 4
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1



#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
# 158 "/usr/arm-none-eabi/include/sys/features.h" 3 4
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1


/*
 * The following private macros are used throughout the headers to control
 * which symbols should be exposed.  They are for internal use only, as
 * indicated by the leading double underscore, and must never be used outside
 * of these headers.
 *
 * __POSIX_VISIBLE
 * 	any version of POSIX.1; enabled by default, or with _POSIX_SOURCE,
 * 	any value of _POSIX_C_SOURCE, or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 2
 * 	POSIX.2-1992; enabled by default, with _POSIX_C_SOURCE >= 2,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199309
 * 	POSIX.1b-1993; enabled by default, with _POSIX_C_SOURCE >= 199309L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199506
 * 	POSIX.1c-1995; enabled by default, with _POSIX_C_SOURCE >= 199506L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 200112
 * 	POSIX.1-2001; enabled by default, with _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __POSIX_VISIBLE >= 200809
 * 	POSIX.1-2008; enabled by default, with _POSIX_C_SOURCE >= 200809L,
 * 	or _XOPEN_SOURCE >= 700.
 *
 * __XSI_VISIBLE
 *	XPG4 XSI extensions; enabled with any version of _XOPEN_SOURCE.
 *
 * __XSI_VISIBLE >= 4
 *	SUSv1 XSI extensions; enabled with both _XOPEN_SOURCE and
 * 	_XOPEN_SOURCE_EXTENDED together.
 *
 * __XSI_VISIBLE >= 500
 *	SUSv2 XSI extensions; enabled with _XOPEN_SOURCE >= 500.
 *
 * __XSI_VISIBLE >= 600
 *	SUSv3 XSI extensions; enabled with _XOPEN_SOURCE >= 600.
 *
 * __XSI_VISIBLE >= 700
 *	SUSv4 XSI extensions; enabled with _XOPEN_SOURCE >= 700.
 *
 * __ISO_C_VISIBLE >= 1999
 * 	ISO C99; enabled with gcc -std=c99 or newer (on by default since GCC 5),
 * 	any version of C++, or with _ISOC99_SOURCE, _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __ISO_C_VISIBLE >= 2011
 * 	ISO C11; enabled with gcc -std=c11 or newer (on by default since GCC 5),
 * 	g++ -std=c++11 or newer (on by default since GCC 6), or with
 * 	_ISOC11_SOURCE.
 *
 * __ATFILE_VISIBLE
 *	"at" functions; enabled by default, with _ATFILE_SOURCE,
 * 	_POSIX_C_SOURCE >= 200809L, or _XOPEN_SOURCE >= 700.
 *
 * __LARGEFILE_VISIBLE
 *	fseeko, ftello; enabled with _LARGEFILE_SOURCE or _XOPEN_SOURCE >= 500.
 *
 * __BSD_VISIBLE
 * 	BSD extensions; enabled by default, or with _BSD_SOURCE.
 *
 * __SVID_VISIBLE
 * 	SVr4 extensions; enabled by default, or with _SVID_SOURCE.
 *
 * __MISC_VISIBLE
 * 	Extensions found in both BSD and SVr4 (shorthand for
 * 	(__BSD_VISIBLE || __SVID_VISIBLE)), or newlib-specific
 * 	extensions; enabled by default.
 *
 * __GNU_VISIBLE
 * 	GNU extensions; enabled with _GNU_SOURCE.
 *
 * __SSP_FORTIFY_LEVEL
 * 	Object Size Checking; defined to 0 (off), 1, or 2.
 *
 * In all cases above, "enabled by default" means either by defining
 * _DEFAULT_SOURCE, or by not defining any of the public feature test macros.
 */


#define __ATFILE_VISIBLE 1





#define __BSD_VISIBLE 1







#define __GNU_VISIBLE 0




#define __ISO_C_VISIBLE 2011
# 277 "/usr/arm-none-eabi/include/sys/features.h" 3 4
#define __LARGEFILE_VISIBLE 0



#define __MISC_VISIBLE 1





#define __POSIX_VISIBLE 200809
# 303 "/usr/arm-none-eabi/include/sys/features.h" 3 4
#define __SVID_VISIBLE 1
# 319 "/usr/arm-none-eabi/include/sys/features.h" 3 4
#define __XSI_VISIBLE 0
# 330 "/usr/arm-none-eabi/include/sys/features.h" 3 4
#define __SSP_FORTIFY_LEVEL 0


/* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  */
# 390 "/usr/arm-none-eabi/include/sys/features.h" 3 4
/* XMK loosely adheres to POSIX -- 1003.1 */
# 9 "/usr/arm-none-eabi/include/machine/_default_types.h" 2 3 4

/*
 * Guess on types by examining *_MIN / *_MAX defines.
 */

/* GCC >= 3.3.0 has __<val>__ implicitly defined. */
#define __EXP(x) __ ##x ##__






/* Check if "long long" is 64bit wide */
/* Modern GCCs provide __LONG_LONG_MAX__, SUSv3 wants LLONG_MAX */


#define __have_longlong64 1


/* Check if "long" is 64bit or 32bit wide */



#define __have_long32 1







typedef signed char __int8_t;

typedef unsigned char __uint8_t;



#define ___int8_t_defined 1







typedef short int __int16_t;

typedef short unsigned int __uint16_t;



#define ___int16_t_defined 1
# 77 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long int __int32_t;

typedef long unsigned int __uint32_t;



#define ___int32_t_defined 1
# 103 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;



#define ___int64_t_defined 1
# 134 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;



#define ___int_least8_t_defined 1
# 160 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;



#define ___int_least16_t_defined 1
# 182 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;



#define ___int_least32_t_defined 1
# 200 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;



#define ___int_least64_t_defined 1







typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 244 "/usr/arm-none-eabi/include/machine/_default_types.h" 3 4
#undef __EXP
# 13 "/usr/arm-none-eabi/include/stdint.h" 2 3 4
#include <sys/_intsup.h>
# 13 "/usr/arm-none-eabi/include/stdint.h" 3 4
# 1 "/usr/arm-none-eabi/include/sys/_intsup.h" 1 3 4
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */


#define _SYS__INTSUP_H 

#include <sys/features.h>
# 12 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
# 1 "/usr/arm-none-eabi/include/sys/features.h" 1 3 4
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
# 13 "/usr/arm-none-eabi/include/sys/_intsup.h" 2 3 4


/* gcc > 3.2 implicitly defines the values we are interested */
#define __STDINT_EXP(x) __ ##x ##__





/* Determine how intptr_t and intN_t fastN_t and leastN_t are defined by gcc
   for this target.  This is used to determine the correct printf() constant in
   inttypes.h and other  constants in stdint.h.
   So we end up with
   ?(signed|unsigned) char == 0
   ?(signed|unsigned) short == 1
   ?(signed|unsigned) int == 2
   ?(signed|unsigned) short int == 3
   ?(signed|unsigned) long == 4
   ?(signed|unsigned) long int == 6
   ?(signed|unsigned) long long == 8
   ?(signed|unsigned) long long int == 10
 */
       
       
       
       
       
       
       
#undef signed
#undef unsigned
#undef char
#undef short
#undef int
#undef __int20
#undef long
#define signed +0
#define unsigned +0
#define char +0
#define short +1
#define __int20 +2
#define int +2
#define long +4
# 64 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define _INTPTR_EQ_INT 






#define _INT32_EQ_LONG 







#define __INT8 "hh"
# 90 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __INT16 "h"
# 101 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __INT32 "l"
# 110 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __INT64 "ll"






#define __FAST8 
# 126 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __FAST16 






#define __FAST32 
# 144 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __FAST64 "ll"



#define __LEAST8 "hh"
# 159 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __LEAST16 "h"
# 170 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __LEAST32 "l"
# 179 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __LEAST64 "ll"

#undef signed
#undef unsigned
#undef char
#undef short
#undef int
#undef long
       
       
       
       
       
# 191 "/usr/arm-none-eabi/include/sys/_intsup.h" 3 4
#undef __int20
       
       
# 14 "/usr/arm-none-eabi/include/stdint.h" 2 3 4
#include <sys/_stdint.h>
# 14 "/usr/arm-none-eabi/include/stdint.h" 3 4
# 1 "/usr/arm-none-eabi/include/sys/_stdint.h" 1 3 4
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */


#define _SYS__STDINT_H 

#include <machine/_default_types.h>
# 12 "/usr/arm-none-eabi/include/sys/_stdint.h" 3 4
# 1 "/usr/arm-none-eabi/include/machine/_default_types.h" 1 3 4
/*
 *  $Id$
 */
# 13 "/usr/arm-none-eabi/include/sys/_stdint.h" 2 3 4







typedef __int8_t int8_t ;
#define _INT8_T_DECLARED 


typedef __uint8_t uint8_t ;
#define _UINT8_T_DECLARED 

#define __int8_t_defined 1




typedef __int16_t int16_t ;
#define _INT16_T_DECLARED 


typedef __uint16_t uint16_t ;
#define _UINT16_T_DECLARED 

#define __int16_t_defined 1




typedef __int32_t int32_t ;
#define _INT32_T_DECLARED 


typedef __uint32_t uint32_t ;
#define _UINT32_T_DECLARED 

#define __int32_t_defined 1




typedef __int64_t int64_t ;
#define _INT64_T_DECLARED 


typedef __uint64_t uint64_t ;
#define _UINT64_T_DECLARED 

#define __int64_t_defined 1



typedef __intmax_t intmax_t;
#define _INTMAX_T_DECLARED 



typedef __uintmax_t uintmax_t;
#define _UINTMAX_T_DECLARED 



typedef __intptr_t intptr_t;
#define _INTPTR_T_DECLARED 



typedef __uintptr_t uintptr_t;
#define _UINTPTR_T_DECLARED 
# 15 "/usr/arm-none-eabi/include/stdint.h" 2 3 4






typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;
#define __int_least8_t_defined 1



typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;
#define __int_least16_t_defined 1



typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;
#define __int_least32_t_defined 1



typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
#define __int_least64_t_defined 1


/*
 * Fastest minimum-width integer types
 *
 * Assume int to be the fastest type for all types with a width 
 * less than __INT_MAX__ rsp. INT_MAX
 */

  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
#define __int_fast8_t_defined 1







  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
#define __int_fast16_t_defined 1







  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
#define __int_fast32_t_defined 1







  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
#define __int_fast64_t_defined 1






/*
 * Fall back to [u]int_least<N>_t for [u]int_fast<N>_t types
 * not having been defined, yet.
 * Leave undefined, if [u]int_least<N>_t should not be available.
 */
# 128 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INTPTR_MIN (-__INTPTR_MAX__ - 1)
#define INTPTR_MAX (__INTPTR_MAX__)
#define UINTPTR_MAX (__UINTPTR_MAX__)
# 149 "/usr/arm-none-eabi/include/stdint.h" 3 4
/* Limits of Specified-Width Integer Types */


#define INT8_MIN (-__INT8_MAX__ - 1)
#define INT8_MAX (__INT8_MAX__)
#define UINT8_MAX (__UINT8_MAX__)







#define INT_LEAST8_MIN (-__INT_LEAST8_MAX__ - 1)
#define INT_LEAST8_MAX (__INT_LEAST8_MAX__)
#define UINT_LEAST8_MAX (__UINT_LEAST8_MAX__)
# 174 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT16_MIN (-__INT16_MAX__ - 1)
#define INT16_MAX (__INT16_MAX__)
#define UINT16_MAX (__UINT16_MAX__)







#define INT_LEAST16_MIN (-__INT_LEAST16_MAX__ - 1)
#define INT_LEAST16_MAX (__INT_LEAST16_MAX__)
#define UINT_LEAST16_MAX (__UINT_LEAST16_MAX__)
# 196 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT32_MIN (-__INT32_MAX__ - 1)
#define INT32_MAX (__INT32_MAX__)
#define UINT32_MAX (__UINT32_MAX__)
# 212 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT_LEAST32_MIN (-__INT_LEAST32_MAX__ - 1)
#define INT_LEAST32_MAX (__INT_LEAST32_MAX__)
#define UINT_LEAST32_MAX (__UINT_LEAST32_MAX__)
# 230 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT64_MIN (-__INT64_MAX__ - 1)
#define INT64_MAX (__INT64_MAX__)
#define UINT64_MAX (__UINT64_MAX__)
# 246 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT_LEAST64_MIN (-__INT_LEAST64_MAX__ - 1)
#define INT_LEAST64_MAX (__INT_LEAST64_MAX__)
#define UINT_LEAST64_MAX (__UINT_LEAST64_MAX__)
# 262 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST8_MIN (-__INT_FAST8_MAX__ - 1)
#define INT_FAST8_MAX (__INT_FAST8_MAX__)
#define UINT_FAST8_MAX (__UINT_FAST8_MAX__)
# 278 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST16_MIN (-__INT_FAST16_MAX__ - 1)
#define INT_FAST16_MAX (__INT_FAST16_MAX__)
#define UINT_FAST16_MAX (__UINT_FAST16_MAX__)
# 294 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST32_MIN (-__INT_FAST32_MAX__ - 1)
#define INT_FAST32_MAX (__INT_FAST32_MAX__)
#define UINT_FAST32_MAX (__UINT_FAST32_MAX__)
# 310 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST64_MIN (-__INT_FAST64_MAX__ - 1)
#define INT_FAST64_MAX (__INT_FAST64_MAX__)
#define UINT_FAST64_MAX (__UINT_FAST64_MAX__)
# 326 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INTMAX_MAX (__INTMAX_MAX__)
#define INTMAX_MIN (-INTMAX_MAX - 1)







#define UINTMAX_MAX (__UINTMAX_MAX__)





/* This must match size_t in stddef.h, currently long unsigned int */

#define SIZE_MAX (__SIZE_MAX__)




/* This must match sig_atomic_t in <signal.h> (currently int) */
#define SIG_ATOMIC_MIN (-__STDINT_EXP(INT_MAX) - 1)
#define SIG_ATOMIC_MAX (__STDINT_EXP(INT_MAX))

/* This must match ptrdiff_t  in <stddef.h> (currently long int) */

#define PTRDIFF_MAX (__PTRDIFF_MAX__)



#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)

/* This must match definition in <wchar.h> */


#define WCHAR_MIN (__WCHAR_MIN__)







/* This must match definition in <wchar.h> */


#define WCHAR_MAX (__WCHAR_MAX__)







/* wint_t is unsigned int on almost all GCC targets.  */

#define WINT_MAX (__WINT_MAX__)




#define WINT_MIN (__WINT_MIN__)




/** Macros for minimum-width integer constant expressions */

#define INT8_C(x) __INT8_C(x)
#define UINT8_C(x) __UINT8_C(x)
# 408 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT16_C(x) __INT16_C(x)
#define UINT16_C(x) __UINT16_C(x)
# 420 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT32_C(x) __INT32_C(x)
#define UINT32_C(x) __UINT32_C(x)
# 433 "/usr/arm-none-eabi/include/stdint.h" 3 4
#define INT64_C(x) __INT64_C(x)
#define UINT64_C(x) __UINT64_C(x)
# 447 "/usr/arm-none-eabi/include/stdint.h" 3 4
/** Macros for greatest-width integer constant expression */

#define INTMAX_C(x) __INTMAX_C(x)
#define UINTMAX_C(x) __UINTMAX_C(x)
# 10 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdint.h" 2 3 4



#define _GCC_WRAP_STDINT_H 
# 50 "asf4/samd21/include/samd21e18a.h" 2


# 51 "asf4/samd21/include/samd21e18a.h"
typedef volatile const uint32_t RoReg; /**< Read only 32-bit register (volatile const unsigned int) */
typedef volatile const uint16_t RoReg16; /**< Read only 16-bit register (volatile const unsigned int) */
typedef volatile const uint8_t RoReg8; /**< Read only  8-bit register (volatile const unsigned int) */





typedef volatile uint32_t WoReg; /**< Write only 32-bit register (volatile unsigned int) */
typedef volatile uint16_t WoReg16; /**< Write only 16-bit register (volatile unsigned int) */
typedef volatile uint8_t WoReg8; /**< Write only  8-bit register (volatile unsigned int) */
typedef volatile uint32_t RwReg; /**< Read-Write 32-bit register (volatile unsigned int) */
typedef volatile uint16_t RwReg16; /**< Read-Write 16-bit register (volatile unsigned int) */
typedef volatile uint8_t RwReg8; /**< Read-Write  8-bit register (volatile unsigned int) */
# 73 "asf4/samd21/include/samd21e18a.h"
/* Macros that deal with adding suffixes to integer literal constants for C/C++ */
#define _U_(x) x ## U
#define _L_(x) x ## L
#define _UL_(x) x ## UL







/* ************************************************************************** */
/**  CMSIS DEFINITIONS FOR SAMD21E18A */
/* ************************************************************************** */
/** \defgroup SAMD21E18A_cmsis CMSIS Definitions */
/*@{*/

/** Interrupt Number Definition */
typedef enum IRQn
{
  /******  Cortex-M0+ Processor Exceptions Numbers ******************************/
  NonMaskableInt_IRQn = -14,/**<  2 Non Maskable Interrupt                 */
  HardFault_IRQn = -13,/**<  3 Cortex-M0+ Hard Fault Interrupt        */
  SVCall_IRQn = -5, /**< 11 Cortex-M0+ SV Call Interrupt           */
  PendSV_IRQn = -2, /**< 14 Cortex-M0+ Pend SV Interrupt           */
  SysTick_IRQn = -1, /**< 15 Cortex-M0+ System Tick Interrupt       */
  /******  SAMD21E18A-specific Interrupt Numbers ***********************/
  PM_IRQn = 0, /**<  0 SAMD21E18A Power Manager (PM) */
  SYSCTRL_IRQn = 1, /**<  1 SAMD21E18A System Control (SYSCTRL) */
  WDT_IRQn = 2, /**<  2 SAMD21E18A Watchdog Timer (WDT) */
  RTC_IRQn = 3, /**<  3 SAMD21E18A Real-Time Counter (RTC) */
  EIC_IRQn = 4, /**<  4 SAMD21E18A External Interrupt Controller (EIC) */
  NVMCTRL_IRQn = 5, /**<  5 SAMD21E18A Non-Volatile Memory Controller (NVMCTRL) */
  DMAC_IRQn = 6, /**<  6 SAMD21E18A Direct Memory Access Controller (DMAC) */
  USB_IRQn = 7, /**<  7 SAMD21E18A Universal Serial Bus (USB) */
  EVSYS_IRQn = 8, /**<  8 SAMD21E18A Event System Interface (EVSYS) */
  SERCOM0_IRQn = 9, /**<  9 SAMD21E18A Serial Communication Interface 0 (SERCOM0) */
  SERCOM1_IRQn = 10, /**< 10 SAMD21E18A Serial Communication Interface 1 (SERCOM1) */
  SERCOM2_IRQn = 11, /**< 11 SAMD21E18A Serial Communication Interface 2 (SERCOM2) */
  SERCOM3_IRQn = 12, /**< 12 SAMD21E18A Serial Communication Interface 3 (SERCOM3) */
  TCC0_IRQn = 15, /**< 15 SAMD21E18A Timer Counter Control 0 (TCC0) */
  TCC1_IRQn = 16, /**< 16 SAMD21E18A Timer Counter Control 1 (TCC1) */
  TCC2_IRQn = 17, /**< 17 SAMD21E18A Timer Counter Control 2 (TCC2) */
  TC3_IRQn = 18, /**< 18 SAMD21E18A Basic Timer Counter 3 (TC3) */
  TC4_IRQn = 19, /**< 19 SAMD21E18A Basic Timer Counter 4 (TC4) */
  TC5_IRQn = 20, /**< 20 SAMD21E18A Basic Timer Counter 5 (TC5) */
  ADC_IRQn = 23, /**< 23 SAMD21E18A Analog Digital Converter (ADC) */
  AC_IRQn = 24, /**< 24 SAMD21E18A Analog Comparators (AC) */
  DAC_IRQn = 25, /**< 25 SAMD21E18A Digital Analog Converter (DAC) */
  PTC_IRQn = 26, /**< 26 SAMD21E18A Peripheral Touch Controller (PTC) */
  I2S_IRQn = 27, /**< 27 SAMD21E18A Inter-IC Sound Interface (I2S) */

  PERIPH_COUNT_IRQn = 28 /**< Number of peripheral IDs */
} IRQn_Type;

typedef struct _DeviceVectors
{
  /* Stack pointer */
  void* pvStack;

  /* Cortex-M handlers */
  void* pfnReset_Handler;
  void* pfnNMI_Handler;
  void* pfnHardFault_Handler;
  void* pvReservedM12;
  void* pvReservedM11;
  void* pvReservedM10;
  void* pvReservedM9;
  void* pvReservedM8;
  void* pvReservedM7;
  void* pvReservedM6;
  void* pfnSVC_Handler;
  void* pvReservedM4;
  void* pvReservedM3;
  void* pfnPendSV_Handler;
  void* pfnSysTick_Handler;

  /* Peripheral handlers */
  void* pfnPM_Handler; /*  0 Power Manager */
  void* pfnSYSCTRL_Handler; /*  1 System Control */
  void* pfnWDT_Handler; /*  2 Watchdog Timer */
  void* pfnRTC_Handler; /*  3 Real-Time Counter */
  void* pfnEIC_Handler; /*  4 External Interrupt Controller */
  void* pfnNVMCTRL_Handler; /*  5 Non-Volatile Memory Controller */
  void* pfnDMAC_Handler; /*  6 Direct Memory Access Controller */
  void* pfnUSB_Handler; /*  7 Universal Serial Bus */
  void* pfnEVSYS_Handler; /*  8 Event System Interface */
  void* pfnSERCOM0_Handler; /*  9 Serial Communication Interface 0 */
  void* pfnSERCOM1_Handler; /* 10 Serial Communication Interface 1 */
  void* pfnSERCOM2_Handler; /* 11 Serial Communication Interface 2 */
  void* pfnSERCOM3_Handler; /* 12 Serial Communication Interface 3 */
  void* pvReserved13;
  void* pvReserved14;
  void* pfnTCC0_Handler; /* 15 Timer Counter Control 0 */
  void* pfnTCC1_Handler; /* 16 Timer Counter Control 1 */
  void* pfnTCC2_Handler; /* 17 Timer Counter Control 2 */
  void* pfnTC3_Handler; /* 18 Basic Timer Counter 3 */
  void* pfnTC4_Handler; /* 19 Basic Timer Counter 4 */
  void* pfnTC5_Handler; /* 20 Basic Timer Counter 5 */
  void* pvReserved21;
  void* pvReserved22;
  void* pfnADC_Handler; /* 23 Analog Digital Converter */
  void* pfnAC_Handler; /* 24 Analog Comparators */
  void* pfnDAC_Handler; /* 25 Digital Analog Converter */
  void* pfnPTC_Handler; /* 26 Peripheral Touch Controller */
  void* pfnI2S_Handler; /* 27 Inter-IC Sound Interface */
  void* pvReserved28;
} DeviceVectors;

/* Cortex-M0+ processor handlers */
void Reset_Handler ( void );
void NMI_Handler ( void );
void HardFault_Handler ( void );
void SVC_Handler ( void );
void PendSV_Handler ( void );
void SysTick_Handler ( void );

/* Peripherals handlers */
void PM_Handler ( void );
void SYSCTRL_Handler ( void );
void WDT_Handler ( void );
void RTC_Handler ( void );
void EIC_Handler ( void );
void NVMCTRL_Handler ( void );
void DMAC_Handler ( void );
void USB_Handler ( void );
void EVSYS_Handler ( void );
void SERCOM0_Handler ( void );
void SERCOM1_Handler ( void );
void SERCOM2_Handler ( void );
void SERCOM3_Handler ( void );
void TCC0_Handler ( void );
void TCC1_Handler ( void );
void TCC2_Handler ( void );
void TC3_Handler ( void );
void TC4_Handler ( void );
void TC5_Handler ( void );
void ADC_Handler ( void );
void AC_Handler ( void );
void DAC_Handler ( void );
void PTC_Handler ( void );
void I2S_Handler ( void );

/*
 * \brief Configuration of the Cortex-M0+ Processor and Core Peripherals
 */

// #define LITTLE_ENDIAN          1        
#define __CM0PLUS_REV 1
#define __MPU_PRESENT 0
#define __NVIC_PRIO_BITS 2
#define __VTOR_PRESENT 1
#define __Vendor_SysTickConfig 0

/**
 * \brief CMSIS includes
 */

#include <core_cm0plus.h>
# 231 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/CMSIS/Include/core_cm0plus.h" 1
/**************************************************************************//**
 * @file     core_cm0plus.h
 * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
 * @version  V5.0.1
 * @date     25. November 2016
 ******************************************************************************/
/*
 * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
# 32 "asf4/samd21/CMSIS/Include/core_cm0plus.h"
#define __CORE_CM0PLUS_H_GENERIC 

#include <stdint.h>





/**
  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  CMSIS violates the following MISRA-C:2004 rules:

   \li Required Rule 8.5, object/function definition in header file.<br>
     Function definitions in header files are used to allow 'inlining'.

   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
     Unions are used for effective representation of core registers.

   \li Advisory Rule 19.7, Function-like macro defined.<br>
     Function-like macros are used to allow more efficient code.
 */


/*******************************************************************************
 *                 CMSIS definitions
 ******************************************************************************/
/**
  \ingroup Cortex-M0+
  @{
 */

/*  CMSIS CM0+ definitions */
#define __CM0PLUS_CMSIS_VERSION_MAIN ( 5U)
#define __CM0PLUS_CMSIS_VERSION_SUB ( 0U)
#define __CM0PLUS_CMSIS_VERSION ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | __CM0PLUS_CMSIS_VERSION_SUB )


#define __CORTEX_M (0U)

/** __FPU_USED indicates whether an FPU is used or not.
    This core does not support an FPU at all
*/
#define __FPU_USED 0U
# 113 "asf4/samd21/CMSIS/Include/core_cm0plus.h"
#include "cmsis_compiler.h" /* CMSIS compiler specific defines */
# 113 "asf4/samd21/CMSIS/Include/core_cm0plus.h"
# 1 "asf4/samd21/CMSIS/Include/cmsis_compiler.h" 1
/**************************************************************************//**
 * @file     cmsis_compiler.h
 * @brief    CMSIS compiler generic header file
 * @version  V5.0.1
 * @date     30. January 2017
 ******************************************************************************/
/*
 * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#define __CMSIS_COMPILER_H 

#include <stdint.h>

/*
 * ARM Compiler 4/5
 */
# 48 "asf4/samd21/CMSIS/Include/cmsis_compiler.h"
#include "cmsis_gcc.h"
# 48 "asf4/samd21/CMSIS/Include/cmsis_compiler.h"
# 1 "asf4/samd21/CMSIS/Include/cmsis_gcc.h" 1
/**************************************************************************//**
 * @file     cmsis_gcc.h
 * @brief    CMSIS compiler GCC header file
 * @version  V5.0.1
 * @date     02. February 2017
 ******************************************************************************/
/*
 * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#define __CMSIS_GCC_H 

/* ignore some GCC warnings */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wunused-parameter"

/* CMSIS compiler specific defines */

#define __ASM __asm


#define __INLINE inline


#define __STATIC_INLINE static inline


#define __NO_RETURN __attribute__((noreturn))


#define __USED __attribute__((used))


#define __WEAK __attribute__((weak))


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpacked"
#pragma GCC diagnostic ignored "-Wattributes"
  struct __attribute__((packed)) T_UINT32 { uint32_t v; };
#pragma GCC diagnostic pop
#define __UNALIGNED_UINT32(x) (((struct T_UINT32 *)(x))->v)


#define __ALIGNED(x) __attribute__((aligned(x)))


#define __PACKED __attribute__((packed, aligned(1)))


#define __PACKED_STRUCT struct __attribute__((packed, aligned(1)))



/* ###########################  Core Function Access  ########################### */
/** \ingroup  CMSIS_Core_FunctionInterface
    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  @{
 */

/**
  \brief   Enable IRQ Interrupts
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) static inline void __enable_irq(void)
{
  __asm volatile ("cpsie i" : : : "memory");
}


/**
  \brief   Disable IRQ Interrupts
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) static inline void __disable_irq(void)
{
  __asm volatile ("cpsid i" : : : "memory");
}


/**
  \brief   Get Control Register
  \details Returns the content of the Control Register.
  \return               Control Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, control" : "=r" (result) );
  return(result);
}
# 130 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/**
  \brief   Set Control Register
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__attribute__((always_inline)) static inline void __set_CONTROL(uint32_t control)
{
  __asm volatile ("MSR control, %0" : : "r" (control) : "memory");
}
# 154 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/**
  \brief   Get IPSR Register
  \details Returns the content of the IPSR Register.
  \return               IPSR Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_IPSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, ipsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get APSR Register
  \details Returns the content of the APSR Register.
  \return               APSR Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_APSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, apsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get xPSR Register
  \details Returns the content of the xPSR Register.
  \return               xPSR Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_xPSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, xpsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get Process Stack Pointer
  \details Returns the current value of the Process Stack Pointer (PSP).
  \return               PSP Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_PSP(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, psp" : "=r" (result) );
  return(result);
}
# 226 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/**
  \brief   Set Process Stack Pointer
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__((always_inline)) static inline void __set_PSP(uint32_t topOfProcStack)
{
  __asm volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
}
# 250 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/**
  \brief   Get Main Stack Pointer
  \details Returns the current value of the Main Stack Pointer (MSP).
  \return               MSP Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_MSP(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, msp" : "=r" (result) );
  return(result);
}
# 280 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/**
  \brief   Set Main Stack Pointer
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__((always_inline)) static inline void __set_MSP(uint32_t topOfMainStack)
{
  __asm volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
}
# 304 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/**
  \brief   Get Priority Mask
  \details Returns the current state of the priority mask bit from the Priority Mask Register.
  \return               Priority Mask value
 */
__attribute__((always_inline)) static inline uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, primask" : "=r" (result) );
  return(result);
}
# 334 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/**
  \brief   Set Priority Mask
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__attribute__((always_inline)) static inline void __set_PRIMASK(uint32_t priMask)
{
  __asm volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
}
# 668 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/*@} end of CMSIS_Core_RegAccFunctions */


/* ##########################  Core Instruction Access  ######################### */
/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  Access to dedicated instructions
  @{
*/

/* Define macros for porting to both thumb1 and thumb2.
 * For thumb1, use low register (r0-r7), specified by constraint "l"
 * Otherwise, use general registers, specified by constraint "r" */

#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
#define __CMSIS_GCC_RW_REG(r) "+l" (r)
#define __CMSIS_GCC_USE_REG(r) "l" (r)






/**
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
//__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
//{
//  __ASM volatile ("nop");
//}
#define __NOP() __ASM volatile ("nop")

/**
  \brief   Wait For Interrupt
  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
 */
//__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
//{
//  __ASM volatile ("wfi");
//}
#define __WFI() __ASM volatile ("wfi")


/**
  \brief   Wait For Event
  \details Wait For Event is a hint instruction that permits the processor to enter
           a low-power state until one of a number of events occurs.
 */
//__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
//{
//  __ASM volatile ("wfe");
//}
#define __WFE() __ASM volatile ("wfe")


/**
  \brief   Send Event
  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
//__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
//{
//  __ASM volatile ("sev");
//}
#define __SEV() __ASM volatile ("sev")


/**
  \brief   Instruction Synchronization Barrier
  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) static inline void __ISB(void)
{
  __asm volatile ("isb 0xF":::"memory");
}


/**
  \brief   Data Synchronization Barrier
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) static inline void __DSB(void)
{
  __asm volatile ("dsb 0xF":::"memory");
}


/**
  \brief   Data Memory Barrier
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) static inline void __DMB(void)
{
  __asm volatile ("dmb 0xF":::"memory");
}


/**
  \brief   Reverse byte order (32 bit)
  \details Reverses the byte order in integer value.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline uint32_t __REV(uint32_t value)
{

  return __builtin_bswap32(value);






}


/**
  \brief   Reverse byte order (16 bit)
  \details Reverses the byte order in two unsigned short values.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline uint32_t __REV16(uint32_t value)
{
  uint32_t result;

  __asm volatile ("rev16 %0, %1" : "=l" (result) : "l" (value) );
  return(result);
}


/**
  \brief   Reverse byte order in signed short value
  \details Reverses the byte order in a signed short value with sign extension to integer.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline int32_t __REVSH(int32_t value)
{

  return (short)__builtin_bswap16(value);






}


/**
  \brief   Rotate Right in unsigned value (32 bit)
  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
  \param [in]    op1  Value to rotate
  \param [in]    op2  Number of Bits to rotate
  \return               Rotated value
 */
__attribute__((always_inline)) static inline uint32_t __ROR(uint32_t op1, uint32_t op2)
{
  return (op1 >> op2) | (op1 << (32U - op2));
}


/**
  \brief   Breakpoint
  \details Causes the processor to enter Debug state.
           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
  \param [in]    value  is ignored by the processor.
                 If required, a debugger can use it to store additional information about the breakpoint.
 */
#define __BKPT(value) __ASM volatile ("bkpt "#value)


/**
  \brief   Reverse bit order of value
  \details Reverses the bit order of the given value.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline uint32_t __RBIT(uint32_t value)
{
  uint32_t result;






  int32_t s = (4 /*sizeof(v)*/ * 8) - 1; /* extra shift needed at end */

  result = value; /* r will be reversed bits of v; first get LSB of v */
  for (value >>= 1U; value; value >>= 1U)
  {
    result <<= 1U;
    result |= value & 1U;
    s--;
  }
  result <<= s; /* shift when v's highest bits are zero */

  return(result);
}


/**
  \brief   Count leading zeros
  \details Counts the number of leading zeros of a data value.
  \param [in]  value  Value to count the leading zeros
  \return             number of leading zeros in value
 */
#define __CLZ __builtin_clz
# 1341 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/*@}*/ /* end of group CMSIS_Core_InstructionInterface */


/* ###################  Compiler specific Intrinsics  ########################### */
/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
  Access to dedicated SIMD instructions
  @{
*/
# 1894 "asf4/samd21/CMSIS/Include/cmsis_gcc.h"
/*@} end of group CMSIS_SIMD_intrinsics */


#pragma GCC diagnostic pop
# 49 "asf4/samd21/CMSIS/Include/cmsis_compiler.h" 2


/*
 * IAR Compiler
 */
# 114 "asf4/samd21/CMSIS/Include/core_cm0plus.h" 2
# 125 "asf4/samd21/CMSIS/Include/core_cm0plus.h"
#define __CORE_CM0PLUS_H_DEPENDANT 





/* check device defines and use defaults */
# 159 "asf4/samd21/CMSIS/Include/core_cm0plus.h"
/* IO definitions (access restrictions to peripheral registers) */
/**
    \defgroup CMSIS_glob_defs CMSIS Global Defines

    <strong>IO Type Qualifiers</strong> are used
    \li to specify the access to peripheral variables.
    \li for automatic generation of peripheral register debug information.
*/



#define __I volatile const

#define __O volatile
#define __IO volatile

/* following defines should be used for structure members */
#define __IM volatile const
#define __OM volatile
#define __IOM volatile

/*@} end of group Cortex-M0+ */



/*******************************************************************************
 *                 Register Abstraction
  Core Register contain:
  - Core Register
  - Core NVIC Register
  - Core SCB Register
  - Core SysTick Register
  - Core MPU Register
 ******************************************************************************/
/**
  \defgroup CMSIS_core_register Defines and Type Definitions
  \brief Type definitions and defines for Cortex-M processor based devices.
*/

/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_CORE  Status and Control Registers
  \brief      Core Register type definitions.
  @{
 */

/**
  \brief  Union type to access the Application Program Status Register (APSR).
 */
typedef union
{
  struct
  {
    uint32_t _reserved0:28; /*!< bit:  0..27  Reserved */
    uint32_t V:1; /*!< bit:     28  Overflow condition code flag */
    uint32_t C:1; /*!< bit:     29  Carry condition code flag */
    uint32_t Z:1; /*!< bit:     30  Zero condition code flag */
    uint32_t N:1; /*!< bit:     31  Negative condition code flag */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} APSR_Type;

/* APSR Register Definitions */
#define APSR_N_Pos 31U
#define APSR_N_Msk (1UL << APSR_N_Pos)

#define APSR_Z_Pos 30U
#define APSR_Z_Msk (1UL << APSR_Z_Pos)

#define APSR_C_Pos 29U
#define APSR_C_Msk (1UL << APSR_C_Pos)

#define APSR_V_Pos 28U
#define APSR_V_Msk (1UL << APSR_V_Pos)


/**
  \brief  Union type to access the Interrupt Program Status Register (IPSR).
 */
typedef union
{
  struct
  {
    uint32_t ISR:9; /*!< bit:  0.. 8  Exception number */
    uint32_t _reserved0:23; /*!< bit:  9..31  Reserved */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} IPSR_Type;

/* IPSR Register Definitions */
#define IPSR_ISR_Pos 0U
#define IPSR_ISR_Msk (0x1FFUL )


/**
  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 */
typedef union
{
  struct
  {
    uint32_t ISR:9; /*!< bit:  0.. 8  Exception number */
    uint32_t _reserved0:15; /*!< bit:  9..23  Reserved */
    uint32_t T:1; /*!< bit:     24  Thumb bit        (read 0) */
    uint32_t _reserved1:3; /*!< bit: 25..27  Reserved */
    uint32_t V:1; /*!< bit:     28  Overflow condition code flag */
    uint32_t C:1; /*!< bit:     29  Carry condition code flag */
    uint32_t Z:1; /*!< bit:     30  Zero condition code flag */
    uint32_t N:1; /*!< bit:     31  Negative condition code flag */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} xPSR_Type;

/* xPSR Register Definitions */
#define xPSR_N_Pos 31U
#define xPSR_N_Msk (1UL << xPSR_N_Pos)

#define xPSR_Z_Pos 30U
#define xPSR_Z_Msk (1UL << xPSR_Z_Pos)

#define xPSR_C_Pos 29U
#define xPSR_C_Msk (1UL << xPSR_C_Pos)

#define xPSR_V_Pos 28U
#define xPSR_V_Msk (1UL << xPSR_V_Pos)

#define xPSR_T_Pos 24U
#define xPSR_T_Msk (1UL << xPSR_T_Pos)

#define xPSR_ISR_Pos 0U
#define xPSR_ISR_Msk (0x1FFUL )


/**
  \brief  Union type to access the Control Registers (CONTROL).
 */
typedef union
{
  struct
  {
    uint32_t nPRIV:1; /*!< bit:      0  Execution privilege in Thread mode */
    uint32_t SPSEL:1; /*!< bit:      1  Stack to be used */
    uint32_t _reserved1:30; /*!< bit:  2..31  Reserved */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} CONTROL_Type;

/* CONTROL Register Definitions */
#define CONTROL_SPSEL_Pos 1U
#define CONTROL_SPSEL_Msk (1UL << CONTROL_SPSEL_Pos)

#define CONTROL_nPRIV_Pos 0U
#define CONTROL_nPRIV_Msk (1UL )

/*@} end of group CMSIS_CORE */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
  \brief      Type definitions for the NVIC Registers
  @{
 */

/**
  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 */
typedef struct
{
  volatile uint32_t ISER[1U]; /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
        uint32_t RESERVED0[31U];
  volatile uint32_t ICER[1U]; /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
        uint32_t RSERVED1[31U];
  volatile uint32_t ISPR[1U]; /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
        uint32_t RESERVED2[31U];
  volatile uint32_t ICPR[1U]; /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
        uint32_t RESERVED3[31U];
        uint32_t RESERVED4[64U];
  volatile uint32_t IP[8U]; /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
} NVIC_Type;

/*@} end of group CMSIS_NVIC */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SCB     System Control Block (SCB)
  \brief    Type definitions for the System Control Block Registers
  @{
 */

/**
  \brief  Structure type to access the System Control Block (SCB).
 */
typedef struct
{
  volatile const uint32_t CPUID; /*!< Offset: 0x000 (R/ )  CPUID Base Register */
  volatile uint32_t ICSR; /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */

  volatile uint32_t VTOR; /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */



  volatile uint32_t AIRCR; /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
  volatile uint32_t SCR; /*!< Offset: 0x010 (R/W)  System Control Register */
  volatile uint32_t CCR; /*!< Offset: 0x014 (R/W)  Configuration Control Register */
        uint32_t RESERVED1;
  volatile uint32_t SHP[2U]; /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
  volatile uint32_t SHCSR; /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
} SCB_Type;

/* SCB CPUID Register Definitions */
#define SCB_CPUID_IMPLEMENTER_Pos 24U
#define SCB_CPUID_IMPLEMENTER_Msk (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)

#define SCB_CPUID_VARIANT_Pos 20U
#define SCB_CPUID_VARIANT_Msk (0xFUL << SCB_CPUID_VARIANT_Pos)

#define SCB_CPUID_ARCHITECTURE_Pos 16U
#define SCB_CPUID_ARCHITECTURE_Msk (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)

#define SCB_CPUID_PARTNO_Pos 4U
#define SCB_CPUID_PARTNO_Msk (0xFFFUL << SCB_CPUID_PARTNO_Pos)

#define SCB_CPUID_REVISION_Pos 0U
#define SCB_CPUID_REVISION_Msk (0xFUL )

/* SCB Interrupt Control State Register Definitions */
#define SCB_ICSR_NMIPENDSET_Pos 31U
#define SCB_ICSR_NMIPENDSET_Msk (1UL << SCB_ICSR_NMIPENDSET_Pos)

#define SCB_ICSR_PENDSVSET_Pos 28U
#define SCB_ICSR_PENDSVSET_Msk (1UL << SCB_ICSR_PENDSVSET_Pos)

#define SCB_ICSR_PENDSVCLR_Pos 27U
#define SCB_ICSR_PENDSVCLR_Msk (1UL << SCB_ICSR_PENDSVCLR_Pos)

#define SCB_ICSR_PENDSTSET_Pos 26U
#define SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos)

#define SCB_ICSR_PENDSTCLR_Pos 25U
#define SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos)

#define SCB_ICSR_ISRPREEMPT_Pos 23U
#define SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos)

#define SCB_ICSR_ISRPENDING_Pos 22U
#define SCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos)

#define SCB_ICSR_VECTPENDING_Pos 12U
#define SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)

#define SCB_ICSR_VECTACTIVE_Pos 0U
#define SCB_ICSR_VECTACTIVE_Msk (0x1FFUL )


/* SCB Interrupt Control State Register Definitions */
#define SCB_VTOR_TBLOFF_Pos 8U
#define SCB_VTOR_TBLOFF_Msk (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)


/* SCB Application Interrupt and Reset Control Register Definitions */
#define SCB_AIRCR_VECTKEY_Pos 16U
#define SCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)

#define SCB_AIRCR_VECTKEYSTAT_Pos 16U
#define SCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)

#define SCB_AIRCR_ENDIANESS_Pos 15U
#define SCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos)

#define SCB_AIRCR_SYSRESETREQ_Pos 2U
#define SCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos)

#define SCB_AIRCR_VECTCLRACTIVE_Pos 1U
#define SCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)

/* SCB System Control Register Definitions */
#define SCB_SCR_SEVONPEND_Pos 4U
#define SCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos)

#define SCB_SCR_SLEEPDEEP_Pos 2U
#define SCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos)

#define SCB_SCR_SLEEPONEXIT_Pos 1U
#define SCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos)

/* SCB Configuration Control Register Definitions */
#define SCB_CCR_STKALIGN_Pos 9U
#define SCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos)

#define SCB_CCR_UNALIGN_TRP_Pos 3U
#define SCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos)

/* SCB System Handler Control and State Register Definitions */
#define SCB_SHCSR_SVCALLPENDED_Pos 15U
#define SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos)

/*@} end of group CMSIS_SCB */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
  \brief    Type definitions for the System Timer Registers.
  @{
 */

/**
  \brief  Structure type to access the System Timer (SysTick).
 */
typedef struct
{
  volatile uint32_t CTRL; /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
  volatile uint32_t LOAD; /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
  volatile uint32_t VAL; /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
  volatile const uint32_t CALIB; /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
} SysTick_Type;

/* SysTick Control / Status Register Definitions */
#define SysTick_CTRL_COUNTFLAG_Pos 16U
#define SysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos)

#define SysTick_CTRL_CLKSOURCE_Pos 2U
#define SysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos)

#define SysTick_CTRL_TICKINT_Pos 1U
#define SysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos)

#define SysTick_CTRL_ENABLE_Pos 0U
#define SysTick_CTRL_ENABLE_Msk (1UL )

/* SysTick Reload Register Definitions */
#define SysTick_LOAD_RELOAD_Pos 0U
#define SysTick_LOAD_RELOAD_Msk (0xFFFFFFUL )

/* SysTick Current Register Definitions */
#define SysTick_VAL_CURRENT_Pos 0U
#define SysTick_VAL_CURRENT_Msk (0xFFFFFFUL )

/* SysTick Calibration Register Definitions */
#define SysTick_CALIB_NOREF_Pos 31U
#define SysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos)

#define SysTick_CALIB_SKEW_Pos 30U
#define SysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos)

#define SysTick_CALIB_TENMS_Pos 0U
#define SysTick_CALIB_TENMS_Msk (0xFFFFFFUL )

/*@} end of group CMSIS_SysTick */
# 600 "asf4/samd21/CMSIS/Include/core_cm0plus.h"
/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
            Therefore they are not covered by the Cortex-M0+ header file.
  @{
 */
/*@} end of group CMSIS_CoreDebug */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_bitfield     Core register bit field macros
  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
  @{
 */

/**
  \brief   Mask and shift a bit field value for use in a register bit range.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted value.
*/
#define _VAL2FLD(field,value) (((uint32_t)(value) << field ## _Pos) & field ## _Msk)

/**
  \brief     Mask and shift a register value to extract a bit filed value.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted bit field value.
*/
#define _FLD2VAL(field,value) (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)

/*@} end of group CMSIS_core_bitfield */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_base     Core Definitions
  \brief      Definitions for base addresses, unions, and structures.
  @{
 */

/* Memory mapping of Core Hardware */
#define SCS_BASE (0xE000E000UL)
#define SysTick_BASE (SCS_BASE + 0x0010UL)
#define NVIC_BASE (SCS_BASE + 0x0100UL)
#define SCB_BASE (SCS_BASE + 0x0D00UL)

#define SCB ((SCB_Type *) SCB_BASE )
#define SysTick ((SysTick_Type *) SysTick_BASE )
#define NVIC ((NVIC_Type *) NVIC_BASE )






/*@} */



/*******************************************************************************
 *                Hardware Abstraction Layer
  Core Function Interface contains:
  - Core NVIC Functions
  - Core SysTick Functions
  - Core Register Access Functions
 ******************************************************************************/
/**
  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
*/



/* ##########################   NVIC functions  #################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
  \brief    Functions that manage interrupts and exceptions via the NVIC.
  @{
 */


/*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
/*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
#define NVIC_EnableIRQ __NVIC_EnableIRQ
#define NVIC_GetEnableIRQ __NVIC_GetEnableIRQ
#define NVIC_DisableIRQ __NVIC_DisableIRQ
#define NVIC_GetPendingIRQ __NVIC_GetPendingIRQ
#define NVIC_SetPendingIRQ __NVIC_SetPendingIRQ
#define NVIC_ClearPendingIRQ __NVIC_ClearPendingIRQ
/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
#define NVIC_SetPriority __NVIC_SetPriority
#define NVIC_GetPriority __NVIC_GetPriority



#define NVIC_SetVector __NVIC_SetVector
#define NVIC_GetVector __NVIC_GetVector


#define NVIC_USER_IRQ_OFFSET 16


/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
/* The following MACROS handle generation of the register offset and byte masks */
#define _BIT_SHIFT(IRQn) ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)
#define _SHP_IDX(IRQn) ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )
#define _IP_IDX(IRQn) ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )


/**
  \brief   Enable Interrupt
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Get Interrupt Enable status
  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt is not enabled.
  \return             1  Interrupt is enabled.
  \note    IRQn must not be negative.
 */
static inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Disable Interrupt
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    __DSB();
    __ISB();
  }
}


/**
  \brief   Get Pending Interrupt
  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
static inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Set Pending Interrupt
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Clear Pending Interrupt
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Set Interrupt Priority
  \details Sets the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
static inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
  }
  else
  {
    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
  }
}


/**
  \brief   Get Interrupt Priority
  \details Reads the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
static inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{

  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
  }
  else
  {
    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
  }
}


/**
  \brief   Set Interrupt Vector
  \details Sets an interrupt vector in SRAM based interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
           VTOR must been relocated to SRAM before.
           If VTOR is not present address 0 must be mapped to SRAM.
  \param [in]   IRQn      Interrupt number
  \param [in]   vector    Address of interrupt handler function
 */
static inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
{

  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;



  vectors[(int32_t)IRQn + 16] = vector;
}


/**
  \brief   Get Interrupt Vector
  \details Reads an interrupt vector from interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn      Interrupt number.
  \return                 Address of interrupt handler function
 */
static inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
{

  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;



  return vectors[(int32_t)IRQn + 16];

}


/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
static inline void NVIC_SystemReset(void)
{
  __DSB(); /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR = ((0x5FAUL << 16U) |
                 (1UL << 2U));
  __DSB(); /* Ensure completion of memory access */

  for(;;) /* wait until reset */
  {
    __asm volatile ("nop");
  }
}

/*@} end of CMSIS_Core_NVICFunctions */


/* ##########################  FPU functions  #################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_FpuFunctions FPU Functions
  \brief    Function that provides FPU type.
  @{
 */

/**
  \brief   get FPU type
  \details returns the FPU type
  \returns
   - \b  0: No FPU
   - \b  1: Single precision FPU
   - \b  2: Double + Single precision FPU
 */
static inline uint32_t SCB_GetFPUType(void)
{
    return 0U; /* No FPU */
}


/*@} end of CMSIS_Core_FpuFunctions */



/* ##################################    SysTick function  ############################################ */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
  \brief    Functions that configure the System.
  @{
 */



/**
  \brief   System Tick Configuration
  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
           Counter is in free running mode to generate periodic interrupts.
  \param [in]  ticks  Number of ticks between two interrupts.
  \return          0  Function succeeded.
  \return          1  Function failed.
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
static inline uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > (0xFFFFFFUL ))
  {
    return (1UL); /* Reload value impossible */
  }

  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = (uint32_t)(ticks - 1UL); /* set reload register */
  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL); /* set Priority for Systick Interrupt */
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0UL; /* Load the SysTick Counter Value */
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2U) |
                   (1UL << 1U) |
                   (1UL ); /* Enable SysTick IRQ and SysTick Timer */
  return (0UL); /* Function successful */
}



/*@} end of CMSIS_Core_SysTickFunctions */
# 232 "asf4/samd21/include/samd21e18a.h" 2

#include "system_samd21.h"
# 233 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/system_samd21.h" 1
/**
 * \file
 *
 * \brief Low-level initialization functions called upon chip startup
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SYSTEM_SAMD21_H_INCLUDED_ 





#include <stdint.h>

extern uint32_t SystemCoreClock; /*!< System Clock Frequency (Core Clock)  */

void SystemInit(void);
void SystemCoreClockUpdate(void);
# 234 "asf4/samd21/include/samd21e18a.h" 2


/*@}*/

/* ************************************************************************** */
/**  SOFTWARE PERIPHERAL API DEFINITION FOR SAMD21E18A */
/* ************************************************************************** */
/** \defgroup SAMD21E18A_api Peripheral Software API */
/*@{*/

#include "component/ac.h"
# 244 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/ac.h" 1
/**
 * \file
 *
 * \brief Component description for AC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_AC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR AC */
/* ========================================================================== */
/** \addtogroup SAMD21_AC Analog Comparators */
/*@{*/

#define AC_U2205 
#define REV_AC 0x111

/* -------- AC_CTRLA : (AC Offset: 0x00) (R/W  8) Control A -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint8_t RUNSTDBY:1; /*!< bit:      2  Run in Standby                     */
    uint8_t :4; /*!< bit:  3.. 6  Reserved                           */
    uint8_t LPMUX:1; /*!< bit:      7  Low-Power Mux                      */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_CTRLA_Type;


#define AC_CTRLA_OFFSET 0x00
#define AC_CTRLA_RESETVALUE _U_(0x00)

#define AC_CTRLA_SWRST_Pos 0
#define AC_CTRLA_SWRST (_U_(0x1) << AC_CTRLA_SWRST_Pos)
#define AC_CTRLA_ENABLE_Pos 1
#define AC_CTRLA_ENABLE (_U_(0x1) << AC_CTRLA_ENABLE_Pos)
#define AC_CTRLA_RUNSTDBY_Pos 2
#define AC_CTRLA_RUNSTDBY_Msk (_U_(0x1) << AC_CTRLA_RUNSTDBY_Pos)
#define AC_CTRLA_RUNSTDBY(value) (AC_CTRLA_RUNSTDBY_Msk & ((value) << AC_CTRLA_RUNSTDBY_Pos))
#define AC_CTRLA_LPMUX_Pos 7
#define AC_CTRLA_LPMUX (_U_(0x1) << AC_CTRLA_LPMUX_Pos)
#define AC_CTRLA_MASK _U_(0x87)

/* -------- AC_CTRLB : (AC Offset: 0x01) ( /W  8) Control B -------- */

typedef union {
  struct {
    uint8_t START0:1; /*!< bit:      0  Comparator 0 Start Comparison      */
    uint8_t START1:1; /*!< bit:      1  Comparator 1 Start Comparison      */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t START:2; /*!< bit:  0.. 1  Comparator x Start Comparison      */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_CTRLB_Type;


#define AC_CTRLB_OFFSET 0x01
#define AC_CTRLB_RESETVALUE _U_(0x00)

#define AC_CTRLB_START0_Pos 0
#define AC_CTRLB_START0 (_U_(1) << AC_CTRLB_START0_Pos)
#define AC_CTRLB_START1_Pos 1
#define AC_CTRLB_START1 (_U_(1) << AC_CTRLB_START1_Pos)
#define AC_CTRLB_START_Pos 0
#define AC_CTRLB_START_Msk (_U_(0x3) << AC_CTRLB_START_Pos)
#define AC_CTRLB_START(value) (AC_CTRLB_START_Msk & ((value) << AC_CTRLB_START_Pos))
#define AC_CTRLB_MASK _U_(0x03)

/* -------- AC_EVCTRL : (AC Offset: 0x02) (R/W 16) Event Control -------- */

typedef union {
  struct {
    uint16_t COMPEO0:1; /*!< bit:      0  Comparator 0 Event Output Enable   */
    uint16_t COMPEO1:1; /*!< bit:      1  Comparator 1 Event Output Enable   */
    uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint16_t WINEO0:1; /*!< bit:      4  Window 0 Event Output Enable       */
    uint16_t :3; /*!< bit:  5.. 7  Reserved                           */
    uint16_t COMPEI0:1; /*!< bit:      8  Comparator 0 Event Input           */
    uint16_t COMPEI1:1; /*!< bit:      9  Comparator 1 Event Input           */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t COMPEO:2; /*!< bit:  0.. 1  Comparator x Event Output Enable   */
    uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint16_t WINEO:1; /*!< bit:      4  Window x Event Output Enable       */
    uint16_t :3; /*!< bit:  5.. 7  Reserved                           */
    uint16_t COMPEI:2; /*!< bit:  8.. 9  Comparator x Event Input           */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} AC_EVCTRL_Type;


#define AC_EVCTRL_OFFSET 0x02
#define AC_EVCTRL_RESETVALUE _U_(0x0000)

#define AC_EVCTRL_COMPEO0_Pos 0
#define AC_EVCTRL_COMPEO0 (_U_(1) << AC_EVCTRL_COMPEO0_Pos)
#define AC_EVCTRL_COMPEO1_Pos 1
#define AC_EVCTRL_COMPEO1 (_U_(1) << AC_EVCTRL_COMPEO1_Pos)
#define AC_EVCTRL_COMPEO_Pos 0
#define AC_EVCTRL_COMPEO_Msk (_U_(0x3) << AC_EVCTRL_COMPEO_Pos)
#define AC_EVCTRL_COMPEO(value) (AC_EVCTRL_COMPEO_Msk & ((value) << AC_EVCTRL_COMPEO_Pos))
#define AC_EVCTRL_WINEO0_Pos 4
#define AC_EVCTRL_WINEO0 (_U_(1) << AC_EVCTRL_WINEO0_Pos)
#define AC_EVCTRL_WINEO_Pos 4
#define AC_EVCTRL_WINEO_Msk (_U_(0x1) << AC_EVCTRL_WINEO_Pos)
#define AC_EVCTRL_WINEO(value) (AC_EVCTRL_WINEO_Msk & ((value) << AC_EVCTRL_WINEO_Pos))
#define AC_EVCTRL_COMPEI0_Pos 8
#define AC_EVCTRL_COMPEI0 (_U_(1) << AC_EVCTRL_COMPEI0_Pos)
#define AC_EVCTRL_COMPEI1_Pos 9
#define AC_EVCTRL_COMPEI1 (_U_(1) << AC_EVCTRL_COMPEI1_Pos)
#define AC_EVCTRL_COMPEI_Pos 8
#define AC_EVCTRL_COMPEI_Msk (_U_(0x3) << AC_EVCTRL_COMPEI_Pos)
#define AC_EVCTRL_COMPEI(value) (AC_EVCTRL_COMPEI_Msk & ((value) << AC_EVCTRL_COMPEI_Pos))
#define AC_EVCTRL_MASK _U_(0x0313)

/* -------- AC_INTENCLR : (AC Offset: 0x04) (R/W  8) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t COMP0:1; /*!< bit:      0  Comparator 0 Interrupt Enable      */
    uint8_t COMP1:1; /*!< bit:      1  Comparator 1 Interrupt Enable      */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t WIN0:1; /*!< bit:      4  Window 0 Interrupt Enable          */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t COMP:2; /*!< bit:  0.. 1  Comparator x Interrupt Enable      */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t WIN:1; /*!< bit:      4  Window x Interrupt Enable          */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_INTENCLR_Type;


#define AC_INTENCLR_OFFSET 0x04
#define AC_INTENCLR_RESETVALUE _U_(0x00)

#define AC_INTENCLR_COMP0_Pos 0
#define AC_INTENCLR_COMP0 (_U_(1) << AC_INTENCLR_COMP0_Pos)
#define AC_INTENCLR_COMP1_Pos 1
#define AC_INTENCLR_COMP1 (_U_(1) << AC_INTENCLR_COMP1_Pos)
#define AC_INTENCLR_COMP_Pos 0
#define AC_INTENCLR_COMP_Msk (_U_(0x3) << AC_INTENCLR_COMP_Pos)
#define AC_INTENCLR_COMP(value) (AC_INTENCLR_COMP_Msk & ((value) << AC_INTENCLR_COMP_Pos))
#define AC_INTENCLR_WIN0_Pos 4
#define AC_INTENCLR_WIN0 (_U_(1) << AC_INTENCLR_WIN0_Pos)
#define AC_INTENCLR_WIN_Pos 4
#define AC_INTENCLR_WIN_Msk (_U_(0x1) << AC_INTENCLR_WIN_Pos)
#define AC_INTENCLR_WIN(value) (AC_INTENCLR_WIN_Msk & ((value) << AC_INTENCLR_WIN_Pos))
#define AC_INTENCLR_MASK _U_(0x13)

/* -------- AC_INTENSET : (AC Offset: 0x05) (R/W  8) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t COMP0:1; /*!< bit:      0  Comparator 0 Interrupt Enable      */
    uint8_t COMP1:1; /*!< bit:      1  Comparator 1 Interrupt Enable      */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t WIN0:1; /*!< bit:      4  Window 0 Interrupt Enable          */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t COMP:2; /*!< bit:  0.. 1  Comparator x Interrupt Enable      */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t WIN:1; /*!< bit:      4  Window x Interrupt Enable          */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_INTENSET_Type;


#define AC_INTENSET_OFFSET 0x05
#define AC_INTENSET_RESETVALUE _U_(0x00)

#define AC_INTENSET_COMP0_Pos 0
#define AC_INTENSET_COMP0 (_U_(1) << AC_INTENSET_COMP0_Pos)
#define AC_INTENSET_COMP1_Pos 1
#define AC_INTENSET_COMP1 (_U_(1) << AC_INTENSET_COMP1_Pos)
#define AC_INTENSET_COMP_Pos 0
#define AC_INTENSET_COMP_Msk (_U_(0x3) << AC_INTENSET_COMP_Pos)
#define AC_INTENSET_COMP(value) (AC_INTENSET_COMP_Msk & ((value) << AC_INTENSET_COMP_Pos))
#define AC_INTENSET_WIN0_Pos 4
#define AC_INTENSET_WIN0 (_U_(1) << AC_INTENSET_WIN0_Pos)
#define AC_INTENSET_WIN_Pos 4
#define AC_INTENSET_WIN_Msk (_U_(0x1) << AC_INTENSET_WIN_Pos)
#define AC_INTENSET_WIN(value) (AC_INTENSET_WIN_Msk & ((value) << AC_INTENSET_WIN_Pos))
#define AC_INTENSET_MASK _U_(0x13)

/* -------- AC_INTFLAG : (AC Offset: 0x06) (R/W  8) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t COMP0:1; /*!< bit:      0  Comparator 0                       */
    volatile const uint8_t COMP1:1; /*!< bit:      1  Comparator 1                       */
    volatile const uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    volatile const uint8_t WIN0:1; /*!< bit:      4  Window 0                           */
    volatile const uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint8_t COMP:2; /*!< bit:  0.. 1  Comparator x                       */
    volatile const uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    volatile const uint8_t WIN:1; /*!< bit:      4  Window x                           */
    volatile const uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_INTFLAG_Type;


#define AC_INTFLAG_OFFSET 0x06
#define AC_INTFLAG_RESETVALUE _U_(0x00)

#define AC_INTFLAG_COMP0_Pos 0
#define AC_INTFLAG_COMP0 (_U_(1) << AC_INTFLAG_COMP0_Pos)
#define AC_INTFLAG_COMP1_Pos 1
#define AC_INTFLAG_COMP1 (_U_(1) << AC_INTFLAG_COMP1_Pos)
#define AC_INTFLAG_COMP_Pos 0
#define AC_INTFLAG_COMP_Msk (_U_(0x3) << AC_INTFLAG_COMP_Pos)
#define AC_INTFLAG_COMP(value) (AC_INTFLAG_COMP_Msk & ((value) << AC_INTFLAG_COMP_Pos))
#define AC_INTFLAG_WIN0_Pos 4
#define AC_INTFLAG_WIN0 (_U_(1) << AC_INTFLAG_WIN0_Pos)
#define AC_INTFLAG_WIN_Pos 4
#define AC_INTFLAG_WIN_Msk (_U_(0x1) << AC_INTFLAG_WIN_Pos)
#define AC_INTFLAG_WIN(value) (AC_INTFLAG_WIN_Msk & ((value) << AC_INTFLAG_WIN_Pos))
#define AC_INTFLAG_MASK _U_(0x13)

/* -------- AC_STATUSA : (AC Offset: 0x08) (R/   8) Status A -------- */

typedef union {
  struct {
    uint8_t STATE0:1; /*!< bit:      0  Comparator 0 Current State         */
    uint8_t STATE1:1; /*!< bit:      1  Comparator 1 Current State         */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t WSTATE0:2; /*!< bit:  4.. 5  Window 0 Current State             */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t STATE:2; /*!< bit:  0.. 1  Comparator x Current State         */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_STATUSA_Type;


#define AC_STATUSA_OFFSET 0x08
#define AC_STATUSA_RESETVALUE _U_(0x00)

#define AC_STATUSA_STATE0_Pos 0
#define AC_STATUSA_STATE0 (_U_(1) << AC_STATUSA_STATE0_Pos)
#define AC_STATUSA_STATE1_Pos 1
#define AC_STATUSA_STATE1 (_U_(1) << AC_STATUSA_STATE1_Pos)
#define AC_STATUSA_STATE_Pos 0
#define AC_STATUSA_STATE_Msk (_U_(0x3) << AC_STATUSA_STATE_Pos)
#define AC_STATUSA_STATE(value) (AC_STATUSA_STATE_Msk & ((value) << AC_STATUSA_STATE_Pos))
#define AC_STATUSA_WSTATE0_Pos 4
#define AC_STATUSA_WSTATE0_Msk (_U_(0x3) << AC_STATUSA_WSTATE0_Pos)
#define AC_STATUSA_WSTATE0(value) (AC_STATUSA_WSTATE0_Msk & ((value) << AC_STATUSA_WSTATE0_Pos))
#define AC_STATUSA_WSTATE0_ABOVE_Val _U_(0x0)
#define AC_STATUSA_WSTATE0_INSIDE_Val _U_(0x1)
#define AC_STATUSA_WSTATE0_BELOW_Val _U_(0x2)
#define AC_STATUSA_WSTATE0_ABOVE (AC_STATUSA_WSTATE0_ABOVE_Val << AC_STATUSA_WSTATE0_Pos)
#define AC_STATUSA_WSTATE0_INSIDE (AC_STATUSA_WSTATE0_INSIDE_Val << AC_STATUSA_WSTATE0_Pos)
#define AC_STATUSA_WSTATE0_BELOW (AC_STATUSA_WSTATE0_BELOW_Val << AC_STATUSA_WSTATE0_Pos)
#define AC_STATUSA_MASK _U_(0x33)

/* -------- AC_STATUSB : (AC Offset: 0x09) (R/   8) Status B -------- */

typedef union {
  struct {
    uint8_t READY0:1; /*!< bit:      0  Comparator 0 Ready                 */
    uint8_t READY1:1; /*!< bit:      1  Comparator 1 Ready                 */
    uint8_t :5; /*!< bit:  2.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy               */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t READY:2; /*!< bit:  0.. 1  Comparator x Ready                 */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_STATUSB_Type;


#define AC_STATUSB_OFFSET 0x09
#define AC_STATUSB_RESETVALUE _U_(0x00)

#define AC_STATUSB_READY0_Pos 0
#define AC_STATUSB_READY0 (_U_(1) << AC_STATUSB_READY0_Pos)
#define AC_STATUSB_READY1_Pos 1
#define AC_STATUSB_READY1 (_U_(1) << AC_STATUSB_READY1_Pos)
#define AC_STATUSB_READY_Pos 0
#define AC_STATUSB_READY_Msk (_U_(0x3) << AC_STATUSB_READY_Pos)
#define AC_STATUSB_READY(value) (AC_STATUSB_READY_Msk & ((value) << AC_STATUSB_READY_Pos))
#define AC_STATUSB_SYNCBUSY_Pos 7
#define AC_STATUSB_SYNCBUSY (_U_(0x1) << AC_STATUSB_SYNCBUSY_Pos)
#define AC_STATUSB_MASK _U_(0x83)

/* -------- AC_STATUSC : (AC Offset: 0x0A) (R/   8) Status C -------- */

typedef union {
  struct {
    uint8_t STATE0:1; /*!< bit:      0  Comparator 0 Current State         */
    uint8_t STATE1:1; /*!< bit:      1  Comparator 1 Current State         */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t WSTATE0:2; /*!< bit:  4.. 5  Window 0 Current State             */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t STATE:2; /*!< bit:  0.. 1  Comparator x Current State         */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_STATUSC_Type;


#define AC_STATUSC_OFFSET 0x0A
#define AC_STATUSC_RESETVALUE _U_(0x00)

#define AC_STATUSC_STATE0_Pos 0
#define AC_STATUSC_STATE0 (_U_(1) << AC_STATUSC_STATE0_Pos)
#define AC_STATUSC_STATE1_Pos 1
#define AC_STATUSC_STATE1 (_U_(1) << AC_STATUSC_STATE1_Pos)
#define AC_STATUSC_STATE_Pos 0
#define AC_STATUSC_STATE_Msk (_U_(0x3) << AC_STATUSC_STATE_Pos)
#define AC_STATUSC_STATE(value) (AC_STATUSC_STATE_Msk & ((value) << AC_STATUSC_STATE_Pos))
#define AC_STATUSC_WSTATE0_Pos 4
#define AC_STATUSC_WSTATE0_Msk (_U_(0x3) << AC_STATUSC_WSTATE0_Pos)
#define AC_STATUSC_WSTATE0(value) (AC_STATUSC_WSTATE0_Msk & ((value) << AC_STATUSC_WSTATE0_Pos))
#define AC_STATUSC_WSTATE0_ABOVE_Val _U_(0x0)
#define AC_STATUSC_WSTATE0_INSIDE_Val _U_(0x1)
#define AC_STATUSC_WSTATE0_BELOW_Val _U_(0x2)
#define AC_STATUSC_WSTATE0_ABOVE (AC_STATUSC_WSTATE0_ABOVE_Val << AC_STATUSC_WSTATE0_Pos)
#define AC_STATUSC_WSTATE0_INSIDE (AC_STATUSC_WSTATE0_INSIDE_Val << AC_STATUSC_WSTATE0_Pos)
#define AC_STATUSC_WSTATE0_BELOW (AC_STATUSC_WSTATE0_BELOW_Val << AC_STATUSC_WSTATE0_Pos)
#define AC_STATUSC_MASK _U_(0x33)

/* -------- AC_WINCTRL : (AC Offset: 0x0C) (R/W  8) Window Control -------- */

typedef union {
  struct {
    uint8_t WEN0:1; /*!< bit:      0  Window 0 Mode Enable               */
    uint8_t WINTSEL0:2; /*!< bit:  1.. 2  Window 0 Interrupt Selection       */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_WINCTRL_Type;


#define AC_WINCTRL_OFFSET 0x0C
#define AC_WINCTRL_RESETVALUE _U_(0x00)

#define AC_WINCTRL_WEN0_Pos 0
#define AC_WINCTRL_WEN0 (_U_(0x1) << AC_WINCTRL_WEN0_Pos)
#define AC_WINCTRL_WINTSEL0_Pos 1
#define AC_WINCTRL_WINTSEL0_Msk (_U_(0x3) << AC_WINCTRL_WINTSEL0_Pos)
#define AC_WINCTRL_WINTSEL0(value) (AC_WINCTRL_WINTSEL0_Msk & ((value) << AC_WINCTRL_WINTSEL0_Pos))
#define AC_WINCTRL_WINTSEL0_ABOVE_Val _U_(0x0)
#define AC_WINCTRL_WINTSEL0_INSIDE_Val _U_(0x1)
#define AC_WINCTRL_WINTSEL0_BELOW_Val _U_(0x2)
#define AC_WINCTRL_WINTSEL0_OUTSIDE_Val _U_(0x3)
#define AC_WINCTRL_WINTSEL0_ABOVE (AC_WINCTRL_WINTSEL0_ABOVE_Val << AC_WINCTRL_WINTSEL0_Pos)
#define AC_WINCTRL_WINTSEL0_INSIDE (AC_WINCTRL_WINTSEL0_INSIDE_Val << AC_WINCTRL_WINTSEL0_Pos)
#define AC_WINCTRL_WINTSEL0_BELOW (AC_WINCTRL_WINTSEL0_BELOW_Val << AC_WINCTRL_WINTSEL0_Pos)
#define AC_WINCTRL_WINTSEL0_OUTSIDE (AC_WINCTRL_WINTSEL0_OUTSIDE_Val << AC_WINCTRL_WINTSEL0_Pos)
#define AC_WINCTRL_MASK _U_(0x07)

/* -------- AC_COMPCTRL : (AC Offset: 0x10) (R/W 32) Comparator Control n -------- */

typedef union {
  struct {
    uint32_t ENABLE:1; /*!< bit:      0  Enable                             */
    uint32_t SINGLE:1; /*!< bit:      1  Single-Shot Mode                   */
    uint32_t SPEED:2; /*!< bit:  2.. 3  Speed Selection                    */
    uint32_t :1; /*!< bit:      4  Reserved                           */
    uint32_t INTSEL:2; /*!< bit:  5.. 6  Interrupt Selection                */
    uint32_t :1; /*!< bit:      7  Reserved                           */
    uint32_t MUXNEG:3; /*!< bit:  8..10  Negative Input Mux Selection       */
    uint32_t :1; /*!< bit:     11  Reserved                           */
    uint32_t MUXPOS:2; /*!< bit: 12..13  Positive Input Mux Selection       */
    uint32_t :1; /*!< bit:     14  Reserved                           */
    uint32_t SWAP:1; /*!< bit:     15  Swap Inputs and Invert             */
    uint32_t OUT:2; /*!< bit: 16..17  Output                             */
    uint32_t :1; /*!< bit:     18  Reserved                           */
    uint32_t HYST:1; /*!< bit:     19  Hysteresis Enable                  */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t FLEN:3; /*!< bit: 24..26  Filter Length                      */
    uint32_t :5; /*!< bit: 27..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} AC_COMPCTRL_Type;


#define AC_COMPCTRL_OFFSET 0x10
#define AC_COMPCTRL_RESETVALUE _U_(0x00000000)

#define AC_COMPCTRL_ENABLE_Pos 0
#define AC_COMPCTRL_ENABLE (_U_(0x1) << AC_COMPCTRL_ENABLE_Pos)
#define AC_COMPCTRL_SINGLE_Pos 1
#define AC_COMPCTRL_SINGLE (_U_(0x1) << AC_COMPCTRL_SINGLE_Pos)
#define AC_COMPCTRL_SPEED_Pos 2
#define AC_COMPCTRL_SPEED_Msk (_U_(0x3) << AC_COMPCTRL_SPEED_Pos)
#define AC_COMPCTRL_SPEED(value) (AC_COMPCTRL_SPEED_Msk & ((value) << AC_COMPCTRL_SPEED_Pos))
#define AC_COMPCTRL_SPEED_LOW_Val _U_(0x0)
#define AC_COMPCTRL_SPEED_HIGH_Val _U_(0x1)
#define AC_COMPCTRL_SPEED_LOW (AC_COMPCTRL_SPEED_LOW_Val << AC_COMPCTRL_SPEED_Pos)
#define AC_COMPCTRL_SPEED_HIGH (AC_COMPCTRL_SPEED_HIGH_Val << AC_COMPCTRL_SPEED_Pos)
#define AC_COMPCTRL_INTSEL_Pos 5
#define AC_COMPCTRL_INTSEL_Msk (_U_(0x3) << AC_COMPCTRL_INTSEL_Pos)
#define AC_COMPCTRL_INTSEL(value) (AC_COMPCTRL_INTSEL_Msk & ((value) << AC_COMPCTRL_INTSEL_Pos))
#define AC_COMPCTRL_INTSEL_TOGGLE_Val _U_(0x0)
#define AC_COMPCTRL_INTSEL_RISING_Val _U_(0x1)
#define AC_COMPCTRL_INTSEL_FALLING_Val _U_(0x2)
#define AC_COMPCTRL_INTSEL_EOC_Val _U_(0x3)
#define AC_COMPCTRL_INTSEL_TOGGLE (AC_COMPCTRL_INTSEL_TOGGLE_Val << AC_COMPCTRL_INTSEL_Pos)
#define AC_COMPCTRL_INTSEL_RISING (AC_COMPCTRL_INTSEL_RISING_Val << AC_COMPCTRL_INTSEL_Pos)
#define AC_COMPCTRL_INTSEL_FALLING (AC_COMPCTRL_INTSEL_FALLING_Val << AC_COMPCTRL_INTSEL_Pos)
#define AC_COMPCTRL_INTSEL_EOC (AC_COMPCTRL_INTSEL_EOC_Val << AC_COMPCTRL_INTSEL_Pos)
#define AC_COMPCTRL_MUXNEG_Pos 8
#define AC_COMPCTRL_MUXNEG_Msk (_U_(0x7) << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG(value) (AC_COMPCTRL_MUXNEG_Msk & ((value) << AC_COMPCTRL_MUXNEG_Pos))
#define AC_COMPCTRL_MUXNEG_PIN0_Val _U_(0x0)
#define AC_COMPCTRL_MUXNEG_PIN1_Val _U_(0x1)
#define AC_COMPCTRL_MUXNEG_PIN2_Val _U_(0x2)
#define AC_COMPCTRL_MUXNEG_PIN3_Val _U_(0x3)
#define AC_COMPCTRL_MUXNEG_GND_Val _U_(0x4)
#define AC_COMPCTRL_MUXNEG_VSCALE_Val _U_(0x5)
#define AC_COMPCTRL_MUXNEG_BANDGAP_Val _U_(0x6)
#define AC_COMPCTRL_MUXNEG_DAC_Val _U_(0x7)
#define AC_COMPCTRL_MUXNEG_PIN0 (AC_COMPCTRL_MUXNEG_PIN0_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG_PIN1 (AC_COMPCTRL_MUXNEG_PIN1_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG_PIN2 (AC_COMPCTRL_MUXNEG_PIN2_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG_PIN3 (AC_COMPCTRL_MUXNEG_PIN3_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG_GND (AC_COMPCTRL_MUXNEG_GND_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG_VSCALE (AC_COMPCTRL_MUXNEG_VSCALE_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG_BANDGAP (AC_COMPCTRL_MUXNEG_BANDGAP_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXNEG_DAC (AC_COMPCTRL_MUXNEG_DAC_Val << AC_COMPCTRL_MUXNEG_Pos)
#define AC_COMPCTRL_MUXPOS_Pos 12
#define AC_COMPCTRL_MUXPOS_Msk (_U_(0x3) << AC_COMPCTRL_MUXPOS_Pos)
#define AC_COMPCTRL_MUXPOS(value) (AC_COMPCTRL_MUXPOS_Msk & ((value) << AC_COMPCTRL_MUXPOS_Pos))
#define AC_COMPCTRL_MUXPOS_PIN0_Val _U_(0x0)
#define AC_COMPCTRL_MUXPOS_PIN1_Val _U_(0x1)
#define AC_COMPCTRL_MUXPOS_PIN2_Val _U_(0x2)
#define AC_COMPCTRL_MUXPOS_PIN3_Val _U_(0x3)
#define AC_COMPCTRL_MUXPOS_PIN0 (AC_COMPCTRL_MUXPOS_PIN0_Val << AC_COMPCTRL_MUXPOS_Pos)
#define AC_COMPCTRL_MUXPOS_PIN1 (AC_COMPCTRL_MUXPOS_PIN1_Val << AC_COMPCTRL_MUXPOS_Pos)
#define AC_COMPCTRL_MUXPOS_PIN2 (AC_COMPCTRL_MUXPOS_PIN2_Val << AC_COMPCTRL_MUXPOS_Pos)
#define AC_COMPCTRL_MUXPOS_PIN3 (AC_COMPCTRL_MUXPOS_PIN3_Val << AC_COMPCTRL_MUXPOS_Pos)
#define AC_COMPCTRL_SWAP_Pos 15
#define AC_COMPCTRL_SWAP (_U_(0x1) << AC_COMPCTRL_SWAP_Pos)
#define AC_COMPCTRL_OUT_Pos 16
#define AC_COMPCTRL_OUT_Msk (_U_(0x3) << AC_COMPCTRL_OUT_Pos)
#define AC_COMPCTRL_OUT(value) (AC_COMPCTRL_OUT_Msk & ((value) << AC_COMPCTRL_OUT_Pos))
#define AC_COMPCTRL_OUT_OFF_Val _U_(0x0)
#define AC_COMPCTRL_OUT_ASYNC_Val _U_(0x1)
#define AC_COMPCTRL_OUT_SYNC_Val _U_(0x2)
#define AC_COMPCTRL_OUT_OFF (AC_COMPCTRL_OUT_OFF_Val << AC_COMPCTRL_OUT_Pos)
#define AC_COMPCTRL_OUT_ASYNC (AC_COMPCTRL_OUT_ASYNC_Val << AC_COMPCTRL_OUT_Pos)
#define AC_COMPCTRL_OUT_SYNC (AC_COMPCTRL_OUT_SYNC_Val << AC_COMPCTRL_OUT_Pos)
#define AC_COMPCTRL_HYST_Pos 19
#define AC_COMPCTRL_HYST (_U_(0x1) << AC_COMPCTRL_HYST_Pos)
#define AC_COMPCTRL_FLEN_Pos 24
#define AC_COMPCTRL_FLEN_Msk (_U_(0x7) << AC_COMPCTRL_FLEN_Pos)
#define AC_COMPCTRL_FLEN(value) (AC_COMPCTRL_FLEN_Msk & ((value) << AC_COMPCTRL_FLEN_Pos))
#define AC_COMPCTRL_FLEN_OFF_Val _U_(0x0)
#define AC_COMPCTRL_FLEN_MAJ3_Val _U_(0x1)
#define AC_COMPCTRL_FLEN_MAJ5_Val _U_(0x2)
#define AC_COMPCTRL_FLEN_OFF (AC_COMPCTRL_FLEN_OFF_Val << AC_COMPCTRL_FLEN_Pos)
#define AC_COMPCTRL_FLEN_MAJ3 (AC_COMPCTRL_FLEN_MAJ3_Val << AC_COMPCTRL_FLEN_Pos)
#define AC_COMPCTRL_FLEN_MAJ5 (AC_COMPCTRL_FLEN_MAJ5_Val << AC_COMPCTRL_FLEN_Pos)
#define AC_COMPCTRL_MASK _U_(0x070BB76F)

/* -------- AC_SCALER : (AC Offset: 0x20) (R/W  8) Scaler n -------- */

typedef union {
  struct {
    uint8_t VALUE:6; /*!< bit:  0.. 5  Scaler Value                       */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} AC_SCALER_Type;


#define AC_SCALER_OFFSET 0x20
#define AC_SCALER_RESETVALUE _U_(0x00)

#define AC_SCALER_VALUE_Pos 0
#define AC_SCALER_VALUE_Msk (_U_(0x3F) << AC_SCALER_VALUE_Pos)
#define AC_SCALER_VALUE(value) (AC_SCALER_VALUE_Msk & ((value) << AC_SCALER_VALUE_Pos))
#define AC_SCALER_MASK _U_(0x3F)

/** \brief AC hardware registers */

typedef struct {
  volatile AC_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W  8) Control A */
  volatile AC_CTRLB_Type CTRLB; /**< \brief Offset: 0x01 ( /W  8) Control B */
  volatile AC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x02 (R/W 16) Event Control */
  volatile AC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x04 (R/W  8) Interrupt Enable Clear */
  volatile AC_INTENSET_Type INTENSET; /**< \brief Offset: 0x05 (R/W  8) Interrupt Enable Set */
  volatile AC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x06 (R/W  8) Interrupt Flag Status and Clear */
       RoReg8 Reserved1[0x1];
  volatile const AC_STATUSA_Type STATUSA; /**< \brief Offset: 0x08 (R/   8) Status A */
  volatile const AC_STATUSB_Type STATUSB; /**< \brief Offset: 0x09 (R/   8) Status B */
  volatile const AC_STATUSC_Type STATUSC; /**< \brief Offset: 0x0A (R/   8) Status C */
       RoReg8 Reserved2[0x1];
  volatile AC_WINCTRL_Type WINCTRL; /**< \brief Offset: 0x0C (R/W  8) Window Control */
       RoReg8 Reserved3[0x3];
  volatile AC_COMPCTRL_Type COMPCTRL[2]; /**< \brief Offset: 0x10 (R/W 32) Comparator Control n */
       RoReg8 Reserved4[0x8];
  volatile AC_SCALER_Type SCALER[2]; /**< \brief Offset: 0x20 (R/W  8) Scaler n */
} Ac;


/*@}*/
# 245 "asf4/samd21/include/samd21e18a.h" 2
#include "component/adc.h"
# 245 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/adc.h" 1
/**
 * \file
 *
 * \brief Component description for ADC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_ADC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR ADC */
/* ========================================================================== */
/** \addtogroup SAMD21_ADC Analog Digital Converter */
/*@{*/

#define ADC_U2204 
#define REV_ADC 0x120

/* -------- ADC_CTRLA : (ADC Offset: 0x00) (R/W  8) Control A -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint8_t RUNSTDBY:1; /*!< bit:      2  Run in Standby                     */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_CTRLA_Type;


#define ADC_CTRLA_OFFSET 0x00
#define ADC_CTRLA_RESETVALUE _U_(0x00)

#define ADC_CTRLA_SWRST_Pos 0
#define ADC_CTRLA_SWRST (_U_(0x1) << ADC_CTRLA_SWRST_Pos)
#define ADC_CTRLA_ENABLE_Pos 1
#define ADC_CTRLA_ENABLE (_U_(0x1) << ADC_CTRLA_ENABLE_Pos)
#define ADC_CTRLA_RUNSTDBY_Pos 2
#define ADC_CTRLA_RUNSTDBY (_U_(0x1) << ADC_CTRLA_RUNSTDBY_Pos)
#define ADC_CTRLA_MASK _U_(0x07)

/* -------- ADC_REFCTRL : (ADC Offset: 0x01) (R/W  8) Reference Control -------- */

typedef union {
  struct {
    uint8_t REFSEL:4; /*!< bit:  0.. 3  Reference Selection                */
    uint8_t :3; /*!< bit:  4.. 6  Reserved                           */
    uint8_t REFCOMP:1; /*!< bit:      7  Reference Buffer Offset Compensation Enable */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_REFCTRL_Type;


#define ADC_REFCTRL_OFFSET 0x01
#define ADC_REFCTRL_RESETVALUE _U_(0x00)

#define ADC_REFCTRL_REFSEL_Pos 0
#define ADC_REFCTRL_REFSEL_Msk (_U_(0xF) << ADC_REFCTRL_REFSEL_Pos)
#define ADC_REFCTRL_REFSEL(value) (ADC_REFCTRL_REFSEL_Msk & ((value) << ADC_REFCTRL_REFSEL_Pos))
#define ADC_REFCTRL_REFSEL_INT1V_Val _U_(0x0)
#define ADC_REFCTRL_REFSEL_INTVCC0_Val _U_(0x1)
#define ADC_REFCTRL_REFSEL_INTVCC1_Val _U_(0x2)
#define ADC_REFCTRL_REFSEL_AREFA_Val _U_(0x3)
#define ADC_REFCTRL_REFSEL_AREFB_Val _U_(0x4)
#define ADC_REFCTRL_REFSEL_INT1V (ADC_REFCTRL_REFSEL_INT1V_Val << ADC_REFCTRL_REFSEL_Pos)
#define ADC_REFCTRL_REFSEL_INTVCC0 (ADC_REFCTRL_REFSEL_INTVCC0_Val << ADC_REFCTRL_REFSEL_Pos)
#define ADC_REFCTRL_REFSEL_INTVCC1 (ADC_REFCTRL_REFSEL_INTVCC1_Val << ADC_REFCTRL_REFSEL_Pos)
#define ADC_REFCTRL_REFSEL_AREFA (ADC_REFCTRL_REFSEL_AREFA_Val << ADC_REFCTRL_REFSEL_Pos)
#define ADC_REFCTRL_REFSEL_AREFB (ADC_REFCTRL_REFSEL_AREFB_Val << ADC_REFCTRL_REFSEL_Pos)
#define ADC_REFCTRL_REFCOMP_Pos 7
#define ADC_REFCTRL_REFCOMP (_U_(0x1) << ADC_REFCTRL_REFCOMP_Pos)
#define ADC_REFCTRL_MASK _U_(0x8F)

/* -------- ADC_AVGCTRL : (ADC Offset: 0x02) (R/W  8) Average Control -------- */

typedef union {
  struct {
    uint8_t SAMPLENUM:4; /*!< bit:  0.. 3  Number of Samples to be Collected  */
    uint8_t ADJRES:3; /*!< bit:  4.. 6  Adjusting Result / Division Coefficient */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_AVGCTRL_Type;


#define ADC_AVGCTRL_OFFSET 0x02
#define ADC_AVGCTRL_RESETVALUE _U_(0x00)

#define ADC_AVGCTRL_SAMPLENUM_Pos 0
#define ADC_AVGCTRL_SAMPLENUM_Msk (_U_(0xF) << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM(value) (ADC_AVGCTRL_SAMPLENUM_Msk & ((value) << ADC_AVGCTRL_SAMPLENUM_Pos))
#define ADC_AVGCTRL_SAMPLENUM_1_Val _U_(0x0)
#define ADC_AVGCTRL_SAMPLENUM_2_Val _U_(0x1)
#define ADC_AVGCTRL_SAMPLENUM_4_Val _U_(0x2)
#define ADC_AVGCTRL_SAMPLENUM_8_Val _U_(0x3)
#define ADC_AVGCTRL_SAMPLENUM_16_Val _U_(0x4)
#define ADC_AVGCTRL_SAMPLENUM_32_Val _U_(0x5)
#define ADC_AVGCTRL_SAMPLENUM_64_Val _U_(0x6)
#define ADC_AVGCTRL_SAMPLENUM_128_Val _U_(0x7)
#define ADC_AVGCTRL_SAMPLENUM_256_Val _U_(0x8)
#define ADC_AVGCTRL_SAMPLENUM_512_Val _U_(0x9)
#define ADC_AVGCTRL_SAMPLENUM_1024_Val _U_(0xA)
#define ADC_AVGCTRL_SAMPLENUM_1 (ADC_AVGCTRL_SAMPLENUM_1_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_2 (ADC_AVGCTRL_SAMPLENUM_2_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_4 (ADC_AVGCTRL_SAMPLENUM_4_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_8 (ADC_AVGCTRL_SAMPLENUM_8_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_16 (ADC_AVGCTRL_SAMPLENUM_16_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_32 (ADC_AVGCTRL_SAMPLENUM_32_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_64 (ADC_AVGCTRL_SAMPLENUM_64_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_128 (ADC_AVGCTRL_SAMPLENUM_128_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_256 (ADC_AVGCTRL_SAMPLENUM_256_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_512 (ADC_AVGCTRL_SAMPLENUM_512_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_SAMPLENUM_1024 (ADC_AVGCTRL_SAMPLENUM_1024_Val << ADC_AVGCTRL_SAMPLENUM_Pos)
#define ADC_AVGCTRL_ADJRES_Pos 4
#define ADC_AVGCTRL_ADJRES_Msk (_U_(0x7) << ADC_AVGCTRL_ADJRES_Pos)
#define ADC_AVGCTRL_ADJRES(value) (ADC_AVGCTRL_ADJRES_Msk & ((value) << ADC_AVGCTRL_ADJRES_Pos))
#define ADC_AVGCTRL_MASK _U_(0x7F)

/* -------- ADC_SAMPCTRL : (ADC Offset: 0x03) (R/W  8) Sampling Time Control -------- */

typedef union {
  struct {
    uint8_t SAMPLEN:6; /*!< bit:  0.. 5  Sampling Time Length               */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_SAMPCTRL_Type;


#define ADC_SAMPCTRL_OFFSET 0x03
#define ADC_SAMPCTRL_RESETVALUE _U_(0x00)

#define ADC_SAMPCTRL_SAMPLEN_Pos 0
#define ADC_SAMPCTRL_SAMPLEN_Msk (_U_(0x3F) << ADC_SAMPCTRL_SAMPLEN_Pos)
#define ADC_SAMPCTRL_SAMPLEN(value) (ADC_SAMPCTRL_SAMPLEN_Msk & ((value) << ADC_SAMPCTRL_SAMPLEN_Pos))
#define ADC_SAMPCTRL_MASK _U_(0x3F)

/* -------- ADC_CTRLB : (ADC Offset: 0x04) (R/W 16) Control B -------- */

typedef union {
  struct {
    uint16_t DIFFMODE:1; /*!< bit:      0  Differential Mode                  */
    uint16_t LEFTADJ:1; /*!< bit:      1  Left-Adjusted Result               */
    uint16_t FREERUN:1; /*!< bit:      2  Free Running Mode                  */
    uint16_t CORREN:1; /*!< bit:      3  Digital Correction Logic Enabled   */
    uint16_t RESSEL:2; /*!< bit:  4.. 5  Conversion Result Resolution       */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t PRESCALER:3; /*!< bit:  8..10  Prescaler Configuration            */
    uint16_t :5; /*!< bit: 11..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} ADC_CTRLB_Type;


#define ADC_CTRLB_OFFSET 0x04
#define ADC_CTRLB_RESETVALUE _U_(0x0000)

#define ADC_CTRLB_DIFFMODE_Pos 0
#define ADC_CTRLB_DIFFMODE (_U_(0x1) << ADC_CTRLB_DIFFMODE_Pos)
#define ADC_CTRLB_LEFTADJ_Pos 1
#define ADC_CTRLB_LEFTADJ (_U_(0x1) << ADC_CTRLB_LEFTADJ_Pos)
#define ADC_CTRLB_FREERUN_Pos 2
#define ADC_CTRLB_FREERUN (_U_(0x1) << ADC_CTRLB_FREERUN_Pos)
#define ADC_CTRLB_CORREN_Pos 3
#define ADC_CTRLB_CORREN (_U_(0x1) << ADC_CTRLB_CORREN_Pos)
#define ADC_CTRLB_RESSEL_Pos 4
#define ADC_CTRLB_RESSEL_Msk (_U_(0x3) << ADC_CTRLB_RESSEL_Pos)
#define ADC_CTRLB_RESSEL(value) (ADC_CTRLB_RESSEL_Msk & ((value) << ADC_CTRLB_RESSEL_Pos))
#define ADC_CTRLB_RESSEL_12BIT_Val _U_(0x0)
#define ADC_CTRLB_RESSEL_16BIT_Val _U_(0x1)
#define ADC_CTRLB_RESSEL_10BIT_Val _U_(0x2)
#define ADC_CTRLB_RESSEL_8BIT_Val _U_(0x3)
#define ADC_CTRLB_RESSEL_12BIT (ADC_CTRLB_RESSEL_12BIT_Val << ADC_CTRLB_RESSEL_Pos)
#define ADC_CTRLB_RESSEL_16BIT (ADC_CTRLB_RESSEL_16BIT_Val << ADC_CTRLB_RESSEL_Pos)
#define ADC_CTRLB_RESSEL_10BIT (ADC_CTRLB_RESSEL_10BIT_Val << ADC_CTRLB_RESSEL_Pos)
#define ADC_CTRLB_RESSEL_8BIT (ADC_CTRLB_RESSEL_8BIT_Val << ADC_CTRLB_RESSEL_Pos)
#define ADC_CTRLB_PRESCALER_Pos 8
#define ADC_CTRLB_PRESCALER_Msk (_U_(0x7) << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER(value) (ADC_CTRLB_PRESCALER_Msk & ((value) << ADC_CTRLB_PRESCALER_Pos))
#define ADC_CTRLB_PRESCALER_DIV4_Val _U_(0x0)
#define ADC_CTRLB_PRESCALER_DIV8_Val _U_(0x1)
#define ADC_CTRLB_PRESCALER_DIV16_Val _U_(0x2)
#define ADC_CTRLB_PRESCALER_DIV32_Val _U_(0x3)
#define ADC_CTRLB_PRESCALER_DIV64_Val _U_(0x4)
#define ADC_CTRLB_PRESCALER_DIV128_Val _U_(0x5)
#define ADC_CTRLB_PRESCALER_DIV256_Val _U_(0x6)
#define ADC_CTRLB_PRESCALER_DIV512_Val _U_(0x7)
#define ADC_CTRLB_PRESCALER_DIV4 (ADC_CTRLB_PRESCALER_DIV4_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER_DIV8 (ADC_CTRLB_PRESCALER_DIV8_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER_DIV16 (ADC_CTRLB_PRESCALER_DIV16_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER_DIV32 (ADC_CTRLB_PRESCALER_DIV32_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER_DIV64 (ADC_CTRLB_PRESCALER_DIV64_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER_DIV128 (ADC_CTRLB_PRESCALER_DIV128_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER_DIV256 (ADC_CTRLB_PRESCALER_DIV256_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_PRESCALER_DIV512 (ADC_CTRLB_PRESCALER_DIV512_Val << ADC_CTRLB_PRESCALER_Pos)
#define ADC_CTRLB_MASK _U_(0x073F)

/* -------- ADC_WINCTRL : (ADC Offset: 0x08) (R/W  8) Window Monitor Control -------- */

typedef union {
  struct {
    uint8_t WINMODE:3; /*!< bit:  0.. 2  Window Monitor Mode                */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_WINCTRL_Type;


#define ADC_WINCTRL_OFFSET 0x08
#define ADC_WINCTRL_RESETVALUE _U_(0x00)

#define ADC_WINCTRL_WINMODE_Pos 0
#define ADC_WINCTRL_WINMODE_Msk (_U_(0x7) << ADC_WINCTRL_WINMODE_Pos)
#define ADC_WINCTRL_WINMODE(value) (ADC_WINCTRL_WINMODE_Msk & ((value) << ADC_WINCTRL_WINMODE_Pos))
#define ADC_WINCTRL_WINMODE_DISABLE_Val _U_(0x0)
#define ADC_WINCTRL_WINMODE_MODE1_Val _U_(0x1)
#define ADC_WINCTRL_WINMODE_MODE2_Val _U_(0x2)
#define ADC_WINCTRL_WINMODE_MODE3_Val _U_(0x3)
#define ADC_WINCTRL_WINMODE_MODE4_Val _U_(0x4)
#define ADC_WINCTRL_WINMODE_DISABLE (ADC_WINCTRL_WINMODE_DISABLE_Val << ADC_WINCTRL_WINMODE_Pos)
#define ADC_WINCTRL_WINMODE_MODE1 (ADC_WINCTRL_WINMODE_MODE1_Val << ADC_WINCTRL_WINMODE_Pos)
#define ADC_WINCTRL_WINMODE_MODE2 (ADC_WINCTRL_WINMODE_MODE2_Val << ADC_WINCTRL_WINMODE_Pos)
#define ADC_WINCTRL_WINMODE_MODE3 (ADC_WINCTRL_WINMODE_MODE3_Val << ADC_WINCTRL_WINMODE_Pos)
#define ADC_WINCTRL_WINMODE_MODE4 (ADC_WINCTRL_WINMODE_MODE4_Val << ADC_WINCTRL_WINMODE_Pos)
#define ADC_WINCTRL_MASK _U_(0x07)

/* -------- ADC_SWTRIG : (ADC Offset: 0x0C) (R/W  8) Software Trigger -------- */

typedef union {
  struct {
    uint8_t FLUSH:1; /*!< bit:      0  ADC Conversion Flush               */
    uint8_t START:1; /*!< bit:      1  ADC Start Conversion               */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_SWTRIG_Type;


#define ADC_SWTRIG_OFFSET 0x0C
#define ADC_SWTRIG_RESETVALUE _U_(0x00)

#define ADC_SWTRIG_FLUSH_Pos 0
#define ADC_SWTRIG_FLUSH (_U_(0x1) << ADC_SWTRIG_FLUSH_Pos)
#define ADC_SWTRIG_START_Pos 1
#define ADC_SWTRIG_START (_U_(0x1) << ADC_SWTRIG_START_Pos)
#define ADC_SWTRIG_MASK _U_(0x03)

/* -------- ADC_INPUTCTRL : (ADC Offset: 0x10) (R/W 32) Input Control -------- */

typedef union {
  struct {
    uint32_t MUXPOS:5; /*!< bit:  0.. 4  Positive Mux Input Selection       */
    uint32_t :3; /*!< bit:  5.. 7  Reserved                           */
    uint32_t MUXNEG:5; /*!< bit:  8..12  Negative Mux Input Selection       */
    uint32_t :3; /*!< bit: 13..15  Reserved                           */
    uint32_t INPUTSCAN:4; /*!< bit: 16..19  Number of Input Channels Included in Scan */
    uint32_t INPUTOFFSET:4; /*!< bit: 20..23  Positive Mux Setting Offset        */
    uint32_t GAIN:4; /*!< bit: 24..27  Gain Factor Selection              */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} ADC_INPUTCTRL_Type;


#define ADC_INPUTCTRL_OFFSET 0x10
#define ADC_INPUTCTRL_RESETVALUE _U_(0x00000000)

#define ADC_INPUTCTRL_MUXPOS_Pos 0
#define ADC_INPUTCTRL_MUXPOS_Msk (_U_(0x1F) << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS(value) (ADC_INPUTCTRL_MUXPOS_Msk & ((value) << ADC_INPUTCTRL_MUXPOS_Pos))
#define ADC_INPUTCTRL_MUXPOS_PIN0_Val _U_(0x0)
#define ADC_INPUTCTRL_MUXPOS_PIN1_Val _U_(0x1)
#define ADC_INPUTCTRL_MUXPOS_PIN2_Val _U_(0x2)
#define ADC_INPUTCTRL_MUXPOS_PIN3_Val _U_(0x3)
#define ADC_INPUTCTRL_MUXPOS_PIN4_Val _U_(0x4)
#define ADC_INPUTCTRL_MUXPOS_PIN5_Val _U_(0x5)
#define ADC_INPUTCTRL_MUXPOS_PIN6_Val _U_(0x6)
#define ADC_INPUTCTRL_MUXPOS_PIN7_Val _U_(0x7)
#define ADC_INPUTCTRL_MUXPOS_PIN8_Val _U_(0x8)
#define ADC_INPUTCTRL_MUXPOS_PIN9_Val _U_(0x9)
#define ADC_INPUTCTRL_MUXPOS_PIN10_Val _U_(0xA)
#define ADC_INPUTCTRL_MUXPOS_PIN11_Val _U_(0xB)
#define ADC_INPUTCTRL_MUXPOS_PIN12_Val _U_(0xC)
#define ADC_INPUTCTRL_MUXPOS_PIN13_Val _U_(0xD)
#define ADC_INPUTCTRL_MUXPOS_PIN14_Val _U_(0xE)
#define ADC_INPUTCTRL_MUXPOS_PIN15_Val _U_(0xF)
#define ADC_INPUTCTRL_MUXPOS_PIN16_Val _U_(0x10)
#define ADC_INPUTCTRL_MUXPOS_PIN17_Val _U_(0x11)
#define ADC_INPUTCTRL_MUXPOS_PIN18_Val _U_(0x12)
#define ADC_INPUTCTRL_MUXPOS_PIN19_Val _U_(0x13)
#define ADC_INPUTCTRL_MUXPOS_TEMP_Val _U_(0x18)
#define ADC_INPUTCTRL_MUXPOS_BANDGAP_Val _U_(0x19)
#define ADC_INPUTCTRL_MUXPOS_SCALEDCOREVCC_Val _U_(0x1A)
#define ADC_INPUTCTRL_MUXPOS_SCALEDIOVCC_Val _U_(0x1B)
#define ADC_INPUTCTRL_MUXPOS_DAC_Val _U_(0x1C)
#define ADC_INPUTCTRL_MUXPOS_PIN0 (ADC_INPUTCTRL_MUXPOS_PIN0_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN1 (ADC_INPUTCTRL_MUXPOS_PIN1_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN2 (ADC_INPUTCTRL_MUXPOS_PIN2_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN3 (ADC_INPUTCTRL_MUXPOS_PIN3_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN4 (ADC_INPUTCTRL_MUXPOS_PIN4_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN5 (ADC_INPUTCTRL_MUXPOS_PIN5_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN6 (ADC_INPUTCTRL_MUXPOS_PIN6_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN7 (ADC_INPUTCTRL_MUXPOS_PIN7_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN8 (ADC_INPUTCTRL_MUXPOS_PIN8_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN9 (ADC_INPUTCTRL_MUXPOS_PIN9_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN10 (ADC_INPUTCTRL_MUXPOS_PIN10_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN11 (ADC_INPUTCTRL_MUXPOS_PIN11_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN12 (ADC_INPUTCTRL_MUXPOS_PIN12_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN13 (ADC_INPUTCTRL_MUXPOS_PIN13_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN14 (ADC_INPUTCTRL_MUXPOS_PIN14_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN15 (ADC_INPUTCTRL_MUXPOS_PIN15_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN16 (ADC_INPUTCTRL_MUXPOS_PIN16_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN17 (ADC_INPUTCTRL_MUXPOS_PIN17_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN18 (ADC_INPUTCTRL_MUXPOS_PIN18_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_PIN19 (ADC_INPUTCTRL_MUXPOS_PIN19_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_TEMP (ADC_INPUTCTRL_MUXPOS_TEMP_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_BANDGAP (ADC_INPUTCTRL_MUXPOS_BANDGAP_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_SCALEDCOREVCC (ADC_INPUTCTRL_MUXPOS_SCALEDCOREVCC_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_SCALEDIOVCC (ADC_INPUTCTRL_MUXPOS_SCALEDIOVCC_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXPOS_DAC (ADC_INPUTCTRL_MUXPOS_DAC_Val << ADC_INPUTCTRL_MUXPOS_Pos)
#define ADC_INPUTCTRL_MUXNEG_Pos 8
#define ADC_INPUTCTRL_MUXNEG_Msk (_U_(0x1F) << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG(value) (ADC_INPUTCTRL_MUXNEG_Msk & ((value) << ADC_INPUTCTRL_MUXNEG_Pos))
#define ADC_INPUTCTRL_MUXNEG_PIN0_Val _U_(0x0)
#define ADC_INPUTCTRL_MUXNEG_PIN1_Val _U_(0x1)
#define ADC_INPUTCTRL_MUXNEG_PIN2_Val _U_(0x2)
#define ADC_INPUTCTRL_MUXNEG_PIN3_Val _U_(0x3)
#define ADC_INPUTCTRL_MUXNEG_PIN4_Val _U_(0x4)
#define ADC_INPUTCTRL_MUXNEG_PIN5_Val _U_(0x5)
#define ADC_INPUTCTRL_MUXNEG_PIN6_Val _U_(0x6)
#define ADC_INPUTCTRL_MUXNEG_PIN7_Val _U_(0x7)
#define ADC_INPUTCTRL_MUXNEG_GND_Val _U_(0x18)
#define ADC_INPUTCTRL_MUXNEG_IOGND_Val _U_(0x19)
#define ADC_INPUTCTRL_MUXNEG_PIN0 (ADC_INPUTCTRL_MUXNEG_PIN0_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_PIN1 (ADC_INPUTCTRL_MUXNEG_PIN1_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_PIN2 (ADC_INPUTCTRL_MUXNEG_PIN2_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_PIN3 (ADC_INPUTCTRL_MUXNEG_PIN3_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_PIN4 (ADC_INPUTCTRL_MUXNEG_PIN4_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_PIN5 (ADC_INPUTCTRL_MUXNEG_PIN5_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_PIN6 (ADC_INPUTCTRL_MUXNEG_PIN6_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_PIN7 (ADC_INPUTCTRL_MUXNEG_PIN7_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_GND (ADC_INPUTCTRL_MUXNEG_GND_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_MUXNEG_IOGND (ADC_INPUTCTRL_MUXNEG_IOGND_Val << ADC_INPUTCTRL_MUXNEG_Pos)
#define ADC_INPUTCTRL_INPUTSCAN_Pos 16
#define ADC_INPUTCTRL_INPUTSCAN_Msk (_U_(0xF) << ADC_INPUTCTRL_INPUTSCAN_Pos)
#define ADC_INPUTCTRL_INPUTSCAN(value) (ADC_INPUTCTRL_INPUTSCAN_Msk & ((value) << ADC_INPUTCTRL_INPUTSCAN_Pos))
#define ADC_INPUTCTRL_INPUTOFFSET_Pos 20
#define ADC_INPUTCTRL_INPUTOFFSET_Msk (_U_(0xF) << ADC_INPUTCTRL_INPUTOFFSET_Pos)
#define ADC_INPUTCTRL_INPUTOFFSET(value) (ADC_INPUTCTRL_INPUTOFFSET_Msk & ((value) << ADC_INPUTCTRL_INPUTOFFSET_Pos))
#define ADC_INPUTCTRL_GAIN_Pos 24
#define ADC_INPUTCTRL_GAIN_Msk (_U_(0xF) << ADC_INPUTCTRL_GAIN_Pos)
#define ADC_INPUTCTRL_GAIN(value) (ADC_INPUTCTRL_GAIN_Msk & ((value) << ADC_INPUTCTRL_GAIN_Pos))
#define ADC_INPUTCTRL_GAIN_1X_Val _U_(0x0)
#define ADC_INPUTCTRL_GAIN_2X_Val _U_(0x1)
#define ADC_INPUTCTRL_GAIN_4X_Val _U_(0x2)
#define ADC_INPUTCTRL_GAIN_8X_Val _U_(0x3)
#define ADC_INPUTCTRL_GAIN_16X_Val _U_(0x4)
#define ADC_INPUTCTRL_GAIN_DIV2_Val _U_(0xF)
#define ADC_INPUTCTRL_GAIN_1X (ADC_INPUTCTRL_GAIN_1X_Val << ADC_INPUTCTRL_GAIN_Pos)
#define ADC_INPUTCTRL_GAIN_2X (ADC_INPUTCTRL_GAIN_2X_Val << ADC_INPUTCTRL_GAIN_Pos)
#define ADC_INPUTCTRL_GAIN_4X (ADC_INPUTCTRL_GAIN_4X_Val << ADC_INPUTCTRL_GAIN_Pos)
#define ADC_INPUTCTRL_GAIN_8X (ADC_INPUTCTRL_GAIN_8X_Val << ADC_INPUTCTRL_GAIN_Pos)
#define ADC_INPUTCTRL_GAIN_16X (ADC_INPUTCTRL_GAIN_16X_Val << ADC_INPUTCTRL_GAIN_Pos)
#define ADC_INPUTCTRL_GAIN_DIV2 (ADC_INPUTCTRL_GAIN_DIV2_Val << ADC_INPUTCTRL_GAIN_Pos)
#define ADC_INPUTCTRL_MASK _U_(0x0FFF1F1F)

/* -------- ADC_EVCTRL : (ADC Offset: 0x14) (R/W  8) Event Control -------- */

typedef union {
  struct {
    uint8_t STARTEI:1; /*!< bit:      0  Start Conversion Event In          */
    uint8_t SYNCEI:1; /*!< bit:      1  Synchronization Event In           */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t RESRDYEO:1; /*!< bit:      4  Result Ready Event Out             */
    uint8_t WINMONEO:1; /*!< bit:      5  Window Monitor Event Out           */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_EVCTRL_Type;


#define ADC_EVCTRL_OFFSET 0x14
#define ADC_EVCTRL_RESETVALUE _U_(0x00)

#define ADC_EVCTRL_STARTEI_Pos 0
#define ADC_EVCTRL_STARTEI (_U_(0x1) << ADC_EVCTRL_STARTEI_Pos)
#define ADC_EVCTRL_SYNCEI_Pos 1
#define ADC_EVCTRL_SYNCEI (_U_(0x1) << ADC_EVCTRL_SYNCEI_Pos)
#define ADC_EVCTRL_RESRDYEO_Pos 4
#define ADC_EVCTRL_RESRDYEO (_U_(0x1) << ADC_EVCTRL_RESRDYEO_Pos)
#define ADC_EVCTRL_WINMONEO_Pos 5
#define ADC_EVCTRL_WINMONEO (_U_(0x1) << ADC_EVCTRL_WINMONEO_Pos)
#define ADC_EVCTRL_MASK _U_(0x33)

/* -------- ADC_INTENCLR : (ADC Offset: 0x16) (R/W  8) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t RESRDY:1; /*!< bit:      0  Result Ready Interrupt Enable      */
    uint8_t OVERRUN:1; /*!< bit:      1  Overrun Interrupt Enable           */
    uint8_t WINMON:1; /*!< bit:      2  Window Monitor Interrupt Enable    */
    uint8_t SYNCRDY:1; /*!< bit:      3  Synchronization Ready Interrupt Enable */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_INTENCLR_Type;


#define ADC_INTENCLR_OFFSET 0x16
#define ADC_INTENCLR_RESETVALUE _U_(0x00)

#define ADC_INTENCLR_RESRDY_Pos 0
#define ADC_INTENCLR_RESRDY (_U_(0x1) << ADC_INTENCLR_RESRDY_Pos)
#define ADC_INTENCLR_OVERRUN_Pos 1
#define ADC_INTENCLR_OVERRUN (_U_(0x1) << ADC_INTENCLR_OVERRUN_Pos)
#define ADC_INTENCLR_WINMON_Pos 2
#define ADC_INTENCLR_WINMON (_U_(0x1) << ADC_INTENCLR_WINMON_Pos)
#define ADC_INTENCLR_SYNCRDY_Pos 3
#define ADC_INTENCLR_SYNCRDY (_U_(0x1) << ADC_INTENCLR_SYNCRDY_Pos)
#define ADC_INTENCLR_MASK _U_(0x0F)

/* -------- ADC_INTENSET : (ADC Offset: 0x17) (R/W  8) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t RESRDY:1; /*!< bit:      0  Result Ready Interrupt Enable      */
    uint8_t OVERRUN:1; /*!< bit:      1  Overrun Interrupt Enable           */
    uint8_t WINMON:1; /*!< bit:      2  Window Monitor Interrupt Enable    */
    uint8_t SYNCRDY:1; /*!< bit:      3  Synchronization Ready Interrupt Enable */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_INTENSET_Type;


#define ADC_INTENSET_OFFSET 0x17
#define ADC_INTENSET_RESETVALUE _U_(0x00)

#define ADC_INTENSET_RESRDY_Pos 0
#define ADC_INTENSET_RESRDY (_U_(0x1) << ADC_INTENSET_RESRDY_Pos)
#define ADC_INTENSET_OVERRUN_Pos 1
#define ADC_INTENSET_OVERRUN (_U_(0x1) << ADC_INTENSET_OVERRUN_Pos)
#define ADC_INTENSET_WINMON_Pos 2
#define ADC_INTENSET_WINMON (_U_(0x1) << ADC_INTENSET_WINMON_Pos)
#define ADC_INTENSET_SYNCRDY_Pos 3
#define ADC_INTENSET_SYNCRDY (_U_(0x1) << ADC_INTENSET_SYNCRDY_Pos)
#define ADC_INTENSET_MASK _U_(0x0F)

/* -------- ADC_INTFLAG : (ADC Offset: 0x18) (R/W  8) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t RESRDY:1; /*!< bit:      0  Result Ready                       */
    volatile const uint8_t OVERRUN:1; /*!< bit:      1  Overrun                            */
    volatile const uint8_t WINMON:1; /*!< bit:      2  Window Monitor                     */
    volatile const uint8_t SYNCRDY:1; /*!< bit:      3  Synchronization Ready              */
    volatile const uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_INTFLAG_Type;


#define ADC_INTFLAG_OFFSET 0x18
#define ADC_INTFLAG_RESETVALUE _U_(0x00)

#define ADC_INTFLAG_RESRDY_Pos 0
#define ADC_INTFLAG_RESRDY (_U_(0x1) << ADC_INTFLAG_RESRDY_Pos)
#define ADC_INTFLAG_OVERRUN_Pos 1
#define ADC_INTFLAG_OVERRUN (_U_(0x1) << ADC_INTFLAG_OVERRUN_Pos)
#define ADC_INTFLAG_WINMON_Pos 2
#define ADC_INTFLAG_WINMON (_U_(0x1) << ADC_INTFLAG_WINMON_Pos)
#define ADC_INTFLAG_SYNCRDY_Pos 3
#define ADC_INTFLAG_SYNCRDY (_U_(0x1) << ADC_INTFLAG_SYNCRDY_Pos)
#define ADC_INTFLAG_MASK _U_(0x0F)

/* -------- ADC_STATUS : (ADC Offset: 0x19) (R/   8) Status -------- */

typedef union {
  struct {
    uint8_t :7; /*!< bit:  0.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy               */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_STATUS_Type;


#define ADC_STATUS_OFFSET 0x19
#define ADC_STATUS_RESETVALUE _U_(0x00)

#define ADC_STATUS_SYNCBUSY_Pos 7
#define ADC_STATUS_SYNCBUSY (_U_(0x1) << ADC_STATUS_SYNCBUSY_Pos)
#define ADC_STATUS_MASK _U_(0x80)

/* -------- ADC_RESULT : (ADC Offset: 0x1A) (R/  16) Result -------- */

typedef union {
  struct {
    uint16_t RESULT:16; /*!< bit:  0..15  Result Conversion Value            */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} ADC_RESULT_Type;


#define ADC_RESULT_OFFSET 0x1A
#define ADC_RESULT_RESETVALUE _U_(0x0000)

#define ADC_RESULT_RESULT_Pos 0
#define ADC_RESULT_RESULT_Msk (_U_(0xFFFF) << ADC_RESULT_RESULT_Pos)
#define ADC_RESULT_RESULT(value) (ADC_RESULT_RESULT_Msk & ((value) << ADC_RESULT_RESULT_Pos))
#define ADC_RESULT_MASK _U_(0xFFFF)

/* -------- ADC_WINLT : (ADC Offset: 0x1C) (R/W 16) Window Monitor Lower Threshold -------- */

typedef union {
  struct {
    uint16_t WINLT:16; /*!< bit:  0..15  Window Lower Threshold             */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} ADC_WINLT_Type;


#define ADC_WINLT_OFFSET 0x1C
#define ADC_WINLT_RESETVALUE _U_(0x0000)

#define ADC_WINLT_WINLT_Pos 0
#define ADC_WINLT_WINLT_Msk (_U_(0xFFFF) << ADC_WINLT_WINLT_Pos)
#define ADC_WINLT_WINLT(value) (ADC_WINLT_WINLT_Msk & ((value) << ADC_WINLT_WINLT_Pos))
#define ADC_WINLT_MASK _U_(0xFFFF)

/* -------- ADC_WINUT : (ADC Offset: 0x20) (R/W 16) Window Monitor Upper Threshold -------- */

typedef union {
  struct {
    uint16_t WINUT:16; /*!< bit:  0..15  Window Upper Threshold             */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} ADC_WINUT_Type;


#define ADC_WINUT_OFFSET 0x20
#define ADC_WINUT_RESETVALUE _U_(0x0000)

#define ADC_WINUT_WINUT_Pos 0
#define ADC_WINUT_WINUT_Msk (_U_(0xFFFF) << ADC_WINUT_WINUT_Pos)
#define ADC_WINUT_WINUT(value) (ADC_WINUT_WINUT_Msk & ((value) << ADC_WINUT_WINUT_Pos))
#define ADC_WINUT_MASK _U_(0xFFFF)

/* -------- ADC_GAINCORR : (ADC Offset: 0x24) (R/W 16) Gain Correction -------- */

typedef union {
  struct {
    uint16_t GAINCORR:12; /*!< bit:  0..11  Gain Correction Value              */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} ADC_GAINCORR_Type;


#define ADC_GAINCORR_OFFSET 0x24
#define ADC_GAINCORR_RESETVALUE _U_(0x0000)

#define ADC_GAINCORR_GAINCORR_Pos 0
#define ADC_GAINCORR_GAINCORR_Msk (_U_(0xFFF) << ADC_GAINCORR_GAINCORR_Pos)
#define ADC_GAINCORR_GAINCORR(value) (ADC_GAINCORR_GAINCORR_Msk & ((value) << ADC_GAINCORR_GAINCORR_Pos))
#define ADC_GAINCORR_MASK _U_(0x0FFF)

/* -------- ADC_OFFSETCORR : (ADC Offset: 0x26) (R/W 16) Offset Correction -------- */

typedef union {
  struct {
    uint16_t OFFSETCORR:12; /*!< bit:  0..11  Offset Correction Value            */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} ADC_OFFSETCORR_Type;


#define ADC_OFFSETCORR_OFFSET 0x26
#define ADC_OFFSETCORR_RESETVALUE _U_(0x0000)

#define ADC_OFFSETCORR_OFFSETCORR_Pos 0
#define ADC_OFFSETCORR_OFFSETCORR_Msk (_U_(0xFFF) << ADC_OFFSETCORR_OFFSETCORR_Pos)
#define ADC_OFFSETCORR_OFFSETCORR(value) (ADC_OFFSETCORR_OFFSETCORR_Msk & ((value) << ADC_OFFSETCORR_OFFSETCORR_Pos))
#define ADC_OFFSETCORR_MASK _U_(0x0FFF)

/* -------- ADC_CALIB : (ADC Offset: 0x28) (R/W 16) Calibration -------- */

typedef union {
  struct {
    uint16_t LINEARITY_CAL:8; /*!< bit:  0.. 7  Linearity Calibration Value        */
    uint16_t BIAS_CAL:3; /*!< bit:  8..10  Bias Calibration Value             */
    uint16_t :5; /*!< bit: 11..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} ADC_CALIB_Type;


#define ADC_CALIB_OFFSET 0x28
#define ADC_CALIB_RESETVALUE _U_(0x0000)

#define ADC_CALIB_LINEARITY_CAL_Pos 0
#define ADC_CALIB_LINEARITY_CAL_Msk (_U_(0xFF) << ADC_CALIB_LINEARITY_CAL_Pos)
#define ADC_CALIB_LINEARITY_CAL(value) (ADC_CALIB_LINEARITY_CAL_Msk & ((value) << ADC_CALIB_LINEARITY_CAL_Pos))
#define ADC_CALIB_BIAS_CAL_Pos 8
#define ADC_CALIB_BIAS_CAL_Msk (_U_(0x7) << ADC_CALIB_BIAS_CAL_Pos)
#define ADC_CALIB_BIAS_CAL(value) (ADC_CALIB_BIAS_CAL_Msk & ((value) << ADC_CALIB_BIAS_CAL_Pos))
#define ADC_CALIB_MASK _U_(0x07FF)

/* -------- ADC_DBGCTRL : (ADC Offset: 0x2A) (R/W  8) Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGRUN:1; /*!< bit:      0  Debug Run                          */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} ADC_DBGCTRL_Type;


#define ADC_DBGCTRL_OFFSET 0x2A
#define ADC_DBGCTRL_RESETVALUE _U_(0x00)

#define ADC_DBGCTRL_DBGRUN_Pos 0
#define ADC_DBGCTRL_DBGRUN (_U_(0x1) << ADC_DBGCTRL_DBGRUN_Pos)
#define ADC_DBGCTRL_MASK _U_(0x01)

/** \brief ADC hardware registers */

typedef struct {
  volatile ADC_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W  8) Control A */
  volatile ADC_REFCTRL_Type REFCTRL; /**< \brief Offset: 0x01 (R/W  8) Reference Control */
  volatile ADC_AVGCTRL_Type AVGCTRL; /**< \brief Offset: 0x02 (R/W  8) Average Control */
  volatile ADC_SAMPCTRL_Type SAMPCTRL; /**< \brief Offset: 0x03 (R/W  8) Sampling Time Control */
  volatile ADC_CTRLB_Type CTRLB; /**< \brief Offset: 0x04 (R/W 16) Control B */
       RoReg8 Reserved1[0x2];
  volatile ADC_WINCTRL_Type WINCTRL; /**< \brief Offset: 0x08 (R/W  8) Window Monitor Control */
       RoReg8 Reserved2[0x3];
  volatile ADC_SWTRIG_Type SWTRIG; /**< \brief Offset: 0x0C (R/W  8) Software Trigger */
       RoReg8 Reserved3[0x3];
  volatile ADC_INPUTCTRL_Type INPUTCTRL; /**< \brief Offset: 0x10 (R/W 32) Input Control */
  volatile ADC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x14 (R/W  8) Event Control */
       RoReg8 Reserved4[0x1];
  volatile ADC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x16 (R/W  8) Interrupt Enable Clear */
  volatile ADC_INTENSET_Type INTENSET; /**< \brief Offset: 0x17 (R/W  8) Interrupt Enable Set */
  volatile ADC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x18 (R/W  8) Interrupt Flag Status and Clear */
  volatile const ADC_STATUS_Type STATUS; /**< \brief Offset: 0x19 (R/   8) Status */
  volatile const ADC_RESULT_Type RESULT; /**< \brief Offset: 0x1A (R/  16) Result */
  volatile ADC_WINLT_Type WINLT; /**< \brief Offset: 0x1C (R/W 16) Window Monitor Lower Threshold */
       RoReg8 Reserved5[0x2];
  volatile ADC_WINUT_Type WINUT; /**< \brief Offset: 0x20 (R/W 16) Window Monitor Upper Threshold */
       RoReg8 Reserved6[0x2];
  volatile ADC_GAINCORR_Type GAINCORR; /**< \brief Offset: 0x24 (R/W 16) Gain Correction */
  volatile ADC_OFFSETCORR_Type OFFSETCORR; /**< \brief Offset: 0x26 (R/W 16) Offset Correction */
  volatile ADC_CALIB_Type CALIB; /**< \brief Offset: 0x28 (R/W 16) Calibration */
  volatile ADC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x2A (R/W  8) Debug Control */
} Adc;


/*@}*/
# 246 "asf4/samd21/include/samd21e18a.h" 2
#include "component/dac.h"
# 246 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/dac.h" 1
/**
 * \file
 *
 * \brief Component description for DAC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_DAC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR DAC */
/* ========================================================================== */
/** \addtogroup SAMD21_DAC Digital Analog Converter */
/*@{*/

#define DAC_U2214 
#define REV_DAC 0x110

/* -------- DAC_CTRLA : (DAC Offset: 0x0) (R/W  8) Control A -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint8_t RUNSTDBY:1; /*!< bit:      2  Run in Standby                     */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DAC_CTRLA_Type;


#define DAC_CTRLA_OFFSET 0x0
#define DAC_CTRLA_RESETVALUE _U_(0x00)

#define DAC_CTRLA_SWRST_Pos 0
#define DAC_CTRLA_SWRST (_U_(0x1) << DAC_CTRLA_SWRST_Pos)
#define DAC_CTRLA_ENABLE_Pos 1
#define DAC_CTRLA_ENABLE (_U_(0x1) << DAC_CTRLA_ENABLE_Pos)
#define DAC_CTRLA_RUNSTDBY_Pos 2
#define DAC_CTRLA_RUNSTDBY (_U_(0x1) << DAC_CTRLA_RUNSTDBY_Pos)
#define DAC_CTRLA_MASK _U_(0x07)

/* -------- DAC_CTRLB : (DAC Offset: 0x1) (R/W  8) Control B -------- */

typedef union {
  struct {
    uint8_t EOEN:1; /*!< bit:      0  External Output Enable             */
    uint8_t IOEN:1; /*!< bit:      1  Internal Output Enable             */
    uint8_t LEFTADJ:1; /*!< bit:      2  Left Adjusted Data                 */
    uint8_t VPD:1; /*!< bit:      3  Voltage Pump Disable               */
    uint8_t BDWP:1; /*!< bit:      4  Bypass DATABUF Write Protection    */
    uint8_t :1; /*!< bit:      5  Reserved                           */
    uint8_t REFSEL:2; /*!< bit:  6.. 7  Reference Selection                */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DAC_CTRLB_Type;


#define DAC_CTRLB_OFFSET 0x1
#define DAC_CTRLB_RESETVALUE _U_(0x00)

#define DAC_CTRLB_EOEN_Pos 0
#define DAC_CTRLB_EOEN (_U_(0x1) << DAC_CTRLB_EOEN_Pos)
#define DAC_CTRLB_IOEN_Pos 1
#define DAC_CTRLB_IOEN (_U_(0x1) << DAC_CTRLB_IOEN_Pos)
#define DAC_CTRLB_LEFTADJ_Pos 2
#define DAC_CTRLB_LEFTADJ (_U_(0x1) << DAC_CTRLB_LEFTADJ_Pos)
#define DAC_CTRLB_VPD_Pos 3
#define DAC_CTRLB_VPD (_U_(0x1) << DAC_CTRLB_VPD_Pos)
#define DAC_CTRLB_BDWP_Pos 4
#define DAC_CTRLB_BDWP (_U_(0x1) << DAC_CTRLB_BDWP_Pos)
#define DAC_CTRLB_REFSEL_Pos 6
#define DAC_CTRLB_REFSEL_Msk (_U_(0x3) << DAC_CTRLB_REFSEL_Pos)
#define DAC_CTRLB_REFSEL(value) (DAC_CTRLB_REFSEL_Msk & ((value) << DAC_CTRLB_REFSEL_Pos))
#define DAC_CTRLB_REFSEL_INT1V_Val _U_(0x0)
#define DAC_CTRLB_REFSEL_AVCC_Val _U_(0x1)
#define DAC_CTRLB_REFSEL_VREFP_Val _U_(0x2)
#define DAC_CTRLB_REFSEL_INT1V (DAC_CTRLB_REFSEL_INT1V_Val << DAC_CTRLB_REFSEL_Pos)
#define DAC_CTRLB_REFSEL_AVCC (DAC_CTRLB_REFSEL_AVCC_Val << DAC_CTRLB_REFSEL_Pos)
#define DAC_CTRLB_REFSEL_VREFP (DAC_CTRLB_REFSEL_VREFP_Val << DAC_CTRLB_REFSEL_Pos)
#define DAC_CTRLB_MASK _U_(0xDF)

/* -------- DAC_EVCTRL : (DAC Offset: 0x2) (R/W  8) Event Control -------- */

typedef union {
  struct {
    uint8_t STARTEI:1; /*!< bit:      0  Start Conversion Event Input       */
    uint8_t EMPTYEO:1; /*!< bit:      1  Data Buffer Empty Event Output     */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DAC_EVCTRL_Type;


#define DAC_EVCTRL_OFFSET 0x2
#define DAC_EVCTRL_RESETVALUE _U_(0x00)

#define DAC_EVCTRL_STARTEI_Pos 0
#define DAC_EVCTRL_STARTEI (_U_(0x1) << DAC_EVCTRL_STARTEI_Pos)
#define DAC_EVCTRL_EMPTYEO_Pos 1
#define DAC_EVCTRL_EMPTYEO (_U_(0x1) << DAC_EVCTRL_EMPTYEO_Pos)
#define DAC_EVCTRL_MASK _U_(0x03)

/* -------- DAC_INTENCLR : (DAC Offset: 0x4) (R/W  8) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t UNDERRUN:1; /*!< bit:      0  Underrun Interrupt Enable          */
    uint8_t EMPTY:1; /*!< bit:      1  Data Buffer Empty Interrupt Enable */
    uint8_t SYNCRDY:1; /*!< bit:      2  Synchronization Ready Interrupt Enable */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DAC_INTENCLR_Type;


#define DAC_INTENCLR_OFFSET 0x4
#define DAC_INTENCLR_RESETVALUE _U_(0x00)

#define DAC_INTENCLR_UNDERRUN_Pos 0
#define DAC_INTENCLR_UNDERRUN (_U_(0x1) << DAC_INTENCLR_UNDERRUN_Pos)
#define DAC_INTENCLR_EMPTY_Pos 1
#define DAC_INTENCLR_EMPTY (_U_(0x1) << DAC_INTENCLR_EMPTY_Pos)
#define DAC_INTENCLR_SYNCRDY_Pos 2
#define DAC_INTENCLR_SYNCRDY (_U_(0x1) << DAC_INTENCLR_SYNCRDY_Pos)
#define DAC_INTENCLR_MASK _U_(0x07)

/* -------- DAC_INTENSET : (DAC Offset: 0x5) (R/W  8) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t UNDERRUN:1; /*!< bit:      0  Underrun Interrupt Enable          */
    uint8_t EMPTY:1; /*!< bit:      1  Data Buffer Empty Interrupt Enable */
    uint8_t SYNCRDY:1; /*!< bit:      2  Synchronization Ready Interrupt Enable */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DAC_INTENSET_Type;


#define DAC_INTENSET_OFFSET 0x5
#define DAC_INTENSET_RESETVALUE _U_(0x00)

#define DAC_INTENSET_UNDERRUN_Pos 0
#define DAC_INTENSET_UNDERRUN (_U_(0x1) << DAC_INTENSET_UNDERRUN_Pos)
#define DAC_INTENSET_EMPTY_Pos 1
#define DAC_INTENSET_EMPTY (_U_(0x1) << DAC_INTENSET_EMPTY_Pos)
#define DAC_INTENSET_SYNCRDY_Pos 2
#define DAC_INTENSET_SYNCRDY (_U_(0x1) << DAC_INTENSET_SYNCRDY_Pos)
#define DAC_INTENSET_MASK _U_(0x07)

/* -------- DAC_INTFLAG : (DAC Offset: 0x6) (R/W  8) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t UNDERRUN:1; /*!< bit:      0  Underrun                           */
    volatile const uint8_t EMPTY:1; /*!< bit:      1  Data Buffer Empty                  */
    volatile const uint8_t SYNCRDY:1; /*!< bit:      2  Synchronization Ready              */
    volatile const uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DAC_INTFLAG_Type;


#define DAC_INTFLAG_OFFSET 0x6
#define DAC_INTFLAG_RESETVALUE _U_(0x00)

#define DAC_INTFLAG_UNDERRUN_Pos 0
#define DAC_INTFLAG_UNDERRUN (_U_(0x1) << DAC_INTFLAG_UNDERRUN_Pos)
#define DAC_INTFLAG_EMPTY_Pos 1
#define DAC_INTFLAG_EMPTY (_U_(0x1) << DAC_INTFLAG_EMPTY_Pos)
#define DAC_INTFLAG_SYNCRDY_Pos 2
#define DAC_INTFLAG_SYNCRDY (_U_(0x1) << DAC_INTFLAG_SYNCRDY_Pos)
#define DAC_INTFLAG_MASK _U_(0x07)

/* -------- DAC_STATUS : (DAC Offset: 0x7) (R/   8) Status -------- */

typedef union {
  struct {
    uint8_t :7; /*!< bit:  0.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy Status        */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DAC_STATUS_Type;


#define DAC_STATUS_OFFSET 0x7
#define DAC_STATUS_RESETVALUE _U_(0x00)

#define DAC_STATUS_SYNCBUSY_Pos 7
#define DAC_STATUS_SYNCBUSY (_U_(0x1) << DAC_STATUS_SYNCBUSY_Pos)
#define DAC_STATUS_MASK _U_(0x80)

/* -------- DAC_DATA : (DAC Offset: 0x8) (R/W 16) Data -------- */

typedef union {
  struct {
    uint16_t DATA:16; /*!< bit:  0..15  Data value to be converted         */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} DAC_DATA_Type;


#define DAC_DATA_OFFSET 0x8
#define DAC_DATA_RESETVALUE _U_(0x0000)

#define DAC_DATA_DATA_Pos 0
#define DAC_DATA_DATA_Msk (_U_(0xFFFF) << DAC_DATA_DATA_Pos)
#define DAC_DATA_DATA(value) (DAC_DATA_DATA_Msk & ((value) << DAC_DATA_DATA_Pos))
#define DAC_DATA_MASK _U_(0xFFFF)

/* -------- DAC_DATABUF : (DAC Offset: 0xC) (R/W 16) Data Buffer -------- */

typedef union {
  struct {
    uint16_t DATABUF:16; /*!< bit:  0..15  Data Buffer                        */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} DAC_DATABUF_Type;


#define DAC_DATABUF_OFFSET 0xC
#define DAC_DATABUF_RESETVALUE _U_(0x0000)

#define DAC_DATABUF_DATABUF_Pos 0
#define DAC_DATABUF_DATABUF_Msk (_U_(0xFFFF) << DAC_DATABUF_DATABUF_Pos)
#define DAC_DATABUF_DATABUF(value) (DAC_DATABUF_DATABUF_Msk & ((value) << DAC_DATABUF_DATABUF_Pos))
#define DAC_DATABUF_MASK _U_(0xFFFF)

/** \brief DAC hardware registers */

typedef struct {
  volatile DAC_CTRLA_Type CTRLA; /**< \brief Offset: 0x0 (R/W  8) Control A */
  volatile DAC_CTRLB_Type CTRLB; /**< \brief Offset: 0x1 (R/W  8) Control B */
  volatile DAC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x2 (R/W  8) Event Control */
       RoReg8 Reserved1[0x1];
  volatile DAC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x4 (R/W  8) Interrupt Enable Clear */
  volatile DAC_INTENSET_Type INTENSET; /**< \brief Offset: 0x5 (R/W  8) Interrupt Enable Set */
  volatile DAC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x6 (R/W  8) Interrupt Flag Status and Clear */
  volatile const DAC_STATUS_Type STATUS; /**< \brief Offset: 0x7 (R/   8) Status */
  volatile DAC_DATA_Type DATA; /**< \brief Offset: 0x8 (R/W 16) Data */
       RoReg8 Reserved2[0x2];
  volatile DAC_DATABUF_Type DATABUF; /**< \brief Offset: 0xC (R/W 16) Data Buffer */
} Dac;


/*@}*/
# 247 "asf4/samd21/include/samd21e18a.h" 2
#include "component/dmac.h"
# 247 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/dmac.h" 1
/**
 * \file
 *
 * \brief Component description for DMAC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_DMAC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR DMAC */
/* ========================================================================== */
/** \addtogroup SAMD21_DMAC Direct Memory Access Controller */
/*@{*/

#define DMAC_U2223 
#define REV_DMAC 0x100

/* -------- DMAC_CTRL : (DMAC Offset: 0x00) (R/W 16) Control -------- */

typedef union {
  struct {
    uint16_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint16_t DMAENABLE:1; /*!< bit:      1  DMA Enable                         */
    uint16_t CRCENABLE:1; /*!< bit:      2  CRC Enable                         */
    uint16_t :5; /*!< bit:  3.. 7  Reserved                           */
    uint16_t LVLEN0:1; /*!< bit:      8  Priority Level 0 Enable            */
    uint16_t LVLEN1:1; /*!< bit:      9  Priority Level 1 Enable            */
    uint16_t LVLEN2:1; /*!< bit:     10  Priority Level 2 Enable            */
    uint16_t LVLEN3:1; /*!< bit:     11  Priority Level 3 Enable            */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t :8; /*!< bit:  0.. 7  Reserved                           */
    uint16_t LVLEN:4; /*!< bit:  8..11  Priority Level x Enable            */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} DMAC_CTRL_Type;


#define DMAC_CTRL_OFFSET 0x00
#define DMAC_CTRL_RESETVALUE _U_(0x0000)

#define DMAC_CTRL_SWRST_Pos 0
#define DMAC_CTRL_SWRST (_U_(0x1) << DMAC_CTRL_SWRST_Pos)
#define DMAC_CTRL_DMAENABLE_Pos 1
#define DMAC_CTRL_DMAENABLE (_U_(0x1) << DMAC_CTRL_DMAENABLE_Pos)
#define DMAC_CTRL_CRCENABLE_Pos 2
#define DMAC_CTRL_CRCENABLE (_U_(0x1) << DMAC_CTRL_CRCENABLE_Pos)
#define DMAC_CTRL_LVLEN0_Pos 8
#define DMAC_CTRL_LVLEN0 (_U_(1) << DMAC_CTRL_LVLEN0_Pos)
#define DMAC_CTRL_LVLEN1_Pos 9
#define DMAC_CTRL_LVLEN1 (_U_(1) << DMAC_CTRL_LVLEN1_Pos)
#define DMAC_CTRL_LVLEN2_Pos 10
#define DMAC_CTRL_LVLEN2 (_U_(1) << DMAC_CTRL_LVLEN2_Pos)
#define DMAC_CTRL_LVLEN3_Pos 11
#define DMAC_CTRL_LVLEN3 (_U_(1) << DMAC_CTRL_LVLEN3_Pos)
#define DMAC_CTRL_LVLEN_Pos 8
#define DMAC_CTRL_LVLEN_Msk (_U_(0xF) << DMAC_CTRL_LVLEN_Pos)
#define DMAC_CTRL_LVLEN(value) (DMAC_CTRL_LVLEN_Msk & ((value) << DMAC_CTRL_LVLEN_Pos))
#define DMAC_CTRL_MASK _U_(0x0F07)

/* -------- DMAC_CRCCTRL : (DMAC Offset: 0x02) (R/W 16) CRC Control -------- */

typedef union {
  struct {
    uint16_t CRCBEATSIZE:2; /*!< bit:  0.. 1  CRC Beat Size                      */
    uint16_t CRCPOLY:2; /*!< bit:  2.. 3  CRC Polynomial Type                */
    uint16_t :4; /*!< bit:  4.. 7  Reserved                           */
    uint16_t CRCSRC:6; /*!< bit:  8..13  CRC Input Source                   */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} DMAC_CRCCTRL_Type;


#define DMAC_CRCCTRL_OFFSET 0x02
#define DMAC_CRCCTRL_RESETVALUE _U_(0x0000)

#define DMAC_CRCCTRL_CRCBEATSIZE_Pos 0
#define DMAC_CRCCTRL_CRCBEATSIZE_Msk (_U_(0x3) << DMAC_CRCCTRL_CRCBEATSIZE_Pos)
#define DMAC_CRCCTRL_CRCBEATSIZE(value) (DMAC_CRCCTRL_CRCBEATSIZE_Msk & ((value) << DMAC_CRCCTRL_CRCBEATSIZE_Pos))
#define DMAC_CRCCTRL_CRCBEATSIZE_BYTE_Val _U_(0x0)
#define DMAC_CRCCTRL_CRCBEATSIZE_HWORD_Val _U_(0x1)
#define DMAC_CRCCTRL_CRCBEATSIZE_WORD_Val _U_(0x2)
#define DMAC_CRCCTRL_CRCBEATSIZE_BYTE (DMAC_CRCCTRL_CRCBEATSIZE_BYTE_Val << DMAC_CRCCTRL_CRCBEATSIZE_Pos)
#define DMAC_CRCCTRL_CRCBEATSIZE_HWORD (DMAC_CRCCTRL_CRCBEATSIZE_HWORD_Val << DMAC_CRCCTRL_CRCBEATSIZE_Pos)
#define DMAC_CRCCTRL_CRCBEATSIZE_WORD (DMAC_CRCCTRL_CRCBEATSIZE_WORD_Val << DMAC_CRCCTRL_CRCBEATSIZE_Pos)
#define DMAC_CRCCTRL_CRCPOLY_Pos 2
#define DMAC_CRCCTRL_CRCPOLY_Msk (_U_(0x3) << DMAC_CRCCTRL_CRCPOLY_Pos)
#define DMAC_CRCCTRL_CRCPOLY(value) (DMAC_CRCCTRL_CRCPOLY_Msk & ((value) << DMAC_CRCCTRL_CRCPOLY_Pos))
#define DMAC_CRCCTRL_CRCPOLY_CRC16_Val _U_(0x0)
#define DMAC_CRCCTRL_CRCPOLY_CRC32_Val _U_(0x1)
#define DMAC_CRCCTRL_CRCPOLY_CRC16 (DMAC_CRCCTRL_CRCPOLY_CRC16_Val << DMAC_CRCCTRL_CRCPOLY_Pos)
#define DMAC_CRCCTRL_CRCPOLY_CRC32 (DMAC_CRCCTRL_CRCPOLY_CRC32_Val << DMAC_CRCCTRL_CRCPOLY_Pos)
#define DMAC_CRCCTRL_CRCSRC_Pos 8
#define DMAC_CRCCTRL_CRCSRC_Msk (_U_(0x3F) << DMAC_CRCCTRL_CRCSRC_Pos)
#define DMAC_CRCCTRL_CRCSRC(value) (DMAC_CRCCTRL_CRCSRC_Msk & ((value) << DMAC_CRCCTRL_CRCSRC_Pos))
#define DMAC_CRCCTRL_CRCSRC_NOACT_Val _U_(0x0)
#define DMAC_CRCCTRL_CRCSRC_IO_Val _U_(0x1)
#define DMAC_CRCCTRL_CRCSRC_NOACT (DMAC_CRCCTRL_CRCSRC_NOACT_Val << DMAC_CRCCTRL_CRCSRC_Pos)
#define DMAC_CRCCTRL_CRCSRC_IO (DMAC_CRCCTRL_CRCSRC_IO_Val << DMAC_CRCCTRL_CRCSRC_Pos)
#define DMAC_CRCCTRL_MASK _U_(0x3F0F)

/* -------- DMAC_CRCDATAIN : (DMAC Offset: 0x04) (R/W 32) CRC Data Input -------- */

typedef union {
  struct {
    uint32_t CRCDATAIN:32; /*!< bit:  0..31  CRC Data Input                     */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_CRCDATAIN_Type;


#define DMAC_CRCDATAIN_OFFSET 0x04
#define DMAC_CRCDATAIN_RESETVALUE _U_(0x00000000)

#define DMAC_CRCDATAIN_CRCDATAIN_Pos 0
#define DMAC_CRCDATAIN_CRCDATAIN_Msk (_U_(0xFFFFFFFF) << DMAC_CRCDATAIN_CRCDATAIN_Pos)
#define DMAC_CRCDATAIN_CRCDATAIN(value) (DMAC_CRCDATAIN_CRCDATAIN_Msk & ((value) << DMAC_CRCDATAIN_CRCDATAIN_Pos))
#define DMAC_CRCDATAIN_MASK _U_(0xFFFFFFFF)

/* -------- DMAC_CRCCHKSUM : (DMAC Offset: 0x08) (R/W 32) CRC Checksum -------- */

typedef union {
  struct {
    uint32_t CRCCHKSUM:32; /*!< bit:  0..31  CRC Checksum                       */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_CRCCHKSUM_Type;


#define DMAC_CRCCHKSUM_OFFSET 0x08
#define DMAC_CRCCHKSUM_RESETVALUE _U_(0x00000000)

#define DMAC_CRCCHKSUM_CRCCHKSUM_Pos 0
#define DMAC_CRCCHKSUM_CRCCHKSUM_Msk (_U_(0xFFFFFFFF) << DMAC_CRCCHKSUM_CRCCHKSUM_Pos)
#define DMAC_CRCCHKSUM_CRCCHKSUM(value) (DMAC_CRCCHKSUM_CRCCHKSUM_Msk & ((value) << DMAC_CRCCHKSUM_CRCCHKSUM_Pos))
#define DMAC_CRCCHKSUM_MASK _U_(0xFFFFFFFF)

/* -------- DMAC_CRCSTATUS : (DMAC Offset: 0x0C) (R/W  8) CRC Status -------- */

typedef union {
  struct {
    uint8_t CRCBUSY:1; /*!< bit:      0  CRC Module Busy                    */
    uint8_t CRCZERO:1; /*!< bit:      1  CRC Zero                           */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_CRCSTATUS_Type;


#define DMAC_CRCSTATUS_OFFSET 0x0C
#define DMAC_CRCSTATUS_RESETVALUE _U_(0x00)

#define DMAC_CRCSTATUS_CRCBUSY_Pos 0
#define DMAC_CRCSTATUS_CRCBUSY (_U_(0x1) << DMAC_CRCSTATUS_CRCBUSY_Pos)
#define DMAC_CRCSTATUS_CRCZERO_Pos 1
#define DMAC_CRCSTATUS_CRCZERO (_U_(0x1) << DMAC_CRCSTATUS_CRCZERO_Pos)
#define DMAC_CRCSTATUS_MASK _U_(0x03)

/* -------- DMAC_DBGCTRL : (DMAC Offset: 0x0D) (R/W  8) Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGRUN:1; /*!< bit:      0  Debug Run                          */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_DBGCTRL_Type;


#define DMAC_DBGCTRL_OFFSET 0x0D
#define DMAC_DBGCTRL_RESETVALUE _U_(0x00)

#define DMAC_DBGCTRL_DBGRUN_Pos 0
#define DMAC_DBGCTRL_DBGRUN (_U_(0x1) << DMAC_DBGCTRL_DBGRUN_Pos)
#define DMAC_DBGCTRL_MASK _U_(0x01)

/* -------- DMAC_QOSCTRL : (DMAC Offset: 0x0E) (R/W  8) QOS Control -------- */

typedef union {
  struct {
    uint8_t WRBQOS:2; /*!< bit:  0.. 1  Write-Back Quality of Service      */
    uint8_t FQOS:2; /*!< bit:  2.. 3  Fetch Quality of Service           */
    uint8_t DQOS:2; /*!< bit:  4.. 5  Data Transfer Quality of Service   */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_QOSCTRL_Type;


#define DMAC_QOSCTRL_OFFSET 0x0E
#define DMAC_QOSCTRL_RESETVALUE _U_(0x15)

#define DMAC_QOSCTRL_WRBQOS_Pos 0
#define DMAC_QOSCTRL_WRBQOS_Msk (_U_(0x3) << DMAC_QOSCTRL_WRBQOS_Pos)
#define DMAC_QOSCTRL_WRBQOS(value) (DMAC_QOSCTRL_WRBQOS_Msk & ((value) << DMAC_QOSCTRL_WRBQOS_Pos))
#define DMAC_QOSCTRL_WRBQOS_DISABLE_Val _U_(0x0)
#define DMAC_QOSCTRL_WRBQOS_LOW_Val _U_(0x1)
#define DMAC_QOSCTRL_WRBQOS_MEDIUM_Val _U_(0x2)
#define DMAC_QOSCTRL_WRBQOS_HIGH_Val _U_(0x3)
#define DMAC_QOSCTRL_WRBQOS_DISABLE (DMAC_QOSCTRL_WRBQOS_DISABLE_Val << DMAC_QOSCTRL_WRBQOS_Pos)
#define DMAC_QOSCTRL_WRBQOS_LOW (DMAC_QOSCTRL_WRBQOS_LOW_Val << DMAC_QOSCTRL_WRBQOS_Pos)
#define DMAC_QOSCTRL_WRBQOS_MEDIUM (DMAC_QOSCTRL_WRBQOS_MEDIUM_Val << DMAC_QOSCTRL_WRBQOS_Pos)
#define DMAC_QOSCTRL_WRBQOS_HIGH (DMAC_QOSCTRL_WRBQOS_HIGH_Val << DMAC_QOSCTRL_WRBQOS_Pos)
#define DMAC_QOSCTRL_FQOS_Pos 2
#define DMAC_QOSCTRL_FQOS_Msk (_U_(0x3) << DMAC_QOSCTRL_FQOS_Pos)
#define DMAC_QOSCTRL_FQOS(value) (DMAC_QOSCTRL_FQOS_Msk & ((value) << DMAC_QOSCTRL_FQOS_Pos))
#define DMAC_QOSCTRL_FQOS_DISABLE_Val _U_(0x0)
#define DMAC_QOSCTRL_FQOS_LOW_Val _U_(0x1)
#define DMAC_QOSCTRL_FQOS_MEDIUM_Val _U_(0x2)
#define DMAC_QOSCTRL_FQOS_HIGH_Val _U_(0x3)
#define DMAC_QOSCTRL_FQOS_DISABLE (DMAC_QOSCTRL_FQOS_DISABLE_Val << DMAC_QOSCTRL_FQOS_Pos)
#define DMAC_QOSCTRL_FQOS_LOW (DMAC_QOSCTRL_FQOS_LOW_Val << DMAC_QOSCTRL_FQOS_Pos)
#define DMAC_QOSCTRL_FQOS_MEDIUM (DMAC_QOSCTRL_FQOS_MEDIUM_Val << DMAC_QOSCTRL_FQOS_Pos)
#define DMAC_QOSCTRL_FQOS_HIGH (DMAC_QOSCTRL_FQOS_HIGH_Val << DMAC_QOSCTRL_FQOS_Pos)
#define DMAC_QOSCTRL_DQOS_Pos 4
#define DMAC_QOSCTRL_DQOS_Msk (_U_(0x3) << DMAC_QOSCTRL_DQOS_Pos)
#define DMAC_QOSCTRL_DQOS(value) (DMAC_QOSCTRL_DQOS_Msk & ((value) << DMAC_QOSCTRL_DQOS_Pos))
#define DMAC_QOSCTRL_DQOS_DISABLE_Val _U_(0x0)
#define DMAC_QOSCTRL_DQOS_LOW_Val _U_(0x1)
#define DMAC_QOSCTRL_DQOS_MEDIUM_Val _U_(0x2)
#define DMAC_QOSCTRL_DQOS_HIGH_Val _U_(0x3)
#define DMAC_QOSCTRL_DQOS_DISABLE (DMAC_QOSCTRL_DQOS_DISABLE_Val << DMAC_QOSCTRL_DQOS_Pos)
#define DMAC_QOSCTRL_DQOS_LOW (DMAC_QOSCTRL_DQOS_LOW_Val << DMAC_QOSCTRL_DQOS_Pos)
#define DMAC_QOSCTRL_DQOS_MEDIUM (DMAC_QOSCTRL_DQOS_MEDIUM_Val << DMAC_QOSCTRL_DQOS_Pos)
#define DMAC_QOSCTRL_DQOS_HIGH (DMAC_QOSCTRL_DQOS_HIGH_Val << DMAC_QOSCTRL_DQOS_Pos)
#define DMAC_QOSCTRL_MASK _U_(0x3F)

/* -------- DMAC_SWTRIGCTRL : (DMAC Offset: 0x10) (R/W 32) Software Trigger Control -------- */

typedef union {
  struct {
    uint32_t SWTRIG0:1; /*!< bit:      0  Channel 0 Software Trigger         */
    uint32_t SWTRIG1:1; /*!< bit:      1  Channel 1 Software Trigger         */
    uint32_t SWTRIG2:1; /*!< bit:      2  Channel 2 Software Trigger         */
    uint32_t SWTRIG3:1; /*!< bit:      3  Channel 3 Software Trigger         */
    uint32_t SWTRIG4:1; /*!< bit:      4  Channel 4 Software Trigger         */
    uint32_t SWTRIG5:1; /*!< bit:      5  Channel 5 Software Trigger         */
    uint32_t SWTRIG6:1; /*!< bit:      6  Channel 6 Software Trigger         */
    uint32_t SWTRIG7:1; /*!< bit:      7  Channel 7 Software Trigger         */
    uint32_t SWTRIG8:1; /*!< bit:      8  Channel 8 Software Trigger         */
    uint32_t SWTRIG9:1; /*!< bit:      9  Channel 9 Software Trigger         */
    uint32_t SWTRIG10:1; /*!< bit:     10  Channel 10 Software Trigger        */
    uint32_t SWTRIG11:1; /*!< bit:     11  Channel 11 Software Trigger        */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t SWTRIG:12; /*!< bit:  0..11  Channel x Software Trigger         */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_SWTRIGCTRL_Type;


#define DMAC_SWTRIGCTRL_OFFSET 0x10
#define DMAC_SWTRIGCTRL_RESETVALUE _U_(0x00000000)

#define DMAC_SWTRIGCTRL_SWTRIG0_Pos 0
#define DMAC_SWTRIGCTRL_SWTRIG0 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG0_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG1_Pos 1
#define DMAC_SWTRIGCTRL_SWTRIG1 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG1_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG2_Pos 2
#define DMAC_SWTRIGCTRL_SWTRIG2 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG2_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG3_Pos 3
#define DMAC_SWTRIGCTRL_SWTRIG3 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG3_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG4_Pos 4
#define DMAC_SWTRIGCTRL_SWTRIG4 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG4_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG5_Pos 5
#define DMAC_SWTRIGCTRL_SWTRIG5 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG5_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG6_Pos 6
#define DMAC_SWTRIGCTRL_SWTRIG6 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG6_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG7_Pos 7
#define DMAC_SWTRIGCTRL_SWTRIG7 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG7_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG8_Pos 8
#define DMAC_SWTRIGCTRL_SWTRIG8 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG8_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG9_Pos 9
#define DMAC_SWTRIGCTRL_SWTRIG9 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG9_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG10_Pos 10
#define DMAC_SWTRIGCTRL_SWTRIG10 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG10_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG11_Pos 11
#define DMAC_SWTRIGCTRL_SWTRIG11 (_U_(1) << DMAC_SWTRIGCTRL_SWTRIG11_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG_Pos 0
#define DMAC_SWTRIGCTRL_SWTRIG_Msk (_U_(0xFFF) << DMAC_SWTRIGCTRL_SWTRIG_Pos)
#define DMAC_SWTRIGCTRL_SWTRIG(value) (DMAC_SWTRIGCTRL_SWTRIG_Msk & ((value) << DMAC_SWTRIGCTRL_SWTRIG_Pos))
#define DMAC_SWTRIGCTRL_MASK _U_(0x00000FFF)

/* -------- DMAC_PRICTRL0 : (DMAC Offset: 0x14) (R/W 32) Priority Control 0 -------- */

typedef union {
  struct {
    uint32_t LVLPRI0:4; /*!< bit:  0.. 3  Level 0 Channel Priority Number    */
    uint32_t :3; /*!< bit:  4.. 6  Reserved                           */
    uint32_t RRLVLEN0:1; /*!< bit:      7  Level 0 Round-Robin Scheduling Enable */
    uint32_t LVLPRI1:4; /*!< bit:  8..11  Level 1 Channel Priority Number    */
    uint32_t :3; /*!< bit: 12..14  Reserved                           */
    uint32_t RRLVLEN1:1; /*!< bit:     15  Level 1 Round-Robin Scheduling Enable */
    uint32_t LVLPRI2:4; /*!< bit: 16..19  Level 2 Channel Priority Number    */
    uint32_t :3; /*!< bit: 20..22  Reserved                           */
    uint32_t RRLVLEN2:1; /*!< bit:     23  Level 2 Round-Robin Scheduling Enable */
    uint32_t LVLPRI3:4; /*!< bit: 24..27  Level 3 Channel Priority Number    */
    uint32_t :3; /*!< bit: 28..30  Reserved                           */
    uint32_t RRLVLEN3:1; /*!< bit:     31  Level 3 Round-Robin Scheduling Enable */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_PRICTRL0_Type;


#define DMAC_PRICTRL0_OFFSET 0x14
#define DMAC_PRICTRL0_RESETVALUE _U_(0x00000000)

#define DMAC_PRICTRL0_LVLPRI0_Pos 0
#define DMAC_PRICTRL0_LVLPRI0_Msk (_U_(0xF) << DMAC_PRICTRL0_LVLPRI0_Pos)
#define DMAC_PRICTRL0_LVLPRI0(value) (DMAC_PRICTRL0_LVLPRI0_Msk & ((value) << DMAC_PRICTRL0_LVLPRI0_Pos))
#define DMAC_PRICTRL0_RRLVLEN0_Pos 7
#define DMAC_PRICTRL0_RRLVLEN0 (_U_(0x1) << DMAC_PRICTRL0_RRLVLEN0_Pos)
#define DMAC_PRICTRL0_LVLPRI1_Pos 8
#define DMAC_PRICTRL0_LVLPRI1_Msk (_U_(0xF) << DMAC_PRICTRL0_LVLPRI1_Pos)
#define DMAC_PRICTRL0_LVLPRI1(value) (DMAC_PRICTRL0_LVLPRI1_Msk & ((value) << DMAC_PRICTRL0_LVLPRI1_Pos))
#define DMAC_PRICTRL0_RRLVLEN1_Pos 15
#define DMAC_PRICTRL0_RRLVLEN1 (_U_(0x1) << DMAC_PRICTRL0_RRLVLEN1_Pos)
#define DMAC_PRICTRL0_LVLPRI2_Pos 16
#define DMAC_PRICTRL0_LVLPRI2_Msk (_U_(0xF) << DMAC_PRICTRL0_LVLPRI2_Pos)
#define DMAC_PRICTRL0_LVLPRI2(value) (DMAC_PRICTRL0_LVLPRI2_Msk & ((value) << DMAC_PRICTRL0_LVLPRI2_Pos))
#define DMAC_PRICTRL0_RRLVLEN2_Pos 23
#define DMAC_PRICTRL0_RRLVLEN2 (_U_(0x1) << DMAC_PRICTRL0_RRLVLEN2_Pos)
#define DMAC_PRICTRL0_LVLPRI3_Pos 24
#define DMAC_PRICTRL0_LVLPRI3_Msk (_U_(0xF) << DMAC_PRICTRL0_LVLPRI3_Pos)
#define DMAC_PRICTRL0_LVLPRI3(value) (DMAC_PRICTRL0_LVLPRI3_Msk & ((value) << DMAC_PRICTRL0_LVLPRI3_Pos))
#define DMAC_PRICTRL0_RRLVLEN3_Pos 31
#define DMAC_PRICTRL0_RRLVLEN3 (_U_(0x1) << DMAC_PRICTRL0_RRLVLEN3_Pos)
#define DMAC_PRICTRL0_MASK _U_(0x8F8F8F8F)

/* -------- DMAC_INTPEND : (DMAC Offset: 0x20) (R/W 16) Interrupt Pending -------- */

typedef union {
  struct {
    uint16_t ID:4; /*!< bit:  0.. 3  Channel ID                         */
    uint16_t :4; /*!< bit:  4.. 7  Reserved                           */
    uint16_t TERR:1; /*!< bit:      8  Transfer Error                     */
    uint16_t TCMPL:1; /*!< bit:      9  Transfer Complete                  */
    uint16_t SUSP:1; /*!< bit:     10  Channel Suspend                    */
    uint16_t :2; /*!< bit: 11..12  Reserved                           */
    uint16_t FERR:1; /*!< bit:     13  Fetch Error                        */
    uint16_t BUSY:1; /*!< bit:     14  Busy                               */
    uint16_t PEND:1; /*!< bit:     15  Pending                            */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} DMAC_INTPEND_Type;


#define DMAC_INTPEND_OFFSET 0x20
#define DMAC_INTPEND_RESETVALUE _U_(0x0000)

#define DMAC_INTPEND_ID_Pos 0
#define DMAC_INTPEND_ID_Msk (_U_(0xF) << DMAC_INTPEND_ID_Pos)
#define DMAC_INTPEND_ID(value) (DMAC_INTPEND_ID_Msk & ((value) << DMAC_INTPEND_ID_Pos))
#define DMAC_INTPEND_TERR_Pos 8
#define DMAC_INTPEND_TERR (_U_(0x1) << DMAC_INTPEND_TERR_Pos)
#define DMAC_INTPEND_TCMPL_Pos 9
#define DMAC_INTPEND_TCMPL (_U_(0x1) << DMAC_INTPEND_TCMPL_Pos)
#define DMAC_INTPEND_SUSP_Pos 10
#define DMAC_INTPEND_SUSP (_U_(0x1) << DMAC_INTPEND_SUSP_Pos)
#define DMAC_INTPEND_FERR_Pos 13
#define DMAC_INTPEND_FERR (_U_(0x1) << DMAC_INTPEND_FERR_Pos)
#define DMAC_INTPEND_BUSY_Pos 14
#define DMAC_INTPEND_BUSY (_U_(0x1) << DMAC_INTPEND_BUSY_Pos)
#define DMAC_INTPEND_PEND_Pos 15
#define DMAC_INTPEND_PEND (_U_(0x1) << DMAC_INTPEND_PEND_Pos)
#define DMAC_INTPEND_MASK _U_(0xE70F)

/* -------- DMAC_INTSTATUS : (DMAC Offset: 0x24) (R/  32) Interrupt Status -------- */

typedef union {
  struct {
    uint32_t CHINT0:1; /*!< bit:      0  Channel 0 Pending Interrupt        */
    uint32_t CHINT1:1; /*!< bit:      1  Channel 1 Pending Interrupt        */
    uint32_t CHINT2:1; /*!< bit:      2  Channel 2 Pending Interrupt        */
    uint32_t CHINT3:1; /*!< bit:      3  Channel 3 Pending Interrupt        */
    uint32_t CHINT4:1; /*!< bit:      4  Channel 4 Pending Interrupt        */
    uint32_t CHINT5:1; /*!< bit:      5  Channel 5 Pending Interrupt        */
    uint32_t CHINT6:1; /*!< bit:      6  Channel 6 Pending Interrupt        */
    uint32_t CHINT7:1; /*!< bit:      7  Channel 7 Pending Interrupt        */
    uint32_t CHINT8:1; /*!< bit:      8  Channel 8 Pending Interrupt        */
    uint32_t CHINT9:1; /*!< bit:      9  Channel 9 Pending Interrupt        */
    uint32_t CHINT10:1; /*!< bit:     10  Channel 10 Pending Interrupt       */
    uint32_t CHINT11:1; /*!< bit:     11  Channel 11 Pending Interrupt       */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t CHINT:12; /*!< bit:  0..11  Channel x Pending Interrupt        */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_INTSTATUS_Type;


#define DMAC_INTSTATUS_OFFSET 0x24
#define DMAC_INTSTATUS_RESETVALUE _U_(0x00000000)

#define DMAC_INTSTATUS_CHINT0_Pos 0
#define DMAC_INTSTATUS_CHINT0 (_U_(1) << DMAC_INTSTATUS_CHINT0_Pos)
#define DMAC_INTSTATUS_CHINT1_Pos 1
#define DMAC_INTSTATUS_CHINT1 (_U_(1) << DMAC_INTSTATUS_CHINT1_Pos)
#define DMAC_INTSTATUS_CHINT2_Pos 2
#define DMAC_INTSTATUS_CHINT2 (_U_(1) << DMAC_INTSTATUS_CHINT2_Pos)
#define DMAC_INTSTATUS_CHINT3_Pos 3
#define DMAC_INTSTATUS_CHINT3 (_U_(1) << DMAC_INTSTATUS_CHINT3_Pos)
#define DMAC_INTSTATUS_CHINT4_Pos 4
#define DMAC_INTSTATUS_CHINT4 (_U_(1) << DMAC_INTSTATUS_CHINT4_Pos)
#define DMAC_INTSTATUS_CHINT5_Pos 5
#define DMAC_INTSTATUS_CHINT5 (_U_(1) << DMAC_INTSTATUS_CHINT5_Pos)
#define DMAC_INTSTATUS_CHINT6_Pos 6
#define DMAC_INTSTATUS_CHINT6 (_U_(1) << DMAC_INTSTATUS_CHINT6_Pos)
#define DMAC_INTSTATUS_CHINT7_Pos 7
#define DMAC_INTSTATUS_CHINT7 (_U_(1) << DMAC_INTSTATUS_CHINT7_Pos)
#define DMAC_INTSTATUS_CHINT8_Pos 8
#define DMAC_INTSTATUS_CHINT8 (_U_(1) << DMAC_INTSTATUS_CHINT8_Pos)
#define DMAC_INTSTATUS_CHINT9_Pos 9
#define DMAC_INTSTATUS_CHINT9 (_U_(1) << DMAC_INTSTATUS_CHINT9_Pos)
#define DMAC_INTSTATUS_CHINT10_Pos 10
#define DMAC_INTSTATUS_CHINT10 (_U_(1) << DMAC_INTSTATUS_CHINT10_Pos)
#define DMAC_INTSTATUS_CHINT11_Pos 11
#define DMAC_INTSTATUS_CHINT11 (_U_(1) << DMAC_INTSTATUS_CHINT11_Pos)
#define DMAC_INTSTATUS_CHINT_Pos 0
#define DMAC_INTSTATUS_CHINT_Msk (_U_(0xFFF) << DMAC_INTSTATUS_CHINT_Pos)
#define DMAC_INTSTATUS_CHINT(value) (DMAC_INTSTATUS_CHINT_Msk & ((value) << DMAC_INTSTATUS_CHINT_Pos))
#define DMAC_INTSTATUS_MASK _U_(0x00000FFF)

/* -------- DMAC_BUSYCH : (DMAC Offset: 0x28) (R/  32) Busy Channels -------- */

typedef union {
  struct {
    uint32_t BUSYCH0:1; /*!< bit:      0  Busy Channel 0                     */
    uint32_t BUSYCH1:1; /*!< bit:      1  Busy Channel 1                     */
    uint32_t BUSYCH2:1; /*!< bit:      2  Busy Channel 2                     */
    uint32_t BUSYCH3:1; /*!< bit:      3  Busy Channel 3                     */
    uint32_t BUSYCH4:1; /*!< bit:      4  Busy Channel 4                     */
    uint32_t BUSYCH5:1; /*!< bit:      5  Busy Channel 5                     */
    uint32_t BUSYCH6:1; /*!< bit:      6  Busy Channel 6                     */
    uint32_t BUSYCH7:1; /*!< bit:      7  Busy Channel 7                     */
    uint32_t BUSYCH8:1; /*!< bit:      8  Busy Channel 8                     */
    uint32_t BUSYCH9:1; /*!< bit:      9  Busy Channel 9                     */
    uint32_t BUSYCH10:1; /*!< bit:     10  Busy Channel 10                    */
    uint32_t BUSYCH11:1; /*!< bit:     11  Busy Channel 11                    */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t BUSYCH:12; /*!< bit:  0..11  Busy Channel x                     */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_BUSYCH_Type;


#define DMAC_BUSYCH_OFFSET 0x28
#define DMAC_BUSYCH_RESETVALUE _U_(0x00000000)

#define DMAC_BUSYCH_BUSYCH0_Pos 0
#define DMAC_BUSYCH_BUSYCH0 (_U_(1) << DMAC_BUSYCH_BUSYCH0_Pos)
#define DMAC_BUSYCH_BUSYCH1_Pos 1
#define DMAC_BUSYCH_BUSYCH1 (_U_(1) << DMAC_BUSYCH_BUSYCH1_Pos)
#define DMAC_BUSYCH_BUSYCH2_Pos 2
#define DMAC_BUSYCH_BUSYCH2 (_U_(1) << DMAC_BUSYCH_BUSYCH2_Pos)
#define DMAC_BUSYCH_BUSYCH3_Pos 3
#define DMAC_BUSYCH_BUSYCH3 (_U_(1) << DMAC_BUSYCH_BUSYCH3_Pos)
#define DMAC_BUSYCH_BUSYCH4_Pos 4
#define DMAC_BUSYCH_BUSYCH4 (_U_(1) << DMAC_BUSYCH_BUSYCH4_Pos)
#define DMAC_BUSYCH_BUSYCH5_Pos 5
#define DMAC_BUSYCH_BUSYCH5 (_U_(1) << DMAC_BUSYCH_BUSYCH5_Pos)
#define DMAC_BUSYCH_BUSYCH6_Pos 6
#define DMAC_BUSYCH_BUSYCH6 (_U_(1) << DMAC_BUSYCH_BUSYCH6_Pos)
#define DMAC_BUSYCH_BUSYCH7_Pos 7
#define DMAC_BUSYCH_BUSYCH7 (_U_(1) << DMAC_BUSYCH_BUSYCH7_Pos)
#define DMAC_BUSYCH_BUSYCH8_Pos 8
#define DMAC_BUSYCH_BUSYCH8 (_U_(1) << DMAC_BUSYCH_BUSYCH8_Pos)
#define DMAC_BUSYCH_BUSYCH9_Pos 9
#define DMAC_BUSYCH_BUSYCH9 (_U_(1) << DMAC_BUSYCH_BUSYCH9_Pos)
#define DMAC_BUSYCH_BUSYCH10_Pos 10
#define DMAC_BUSYCH_BUSYCH10 (_U_(1) << DMAC_BUSYCH_BUSYCH10_Pos)
#define DMAC_BUSYCH_BUSYCH11_Pos 11
#define DMAC_BUSYCH_BUSYCH11 (_U_(1) << DMAC_BUSYCH_BUSYCH11_Pos)
#define DMAC_BUSYCH_BUSYCH_Pos 0
#define DMAC_BUSYCH_BUSYCH_Msk (_U_(0xFFF) << DMAC_BUSYCH_BUSYCH_Pos)
#define DMAC_BUSYCH_BUSYCH(value) (DMAC_BUSYCH_BUSYCH_Msk & ((value) << DMAC_BUSYCH_BUSYCH_Pos))
#define DMAC_BUSYCH_MASK _U_(0x00000FFF)

/* -------- DMAC_PENDCH : (DMAC Offset: 0x2C) (R/  32) Pending Channels -------- */

typedef union {
  struct {
    uint32_t PENDCH0:1; /*!< bit:      0  Pending Channel 0                  */
    uint32_t PENDCH1:1; /*!< bit:      1  Pending Channel 1                  */
    uint32_t PENDCH2:1; /*!< bit:      2  Pending Channel 2                  */
    uint32_t PENDCH3:1; /*!< bit:      3  Pending Channel 3                  */
    uint32_t PENDCH4:1; /*!< bit:      4  Pending Channel 4                  */
    uint32_t PENDCH5:1; /*!< bit:      5  Pending Channel 5                  */
    uint32_t PENDCH6:1; /*!< bit:      6  Pending Channel 6                  */
    uint32_t PENDCH7:1; /*!< bit:      7  Pending Channel 7                  */
    uint32_t PENDCH8:1; /*!< bit:      8  Pending Channel 8                  */
    uint32_t PENDCH9:1; /*!< bit:      9  Pending Channel 9                  */
    uint32_t PENDCH10:1; /*!< bit:     10  Pending Channel 10                 */
    uint32_t PENDCH11:1; /*!< bit:     11  Pending Channel 11                 */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t PENDCH:12; /*!< bit:  0..11  Pending Channel x                  */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_PENDCH_Type;


#define DMAC_PENDCH_OFFSET 0x2C
#define DMAC_PENDCH_RESETVALUE _U_(0x00000000)

#define DMAC_PENDCH_PENDCH0_Pos 0
#define DMAC_PENDCH_PENDCH0 (_U_(1) << DMAC_PENDCH_PENDCH0_Pos)
#define DMAC_PENDCH_PENDCH1_Pos 1
#define DMAC_PENDCH_PENDCH1 (_U_(1) << DMAC_PENDCH_PENDCH1_Pos)
#define DMAC_PENDCH_PENDCH2_Pos 2
#define DMAC_PENDCH_PENDCH2 (_U_(1) << DMAC_PENDCH_PENDCH2_Pos)
#define DMAC_PENDCH_PENDCH3_Pos 3
#define DMAC_PENDCH_PENDCH3 (_U_(1) << DMAC_PENDCH_PENDCH3_Pos)
#define DMAC_PENDCH_PENDCH4_Pos 4
#define DMAC_PENDCH_PENDCH4 (_U_(1) << DMAC_PENDCH_PENDCH4_Pos)
#define DMAC_PENDCH_PENDCH5_Pos 5
#define DMAC_PENDCH_PENDCH5 (_U_(1) << DMAC_PENDCH_PENDCH5_Pos)
#define DMAC_PENDCH_PENDCH6_Pos 6
#define DMAC_PENDCH_PENDCH6 (_U_(1) << DMAC_PENDCH_PENDCH6_Pos)
#define DMAC_PENDCH_PENDCH7_Pos 7
#define DMAC_PENDCH_PENDCH7 (_U_(1) << DMAC_PENDCH_PENDCH7_Pos)
#define DMAC_PENDCH_PENDCH8_Pos 8
#define DMAC_PENDCH_PENDCH8 (_U_(1) << DMAC_PENDCH_PENDCH8_Pos)
#define DMAC_PENDCH_PENDCH9_Pos 9
#define DMAC_PENDCH_PENDCH9 (_U_(1) << DMAC_PENDCH_PENDCH9_Pos)
#define DMAC_PENDCH_PENDCH10_Pos 10
#define DMAC_PENDCH_PENDCH10 (_U_(1) << DMAC_PENDCH_PENDCH10_Pos)
#define DMAC_PENDCH_PENDCH11_Pos 11
#define DMAC_PENDCH_PENDCH11 (_U_(1) << DMAC_PENDCH_PENDCH11_Pos)
#define DMAC_PENDCH_PENDCH_Pos 0
#define DMAC_PENDCH_PENDCH_Msk (_U_(0xFFF) << DMAC_PENDCH_PENDCH_Pos)
#define DMAC_PENDCH_PENDCH(value) (DMAC_PENDCH_PENDCH_Msk & ((value) << DMAC_PENDCH_PENDCH_Pos))
#define DMAC_PENDCH_MASK _U_(0x00000FFF)

/* -------- DMAC_ACTIVE : (DMAC Offset: 0x30) (R/  32) Active Channel and Levels -------- */

typedef union {
  struct {
    uint32_t LVLEX0:1; /*!< bit:      0  Level 0 Channel Trigger Request Executing */
    uint32_t LVLEX1:1; /*!< bit:      1  Level 1 Channel Trigger Request Executing */
    uint32_t LVLEX2:1; /*!< bit:      2  Level 2 Channel Trigger Request Executing */
    uint32_t LVLEX3:1; /*!< bit:      3  Level 3 Channel Trigger Request Executing */
    uint32_t :4; /*!< bit:  4.. 7  Reserved                           */
    uint32_t ID:5; /*!< bit:  8..12  Active Channel ID                  */
    uint32_t :2; /*!< bit: 13..14  Reserved                           */
    uint32_t ABUSY:1; /*!< bit:     15  Active Channel Busy                */
    uint32_t BTCNT:16; /*!< bit: 16..31  Active Channel Block Transfer Count */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t LVLEX:4; /*!< bit:  0.. 3  Level x Channel Trigger Request Executing */
    uint32_t :28; /*!< bit:  4..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_ACTIVE_Type;


#define DMAC_ACTIVE_OFFSET 0x30
#define DMAC_ACTIVE_RESETVALUE _U_(0x00000000)

#define DMAC_ACTIVE_LVLEX0_Pos 0
#define DMAC_ACTIVE_LVLEX0 (_U_(1) << DMAC_ACTIVE_LVLEX0_Pos)
#define DMAC_ACTIVE_LVLEX1_Pos 1
#define DMAC_ACTIVE_LVLEX1 (_U_(1) << DMAC_ACTIVE_LVLEX1_Pos)
#define DMAC_ACTIVE_LVLEX2_Pos 2
#define DMAC_ACTIVE_LVLEX2 (_U_(1) << DMAC_ACTIVE_LVLEX2_Pos)
#define DMAC_ACTIVE_LVLEX3_Pos 3
#define DMAC_ACTIVE_LVLEX3 (_U_(1) << DMAC_ACTIVE_LVLEX3_Pos)
#define DMAC_ACTIVE_LVLEX_Pos 0
#define DMAC_ACTIVE_LVLEX_Msk (_U_(0xF) << DMAC_ACTIVE_LVLEX_Pos)
#define DMAC_ACTIVE_LVLEX(value) (DMAC_ACTIVE_LVLEX_Msk & ((value) << DMAC_ACTIVE_LVLEX_Pos))
#define DMAC_ACTIVE_ID_Pos 8
#define DMAC_ACTIVE_ID_Msk (_U_(0x1F) << DMAC_ACTIVE_ID_Pos)
#define DMAC_ACTIVE_ID(value) (DMAC_ACTIVE_ID_Msk & ((value) << DMAC_ACTIVE_ID_Pos))
#define DMAC_ACTIVE_ABUSY_Pos 15
#define DMAC_ACTIVE_ABUSY (_U_(0x1) << DMAC_ACTIVE_ABUSY_Pos)
#define DMAC_ACTIVE_BTCNT_Pos 16
#define DMAC_ACTIVE_BTCNT_Msk (_U_(0xFFFF) << DMAC_ACTIVE_BTCNT_Pos)
#define DMAC_ACTIVE_BTCNT(value) (DMAC_ACTIVE_BTCNT_Msk & ((value) << DMAC_ACTIVE_BTCNT_Pos))
#define DMAC_ACTIVE_MASK _U_(0xFFFF9F0F)

/* -------- DMAC_BASEADDR : (DMAC Offset: 0x34) (R/W 32) Descriptor Memory Section Base Address -------- */

typedef union {
  struct {
    uint32_t BASEADDR:32; /*!< bit:  0..31  Descriptor Memory Base Address     */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_BASEADDR_Type;


#define DMAC_BASEADDR_OFFSET 0x34
#define DMAC_BASEADDR_RESETVALUE _U_(0x00000000)

#define DMAC_BASEADDR_BASEADDR_Pos 0
#define DMAC_BASEADDR_BASEADDR_Msk (_U_(0xFFFFFFFF) << DMAC_BASEADDR_BASEADDR_Pos)
#define DMAC_BASEADDR_BASEADDR(value) (DMAC_BASEADDR_BASEADDR_Msk & ((value) << DMAC_BASEADDR_BASEADDR_Pos))
#define DMAC_BASEADDR_MASK _U_(0xFFFFFFFF)

/* -------- DMAC_WRBADDR : (DMAC Offset: 0x38) (R/W 32) Write-Back Memory Section Base Address -------- */

typedef union {
  struct {
    uint32_t WRBADDR:32; /*!< bit:  0..31  Write-Back Memory Base Address     */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_WRBADDR_Type;


#define DMAC_WRBADDR_OFFSET 0x38
#define DMAC_WRBADDR_RESETVALUE _U_(0x00000000)

#define DMAC_WRBADDR_WRBADDR_Pos 0
#define DMAC_WRBADDR_WRBADDR_Msk (_U_(0xFFFFFFFF) << DMAC_WRBADDR_WRBADDR_Pos)
#define DMAC_WRBADDR_WRBADDR(value) (DMAC_WRBADDR_WRBADDR_Msk & ((value) << DMAC_WRBADDR_WRBADDR_Pos))
#define DMAC_WRBADDR_MASK _U_(0xFFFFFFFF)

/* -------- DMAC_CHID : (DMAC Offset: 0x3F) (R/W  8) Channel ID -------- */

typedef union {
  struct {
    uint8_t ID:4; /*!< bit:  0.. 3  Channel ID                         */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_CHID_Type;


#define DMAC_CHID_OFFSET 0x3F
#define DMAC_CHID_RESETVALUE _U_(0x00)

#define DMAC_CHID_ID_Pos 0
#define DMAC_CHID_ID_Msk (_U_(0xF) << DMAC_CHID_ID_Pos)
#define DMAC_CHID_ID(value) (DMAC_CHID_ID_Msk & ((value) << DMAC_CHID_ID_Pos))
#define DMAC_CHID_MASK _U_(0x0F)

/* -------- DMAC_CHCTRLA : (DMAC Offset: 0x40) (R/W  8) Channel Control A -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Channel Software Reset             */
    uint8_t ENABLE:1; /*!< bit:      1  Channel Enable                     */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_CHCTRLA_Type;


#define DMAC_CHCTRLA_OFFSET 0x40
#define DMAC_CHCTRLA_RESETVALUE _U_(0x00)

#define DMAC_CHCTRLA_SWRST_Pos 0
#define DMAC_CHCTRLA_SWRST (_U_(0x1) << DMAC_CHCTRLA_SWRST_Pos)
#define DMAC_CHCTRLA_ENABLE_Pos 1
#define DMAC_CHCTRLA_ENABLE (_U_(0x1) << DMAC_CHCTRLA_ENABLE_Pos)
#define DMAC_CHCTRLA_MASK _U_(0x03)

/* -------- DMAC_CHCTRLB : (DMAC Offset: 0x44) (R/W 32) Channel Control B -------- */

typedef union {
  struct {
    uint32_t EVACT:3; /*!< bit:  0.. 2  Event Input Action                 */
    uint32_t EVIE:1; /*!< bit:      3  Channel Event Input Enable         */
    uint32_t EVOE:1; /*!< bit:      4  Channel Event Output Enable        */
    uint32_t LVL:2; /*!< bit:  5.. 6  Channel Arbitration Level          */
    uint32_t :1; /*!< bit:      7  Reserved                           */
    uint32_t TRIGSRC:6; /*!< bit:  8..13  Trigger Source                     */
    uint32_t :8; /*!< bit: 14..21  Reserved                           */
    uint32_t TRIGACT:2; /*!< bit: 22..23  Trigger Action                     */
    uint32_t CMD:2; /*!< bit: 24..25  Software Command                   */
    uint32_t :6; /*!< bit: 26..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_CHCTRLB_Type;


#define DMAC_CHCTRLB_OFFSET 0x44
#define DMAC_CHCTRLB_RESETVALUE _U_(0x00000000)

#define DMAC_CHCTRLB_EVACT_Pos 0
#define DMAC_CHCTRLB_EVACT_Msk (_U_(0x7) << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVACT(value) (DMAC_CHCTRLB_EVACT_Msk & ((value) << DMAC_CHCTRLB_EVACT_Pos))
#define DMAC_CHCTRLB_EVACT_NOACT_Val _U_(0x0)
#define DMAC_CHCTRLB_EVACT_TRIG_Val _U_(0x1)
#define DMAC_CHCTRLB_EVACT_CTRIG_Val _U_(0x2)
#define DMAC_CHCTRLB_EVACT_CBLOCK_Val _U_(0x3)
#define DMAC_CHCTRLB_EVACT_SUSPEND_Val _U_(0x4)
#define DMAC_CHCTRLB_EVACT_RESUME_Val _U_(0x5)
#define DMAC_CHCTRLB_EVACT_SSKIP_Val _U_(0x6)
#define DMAC_CHCTRLB_EVACT_NOACT (DMAC_CHCTRLB_EVACT_NOACT_Val << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVACT_TRIG (DMAC_CHCTRLB_EVACT_TRIG_Val << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVACT_CTRIG (DMAC_CHCTRLB_EVACT_CTRIG_Val << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVACT_CBLOCK (DMAC_CHCTRLB_EVACT_CBLOCK_Val << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVACT_SUSPEND (DMAC_CHCTRLB_EVACT_SUSPEND_Val << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVACT_RESUME (DMAC_CHCTRLB_EVACT_RESUME_Val << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVACT_SSKIP (DMAC_CHCTRLB_EVACT_SSKIP_Val << DMAC_CHCTRLB_EVACT_Pos)
#define DMAC_CHCTRLB_EVIE_Pos 3
#define DMAC_CHCTRLB_EVIE (_U_(0x1) << DMAC_CHCTRLB_EVIE_Pos)
#define DMAC_CHCTRLB_EVOE_Pos 4
#define DMAC_CHCTRLB_EVOE (_U_(0x1) << DMAC_CHCTRLB_EVOE_Pos)
#define DMAC_CHCTRLB_LVL_Pos 5
#define DMAC_CHCTRLB_LVL_Msk (_U_(0x3) << DMAC_CHCTRLB_LVL_Pos)
#define DMAC_CHCTRLB_LVL(value) (DMAC_CHCTRLB_LVL_Msk & ((value) << DMAC_CHCTRLB_LVL_Pos))
#define DMAC_CHCTRLB_LVL_LVL0_Val _U_(0x0)
#define DMAC_CHCTRLB_LVL_LVL1_Val _U_(0x1)
#define DMAC_CHCTRLB_LVL_LVL2_Val _U_(0x2)
#define DMAC_CHCTRLB_LVL_LVL3_Val _U_(0x3)
#define DMAC_CHCTRLB_LVL_LVL0 (DMAC_CHCTRLB_LVL_LVL0_Val << DMAC_CHCTRLB_LVL_Pos)
#define DMAC_CHCTRLB_LVL_LVL1 (DMAC_CHCTRLB_LVL_LVL1_Val << DMAC_CHCTRLB_LVL_Pos)
#define DMAC_CHCTRLB_LVL_LVL2 (DMAC_CHCTRLB_LVL_LVL2_Val << DMAC_CHCTRLB_LVL_Pos)
#define DMAC_CHCTRLB_LVL_LVL3 (DMAC_CHCTRLB_LVL_LVL3_Val << DMAC_CHCTRLB_LVL_Pos)
#define DMAC_CHCTRLB_TRIGSRC_Pos 8
#define DMAC_CHCTRLB_TRIGSRC_Msk (_U_(0x3F) << DMAC_CHCTRLB_TRIGSRC_Pos)
#define DMAC_CHCTRLB_TRIGSRC(value) (DMAC_CHCTRLB_TRIGSRC_Msk & ((value) << DMAC_CHCTRLB_TRIGSRC_Pos))
#define DMAC_CHCTRLB_TRIGSRC_DISABLE_Val _U_(0x0)
#define DMAC_CHCTRLB_TRIGSRC_DISABLE (DMAC_CHCTRLB_TRIGSRC_DISABLE_Val << DMAC_CHCTRLB_TRIGSRC_Pos)
#define DMAC_CHCTRLB_TRIGACT_Pos 22
#define DMAC_CHCTRLB_TRIGACT_Msk (_U_(0x3) << DMAC_CHCTRLB_TRIGACT_Pos)
#define DMAC_CHCTRLB_TRIGACT(value) (DMAC_CHCTRLB_TRIGACT_Msk & ((value) << DMAC_CHCTRLB_TRIGACT_Pos))
#define DMAC_CHCTRLB_TRIGACT_BLOCK_Val _U_(0x0)
#define DMAC_CHCTRLB_TRIGACT_BEAT_Val _U_(0x2)
#define DMAC_CHCTRLB_TRIGACT_TRANSACTION_Val _U_(0x3)
#define DMAC_CHCTRLB_TRIGACT_BLOCK (DMAC_CHCTRLB_TRIGACT_BLOCK_Val << DMAC_CHCTRLB_TRIGACT_Pos)
#define DMAC_CHCTRLB_TRIGACT_BEAT (DMAC_CHCTRLB_TRIGACT_BEAT_Val << DMAC_CHCTRLB_TRIGACT_Pos)
#define DMAC_CHCTRLB_TRIGACT_TRANSACTION (DMAC_CHCTRLB_TRIGACT_TRANSACTION_Val << DMAC_CHCTRLB_TRIGACT_Pos)
#define DMAC_CHCTRLB_CMD_Pos 24
#define DMAC_CHCTRLB_CMD_Msk (_U_(0x3) << DMAC_CHCTRLB_CMD_Pos)
#define DMAC_CHCTRLB_CMD(value) (DMAC_CHCTRLB_CMD_Msk & ((value) << DMAC_CHCTRLB_CMD_Pos))
#define DMAC_CHCTRLB_CMD_NOACT_Val _U_(0x0)
#define DMAC_CHCTRLB_CMD_SUSPEND_Val _U_(0x1)
#define DMAC_CHCTRLB_CMD_RESUME_Val _U_(0x2)
#define DMAC_CHCTRLB_CMD_NOACT (DMAC_CHCTRLB_CMD_NOACT_Val << DMAC_CHCTRLB_CMD_Pos)
#define DMAC_CHCTRLB_CMD_SUSPEND (DMAC_CHCTRLB_CMD_SUSPEND_Val << DMAC_CHCTRLB_CMD_Pos)
#define DMAC_CHCTRLB_CMD_RESUME (DMAC_CHCTRLB_CMD_RESUME_Val << DMAC_CHCTRLB_CMD_Pos)
#define DMAC_CHCTRLB_MASK _U_(0x03C03F7F)

/* -------- DMAC_CHINTENCLR : (DMAC Offset: 0x4C) (R/W  8) Channel Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t TERR:1; /*!< bit:      0  Channel Transfer Error Interrupt Enable */
    uint8_t TCMPL:1; /*!< bit:      1  Channel Transfer Complete Interrupt Enable */
    uint8_t SUSP:1; /*!< bit:      2  Channel Suspend Interrupt Enable   */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_CHINTENCLR_Type;


#define DMAC_CHINTENCLR_OFFSET 0x4C
#define DMAC_CHINTENCLR_RESETVALUE _U_(0x00)

#define DMAC_CHINTENCLR_TERR_Pos 0
#define DMAC_CHINTENCLR_TERR (_U_(0x1) << DMAC_CHINTENCLR_TERR_Pos)
#define DMAC_CHINTENCLR_TCMPL_Pos 1
#define DMAC_CHINTENCLR_TCMPL (_U_(0x1) << DMAC_CHINTENCLR_TCMPL_Pos)
#define DMAC_CHINTENCLR_SUSP_Pos 2
#define DMAC_CHINTENCLR_SUSP (_U_(0x1) << DMAC_CHINTENCLR_SUSP_Pos)
#define DMAC_CHINTENCLR_MASK _U_(0x07)

/* -------- DMAC_CHINTENSET : (DMAC Offset: 0x4D) (R/W  8) Channel Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t TERR:1; /*!< bit:      0  Channel Transfer Error Interrupt Enable */
    uint8_t TCMPL:1; /*!< bit:      1  Channel Transfer Complete Interrupt Enable */
    uint8_t SUSP:1; /*!< bit:      2  Channel Suspend Interrupt Enable   */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_CHINTENSET_Type;


#define DMAC_CHINTENSET_OFFSET 0x4D
#define DMAC_CHINTENSET_RESETVALUE _U_(0x00)

#define DMAC_CHINTENSET_TERR_Pos 0
#define DMAC_CHINTENSET_TERR (_U_(0x1) << DMAC_CHINTENSET_TERR_Pos)
#define DMAC_CHINTENSET_TCMPL_Pos 1
#define DMAC_CHINTENSET_TCMPL (_U_(0x1) << DMAC_CHINTENSET_TCMPL_Pos)
#define DMAC_CHINTENSET_SUSP_Pos 2
#define DMAC_CHINTENSET_SUSP (_U_(0x1) << DMAC_CHINTENSET_SUSP_Pos)
#define DMAC_CHINTENSET_MASK _U_(0x07)

/* -------- DMAC_CHINTFLAG : (DMAC Offset: 0x4E) (R/W  8) Channel Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t TERR:1; /*!< bit:      0  Channel Transfer Error             */
    volatile const uint8_t TCMPL:1; /*!< bit:      1  Channel Transfer Complete          */
    volatile const uint8_t SUSP:1; /*!< bit:      2  Channel Suspend                    */
    volatile const uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_CHINTFLAG_Type;


#define DMAC_CHINTFLAG_OFFSET 0x4E
#define DMAC_CHINTFLAG_RESETVALUE _U_(0x00)

#define DMAC_CHINTFLAG_TERR_Pos 0
#define DMAC_CHINTFLAG_TERR (_U_(0x1) << DMAC_CHINTFLAG_TERR_Pos)
#define DMAC_CHINTFLAG_TCMPL_Pos 1
#define DMAC_CHINTFLAG_TCMPL (_U_(0x1) << DMAC_CHINTFLAG_TCMPL_Pos)
#define DMAC_CHINTFLAG_SUSP_Pos 2
#define DMAC_CHINTFLAG_SUSP (_U_(0x1) << DMAC_CHINTFLAG_SUSP_Pos)
#define DMAC_CHINTFLAG_MASK _U_(0x07)

/* -------- DMAC_CHSTATUS : (DMAC Offset: 0x4F) (R/   8) Channel Status -------- */

typedef union {
  struct {
    uint8_t PEND:1; /*!< bit:      0  Channel Pending                    */
    uint8_t BUSY:1; /*!< bit:      1  Channel Busy                       */
    uint8_t FERR:1; /*!< bit:      2  Channel Fetch Error                */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DMAC_CHSTATUS_Type;


#define DMAC_CHSTATUS_OFFSET 0x4F
#define DMAC_CHSTATUS_RESETVALUE _U_(0x00)

#define DMAC_CHSTATUS_PEND_Pos 0
#define DMAC_CHSTATUS_PEND (_U_(0x1) << DMAC_CHSTATUS_PEND_Pos)
#define DMAC_CHSTATUS_BUSY_Pos 1
#define DMAC_CHSTATUS_BUSY (_U_(0x1) << DMAC_CHSTATUS_BUSY_Pos)
#define DMAC_CHSTATUS_FERR_Pos 2
#define DMAC_CHSTATUS_FERR (_U_(0x1) << DMAC_CHSTATUS_FERR_Pos)
#define DMAC_CHSTATUS_MASK _U_(0x07)

/* -------- DMAC_BTCTRL : (DMAC Offset: 0x00) (R/W 16) Block Transfer Control -------- */

typedef union {
  struct {
    uint16_t VALID:1; /*!< bit:      0  Descriptor Valid                   */
    uint16_t EVOSEL:2; /*!< bit:  1.. 2  Event Output Selection             */
    uint16_t BLOCKACT:2; /*!< bit:  3.. 4  Block Action                       */
    uint16_t :3; /*!< bit:  5.. 7  Reserved                           */
    uint16_t BEATSIZE:2; /*!< bit:  8.. 9  Beat Size                          */
    uint16_t SRCINC:1; /*!< bit:     10  Source Address Increment Enable    */
    uint16_t DSTINC:1; /*!< bit:     11  Destination Address Increment Enable */
    uint16_t STEPSEL:1; /*!< bit:     12  Step Selection                     */
    uint16_t STEPSIZE:3; /*!< bit: 13..15  Address Increment Step Size        */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} DMAC_BTCTRL_Type;


#define DMAC_BTCTRL_OFFSET 0x00
#define DMAC_BTCTRL_RESETVALUE _U_(0x0000)

#define DMAC_BTCTRL_VALID_Pos 0
#define DMAC_BTCTRL_VALID (_U_(0x1) << DMAC_BTCTRL_VALID_Pos)
#define DMAC_BTCTRL_EVOSEL_Pos 1
#define DMAC_BTCTRL_EVOSEL_Msk (_U_(0x3) << DMAC_BTCTRL_EVOSEL_Pos)
#define DMAC_BTCTRL_EVOSEL(value) (DMAC_BTCTRL_EVOSEL_Msk & ((value) << DMAC_BTCTRL_EVOSEL_Pos))
#define DMAC_BTCTRL_EVOSEL_DISABLE_Val _U_(0x0)
#define DMAC_BTCTRL_EVOSEL_BLOCK_Val _U_(0x1)
#define DMAC_BTCTRL_EVOSEL_BEAT_Val _U_(0x3)
#define DMAC_BTCTRL_EVOSEL_DISABLE (DMAC_BTCTRL_EVOSEL_DISABLE_Val << DMAC_BTCTRL_EVOSEL_Pos)
#define DMAC_BTCTRL_EVOSEL_BLOCK (DMAC_BTCTRL_EVOSEL_BLOCK_Val << DMAC_BTCTRL_EVOSEL_Pos)
#define DMAC_BTCTRL_EVOSEL_BEAT (DMAC_BTCTRL_EVOSEL_BEAT_Val << DMAC_BTCTRL_EVOSEL_Pos)
#define DMAC_BTCTRL_BLOCKACT_Pos 3
#define DMAC_BTCTRL_BLOCKACT_Msk (_U_(0x3) << DMAC_BTCTRL_BLOCKACT_Pos)
#define DMAC_BTCTRL_BLOCKACT(value) (DMAC_BTCTRL_BLOCKACT_Msk & ((value) << DMAC_BTCTRL_BLOCKACT_Pos))
#define DMAC_BTCTRL_BLOCKACT_NOACT_Val _U_(0x0)
#define DMAC_BTCTRL_BLOCKACT_INT_Val _U_(0x1)
#define DMAC_BTCTRL_BLOCKACT_SUSPEND_Val _U_(0x2)
#define DMAC_BTCTRL_BLOCKACT_BOTH_Val _U_(0x3)
#define DMAC_BTCTRL_BLOCKACT_NOACT (DMAC_BTCTRL_BLOCKACT_NOACT_Val << DMAC_BTCTRL_BLOCKACT_Pos)
#define DMAC_BTCTRL_BLOCKACT_INT (DMAC_BTCTRL_BLOCKACT_INT_Val << DMAC_BTCTRL_BLOCKACT_Pos)
#define DMAC_BTCTRL_BLOCKACT_SUSPEND (DMAC_BTCTRL_BLOCKACT_SUSPEND_Val << DMAC_BTCTRL_BLOCKACT_Pos)
#define DMAC_BTCTRL_BLOCKACT_BOTH (DMAC_BTCTRL_BLOCKACT_BOTH_Val << DMAC_BTCTRL_BLOCKACT_Pos)
#define DMAC_BTCTRL_BEATSIZE_Pos 8
#define DMAC_BTCTRL_BEATSIZE_Msk (_U_(0x3) << DMAC_BTCTRL_BEATSIZE_Pos)
#define DMAC_BTCTRL_BEATSIZE(value) (DMAC_BTCTRL_BEATSIZE_Msk & ((value) << DMAC_BTCTRL_BEATSIZE_Pos))
#define DMAC_BTCTRL_BEATSIZE_BYTE_Val _U_(0x0)
#define DMAC_BTCTRL_BEATSIZE_HWORD_Val _U_(0x1)
#define DMAC_BTCTRL_BEATSIZE_WORD_Val _U_(0x2)
#define DMAC_BTCTRL_BEATSIZE_BYTE (DMAC_BTCTRL_BEATSIZE_BYTE_Val << DMAC_BTCTRL_BEATSIZE_Pos)
#define DMAC_BTCTRL_BEATSIZE_HWORD (DMAC_BTCTRL_BEATSIZE_HWORD_Val << DMAC_BTCTRL_BEATSIZE_Pos)
#define DMAC_BTCTRL_BEATSIZE_WORD (DMAC_BTCTRL_BEATSIZE_WORD_Val << DMAC_BTCTRL_BEATSIZE_Pos)
#define DMAC_BTCTRL_SRCINC_Pos 10
#define DMAC_BTCTRL_SRCINC (_U_(0x1) << DMAC_BTCTRL_SRCINC_Pos)
#define DMAC_BTCTRL_DSTINC_Pos 11
#define DMAC_BTCTRL_DSTINC (_U_(0x1) << DMAC_BTCTRL_DSTINC_Pos)
#define DMAC_BTCTRL_STEPSEL_Pos 12
#define DMAC_BTCTRL_STEPSEL (_U_(0x1) << DMAC_BTCTRL_STEPSEL_Pos)
#define DMAC_BTCTRL_STEPSEL_DST_Val _U_(0x0)
#define DMAC_BTCTRL_STEPSEL_SRC_Val _U_(0x1)
#define DMAC_BTCTRL_STEPSEL_DST (DMAC_BTCTRL_STEPSEL_DST_Val << DMAC_BTCTRL_STEPSEL_Pos)
#define DMAC_BTCTRL_STEPSEL_SRC (DMAC_BTCTRL_STEPSEL_SRC_Val << DMAC_BTCTRL_STEPSEL_Pos)
#define DMAC_BTCTRL_STEPSIZE_Pos 13
#define DMAC_BTCTRL_STEPSIZE_Msk (_U_(0x7) << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE(value) (DMAC_BTCTRL_STEPSIZE_Msk & ((value) << DMAC_BTCTRL_STEPSIZE_Pos))
#define DMAC_BTCTRL_STEPSIZE_X1_Val _U_(0x0)
#define DMAC_BTCTRL_STEPSIZE_X2_Val _U_(0x1)
#define DMAC_BTCTRL_STEPSIZE_X4_Val _U_(0x2)
#define DMAC_BTCTRL_STEPSIZE_X8_Val _U_(0x3)
#define DMAC_BTCTRL_STEPSIZE_X16_Val _U_(0x4)
#define DMAC_BTCTRL_STEPSIZE_X32_Val _U_(0x5)
#define DMAC_BTCTRL_STEPSIZE_X64_Val _U_(0x6)
#define DMAC_BTCTRL_STEPSIZE_X128_Val _U_(0x7)
#define DMAC_BTCTRL_STEPSIZE_X1 (DMAC_BTCTRL_STEPSIZE_X1_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE_X2 (DMAC_BTCTRL_STEPSIZE_X2_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE_X4 (DMAC_BTCTRL_STEPSIZE_X4_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE_X8 (DMAC_BTCTRL_STEPSIZE_X8_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE_X16 (DMAC_BTCTRL_STEPSIZE_X16_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE_X32 (DMAC_BTCTRL_STEPSIZE_X32_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE_X64 (DMAC_BTCTRL_STEPSIZE_X64_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_STEPSIZE_X128 (DMAC_BTCTRL_STEPSIZE_X128_Val << DMAC_BTCTRL_STEPSIZE_Pos)
#define DMAC_BTCTRL_MASK _U_(0xFF1F)

/* -------- DMAC_BTCNT : (DMAC Offset: 0x02) (R/W 16) Block Transfer Count -------- */

typedef union {
  struct {
    uint16_t BTCNT:16; /*!< bit:  0..15  Block Transfer Count               */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} DMAC_BTCNT_Type;


#define DMAC_BTCNT_OFFSET 0x02

#define DMAC_BTCNT_BTCNT_Pos 0
#define DMAC_BTCNT_BTCNT_Msk (_U_(0xFFFF) << DMAC_BTCNT_BTCNT_Pos)
#define DMAC_BTCNT_BTCNT(value) (DMAC_BTCNT_BTCNT_Msk & ((value) << DMAC_BTCNT_BTCNT_Pos))
#define DMAC_BTCNT_MASK _U_(0xFFFF)

/* -------- DMAC_SRCADDR : (DMAC Offset: 0x04) (R/W 32) Block Transfer Source Address -------- */

typedef union {
  struct {
    uint32_t SRCADDR:32; /*!< bit:  0..31  Transfer Source Address            */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_SRCADDR_Type;


#define DMAC_SRCADDR_OFFSET 0x04

#define DMAC_SRCADDR_SRCADDR_Pos 0
#define DMAC_SRCADDR_SRCADDR_Msk (_U_(0xFFFFFFFF) << DMAC_SRCADDR_SRCADDR_Pos)
#define DMAC_SRCADDR_SRCADDR(value) (DMAC_SRCADDR_SRCADDR_Msk & ((value) << DMAC_SRCADDR_SRCADDR_Pos))
#define DMAC_SRCADDR_MASK _U_(0xFFFFFFFF)

/* -------- DMAC_DSTADDR : (DMAC Offset: 0x08) (R/W 32) Block Transfer Destination Address -------- */

typedef union {
  struct {
    uint32_t DSTADDR:32; /*!< bit:  0..31  Transfer Destination Address       */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_DSTADDR_Type;


#define DMAC_DSTADDR_OFFSET 0x08

#define DMAC_DSTADDR_DSTADDR_Pos 0
#define DMAC_DSTADDR_DSTADDR_Msk (_U_(0xFFFFFFFF) << DMAC_DSTADDR_DSTADDR_Pos)
#define DMAC_DSTADDR_DSTADDR(value) (DMAC_DSTADDR_DSTADDR_Msk & ((value) << DMAC_DSTADDR_DSTADDR_Pos))
#define DMAC_DSTADDR_MASK _U_(0xFFFFFFFF)

/* -------- DMAC_DESCADDR : (DMAC Offset: 0x0C) (R/W 32) Next Descriptor Address -------- */

typedef union {
  struct {
    uint32_t DESCADDR:32; /*!< bit:  0..31  Next Descriptor Address            */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DMAC_DESCADDR_Type;


#define DMAC_DESCADDR_OFFSET 0x0C

#define DMAC_DESCADDR_DESCADDR_Pos 0
#define DMAC_DESCADDR_DESCADDR_Msk (_U_(0xFFFFFFFF) << DMAC_DESCADDR_DESCADDR_Pos)
#define DMAC_DESCADDR_DESCADDR(value) (DMAC_DESCADDR_DESCADDR_Msk & ((value) << DMAC_DESCADDR_DESCADDR_Pos))
#define DMAC_DESCADDR_MASK _U_(0xFFFFFFFF)

/** \brief DMAC APB hardware registers */

typedef struct {
  volatile DMAC_CTRL_Type CTRL; /**< \brief Offset: 0x00 (R/W 16) Control */
  volatile DMAC_CRCCTRL_Type CRCCTRL; /**< \brief Offset: 0x02 (R/W 16) CRC Control */
  volatile DMAC_CRCDATAIN_Type CRCDATAIN; /**< \brief Offset: 0x04 (R/W 32) CRC Data Input */
  volatile DMAC_CRCCHKSUM_Type CRCCHKSUM; /**< \brief Offset: 0x08 (R/W 32) CRC Checksum */
  volatile DMAC_CRCSTATUS_Type CRCSTATUS; /**< \brief Offset: 0x0C (R/W  8) CRC Status */
  volatile DMAC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x0D (R/W  8) Debug Control */
  volatile DMAC_QOSCTRL_Type QOSCTRL; /**< \brief Offset: 0x0E (R/W  8) QOS Control */
       RoReg8 Reserved1[0x1];
  volatile DMAC_SWTRIGCTRL_Type SWTRIGCTRL; /**< \brief Offset: 0x10 (R/W 32) Software Trigger Control */
  volatile DMAC_PRICTRL0_Type PRICTRL0; /**< \brief Offset: 0x14 (R/W 32) Priority Control 0 */
       RoReg8 Reserved2[0x8];
  volatile DMAC_INTPEND_Type INTPEND; /**< \brief Offset: 0x20 (R/W 16) Interrupt Pending */
       RoReg8 Reserved3[0x2];
  volatile const DMAC_INTSTATUS_Type INTSTATUS; /**< \brief Offset: 0x24 (R/  32) Interrupt Status */
  volatile const DMAC_BUSYCH_Type BUSYCH; /**< \brief Offset: 0x28 (R/  32) Busy Channels */
  volatile const DMAC_PENDCH_Type PENDCH; /**< \brief Offset: 0x2C (R/  32) Pending Channels */
  volatile const DMAC_ACTIVE_Type ACTIVE; /**< \brief Offset: 0x30 (R/  32) Active Channel and Levels */
  volatile DMAC_BASEADDR_Type BASEADDR; /**< \brief Offset: 0x34 (R/W 32) Descriptor Memory Section Base Address */
  volatile DMAC_WRBADDR_Type WRBADDR; /**< \brief Offset: 0x38 (R/W 32) Write-Back Memory Section Base Address */
       RoReg8 Reserved4[0x3];
  volatile DMAC_CHID_Type CHID; /**< \brief Offset: 0x3F (R/W  8) Channel ID */
  volatile DMAC_CHCTRLA_Type CHCTRLA; /**< \brief Offset: 0x40 (R/W  8) Channel Control A */
       RoReg8 Reserved5[0x3];
  volatile DMAC_CHCTRLB_Type CHCTRLB; /**< \brief Offset: 0x44 (R/W 32) Channel Control B */
       RoReg8 Reserved6[0x4];
  volatile DMAC_CHINTENCLR_Type CHINTENCLR; /**< \brief Offset: 0x4C (R/W  8) Channel Interrupt Enable Clear */
  volatile DMAC_CHINTENSET_Type CHINTENSET; /**< \brief Offset: 0x4D (R/W  8) Channel Interrupt Enable Set */
  volatile DMAC_CHINTFLAG_Type CHINTFLAG; /**< \brief Offset: 0x4E (R/W  8) Channel Interrupt Flag Status and Clear */
  volatile const DMAC_CHSTATUS_Type CHSTATUS; /**< \brief Offset: 0x4F (R/   8) Channel Status */
} Dmac;


/** \brief DMAC Descriptor SRAM registers */

typedef struct {
  volatile DMAC_BTCTRL_Type BTCTRL; /**< \brief Offset: 0x00 (R/W 16) Block Transfer Control */
  volatile DMAC_BTCNT_Type BTCNT; /**< \brief Offset: 0x02 (R/W 16) Block Transfer Count */
  volatile DMAC_SRCADDR_Type SRCADDR; /**< \brief Offset: 0x04 (R/W 32) Block Transfer Source Address */
  volatile DMAC_DSTADDR_Type DSTADDR; /**< \brief Offset: 0x08 (R/W 32) Block Transfer Destination Address */
  volatile DMAC_DESCADDR_Type DESCADDR; /**< \brief Offset: 0x0C (R/W 32) Next Descriptor Address */
} DmacDescriptor

  __attribute__ ((aligned (8)))

;


#define SECTION_DMAC_DESCRIPTOR 

/*@}*/
# 248 "asf4/samd21/include/samd21e18a.h" 2
#include "component/dsu.h"
# 248 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/dsu.h" 1
/**
 * \file
 *
 * \brief Component description for DSU
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_DSU_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR DSU */
/* ========================================================================== */
/** \addtogroup SAMD21_DSU Device Service Unit */
/*@{*/

#define DSU_U2209 
#define REV_DSU 0x200

/* -------- DSU_CTRL : (DSU Offset: 0x0000) ( /W  8) Control -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t :1; /*!< bit:      1  Reserved                           */
    uint8_t CRC:1; /*!< bit:      2  32-bit Cyclic Redundancy Check     */
    uint8_t MBIST:1; /*!< bit:      3  Memory Built-In Self-Test          */
    uint8_t CE:1; /*!< bit:      4  Chip Erase                         */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DSU_CTRL_Type;


#define DSU_CTRL_OFFSET 0x0000
#define DSU_CTRL_RESETVALUE _U_(0x00)

#define DSU_CTRL_SWRST_Pos 0
#define DSU_CTRL_SWRST (_U_(0x1) << DSU_CTRL_SWRST_Pos)
#define DSU_CTRL_CRC_Pos 2
#define DSU_CTRL_CRC (_U_(0x1) << DSU_CTRL_CRC_Pos)
#define DSU_CTRL_MBIST_Pos 3
#define DSU_CTRL_MBIST (_U_(0x1) << DSU_CTRL_MBIST_Pos)
#define DSU_CTRL_CE_Pos 4
#define DSU_CTRL_CE (_U_(0x1) << DSU_CTRL_CE_Pos)
#define DSU_CTRL_MASK _U_(0x1D)

/* -------- DSU_STATUSA : (DSU Offset: 0x0001) (R/W  8) Status A -------- */

typedef union {
  struct {
    uint8_t DONE:1; /*!< bit:      0  Done                               */
    uint8_t CRSTEXT:1; /*!< bit:      1  CPU Reset Phase Extension          */
    uint8_t BERR:1; /*!< bit:      2  Bus Error                          */
    uint8_t FAIL:1; /*!< bit:      3  Failure                            */
    uint8_t PERR:1; /*!< bit:      4  Protection Error                   */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DSU_STATUSA_Type;


#define DSU_STATUSA_OFFSET 0x0001
#define DSU_STATUSA_RESETVALUE _U_(0x00)

#define DSU_STATUSA_DONE_Pos 0
#define DSU_STATUSA_DONE (_U_(0x1) << DSU_STATUSA_DONE_Pos)
#define DSU_STATUSA_CRSTEXT_Pos 1
#define DSU_STATUSA_CRSTEXT (_U_(0x1) << DSU_STATUSA_CRSTEXT_Pos)
#define DSU_STATUSA_BERR_Pos 2
#define DSU_STATUSA_BERR (_U_(0x1) << DSU_STATUSA_BERR_Pos)
#define DSU_STATUSA_FAIL_Pos 3
#define DSU_STATUSA_FAIL (_U_(0x1) << DSU_STATUSA_FAIL_Pos)
#define DSU_STATUSA_PERR_Pos 4
#define DSU_STATUSA_PERR (_U_(0x1) << DSU_STATUSA_PERR_Pos)
#define DSU_STATUSA_MASK _U_(0x1F)

/* -------- DSU_STATUSB : (DSU Offset: 0x0002) (R/   8) Status B -------- */

typedef union {
  struct {
    uint8_t PROT:1; /*!< bit:      0  Protected                          */
    uint8_t DBGPRES:1; /*!< bit:      1  Debugger Present                   */
    uint8_t DCCD0:1; /*!< bit:      2  Debug Communication Channel 0 Dirty */
    uint8_t DCCD1:1; /*!< bit:      3  Debug Communication Channel 1 Dirty */
    uint8_t HPE:1; /*!< bit:      4  Hot-Plugging Enable                */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint8_t DCCD:2; /*!< bit:  2.. 3  Debug Communication Channel x Dirty */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} DSU_STATUSB_Type;


#define DSU_STATUSB_OFFSET 0x0002
#define DSU_STATUSB_RESETVALUE _U_(0x10)

#define DSU_STATUSB_PROT_Pos 0
#define DSU_STATUSB_PROT (_U_(0x1) << DSU_STATUSB_PROT_Pos)
#define DSU_STATUSB_DBGPRES_Pos 1
#define DSU_STATUSB_DBGPRES (_U_(0x1) << DSU_STATUSB_DBGPRES_Pos)
#define DSU_STATUSB_DCCD0_Pos 2
#define DSU_STATUSB_DCCD0 (_U_(1) << DSU_STATUSB_DCCD0_Pos)
#define DSU_STATUSB_DCCD1_Pos 3
#define DSU_STATUSB_DCCD1 (_U_(1) << DSU_STATUSB_DCCD1_Pos)
#define DSU_STATUSB_DCCD_Pos 2
#define DSU_STATUSB_DCCD_Msk (_U_(0x3) << DSU_STATUSB_DCCD_Pos)
#define DSU_STATUSB_DCCD(value) (DSU_STATUSB_DCCD_Msk & ((value) << DSU_STATUSB_DCCD_Pos))
#define DSU_STATUSB_HPE_Pos 4
#define DSU_STATUSB_HPE (_U_(0x1) << DSU_STATUSB_HPE_Pos)
#define DSU_STATUSB_MASK _U_(0x1F)

/* -------- DSU_ADDR : (DSU Offset: 0x0004) (R/W 32) Address -------- */

typedef union {
  struct {
    uint32_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint32_t ADDR:30; /*!< bit:  2..31  Address                            */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_ADDR_Type;


#define DSU_ADDR_OFFSET 0x0004
#define DSU_ADDR_RESETVALUE _U_(0x00000000)

#define DSU_ADDR_ADDR_Pos 2
#define DSU_ADDR_ADDR_Msk (_U_(0x3FFFFFFF) << DSU_ADDR_ADDR_Pos)
#define DSU_ADDR_ADDR(value) (DSU_ADDR_ADDR_Msk & ((value) << DSU_ADDR_ADDR_Pos))
#define DSU_ADDR_MASK _U_(0xFFFFFFFC)

/* -------- DSU_LENGTH : (DSU Offset: 0x0008) (R/W 32) Length -------- */

typedef union {
  struct {
    uint32_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint32_t LENGTH:30; /*!< bit:  2..31  Length                             */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_LENGTH_Type;


#define DSU_LENGTH_OFFSET 0x0008
#define DSU_LENGTH_RESETVALUE _U_(0x00000000)

#define DSU_LENGTH_LENGTH_Pos 2
#define DSU_LENGTH_LENGTH_Msk (_U_(0x3FFFFFFF) << DSU_LENGTH_LENGTH_Pos)
#define DSU_LENGTH_LENGTH(value) (DSU_LENGTH_LENGTH_Msk & ((value) << DSU_LENGTH_LENGTH_Pos))
#define DSU_LENGTH_MASK _U_(0xFFFFFFFC)

/* -------- DSU_DATA : (DSU Offset: 0x000C) (R/W 32) Data -------- */

typedef union {
  struct {
    uint32_t DATA:32; /*!< bit:  0..31  Data                               */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_DATA_Type;


#define DSU_DATA_OFFSET 0x000C
#define DSU_DATA_RESETVALUE _U_(0x00000000)

#define DSU_DATA_DATA_Pos 0
#define DSU_DATA_DATA_Msk (_U_(0xFFFFFFFF) << DSU_DATA_DATA_Pos)
#define DSU_DATA_DATA(value) (DSU_DATA_DATA_Msk & ((value) << DSU_DATA_DATA_Pos))
#define DSU_DATA_MASK _U_(0xFFFFFFFF)

/* -------- DSU_DCC : (DSU Offset: 0x0010) (R/W 32) Debug Communication Channel n -------- */

typedef union {
  struct {
    uint32_t DATA:32; /*!< bit:  0..31  Data                               */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_DCC_Type;


#define DSU_DCC_OFFSET 0x0010
#define DSU_DCC_RESETVALUE _U_(0x00000000)

#define DSU_DCC_DATA_Pos 0
#define DSU_DCC_DATA_Msk (_U_(0xFFFFFFFF) << DSU_DCC_DATA_Pos)
#define DSU_DCC_DATA(value) (DSU_DCC_DATA_Msk & ((value) << DSU_DCC_DATA_Pos))
#define DSU_DCC_MASK _U_(0xFFFFFFFF)

/* -------- DSU_DID : (DSU Offset: 0x0018) (R/  32) Device Identification -------- */

typedef union {
  struct {
    uint32_t DEVSEL:8; /*!< bit:  0.. 7  Device Select                      */
    uint32_t REVISION:4; /*!< bit:  8..11  Revision                           */
    uint32_t DIE:4; /*!< bit: 12..15  Die Identification                 */
    uint32_t SERIES:6; /*!< bit: 16..21  Product Series                     */
    uint32_t :1; /*!< bit:     22  Reserved                           */
    uint32_t FAMILY:5; /*!< bit: 23..27  Product Family                     */
    uint32_t PROCESSOR:4; /*!< bit: 28..31  Processor                          */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_DID_Type;


#define DSU_DID_OFFSET 0x0018

#define DSU_DID_DEVSEL_Pos 0
#define DSU_DID_DEVSEL_Msk (_U_(0xFF) << DSU_DID_DEVSEL_Pos)
#define DSU_DID_DEVSEL(value) (DSU_DID_DEVSEL_Msk & ((value) << DSU_DID_DEVSEL_Pos))
#define DSU_DID_REVISION_Pos 8
#define DSU_DID_REVISION_Msk (_U_(0xF) << DSU_DID_REVISION_Pos)
#define DSU_DID_REVISION(value) (DSU_DID_REVISION_Msk & ((value) << DSU_DID_REVISION_Pos))
#define DSU_DID_DIE_Pos 12
#define DSU_DID_DIE_Msk (_U_(0xF) << DSU_DID_DIE_Pos)
#define DSU_DID_DIE(value) (DSU_DID_DIE_Msk & ((value) << DSU_DID_DIE_Pos))
#define DSU_DID_SERIES_Pos 16
#define DSU_DID_SERIES_Msk (_U_(0x3F) << DSU_DID_SERIES_Pos)
#define DSU_DID_SERIES(value) (DSU_DID_SERIES_Msk & ((value) << DSU_DID_SERIES_Pos))
#define DSU_DID_FAMILY_Pos 23
#define DSU_DID_FAMILY_Msk (_U_(0x1F) << DSU_DID_FAMILY_Pos)
#define DSU_DID_FAMILY(value) (DSU_DID_FAMILY_Msk & ((value) << DSU_DID_FAMILY_Pos))
#define DSU_DID_PROCESSOR_Pos 28
#define DSU_DID_PROCESSOR_Msk (_U_(0xF) << DSU_DID_PROCESSOR_Pos)
#define DSU_DID_PROCESSOR(value) (DSU_DID_PROCESSOR_Msk & ((value) << DSU_DID_PROCESSOR_Pos))
#define DSU_DID_MASK _U_(0xFFBFFFFF)

/* -------- DSU_ENTRY : (DSU Offset: 0x1000) (R/  32) CoreSight ROM Table Entry 0 -------- */

typedef union {
  struct {
    uint32_t EPRES:1; /*!< bit:      0  Entry Present                      */
    uint32_t FMT:1; /*!< bit:      1  Format                             */
    uint32_t :10; /*!< bit:  2..11  Reserved                           */
    uint32_t ADDOFF:20; /*!< bit: 12..31  Address Offset                     */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_ENTRY_Type;


#define DSU_ENTRY_OFFSET 0x1000
#define DSU_ENTRY_RESETVALUE _U_(0x9F9FC002)

#define DSU_ENTRY_EPRES_Pos 0
#define DSU_ENTRY_EPRES (_U_(0x1) << DSU_ENTRY_EPRES_Pos)
#define DSU_ENTRY_FMT_Pos 1
#define DSU_ENTRY_FMT (_U_(0x1) << DSU_ENTRY_FMT_Pos)
#define DSU_ENTRY_ADDOFF_Pos 12
#define DSU_ENTRY_ADDOFF_Msk (_U_(0xFFFFF) << DSU_ENTRY_ADDOFF_Pos)
#define DSU_ENTRY_ADDOFF(value) (DSU_ENTRY_ADDOFF_Msk & ((value) << DSU_ENTRY_ADDOFF_Pos))
#define DSU_ENTRY_MASK _U_(0xFFFFF003)

/* -------- DSU_ENTRY1 : (DSU Offset: 0x1004) (R/  32) CoreSight ROM Table Entry 1 -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} DSU_ENTRY1_Type;


#define DSU_ENTRY1_OFFSET 0x1004
#define DSU_ENTRY1_RESETVALUE _U_(0x00003002)
#define DSU_ENTRY1_MASK _U_(0xFFFFFFFF)

/* -------- DSU_END : (DSU Offset: 0x1008) (R/  32) CoreSight ROM Table End -------- */

typedef union {
  struct {
    uint32_t END:32; /*!< bit:  0..31  End Marker                         */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_END_Type;


#define DSU_END_OFFSET 0x1008
#define DSU_END_RESETVALUE _U_(0x00000000)

#define DSU_END_END_Pos 0
#define DSU_END_END_Msk (_U_(0xFFFFFFFF) << DSU_END_END_Pos)
#define DSU_END_END(value) (DSU_END_END_Msk & ((value) << DSU_END_END_Pos))
#define DSU_END_MASK _U_(0xFFFFFFFF)

/* -------- DSU_MEMTYPE : (DSU Offset: 0x1FCC) (R/  32) CoreSight ROM Table Memory Type -------- */

typedef union {
  struct {
    uint32_t SMEMP:1; /*!< bit:      0  System Memory Present              */
    uint32_t :31; /*!< bit:  1..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_MEMTYPE_Type;


#define DSU_MEMTYPE_OFFSET 0x1FCC
#define DSU_MEMTYPE_RESETVALUE _U_(0x00000000)

#define DSU_MEMTYPE_SMEMP_Pos 0
#define DSU_MEMTYPE_SMEMP (_U_(0x1) << DSU_MEMTYPE_SMEMP_Pos)
#define DSU_MEMTYPE_MASK _U_(0x00000001)

/* -------- DSU_PID4 : (DSU Offset: 0x1FD0) (R/  32) Peripheral Identification 4 -------- */

typedef union {
  struct {
    uint32_t JEPCC:4; /*!< bit:  0.. 3  JEP-106 Continuation Code          */
    uint32_t FKBC:4; /*!< bit:  4.. 7  4KB Count                          */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_PID4_Type;


#define DSU_PID4_OFFSET 0x1FD0
#define DSU_PID4_RESETVALUE _U_(0x00000000)

#define DSU_PID4_JEPCC_Pos 0
#define DSU_PID4_JEPCC_Msk (_U_(0xF) << DSU_PID4_JEPCC_Pos)
#define DSU_PID4_JEPCC(value) (DSU_PID4_JEPCC_Msk & ((value) << DSU_PID4_JEPCC_Pos))
#define DSU_PID4_FKBC_Pos 4
#define DSU_PID4_FKBC_Msk (_U_(0xF) << DSU_PID4_FKBC_Pos)
#define DSU_PID4_FKBC(value) (DSU_PID4_FKBC_Msk & ((value) << DSU_PID4_FKBC_Pos))
#define DSU_PID4_MASK _U_(0x000000FF)

/* -------- DSU_PID0 : (DSU Offset: 0x1FE0) (R/  32) Peripheral Identification 0 -------- */

typedef union {
  struct {
    uint32_t PARTNBL:8; /*!< bit:  0.. 7  Part Number Low                    */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_PID0_Type;


#define DSU_PID0_OFFSET 0x1FE0
#define DSU_PID0_RESETVALUE _U_(0x000000D0)

#define DSU_PID0_PARTNBL_Pos 0
#define DSU_PID0_PARTNBL_Msk (_U_(0xFF) << DSU_PID0_PARTNBL_Pos)
#define DSU_PID0_PARTNBL(value) (DSU_PID0_PARTNBL_Msk & ((value) << DSU_PID0_PARTNBL_Pos))
#define DSU_PID0_MASK _U_(0x000000FF)

/* -------- DSU_PID1 : (DSU Offset: 0x1FE4) (R/  32) Peripheral Identification 1 -------- */

typedef union {
  struct {
    uint32_t PARTNBH:4; /*!< bit:  0.. 3  Part Number High                   */
    uint32_t JEPIDCL:4; /*!< bit:  4.. 7  Low part of the JEP-106 Identity Code */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_PID1_Type;


#define DSU_PID1_OFFSET 0x1FE4
#define DSU_PID1_RESETVALUE _U_(0x000000FC)

#define DSU_PID1_PARTNBH_Pos 0
#define DSU_PID1_PARTNBH_Msk (_U_(0xF) << DSU_PID1_PARTNBH_Pos)
#define DSU_PID1_PARTNBH(value) (DSU_PID1_PARTNBH_Msk & ((value) << DSU_PID1_PARTNBH_Pos))
#define DSU_PID1_JEPIDCL_Pos 4
#define DSU_PID1_JEPIDCL_Msk (_U_(0xF) << DSU_PID1_JEPIDCL_Pos)
#define DSU_PID1_JEPIDCL(value) (DSU_PID1_JEPIDCL_Msk & ((value) << DSU_PID1_JEPIDCL_Pos))
#define DSU_PID1_MASK _U_(0x000000FF)

/* -------- DSU_PID2 : (DSU Offset: 0x1FE8) (R/  32) Peripheral Identification 2 -------- */

typedef union {
  struct {
    uint32_t JEPIDCH:3; /*!< bit:  0.. 2  JEP-106 Identity Code High         */
    uint32_t JEPU:1; /*!< bit:      3  JEP-106 Identity Code is used      */
    uint32_t REVISION:4; /*!< bit:  4.. 7  Revision Number                    */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_PID2_Type;


#define DSU_PID2_OFFSET 0x1FE8
#define DSU_PID2_RESETVALUE _U_(0x00000009)

#define DSU_PID2_JEPIDCH_Pos 0
#define DSU_PID2_JEPIDCH_Msk (_U_(0x7) << DSU_PID2_JEPIDCH_Pos)
#define DSU_PID2_JEPIDCH(value) (DSU_PID2_JEPIDCH_Msk & ((value) << DSU_PID2_JEPIDCH_Pos))
#define DSU_PID2_JEPU_Pos 3
#define DSU_PID2_JEPU (_U_(0x1) << DSU_PID2_JEPU_Pos)
#define DSU_PID2_REVISION_Pos 4
#define DSU_PID2_REVISION_Msk (_U_(0xF) << DSU_PID2_REVISION_Pos)
#define DSU_PID2_REVISION(value) (DSU_PID2_REVISION_Msk & ((value) << DSU_PID2_REVISION_Pos))
#define DSU_PID2_MASK _U_(0x000000FF)

/* -------- DSU_PID3 : (DSU Offset: 0x1FEC) (R/  32) Peripheral Identification 3 -------- */

typedef union {
  struct {
    uint32_t CUSMOD:4; /*!< bit:  0.. 3  ARM CUSMOD                         */
    uint32_t REVAND:4; /*!< bit:  4.. 7  Revision Number                    */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_PID3_Type;


#define DSU_PID3_OFFSET 0x1FEC
#define DSU_PID3_RESETVALUE _U_(0x00000000)

#define DSU_PID3_CUSMOD_Pos 0
#define DSU_PID3_CUSMOD_Msk (_U_(0xF) << DSU_PID3_CUSMOD_Pos)
#define DSU_PID3_CUSMOD(value) (DSU_PID3_CUSMOD_Msk & ((value) << DSU_PID3_CUSMOD_Pos))
#define DSU_PID3_REVAND_Pos 4
#define DSU_PID3_REVAND_Msk (_U_(0xF) << DSU_PID3_REVAND_Pos)
#define DSU_PID3_REVAND(value) (DSU_PID3_REVAND_Msk & ((value) << DSU_PID3_REVAND_Pos))
#define DSU_PID3_MASK _U_(0x000000FF)

/* -------- DSU_CID0 : (DSU Offset: 0x1FF0) (R/  32) Component Identification 0 -------- */

typedef union {
  struct {
    uint32_t PREAMBLEB0:8; /*!< bit:  0.. 7  Preamble Byte 0                    */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_CID0_Type;


#define DSU_CID0_OFFSET 0x1FF0
#define DSU_CID0_RESETVALUE _U_(0x0000000D)

#define DSU_CID0_PREAMBLEB0_Pos 0
#define DSU_CID0_PREAMBLEB0_Msk (_U_(0xFF) << DSU_CID0_PREAMBLEB0_Pos)
#define DSU_CID0_PREAMBLEB0(value) (DSU_CID0_PREAMBLEB0_Msk & ((value) << DSU_CID0_PREAMBLEB0_Pos))
#define DSU_CID0_MASK _U_(0x000000FF)

/* -------- DSU_CID1 : (DSU Offset: 0x1FF4) (R/  32) Component Identification 1 -------- */

typedef union {
  struct {
    uint32_t PREAMBLE:4; /*!< bit:  0.. 3  Preamble                           */
    uint32_t CCLASS:4; /*!< bit:  4.. 7  Component Class                    */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_CID1_Type;


#define DSU_CID1_OFFSET 0x1FF4
#define DSU_CID1_RESETVALUE _U_(0x00000010)

#define DSU_CID1_PREAMBLE_Pos 0
#define DSU_CID1_PREAMBLE_Msk (_U_(0xF) << DSU_CID1_PREAMBLE_Pos)
#define DSU_CID1_PREAMBLE(value) (DSU_CID1_PREAMBLE_Msk & ((value) << DSU_CID1_PREAMBLE_Pos))
#define DSU_CID1_CCLASS_Pos 4
#define DSU_CID1_CCLASS_Msk (_U_(0xF) << DSU_CID1_CCLASS_Pos)
#define DSU_CID1_CCLASS(value) (DSU_CID1_CCLASS_Msk & ((value) << DSU_CID1_CCLASS_Pos))
#define DSU_CID1_MASK _U_(0x000000FF)

/* -------- DSU_CID2 : (DSU Offset: 0x1FF8) (R/  32) Component Identification 2 -------- */

typedef union {
  struct {
    uint32_t PREAMBLEB2:8; /*!< bit:  0.. 7  Preamble Byte 2                    */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_CID2_Type;


#define DSU_CID2_OFFSET 0x1FF8
#define DSU_CID2_RESETVALUE _U_(0x00000005)

#define DSU_CID2_PREAMBLEB2_Pos 0
#define DSU_CID2_PREAMBLEB2_Msk (_U_(0xFF) << DSU_CID2_PREAMBLEB2_Pos)
#define DSU_CID2_PREAMBLEB2(value) (DSU_CID2_PREAMBLEB2_Msk & ((value) << DSU_CID2_PREAMBLEB2_Pos))
#define DSU_CID2_MASK _U_(0x000000FF)

/* -------- DSU_CID3 : (DSU Offset: 0x1FFC) (R/  32) Component Identification 3 -------- */

typedef union {
  struct {
    uint32_t PREAMBLEB3:8; /*!< bit:  0.. 7  Preamble Byte 3                    */
    uint32_t :24; /*!< bit:  8..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} DSU_CID3_Type;


#define DSU_CID3_OFFSET 0x1FFC
#define DSU_CID3_RESETVALUE _U_(0x000000B1)

#define DSU_CID3_PREAMBLEB3_Pos 0
#define DSU_CID3_PREAMBLEB3_Msk (_U_(0xFF) << DSU_CID3_PREAMBLEB3_Pos)
#define DSU_CID3_PREAMBLEB3(value) (DSU_CID3_PREAMBLEB3_Msk & ((value) << DSU_CID3_PREAMBLEB3_Pos))
#define DSU_CID3_MASK _U_(0x000000FF)

/** \brief DSU hardware registers */

typedef struct {
  volatile DSU_CTRL_Type CTRL; /**< \brief Offset: 0x0000 ( /W  8) Control */
  volatile DSU_STATUSA_Type STATUSA; /**< \brief Offset: 0x0001 (R/W  8) Status A */
  volatile const DSU_STATUSB_Type STATUSB; /**< \brief Offset: 0x0002 (R/   8) Status B */
       RoReg8 Reserved1[0x1];
  volatile DSU_ADDR_Type ADDR; /**< \brief Offset: 0x0004 (R/W 32) Address */
  volatile DSU_LENGTH_Type LENGTH; /**< \brief Offset: 0x0008 (R/W 32) Length */
  volatile DSU_DATA_Type DATA; /**< \brief Offset: 0x000C (R/W 32) Data */
  volatile DSU_DCC_Type DCC[2]; /**< \brief Offset: 0x0010 (R/W 32) Debug Communication Channel n */
  volatile const DSU_DID_Type DID; /**< \brief Offset: 0x0018 (R/  32) Device Identification */
       RoReg8 Reserved2[0xFE4];
  volatile const DSU_ENTRY_Type ENTRY; /**< \brief Offset: 0x1000 (R/  32) CoreSight ROM Table Entry 0 */
  volatile const DSU_ENTRY1_Type ENTRY1; /**< \brief Offset: 0x1004 (R/  32) CoreSight ROM Table Entry 1 */
  volatile const DSU_END_Type END; /**< \brief Offset: 0x1008 (R/  32) CoreSight ROM Table End */
       RoReg8 Reserved3[0xFC0];
  volatile const DSU_MEMTYPE_Type MEMTYPE; /**< \brief Offset: 0x1FCC (R/  32) CoreSight ROM Table Memory Type */
  volatile const DSU_PID4_Type PID4; /**< \brief Offset: 0x1FD0 (R/  32) Peripheral Identification 4 */
       RoReg8 Reserved4[0xC];
  volatile const DSU_PID0_Type PID0; /**< \brief Offset: 0x1FE0 (R/  32) Peripheral Identification 0 */
  volatile const DSU_PID1_Type PID1; /**< \brief Offset: 0x1FE4 (R/  32) Peripheral Identification 1 */
  volatile const DSU_PID2_Type PID2; /**< \brief Offset: 0x1FE8 (R/  32) Peripheral Identification 2 */
  volatile const DSU_PID3_Type PID3; /**< \brief Offset: 0x1FEC (R/  32) Peripheral Identification 3 */
  volatile const DSU_CID0_Type CID0; /**< \brief Offset: 0x1FF0 (R/  32) Component Identification 0 */
  volatile const DSU_CID1_Type CID1; /**< \brief Offset: 0x1FF4 (R/  32) Component Identification 1 */
  volatile const DSU_CID2_Type CID2; /**< \brief Offset: 0x1FF8 (R/  32) Component Identification 2 */
  volatile const DSU_CID3_Type CID3; /**< \brief Offset: 0x1FFC (R/  32) Component Identification 3 */
} Dsu;


/*@}*/
# 249 "asf4/samd21/include/samd21e18a.h" 2
#include "component/eic.h"
# 249 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/eic.h" 1
/**
 * \file
 *
 * \brief Component description for EIC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_EIC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR EIC */
/* ========================================================================== */
/** \addtogroup SAMD21_EIC External Interrupt Controller */
/*@{*/

#define EIC_U2217 
#define REV_EIC 0x101

/* -------- EIC_CTRL : (EIC Offset: 0x00) (R/W  8) Control -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} EIC_CTRL_Type;


#define EIC_CTRL_OFFSET 0x00
#define EIC_CTRL_RESETVALUE _U_(0x00)

#define EIC_CTRL_SWRST_Pos 0
#define EIC_CTRL_SWRST (_U_(0x1) << EIC_CTRL_SWRST_Pos)
#define EIC_CTRL_ENABLE_Pos 1
#define EIC_CTRL_ENABLE (_U_(0x1) << EIC_CTRL_ENABLE_Pos)
#define EIC_CTRL_MASK _U_(0x03)

/* -------- EIC_STATUS : (EIC Offset: 0x01) (R/   8) Status -------- */

typedef union {
  struct {
    uint8_t :7; /*!< bit:  0.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy               */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} EIC_STATUS_Type;


#define EIC_STATUS_OFFSET 0x01
#define EIC_STATUS_RESETVALUE _U_(0x00)

#define EIC_STATUS_SYNCBUSY_Pos 7
#define EIC_STATUS_SYNCBUSY (_U_(0x1) << EIC_STATUS_SYNCBUSY_Pos)
#define EIC_STATUS_MASK _U_(0x80)

/* -------- EIC_NMICTRL : (EIC Offset: 0x02) (R/W  8) Non-Maskable Interrupt Control -------- */

typedef union {
  struct {
    uint8_t NMISENSE:3; /*!< bit:  0.. 2  Non-Maskable Interrupt Sense       */
    uint8_t NMIFILTEN:1; /*!< bit:      3  Non-Maskable Interrupt Filter Enable */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} EIC_NMICTRL_Type;


#define EIC_NMICTRL_OFFSET 0x02
#define EIC_NMICTRL_RESETVALUE _U_(0x00)

#define EIC_NMICTRL_NMISENSE_Pos 0
#define EIC_NMICTRL_NMISENSE_Msk (_U_(0x7) << EIC_NMICTRL_NMISENSE_Pos)
#define EIC_NMICTRL_NMISENSE(value) (EIC_NMICTRL_NMISENSE_Msk & ((value) << EIC_NMICTRL_NMISENSE_Pos))
#define EIC_NMICTRL_NMISENSE_NONE_Val _U_(0x0)
#define EIC_NMICTRL_NMISENSE_RISE_Val _U_(0x1)
#define EIC_NMICTRL_NMISENSE_FALL_Val _U_(0x2)
#define EIC_NMICTRL_NMISENSE_BOTH_Val _U_(0x3)
#define EIC_NMICTRL_NMISENSE_HIGH_Val _U_(0x4)
#define EIC_NMICTRL_NMISENSE_LOW_Val _U_(0x5)
#define EIC_NMICTRL_NMISENSE_NONE (EIC_NMICTRL_NMISENSE_NONE_Val << EIC_NMICTRL_NMISENSE_Pos)
#define EIC_NMICTRL_NMISENSE_RISE (EIC_NMICTRL_NMISENSE_RISE_Val << EIC_NMICTRL_NMISENSE_Pos)
#define EIC_NMICTRL_NMISENSE_FALL (EIC_NMICTRL_NMISENSE_FALL_Val << EIC_NMICTRL_NMISENSE_Pos)
#define EIC_NMICTRL_NMISENSE_BOTH (EIC_NMICTRL_NMISENSE_BOTH_Val << EIC_NMICTRL_NMISENSE_Pos)
#define EIC_NMICTRL_NMISENSE_HIGH (EIC_NMICTRL_NMISENSE_HIGH_Val << EIC_NMICTRL_NMISENSE_Pos)
#define EIC_NMICTRL_NMISENSE_LOW (EIC_NMICTRL_NMISENSE_LOW_Val << EIC_NMICTRL_NMISENSE_Pos)
#define EIC_NMICTRL_NMIFILTEN_Pos 3
#define EIC_NMICTRL_NMIFILTEN (_U_(0x1) << EIC_NMICTRL_NMIFILTEN_Pos)
#define EIC_NMICTRL_MASK _U_(0x0F)

/* -------- EIC_NMIFLAG : (EIC Offset: 0x03) (R/W  8) Non-Maskable Interrupt Flag Status and Clear -------- */

typedef union {
  struct {
    uint8_t NMI:1; /*!< bit:      0  Non-Maskable Interrupt             */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} EIC_NMIFLAG_Type;


#define EIC_NMIFLAG_OFFSET 0x03
#define EIC_NMIFLAG_RESETVALUE _U_(0x00)

#define EIC_NMIFLAG_NMI_Pos 0
#define EIC_NMIFLAG_NMI (_U_(0x1) << EIC_NMIFLAG_NMI_Pos)
#define EIC_NMIFLAG_MASK _U_(0x01)

/* -------- EIC_EVCTRL : (EIC Offset: 0x04) (R/W 32) Event Control -------- */

typedef union {
  struct {
    uint32_t EXTINTEO0:1; /*!< bit:      0  External Interrupt 0 Event Output Enable */
    uint32_t EXTINTEO1:1; /*!< bit:      1  External Interrupt 1 Event Output Enable */
    uint32_t EXTINTEO2:1; /*!< bit:      2  External Interrupt 2 Event Output Enable */
    uint32_t EXTINTEO3:1; /*!< bit:      3  External Interrupt 3 Event Output Enable */
    uint32_t EXTINTEO4:1; /*!< bit:      4  External Interrupt 4 Event Output Enable */
    uint32_t EXTINTEO5:1; /*!< bit:      5  External Interrupt 5 Event Output Enable */
    uint32_t EXTINTEO6:1; /*!< bit:      6  External Interrupt 6 Event Output Enable */
    uint32_t EXTINTEO7:1; /*!< bit:      7  External Interrupt 7 Event Output Enable */
    uint32_t EXTINTEO8:1; /*!< bit:      8  External Interrupt 8 Event Output Enable */
    uint32_t EXTINTEO9:1; /*!< bit:      9  External Interrupt 9 Event Output Enable */
    uint32_t EXTINTEO10:1; /*!< bit:     10  External Interrupt 10 Event Output Enable */
    uint32_t EXTINTEO11:1; /*!< bit:     11  External Interrupt 11 Event Output Enable */
    uint32_t EXTINTEO12:1; /*!< bit:     12  External Interrupt 12 Event Output Enable */
    uint32_t EXTINTEO13:1; /*!< bit:     13  External Interrupt 13 Event Output Enable */
    uint32_t EXTINTEO14:1; /*!< bit:     14  External Interrupt 14 Event Output Enable */
    uint32_t EXTINTEO15:1; /*!< bit:     15  External Interrupt 15 Event Output Enable */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t EXTINTEO:16; /*!< bit:  0..15  External Interrupt x Event Output Enable */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EIC_EVCTRL_Type;


#define EIC_EVCTRL_OFFSET 0x04
#define EIC_EVCTRL_RESETVALUE _U_(0x00000000)

#define EIC_EVCTRL_EXTINTEO0_Pos 0
#define EIC_EVCTRL_EXTINTEO0 (_U_(1) << EIC_EVCTRL_EXTINTEO0_Pos)
#define EIC_EVCTRL_EXTINTEO1_Pos 1
#define EIC_EVCTRL_EXTINTEO1 (_U_(1) << EIC_EVCTRL_EXTINTEO1_Pos)
#define EIC_EVCTRL_EXTINTEO2_Pos 2
#define EIC_EVCTRL_EXTINTEO2 (_U_(1) << EIC_EVCTRL_EXTINTEO2_Pos)
#define EIC_EVCTRL_EXTINTEO3_Pos 3
#define EIC_EVCTRL_EXTINTEO3 (_U_(1) << EIC_EVCTRL_EXTINTEO3_Pos)
#define EIC_EVCTRL_EXTINTEO4_Pos 4
#define EIC_EVCTRL_EXTINTEO4 (_U_(1) << EIC_EVCTRL_EXTINTEO4_Pos)
#define EIC_EVCTRL_EXTINTEO5_Pos 5
#define EIC_EVCTRL_EXTINTEO5 (_U_(1) << EIC_EVCTRL_EXTINTEO5_Pos)
#define EIC_EVCTRL_EXTINTEO6_Pos 6
#define EIC_EVCTRL_EXTINTEO6 (_U_(1) << EIC_EVCTRL_EXTINTEO6_Pos)
#define EIC_EVCTRL_EXTINTEO7_Pos 7
#define EIC_EVCTRL_EXTINTEO7 (_U_(1) << EIC_EVCTRL_EXTINTEO7_Pos)
#define EIC_EVCTRL_EXTINTEO8_Pos 8
#define EIC_EVCTRL_EXTINTEO8 (_U_(1) << EIC_EVCTRL_EXTINTEO8_Pos)
#define EIC_EVCTRL_EXTINTEO9_Pos 9
#define EIC_EVCTRL_EXTINTEO9 (_U_(1) << EIC_EVCTRL_EXTINTEO9_Pos)
#define EIC_EVCTRL_EXTINTEO10_Pos 10
#define EIC_EVCTRL_EXTINTEO10 (_U_(1) << EIC_EVCTRL_EXTINTEO10_Pos)
#define EIC_EVCTRL_EXTINTEO11_Pos 11
#define EIC_EVCTRL_EXTINTEO11 (_U_(1) << EIC_EVCTRL_EXTINTEO11_Pos)
#define EIC_EVCTRL_EXTINTEO12_Pos 12
#define EIC_EVCTRL_EXTINTEO12 (_U_(1) << EIC_EVCTRL_EXTINTEO12_Pos)
#define EIC_EVCTRL_EXTINTEO13_Pos 13
#define EIC_EVCTRL_EXTINTEO13 (_U_(1) << EIC_EVCTRL_EXTINTEO13_Pos)
#define EIC_EVCTRL_EXTINTEO14_Pos 14
#define EIC_EVCTRL_EXTINTEO14 (_U_(1) << EIC_EVCTRL_EXTINTEO14_Pos)
#define EIC_EVCTRL_EXTINTEO15_Pos 15
#define EIC_EVCTRL_EXTINTEO15 (_U_(1) << EIC_EVCTRL_EXTINTEO15_Pos)
#define EIC_EVCTRL_EXTINTEO_Pos 0
#define EIC_EVCTRL_EXTINTEO_Msk (_U_(0xFFFF) << EIC_EVCTRL_EXTINTEO_Pos)
#define EIC_EVCTRL_EXTINTEO(value) (EIC_EVCTRL_EXTINTEO_Msk & ((value) << EIC_EVCTRL_EXTINTEO_Pos))
#define EIC_EVCTRL_MASK _U_(0x0000FFFF)

/* -------- EIC_INTENCLR : (EIC Offset: 0x08) (R/W 32) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint32_t EXTINT0:1; /*!< bit:      0  External Interrupt 0 Enable        */
    uint32_t EXTINT1:1; /*!< bit:      1  External Interrupt 1 Enable        */
    uint32_t EXTINT2:1; /*!< bit:      2  External Interrupt 2 Enable        */
    uint32_t EXTINT3:1; /*!< bit:      3  External Interrupt 3 Enable        */
    uint32_t EXTINT4:1; /*!< bit:      4  External Interrupt 4 Enable        */
    uint32_t EXTINT5:1; /*!< bit:      5  External Interrupt 5 Enable        */
    uint32_t EXTINT6:1; /*!< bit:      6  External Interrupt 6 Enable        */
    uint32_t EXTINT7:1; /*!< bit:      7  External Interrupt 7 Enable        */
    uint32_t EXTINT8:1; /*!< bit:      8  External Interrupt 8 Enable        */
    uint32_t EXTINT9:1; /*!< bit:      9  External Interrupt 9 Enable        */
    uint32_t EXTINT10:1; /*!< bit:     10  External Interrupt 10 Enable       */
    uint32_t EXTINT11:1; /*!< bit:     11  External Interrupt 11 Enable       */
    uint32_t EXTINT12:1; /*!< bit:     12  External Interrupt 12 Enable       */
    uint32_t EXTINT13:1; /*!< bit:     13  External Interrupt 13 Enable       */
    uint32_t EXTINT14:1; /*!< bit:     14  External Interrupt 14 Enable       */
    uint32_t EXTINT15:1; /*!< bit:     15  External Interrupt 15 Enable       */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t EXTINT:16; /*!< bit:  0..15  External Interrupt x Enable        */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EIC_INTENCLR_Type;


#define EIC_INTENCLR_OFFSET 0x08
#define EIC_INTENCLR_RESETVALUE _U_(0x00000000)

#define EIC_INTENCLR_EXTINT0_Pos 0
#define EIC_INTENCLR_EXTINT0 (_U_(1) << EIC_INTENCLR_EXTINT0_Pos)
#define EIC_INTENCLR_EXTINT1_Pos 1
#define EIC_INTENCLR_EXTINT1 (_U_(1) << EIC_INTENCLR_EXTINT1_Pos)
#define EIC_INTENCLR_EXTINT2_Pos 2
#define EIC_INTENCLR_EXTINT2 (_U_(1) << EIC_INTENCLR_EXTINT2_Pos)
#define EIC_INTENCLR_EXTINT3_Pos 3
#define EIC_INTENCLR_EXTINT3 (_U_(1) << EIC_INTENCLR_EXTINT3_Pos)
#define EIC_INTENCLR_EXTINT4_Pos 4
#define EIC_INTENCLR_EXTINT4 (_U_(1) << EIC_INTENCLR_EXTINT4_Pos)
#define EIC_INTENCLR_EXTINT5_Pos 5
#define EIC_INTENCLR_EXTINT5 (_U_(1) << EIC_INTENCLR_EXTINT5_Pos)
#define EIC_INTENCLR_EXTINT6_Pos 6
#define EIC_INTENCLR_EXTINT6 (_U_(1) << EIC_INTENCLR_EXTINT6_Pos)
#define EIC_INTENCLR_EXTINT7_Pos 7
#define EIC_INTENCLR_EXTINT7 (_U_(1) << EIC_INTENCLR_EXTINT7_Pos)
#define EIC_INTENCLR_EXTINT8_Pos 8
#define EIC_INTENCLR_EXTINT8 (_U_(1) << EIC_INTENCLR_EXTINT8_Pos)
#define EIC_INTENCLR_EXTINT9_Pos 9
#define EIC_INTENCLR_EXTINT9 (_U_(1) << EIC_INTENCLR_EXTINT9_Pos)
#define EIC_INTENCLR_EXTINT10_Pos 10
#define EIC_INTENCLR_EXTINT10 (_U_(1) << EIC_INTENCLR_EXTINT10_Pos)
#define EIC_INTENCLR_EXTINT11_Pos 11
#define EIC_INTENCLR_EXTINT11 (_U_(1) << EIC_INTENCLR_EXTINT11_Pos)
#define EIC_INTENCLR_EXTINT12_Pos 12
#define EIC_INTENCLR_EXTINT12 (_U_(1) << EIC_INTENCLR_EXTINT12_Pos)
#define EIC_INTENCLR_EXTINT13_Pos 13
#define EIC_INTENCLR_EXTINT13 (_U_(1) << EIC_INTENCLR_EXTINT13_Pos)
#define EIC_INTENCLR_EXTINT14_Pos 14
#define EIC_INTENCLR_EXTINT14 (_U_(1) << EIC_INTENCLR_EXTINT14_Pos)
#define EIC_INTENCLR_EXTINT15_Pos 15
#define EIC_INTENCLR_EXTINT15 (_U_(1) << EIC_INTENCLR_EXTINT15_Pos)
#define EIC_INTENCLR_EXTINT_Pos 0
#define EIC_INTENCLR_EXTINT_Msk (_U_(0xFFFF) << EIC_INTENCLR_EXTINT_Pos)
#define EIC_INTENCLR_EXTINT(value) (EIC_INTENCLR_EXTINT_Msk & ((value) << EIC_INTENCLR_EXTINT_Pos))
#define EIC_INTENCLR_MASK _U_(0x0000FFFF)

/* -------- EIC_INTENSET : (EIC Offset: 0x0C) (R/W 32) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint32_t EXTINT0:1; /*!< bit:      0  External Interrupt 0 Enable        */
    uint32_t EXTINT1:1; /*!< bit:      1  External Interrupt 1 Enable        */
    uint32_t EXTINT2:1; /*!< bit:      2  External Interrupt 2 Enable        */
    uint32_t EXTINT3:1; /*!< bit:      3  External Interrupt 3 Enable        */
    uint32_t EXTINT4:1; /*!< bit:      4  External Interrupt 4 Enable        */
    uint32_t EXTINT5:1; /*!< bit:      5  External Interrupt 5 Enable        */
    uint32_t EXTINT6:1; /*!< bit:      6  External Interrupt 6 Enable        */
    uint32_t EXTINT7:1; /*!< bit:      7  External Interrupt 7 Enable        */
    uint32_t EXTINT8:1; /*!< bit:      8  External Interrupt 8 Enable        */
    uint32_t EXTINT9:1; /*!< bit:      9  External Interrupt 9 Enable        */
    uint32_t EXTINT10:1; /*!< bit:     10  External Interrupt 10 Enable       */
    uint32_t EXTINT11:1; /*!< bit:     11  External Interrupt 11 Enable       */
    uint32_t EXTINT12:1; /*!< bit:     12  External Interrupt 12 Enable       */
    uint32_t EXTINT13:1; /*!< bit:     13  External Interrupt 13 Enable       */
    uint32_t EXTINT14:1; /*!< bit:     14  External Interrupt 14 Enable       */
    uint32_t EXTINT15:1; /*!< bit:     15  External Interrupt 15 Enable       */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t EXTINT:16; /*!< bit:  0..15  External Interrupt x Enable        */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EIC_INTENSET_Type;


#define EIC_INTENSET_OFFSET 0x0C
#define EIC_INTENSET_RESETVALUE _U_(0x00000000)

#define EIC_INTENSET_EXTINT0_Pos 0
#define EIC_INTENSET_EXTINT0 (_U_(1) << EIC_INTENSET_EXTINT0_Pos)
#define EIC_INTENSET_EXTINT1_Pos 1
#define EIC_INTENSET_EXTINT1 (_U_(1) << EIC_INTENSET_EXTINT1_Pos)
#define EIC_INTENSET_EXTINT2_Pos 2
#define EIC_INTENSET_EXTINT2 (_U_(1) << EIC_INTENSET_EXTINT2_Pos)
#define EIC_INTENSET_EXTINT3_Pos 3
#define EIC_INTENSET_EXTINT3 (_U_(1) << EIC_INTENSET_EXTINT3_Pos)
#define EIC_INTENSET_EXTINT4_Pos 4
#define EIC_INTENSET_EXTINT4 (_U_(1) << EIC_INTENSET_EXTINT4_Pos)
#define EIC_INTENSET_EXTINT5_Pos 5
#define EIC_INTENSET_EXTINT5 (_U_(1) << EIC_INTENSET_EXTINT5_Pos)
#define EIC_INTENSET_EXTINT6_Pos 6
#define EIC_INTENSET_EXTINT6 (_U_(1) << EIC_INTENSET_EXTINT6_Pos)
#define EIC_INTENSET_EXTINT7_Pos 7
#define EIC_INTENSET_EXTINT7 (_U_(1) << EIC_INTENSET_EXTINT7_Pos)
#define EIC_INTENSET_EXTINT8_Pos 8
#define EIC_INTENSET_EXTINT8 (_U_(1) << EIC_INTENSET_EXTINT8_Pos)
#define EIC_INTENSET_EXTINT9_Pos 9
#define EIC_INTENSET_EXTINT9 (_U_(1) << EIC_INTENSET_EXTINT9_Pos)
#define EIC_INTENSET_EXTINT10_Pos 10
#define EIC_INTENSET_EXTINT10 (_U_(1) << EIC_INTENSET_EXTINT10_Pos)
#define EIC_INTENSET_EXTINT11_Pos 11
#define EIC_INTENSET_EXTINT11 (_U_(1) << EIC_INTENSET_EXTINT11_Pos)
#define EIC_INTENSET_EXTINT12_Pos 12
#define EIC_INTENSET_EXTINT12 (_U_(1) << EIC_INTENSET_EXTINT12_Pos)
#define EIC_INTENSET_EXTINT13_Pos 13
#define EIC_INTENSET_EXTINT13 (_U_(1) << EIC_INTENSET_EXTINT13_Pos)
#define EIC_INTENSET_EXTINT14_Pos 14
#define EIC_INTENSET_EXTINT14 (_U_(1) << EIC_INTENSET_EXTINT14_Pos)
#define EIC_INTENSET_EXTINT15_Pos 15
#define EIC_INTENSET_EXTINT15 (_U_(1) << EIC_INTENSET_EXTINT15_Pos)
#define EIC_INTENSET_EXTINT_Pos 0
#define EIC_INTENSET_EXTINT_Msk (_U_(0xFFFF) << EIC_INTENSET_EXTINT_Pos)
#define EIC_INTENSET_EXTINT(value) (EIC_INTENSET_EXTINT_Msk & ((value) << EIC_INTENSET_EXTINT_Pos))
#define EIC_INTENSET_MASK _U_(0x0000FFFF)

/* -------- EIC_INTFLAG : (EIC Offset: 0x10) (R/W 32) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint32_t EXTINT0:1; /*!< bit:      0  External Interrupt 0               */
    volatile const uint32_t EXTINT1:1; /*!< bit:      1  External Interrupt 1               */
    volatile const uint32_t EXTINT2:1; /*!< bit:      2  External Interrupt 2               */
    volatile const uint32_t EXTINT3:1; /*!< bit:      3  External Interrupt 3               */
    volatile const uint32_t EXTINT4:1; /*!< bit:      4  External Interrupt 4               */
    volatile const uint32_t EXTINT5:1; /*!< bit:      5  External Interrupt 5               */
    volatile const uint32_t EXTINT6:1; /*!< bit:      6  External Interrupt 6               */
    volatile const uint32_t EXTINT7:1; /*!< bit:      7  External Interrupt 7               */
    volatile const uint32_t EXTINT8:1; /*!< bit:      8  External Interrupt 8               */
    volatile const uint32_t EXTINT9:1; /*!< bit:      9  External Interrupt 9               */
    volatile const uint32_t EXTINT10:1; /*!< bit:     10  External Interrupt 10              */
    volatile const uint32_t EXTINT11:1; /*!< bit:     11  External Interrupt 11              */
    volatile const uint32_t EXTINT12:1; /*!< bit:     12  External Interrupt 12              */
    volatile const uint32_t EXTINT13:1; /*!< bit:     13  External Interrupt 13              */
    volatile const uint32_t EXTINT14:1; /*!< bit:     14  External Interrupt 14              */
    volatile const uint32_t EXTINT15:1; /*!< bit:     15  External Interrupt 15              */
    volatile const uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint32_t EXTINT:16; /*!< bit:  0..15  External Interrupt x               */
    volatile const uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EIC_INTFLAG_Type;


#define EIC_INTFLAG_OFFSET 0x10
#define EIC_INTFLAG_RESETVALUE _U_(0x00000000)

#define EIC_INTFLAG_EXTINT0_Pos 0
#define EIC_INTFLAG_EXTINT0 (_U_(1) << EIC_INTFLAG_EXTINT0_Pos)
#define EIC_INTFLAG_EXTINT1_Pos 1
#define EIC_INTFLAG_EXTINT1 (_U_(1) << EIC_INTFLAG_EXTINT1_Pos)
#define EIC_INTFLAG_EXTINT2_Pos 2
#define EIC_INTFLAG_EXTINT2 (_U_(1) << EIC_INTFLAG_EXTINT2_Pos)
#define EIC_INTFLAG_EXTINT3_Pos 3
#define EIC_INTFLAG_EXTINT3 (_U_(1) << EIC_INTFLAG_EXTINT3_Pos)
#define EIC_INTFLAG_EXTINT4_Pos 4
#define EIC_INTFLAG_EXTINT4 (_U_(1) << EIC_INTFLAG_EXTINT4_Pos)
#define EIC_INTFLAG_EXTINT5_Pos 5
#define EIC_INTFLAG_EXTINT5 (_U_(1) << EIC_INTFLAG_EXTINT5_Pos)
#define EIC_INTFLAG_EXTINT6_Pos 6
#define EIC_INTFLAG_EXTINT6 (_U_(1) << EIC_INTFLAG_EXTINT6_Pos)
#define EIC_INTFLAG_EXTINT7_Pos 7
#define EIC_INTFLAG_EXTINT7 (_U_(1) << EIC_INTFLAG_EXTINT7_Pos)
#define EIC_INTFLAG_EXTINT8_Pos 8
#define EIC_INTFLAG_EXTINT8 (_U_(1) << EIC_INTFLAG_EXTINT8_Pos)
#define EIC_INTFLAG_EXTINT9_Pos 9
#define EIC_INTFLAG_EXTINT9 (_U_(1) << EIC_INTFLAG_EXTINT9_Pos)
#define EIC_INTFLAG_EXTINT10_Pos 10
#define EIC_INTFLAG_EXTINT10 (_U_(1) << EIC_INTFLAG_EXTINT10_Pos)
#define EIC_INTFLAG_EXTINT11_Pos 11
#define EIC_INTFLAG_EXTINT11 (_U_(1) << EIC_INTFLAG_EXTINT11_Pos)
#define EIC_INTFLAG_EXTINT12_Pos 12
#define EIC_INTFLAG_EXTINT12 (_U_(1) << EIC_INTFLAG_EXTINT12_Pos)
#define EIC_INTFLAG_EXTINT13_Pos 13
#define EIC_INTFLAG_EXTINT13 (_U_(1) << EIC_INTFLAG_EXTINT13_Pos)
#define EIC_INTFLAG_EXTINT14_Pos 14
#define EIC_INTFLAG_EXTINT14 (_U_(1) << EIC_INTFLAG_EXTINT14_Pos)
#define EIC_INTFLAG_EXTINT15_Pos 15
#define EIC_INTFLAG_EXTINT15 (_U_(1) << EIC_INTFLAG_EXTINT15_Pos)
#define EIC_INTFLAG_EXTINT_Pos 0
#define EIC_INTFLAG_EXTINT_Msk (_U_(0xFFFF) << EIC_INTFLAG_EXTINT_Pos)
#define EIC_INTFLAG_EXTINT(value) (EIC_INTFLAG_EXTINT_Msk & ((value) << EIC_INTFLAG_EXTINT_Pos))
#define EIC_INTFLAG_MASK _U_(0x0000FFFF)

/* -------- EIC_WAKEUP : (EIC Offset: 0x14) (R/W 32) Wake-Up Enable -------- */

typedef union {
  struct {
    uint32_t WAKEUPEN0:1; /*!< bit:      0  External Interrupt 0 Wake-up Enable */
    uint32_t WAKEUPEN1:1; /*!< bit:      1  External Interrupt 1 Wake-up Enable */
    uint32_t WAKEUPEN2:1; /*!< bit:      2  External Interrupt 2 Wake-up Enable */
    uint32_t WAKEUPEN3:1; /*!< bit:      3  External Interrupt 3 Wake-up Enable */
    uint32_t WAKEUPEN4:1; /*!< bit:      4  External Interrupt 4 Wake-up Enable */
    uint32_t WAKEUPEN5:1; /*!< bit:      5  External Interrupt 5 Wake-up Enable */
    uint32_t WAKEUPEN6:1; /*!< bit:      6  External Interrupt 6 Wake-up Enable */
    uint32_t WAKEUPEN7:1; /*!< bit:      7  External Interrupt 7 Wake-up Enable */
    uint32_t WAKEUPEN8:1; /*!< bit:      8  External Interrupt 8 Wake-up Enable */
    uint32_t WAKEUPEN9:1; /*!< bit:      9  External Interrupt 9 Wake-up Enable */
    uint32_t WAKEUPEN10:1; /*!< bit:     10  External Interrupt 10 Wake-up Enable */
    uint32_t WAKEUPEN11:1; /*!< bit:     11  External Interrupt 11 Wake-up Enable */
    uint32_t WAKEUPEN12:1; /*!< bit:     12  External Interrupt 12 Wake-up Enable */
    uint32_t WAKEUPEN13:1; /*!< bit:     13  External Interrupt 13 Wake-up Enable */
    uint32_t WAKEUPEN14:1; /*!< bit:     14  External Interrupt 14 Wake-up Enable */
    uint32_t WAKEUPEN15:1; /*!< bit:     15  External Interrupt 15 Wake-up Enable */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t WAKEUPEN:16; /*!< bit:  0..15  External Interrupt x Wake-up Enable */
    uint32_t :16; /*!< bit: 16..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EIC_WAKEUP_Type;


#define EIC_WAKEUP_OFFSET 0x14
#define EIC_WAKEUP_RESETVALUE _U_(0x00000000)

#define EIC_WAKEUP_WAKEUPEN0_Pos 0
#define EIC_WAKEUP_WAKEUPEN0 (_U_(1) << EIC_WAKEUP_WAKEUPEN0_Pos)
#define EIC_WAKEUP_WAKEUPEN1_Pos 1
#define EIC_WAKEUP_WAKEUPEN1 (_U_(1) << EIC_WAKEUP_WAKEUPEN1_Pos)
#define EIC_WAKEUP_WAKEUPEN2_Pos 2
#define EIC_WAKEUP_WAKEUPEN2 (_U_(1) << EIC_WAKEUP_WAKEUPEN2_Pos)
#define EIC_WAKEUP_WAKEUPEN3_Pos 3
#define EIC_WAKEUP_WAKEUPEN3 (_U_(1) << EIC_WAKEUP_WAKEUPEN3_Pos)
#define EIC_WAKEUP_WAKEUPEN4_Pos 4
#define EIC_WAKEUP_WAKEUPEN4 (_U_(1) << EIC_WAKEUP_WAKEUPEN4_Pos)
#define EIC_WAKEUP_WAKEUPEN5_Pos 5
#define EIC_WAKEUP_WAKEUPEN5 (_U_(1) << EIC_WAKEUP_WAKEUPEN5_Pos)
#define EIC_WAKEUP_WAKEUPEN6_Pos 6
#define EIC_WAKEUP_WAKEUPEN6 (_U_(1) << EIC_WAKEUP_WAKEUPEN6_Pos)
#define EIC_WAKEUP_WAKEUPEN7_Pos 7
#define EIC_WAKEUP_WAKEUPEN7 (_U_(1) << EIC_WAKEUP_WAKEUPEN7_Pos)
#define EIC_WAKEUP_WAKEUPEN8_Pos 8
#define EIC_WAKEUP_WAKEUPEN8 (_U_(1) << EIC_WAKEUP_WAKEUPEN8_Pos)
#define EIC_WAKEUP_WAKEUPEN9_Pos 9
#define EIC_WAKEUP_WAKEUPEN9 (_U_(1) << EIC_WAKEUP_WAKEUPEN9_Pos)
#define EIC_WAKEUP_WAKEUPEN10_Pos 10
#define EIC_WAKEUP_WAKEUPEN10 (_U_(1) << EIC_WAKEUP_WAKEUPEN10_Pos)
#define EIC_WAKEUP_WAKEUPEN11_Pos 11
#define EIC_WAKEUP_WAKEUPEN11 (_U_(1) << EIC_WAKEUP_WAKEUPEN11_Pos)
#define EIC_WAKEUP_WAKEUPEN12_Pos 12
#define EIC_WAKEUP_WAKEUPEN12 (_U_(1) << EIC_WAKEUP_WAKEUPEN12_Pos)
#define EIC_WAKEUP_WAKEUPEN13_Pos 13
#define EIC_WAKEUP_WAKEUPEN13 (_U_(1) << EIC_WAKEUP_WAKEUPEN13_Pos)
#define EIC_WAKEUP_WAKEUPEN14_Pos 14
#define EIC_WAKEUP_WAKEUPEN14 (_U_(1) << EIC_WAKEUP_WAKEUPEN14_Pos)
#define EIC_WAKEUP_WAKEUPEN15_Pos 15
#define EIC_WAKEUP_WAKEUPEN15 (_U_(1) << EIC_WAKEUP_WAKEUPEN15_Pos)
#define EIC_WAKEUP_WAKEUPEN_Pos 0
#define EIC_WAKEUP_WAKEUPEN_Msk (_U_(0xFFFF) << EIC_WAKEUP_WAKEUPEN_Pos)
#define EIC_WAKEUP_WAKEUPEN(value) (EIC_WAKEUP_WAKEUPEN_Msk & ((value) << EIC_WAKEUP_WAKEUPEN_Pos))
#define EIC_WAKEUP_MASK _U_(0x0000FFFF)

/* -------- EIC_CONFIG : (EIC Offset: 0x18) (R/W 32) Configuration n -------- */

typedef union {
  struct {
    uint32_t SENSE0:3; /*!< bit:  0.. 2  Input Sense 0 Configuration        */
    uint32_t FILTEN0:1; /*!< bit:      3  Filter 0 Enable                    */
    uint32_t SENSE1:3; /*!< bit:  4.. 6  Input Sense 1 Configuration        */
    uint32_t FILTEN1:1; /*!< bit:      7  Filter 1 Enable                    */
    uint32_t SENSE2:3; /*!< bit:  8..10  Input Sense 2 Configuration        */
    uint32_t FILTEN2:1; /*!< bit:     11  Filter 2 Enable                    */
    uint32_t SENSE3:3; /*!< bit: 12..14  Input Sense 3 Configuration        */
    uint32_t FILTEN3:1; /*!< bit:     15  Filter 3 Enable                    */
    uint32_t SENSE4:3; /*!< bit: 16..18  Input Sense 4 Configuration        */
    uint32_t FILTEN4:1; /*!< bit:     19  Filter 4 Enable                    */
    uint32_t SENSE5:3; /*!< bit: 20..22  Input Sense 5 Configuration        */
    uint32_t FILTEN5:1; /*!< bit:     23  Filter 5 Enable                    */
    uint32_t SENSE6:3; /*!< bit: 24..26  Input Sense 6 Configuration        */
    uint32_t FILTEN6:1; /*!< bit:     27  Filter 6 Enable                    */
    uint32_t SENSE7:3; /*!< bit: 28..30  Input Sense 7 Configuration        */
    uint32_t FILTEN7:1; /*!< bit:     31  Filter 7 Enable                    */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EIC_CONFIG_Type;


#define EIC_CONFIG_OFFSET 0x18
#define EIC_CONFIG_RESETVALUE _U_(0x00000000)

#define EIC_CONFIG_SENSE0_Pos 0
#define EIC_CONFIG_SENSE0_Msk (_U_(0x7) << EIC_CONFIG_SENSE0_Pos)
#define EIC_CONFIG_SENSE0(value) (EIC_CONFIG_SENSE0_Msk & ((value) << EIC_CONFIG_SENSE0_Pos))
#define EIC_CONFIG_SENSE0_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE0_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE0_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE0_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE0_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE0_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE0_NONE (EIC_CONFIG_SENSE0_NONE_Val << EIC_CONFIG_SENSE0_Pos)
#define EIC_CONFIG_SENSE0_RISE (EIC_CONFIG_SENSE0_RISE_Val << EIC_CONFIG_SENSE0_Pos)
#define EIC_CONFIG_SENSE0_FALL (EIC_CONFIG_SENSE0_FALL_Val << EIC_CONFIG_SENSE0_Pos)
#define EIC_CONFIG_SENSE0_BOTH (EIC_CONFIG_SENSE0_BOTH_Val << EIC_CONFIG_SENSE0_Pos)
#define EIC_CONFIG_SENSE0_HIGH (EIC_CONFIG_SENSE0_HIGH_Val << EIC_CONFIG_SENSE0_Pos)
#define EIC_CONFIG_SENSE0_LOW (EIC_CONFIG_SENSE0_LOW_Val << EIC_CONFIG_SENSE0_Pos)
#define EIC_CONFIG_FILTEN0_Pos 3
#define EIC_CONFIG_FILTEN0 (_U_(0x1) << EIC_CONFIG_FILTEN0_Pos)
#define EIC_CONFIG_SENSE1_Pos 4
#define EIC_CONFIG_SENSE1_Msk (_U_(0x7) << EIC_CONFIG_SENSE1_Pos)
#define EIC_CONFIG_SENSE1(value) (EIC_CONFIG_SENSE1_Msk & ((value) << EIC_CONFIG_SENSE1_Pos))
#define EIC_CONFIG_SENSE1_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE1_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE1_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE1_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE1_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE1_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE1_NONE (EIC_CONFIG_SENSE1_NONE_Val << EIC_CONFIG_SENSE1_Pos)
#define EIC_CONFIG_SENSE1_RISE (EIC_CONFIG_SENSE1_RISE_Val << EIC_CONFIG_SENSE1_Pos)
#define EIC_CONFIG_SENSE1_FALL (EIC_CONFIG_SENSE1_FALL_Val << EIC_CONFIG_SENSE1_Pos)
#define EIC_CONFIG_SENSE1_BOTH (EIC_CONFIG_SENSE1_BOTH_Val << EIC_CONFIG_SENSE1_Pos)
#define EIC_CONFIG_SENSE1_HIGH (EIC_CONFIG_SENSE1_HIGH_Val << EIC_CONFIG_SENSE1_Pos)
#define EIC_CONFIG_SENSE1_LOW (EIC_CONFIG_SENSE1_LOW_Val << EIC_CONFIG_SENSE1_Pos)
#define EIC_CONFIG_FILTEN1_Pos 7
#define EIC_CONFIG_FILTEN1 (_U_(0x1) << EIC_CONFIG_FILTEN1_Pos)
#define EIC_CONFIG_SENSE2_Pos 8
#define EIC_CONFIG_SENSE2_Msk (_U_(0x7) << EIC_CONFIG_SENSE2_Pos)
#define EIC_CONFIG_SENSE2(value) (EIC_CONFIG_SENSE2_Msk & ((value) << EIC_CONFIG_SENSE2_Pos))
#define EIC_CONFIG_SENSE2_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE2_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE2_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE2_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE2_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE2_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE2_NONE (EIC_CONFIG_SENSE2_NONE_Val << EIC_CONFIG_SENSE2_Pos)
#define EIC_CONFIG_SENSE2_RISE (EIC_CONFIG_SENSE2_RISE_Val << EIC_CONFIG_SENSE2_Pos)
#define EIC_CONFIG_SENSE2_FALL (EIC_CONFIG_SENSE2_FALL_Val << EIC_CONFIG_SENSE2_Pos)
#define EIC_CONFIG_SENSE2_BOTH (EIC_CONFIG_SENSE2_BOTH_Val << EIC_CONFIG_SENSE2_Pos)
#define EIC_CONFIG_SENSE2_HIGH (EIC_CONFIG_SENSE2_HIGH_Val << EIC_CONFIG_SENSE2_Pos)
#define EIC_CONFIG_SENSE2_LOW (EIC_CONFIG_SENSE2_LOW_Val << EIC_CONFIG_SENSE2_Pos)
#define EIC_CONFIG_FILTEN2_Pos 11
#define EIC_CONFIG_FILTEN2 (_U_(0x1) << EIC_CONFIG_FILTEN2_Pos)
#define EIC_CONFIG_SENSE3_Pos 12
#define EIC_CONFIG_SENSE3_Msk (_U_(0x7) << EIC_CONFIG_SENSE3_Pos)
#define EIC_CONFIG_SENSE3(value) (EIC_CONFIG_SENSE3_Msk & ((value) << EIC_CONFIG_SENSE3_Pos))
#define EIC_CONFIG_SENSE3_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE3_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE3_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE3_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE3_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE3_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE3_NONE (EIC_CONFIG_SENSE3_NONE_Val << EIC_CONFIG_SENSE3_Pos)
#define EIC_CONFIG_SENSE3_RISE (EIC_CONFIG_SENSE3_RISE_Val << EIC_CONFIG_SENSE3_Pos)
#define EIC_CONFIG_SENSE3_FALL (EIC_CONFIG_SENSE3_FALL_Val << EIC_CONFIG_SENSE3_Pos)
#define EIC_CONFIG_SENSE3_BOTH (EIC_CONFIG_SENSE3_BOTH_Val << EIC_CONFIG_SENSE3_Pos)
#define EIC_CONFIG_SENSE3_HIGH (EIC_CONFIG_SENSE3_HIGH_Val << EIC_CONFIG_SENSE3_Pos)
#define EIC_CONFIG_SENSE3_LOW (EIC_CONFIG_SENSE3_LOW_Val << EIC_CONFIG_SENSE3_Pos)
#define EIC_CONFIG_FILTEN3_Pos 15
#define EIC_CONFIG_FILTEN3 (_U_(0x1) << EIC_CONFIG_FILTEN3_Pos)
#define EIC_CONFIG_SENSE4_Pos 16
#define EIC_CONFIG_SENSE4_Msk (_U_(0x7) << EIC_CONFIG_SENSE4_Pos)
#define EIC_CONFIG_SENSE4(value) (EIC_CONFIG_SENSE4_Msk & ((value) << EIC_CONFIG_SENSE4_Pos))
#define EIC_CONFIG_SENSE4_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE4_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE4_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE4_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE4_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE4_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE4_NONE (EIC_CONFIG_SENSE4_NONE_Val << EIC_CONFIG_SENSE4_Pos)
#define EIC_CONFIG_SENSE4_RISE (EIC_CONFIG_SENSE4_RISE_Val << EIC_CONFIG_SENSE4_Pos)
#define EIC_CONFIG_SENSE4_FALL (EIC_CONFIG_SENSE4_FALL_Val << EIC_CONFIG_SENSE4_Pos)
#define EIC_CONFIG_SENSE4_BOTH (EIC_CONFIG_SENSE4_BOTH_Val << EIC_CONFIG_SENSE4_Pos)
#define EIC_CONFIG_SENSE4_HIGH (EIC_CONFIG_SENSE4_HIGH_Val << EIC_CONFIG_SENSE4_Pos)
#define EIC_CONFIG_SENSE4_LOW (EIC_CONFIG_SENSE4_LOW_Val << EIC_CONFIG_SENSE4_Pos)
#define EIC_CONFIG_FILTEN4_Pos 19
#define EIC_CONFIG_FILTEN4 (_U_(0x1) << EIC_CONFIG_FILTEN4_Pos)
#define EIC_CONFIG_SENSE5_Pos 20
#define EIC_CONFIG_SENSE5_Msk (_U_(0x7) << EIC_CONFIG_SENSE5_Pos)
#define EIC_CONFIG_SENSE5(value) (EIC_CONFIG_SENSE5_Msk & ((value) << EIC_CONFIG_SENSE5_Pos))
#define EIC_CONFIG_SENSE5_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE5_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE5_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE5_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE5_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE5_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE5_NONE (EIC_CONFIG_SENSE5_NONE_Val << EIC_CONFIG_SENSE5_Pos)
#define EIC_CONFIG_SENSE5_RISE (EIC_CONFIG_SENSE5_RISE_Val << EIC_CONFIG_SENSE5_Pos)
#define EIC_CONFIG_SENSE5_FALL (EIC_CONFIG_SENSE5_FALL_Val << EIC_CONFIG_SENSE5_Pos)
#define EIC_CONFIG_SENSE5_BOTH (EIC_CONFIG_SENSE5_BOTH_Val << EIC_CONFIG_SENSE5_Pos)
#define EIC_CONFIG_SENSE5_HIGH (EIC_CONFIG_SENSE5_HIGH_Val << EIC_CONFIG_SENSE5_Pos)
#define EIC_CONFIG_SENSE5_LOW (EIC_CONFIG_SENSE5_LOW_Val << EIC_CONFIG_SENSE5_Pos)
#define EIC_CONFIG_FILTEN5_Pos 23
#define EIC_CONFIG_FILTEN5 (_U_(0x1) << EIC_CONFIG_FILTEN5_Pos)
#define EIC_CONFIG_SENSE6_Pos 24
#define EIC_CONFIG_SENSE6_Msk (_U_(0x7) << EIC_CONFIG_SENSE6_Pos)
#define EIC_CONFIG_SENSE6(value) (EIC_CONFIG_SENSE6_Msk & ((value) << EIC_CONFIG_SENSE6_Pos))
#define EIC_CONFIG_SENSE6_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE6_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE6_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE6_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE6_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE6_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE6_NONE (EIC_CONFIG_SENSE6_NONE_Val << EIC_CONFIG_SENSE6_Pos)
#define EIC_CONFIG_SENSE6_RISE (EIC_CONFIG_SENSE6_RISE_Val << EIC_CONFIG_SENSE6_Pos)
#define EIC_CONFIG_SENSE6_FALL (EIC_CONFIG_SENSE6_FALL_Val << EIC_CONFIG_SENSE6_Pos)
#define EIC_CONFIG_SENSE6_BOTH (EIC_CONFIG_SENSE6_BOTH_Val << EIC_CONFIG_SENSE6_Pos)
#define EIC_CONFIG_SENSE6_HIGH (EIC_CONFIG_SENSE6_HIGH_Val << EIC_CONFIG_SENSE6_Pos)
#define EIC_CONFIG_SENSE6_LOW (EIC_CONFIG_SENSE6_LOW_Val << EIC_CONFIG_SENSE6_Pos)
#define EIC_CONFIG_FILTEN6_Pos 27
#define EIC_CONFIG_FILTEN6 (_U_(0x1) << EIC_CONFIG_FILTEN6_Pos)
#define EIC_CONFIG_SENSE7_Pos 28
#define EIC_CONFIG_SENSE7_Msk (_U_(0x7) << EIC_CONFIG_SENSE7_Pos)
#define EIC_CONFIG_SENSE7(value) (EIC_CONFIG_SENSE7_Msk & ((value) << EIC_CONFIG_SENSE7_Pos))
#define EIC_CONFIG_SENSE7_NONE_Val _U_(0x0)
#define EIC_CONFIG_SENSE7_RISE_Val _U_(0x1)
#define EIC_CONFIG_SENSE7_FALL_Val _U_(0x2)
#define EIC_CONFIG_SENSE7_BOTH_Val _U_(0x3)
#define EIC_CONFIG_SENSE7_HIGH_Val _U_(0x4)
#define EIC_CONFIG_SENSE7_LOW_Val _U_(0x5)
#define EIC_CONFIG_SENSE7_NONE (EIC_CONFIG_SENSE7_NONE_Val << EIC_CONFIG_SENSE7_Pos)
#define EIC_CONFIG_SENSE7_RISE (EIC_CONFIG_SENSE7_RISE_Val << EIC_CONFIG_SENSE7_Pos)
#define EIC_CONFIG_SENSE7_FALL (EIC_CONFIG_SENSE7_FALL_Val << EIC_CONFIG_SENSE7_Pos)
#define EIC_CONFIG_SENSE7_BOTH (EIC_CONFIG_SENSE7_BOTH_Val << EIC_CONFIG_SENSE7_Pos)
#define EIC_CONFIG_SENSE7_HIGH (EIC_CONFIG_SENSE7_HIGH_Val << EIC_CONFIG_SENSE7_Pos)
#define EIC_CONFIG_SENSE7_LOW (EIC_CONFIG_SENSE7_LOW_Val << EIC_CONFIG_SENSE7_Pos)
#define EIC_CONFIG_FILTEN7_Pos 31
#define EIC_CONFIG_FILTEN7 (_U_(0x1) << EIC_CONFIG_FILTEN7_Pos)
#define EIC_CONFIG_MASK _U_(0xFFFFFFFF)

/** \brief EIC hardware registers */

typedef struct {
  volatile EIC_CTRL_Type CTRL; /**< \brief Offset: 0x00 (R/W  8) Control */
  volatile const EIC_STATUS_Type STATUS; /**< \brief Offset: 0x01 (R/   8) Status */
  volatile EIC_NMICTRL_Type NMICTRL; /**< \brief Offset: 0x02 (R/W  8) Non-Maskable Interrupt Control */
  volatile EIC_NMIFLAG_Type NMIFLAG; /**< \brief Offset: 0x03 (R/W  8) Non-Maskable Interrupt Flag Status and Clear */
  volatile EIC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x04 (R/W 32) Event Control */
  volatile EIC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x08 (R/W 32) Interrupt Enable Clear */
  volatile EIC_INTENSET_Type INTENSET; /**< \brief Offset: 0x0C (R/W 32) Interrupt Enable Set */
  volatile EIC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x10 (R/W 32) Interrupt Flag Status and Clear */
  volatile EIC_WAKEUP_Type WAKEUP; /**< \brief Offset: 0x14 (R/W 32) Wake-Up Enable */
  volatile EIC_CONFIG_Type CONFIG[2]; /**< \brief Offset: 0x18 (R/W 32) Configuration n */
} Eic;


/*@}*/
# 250 "asf4/samd21/include/samd21e18a.h" 2
#include "component/evsys.h"
# 250 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/evsys.h" 1
/**
 * \file
 *
 * \brief Component description for EVSYS
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_EVSYS_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR EVSYS */
/* ========================================================================== */
/** \addtogroup SAMD21_EVSYS Event System Interface */
/*@{*/

#define EVSYS_U2208 
#define REV_EVSYS 0x101

/* -------- EVSYS_CTRL : (EVSYS Offset: 0x00) ( /W  8) Control -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t :3; /*!< bit:  1.. 3  Reserved                           */
    uint8_t GCLKREQ:1; /*!< bit:      4  Generic Clock Requests             */
    uint8_t :3; /*!< bit:  5.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} EVSYS_CTRL_Type;


#define EVSYS_CTRL_OFFSET 0x00
#define EVSYS_CTRL_RESETVALUE _U_(0x00)

#define EVSYS_CTRL_SWRST_Pos 0
#define EVSYS_CTRL_SWRST (_U_(0x1) << EVSYS_CTRL_SWRST_Pos)
#define EVSYS_CTRL_GCLKREQ_Pos 4
#define EVSYS_CTRL_GCLKREQ (_U_(0x1) << EVSYS_CTRL_GCLKREQ_Pos)
#define EVSYS_CTRL_MASK _U_(0x11)

/* -------- EVSYS_CHANNEL : (EVSYS Offset: 0x04) (R/W 32) Channel -------- */

typedef union {
  struct {
    uint32_t CHANNEL:4; /*!< bit:  0.. 3  Channel Selection                  */
    uint32_t :4; /*!< bit:  4.. 7  Reserved                           */
    uint32_t SWEVT:1; /*!< bit:      8  Software Event                     */
    uint32_t :7; /*!< bit:  9..15  Reserved                           */
    uint32_t EVGEN:7; /*!< bit: 16..22  Event Generator Selection          */
    uint32_t :1; /*!< bit:     23  Reserved                           */
    uint32_t PATH:2; /*!< bit: 24..25  Path Selection                     */
    uint32_t EDGSEL:2; /*!< bit: 26..27  Edge Detection Selection           */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EVSYS_CHANNEL_Type;


#define EVSYS_CHANNEL_OFFSET 0x04
#define EVSYS_CHANNEL_RESETVALUE _U_(0x00000000)

#define EVSYS_CHANNEL_CHANNEL_Pos 0
#define EVSYS_CHANNEL_CHANNEL_Msk (_U_(0xF) << EVSYS_CHANNEL_CHANNEL_Pos)
#define EVSYS_CHANNEL_CHANNEL(value) (EVSYS_CHANNEL_CHANNEL_Msk & ((value) << EVSYS_CHANNEL_CHANNEL_Pos))
#define EVSYS_CHANNEL_SWEVT_Pos 8
#define EVSYS_CHANNEL_SWEVT (_U_(0x1) << EVSYS_CHANNEL_SWEVT_Pos)
#define EVSYS_CHANNEL_EVGEN_Pos 16
#define EVSYS_CHANNEL_EVGEN_Msk (_U_(0x7F) << EVSYS_CHANNEL_EVGEN_Pos)
#define EVSYS_CHANNEL_EVGEN(value) (EVSYS_CHANNEL_EVGEN_Msk & ((value) << EVSYS_CHANNEL_EVGEN_Pos))
#define EVSYS_CHANNEL_PATH_Pos 24
#define EVSYS_CHANNEL_PATH_Msk (_U_(0x3) << EVSYS_CHANNEL_PATH_Pos)
#define EVSYS_CHANNEL_PATH(value) (EVSYS_CHANNEL_PATH_Msk & ((value) << EVSYS_CHANNEL_PATH_Pos))
#define EVSYS_CHANNEL_PATH_SYNCHRONOUS_Val _U_(0x0)
#define EVSYS_CHANNEL_PATH_RESYNCHRONIZED_Val _U_(0x1)
#define EVSYS_CHANNEL_PATH_ASYNCHRONOUS_Val _U_(0x2)
#define EVSYS_CHANNEL_PATH_SYNCHRONOUS (EVSYS_CHANNEL_PATH_SYNCHRONOUS_Val << EVSYS_CHANNEL_PATH_Pos)
#define EVSYS_CHANNEL_PATH_RESYNCHRONIZED (EVSYS_CHANNEL_PATH_RESYNCHRONIZED_Val << EVSYS_CHANNEL_PATH_Pos)
#define EVSYS_CHANNEL_PATH_ASYNCHRONOUS (EVSYS_CHANNEL_PATH_ASYNCHRONOUS_Val << EVSYS_CHANNEL_PATH_Pos)
#define EVSYS_CHANNEL_EDGSEL_Pos 26
#define EVSYS_CHANNEL_EDGSEL_Msk (_U_(0x3) << EVSYS_CHANNEL_EDGSEL_Pos)
#define EVSYS_CHANNEL_EDGSEL(value) (EVSYS_CHANNEL_EDGSEL_Msk & ((value) << EVSYS_CHANNEL_EDGSEL_Pos))
#define EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT_Val _U_(0x0)
#define EVSYS_CHANNEL_EDGSEL_RISING_EDGE_Val _U_(0x1)
#define EVSYS_CHANNEL_EDGSEL_FALLING_EDGE_Val _U_(0x2)
#define EVSYS_CHANNEL_EDGSEL_BOTH_EDGES_Val _U_(0x3)
#define EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT (EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT_Val << EVSYS_CHANNEL_EDGSEL_Pos)
#define EVSYS_CHANNEL_EDGSEL_RISING_EDGE (EVSYS_CHANNEL_EDGSEL_RISING_EDGE_Val << EVSYS_CHANNEL_EDGSEL_Pos)
#define EVSYS_CHANNEL_EDGSEL_FALLING_EDGE (EVSYS_CHANNEL_EDGSEL_FALLING_EDGE_Val << EVSYS_CHANNEL_EDGSEL_Pos)
#define EVSYS_CHANNEL_EDGSEL_BOTH_EDGES (EVSYS_CHANNEL_EDGSEL_BOTH_EDGES_Val << EVSYS_CHANNEL_EDGSEL_Pos)
#define EVSYS_CHANNEL_MASK _U_(0x0F7F010F)

/* -------- EVSYS_USER : (EVSYS Offset: 0x08) (R/W 16) User Multiplexer -------- */

typedef union {
  struct {
    uint16_t USER:5; /*!< bit:  0.. 4  User Multiplexer Selection         */
    uint16_t :3; /*!< bit:  5.. 7  Reserved                           */
    uint16_t CHANNEL:5; /*!< bit:  8..12  Channel Event Selection            */
    uint16_t :3; /*!< bit: 13..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} EVSYS_USER_Type;


#define EVSYS_USER_OFFSET 0x08
#define EVSYS_USER_RESETVALUE _U_(0x0000)

#define EVSYS_USER_USER_Pos 0
#define EVSYS_USER_USER_Msk (_U_(0x1F) << EVSYS_USER_USER_Pos)
#define EVSYS_USER_USER(value) (EVSYS_USER_USER_Msk & ((value) << EVSYS_USER_USER_Pos))
#define EVSYS_USER_CHANNEL_Pos 8
#define EVSYS_USER_CHANNEL_Msk (_U_(0x1F) << EVSYS_USER_CHANNEL_Pos)
#define EVSYS_USER_CHANNEL(value) (EVSYS_USER_CHANNEL_Msk & ((value) << EVSYS_USER_CHANNEL_Pos))
#define EVSYS_USER_CHANNEL_0_Val _U_(0x0)
#define EVSYS_USER_CHANNEL_0 (EVSYS_USER_CHANNEL_0_Val << EVSYS_USER_CHANNEL_Pos)
#define EVSYS_USER_MASK _U_(0x1F1F)

/* -------- EVSYS_CHSTATUS : (EVSYS Offset: 0x0C) (R/  32) Channel Status -------- */

typedef union {
  struct {
    uint32_t USRRDY0:1; /*!< bit:      0  Channel 0 User Ready               */
    uint32_t USRRDY1:1; /*!< bit:      1  Channel 1 User Ready               */
    uint32_t USRRDY2:1; /*!< bit:      2  Channel 2 User Ready               */
    uint32_t USRRDY3:1; /*!< bit:      3  Channel 3 User Ready               */
    uint32_t USRRDY4:1; /*!< bit:      4  Channel 4 User Ready               */
    uint32_t USRRDY5:1; /*!< bit:      5  Channel 5 User Ready               */
    uint32_t USRRDY6:1; /*!< bit:      6  Channel 6 User Ready               */
    uint32_t USRRDY7:1; /*!< bit:      7  Channel 7 User Ready               */
    uint32_t CHBUSY0:1; /*!< bit:      8  Channel 0 Busy                     */
    uint32_t CHBUSY1:1; /*!< bit:      9  Channel 1 Busy                     */
    uint32_t CHBUSY2:1; /*!< bit:     10  Channel 2 Busy                     */
    uint32_t CHBUSY3:1; /*!< bit:     11  Channel 3 Busy                     */
    uint32_t CHBUSY4:1; /*!< bit:     12  Channel 4 Busy                     */
    uint32_t CHBUSY5:1; /*!< bit:     13  Channel 5 Busy                     */
    uint32_t CHBUSY6:1; /*!< bit:     14  Channel 6 Busy                     */
    uint32_t CHBUSY7:1; /*!< bit:     15  Channel 7 Busy                     */
    uint32_t USRRDY8:1; /*!< bit:     16  Channel 8 User Ready               */
    uint32_t USRRDY9:1; /*!< bit:     17  Channel 9 User Ready               */
    uint32_t USRRDY10:1; /*!< bit:     18  Channel 10 User Ready              */
    uint32_t USRRDY11:1; /*!< bit:     19  Channel 11 User Ready              */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t CHBUSY8:1; /*!< bit:     24  Channel 8 Busy                     */
    uint32_t CHBUSY9:1; /*!< bit:     25  Channel 9 Busy                     */
    uint32_t CHBUSY10:1; /*!< bit:     26  Channel 10 Busy                    */
    uint32_t CHBUSY11:1; /*!< bit:     27  Channel 11 Busy                    */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t USRRDY:8; /*!< bit:  0.. 7  Channel x User Ready               */
    uint32_t CHBUSY:8; /*!< bit:  8..15  Channel x Busy                     */
    uint32_t USRRDYp8:4; /*!< bit: 16..19  Channel x+8 User Ready             */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t CHBUSYp8:4; /*!< bit: 24..27  Channel x+8 Busy                   */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EVSYS_CHSTATUS_Type;


#define EVSYS_CHSTATUS_OFFSET 0x0C
#define EVSYS_CHSTATUS_RESETVALUE _U_(0x000F00FF)

#define EVSYS_CHSTATUS_USRRDY0_Pos 0
#define EVSYS_CHSTATUS_USRRDY0 (_U_(1) << EVSYS_CHSTATUS_USRRDY0_Pos)
#define EVSYS_CHSTATUS_USRRDY1_Pos 1
#define EVSYS_CHSTATUS_USRRDY1 (_U_(1) << EVSYS_CHSTATUS_USRRDY1_Pos)
#define EVSYS_CHSTATUS_USRRDY2_Pos 2
#define EVSYS_CHSTATUS_USRRDY2 (_U_(1) << EVSYS_CHSTATUS_USRRDY2_Pos)
#define EVSYS_CHSTATUS_USRRDY3_Pos 3
#define EVSYS_CHSTATUS_USRRDY3 (_U_(1) << EVSYS_CHSTATUS_USRRDY3_Pos)
#define EVSYS_CHSTATUS_USRRDY4_Pos 4
#define EVSYS_CHSTATUS_USRRDY4 (_U_(1) << EVSYS_CHSTATUS_USRRDY4_Pos)
#define EVSYS_CHSTATUS_USRRDY5_Pos 5
#define EVSYS_CHSTATUS_USRRDY5 (_U_(1) << EVSYS_CHSTATUS_USRRDY5_Pos)
#define EVSYS_CHSTATUS_USRRDY6_Pos 6
#define EVSYS_CHSTATUS_USRRDY6 (_U_(1) << EVSYS_CHSTATUS_USRRDY6_Pos)
#define EVSYS_CHSTATUS_USRRDY7_Pos 7
#define EVSYS_CHSTATUS_USRRDY7 (_U_(1) << EVSYS_CHSTATUS_USRRDY7_Pos)
#define EVSYS_CHSTATUS_USRRDY_Pos 0
#define EVSYS_CHSTATUS_USRRDY_Msk (_U_(0xFF) << EVSYS_CHSTATUS_USRRDY_Pos)
#define EVSYS_CHSTATUS_USRRDY(value) (EVSYS_CHSTATUS_USRRDY_Msk & ((value) << EVSYS_CHSTATUS_USRRDY_Pos))
#define EVSYS_CHSTATUS_CHBUSY0_Pos 8
#define EVSYS_CHSTATUS_CHBUSY0 (_U_(1) << EVSYS_CHSTATUS_CHBUSY0_Pos)
#define EVSYS_CHSTATUS_CHBUSY1_Pos 9
#define EVSYS_CHSTATUS_CHBUSY1 (_U_(1) << EVSYS_CHSTATUS_CHBUSY1_Pos)
#define EVSYS_CHSTATUS_CHBUSY2_Pos 10
#define EVSYS_CHSTATUS_CHBUSY2 (_U_(1) << EVSYS_CHSTATUS_CHBUSY2_Pos)
#define EVSYS_CHSTATUS_CHBUSY3_Pos 11
#define EVSYS_CHSTATUS_CHBUSY3 (_U_(1) << EVSYS_CHSTATUS_CHBUSY3_Pos)
#define EVSYS_CHSTATUS_CHBUSY4_Pos 12
#define EVSYS_CHSTATUS_CHBUSY4 (_U_(1) << EVSYS_CHSTATUS_CHBUSY4_Pos)
#define EVSYS_CHSTATUS_CHBUSY5_Pos 13
#define EVSYS_CHSTATUS_CHBUSY5 (_U_(1) << EVSYS_CHSTATUS_CHBUSY5_Pos)
#define EVSYS_CHSTATUS_CHBUSY6_Pos 14
#define EVSYS_CHSTATUS_CHBUSY6 (_U_(1) << EVSYS_CHSTATUS_CHBUSY6_Pos)
#define EVSYS_CHSTATUS_CHBUSY7_Pos 15
#define EVSYS_CHSTATUS_CHBUSY7 (_U_(1) << EVSYS_CHSTATUS_CHBUSY7_Pos)
#define EVSYS_CHSTATUS_CHBUSY_Pos 8
#define EVSYS_CHSTATUS_CHBUSY_Msk (_U_(0xFF) << EVSYS_CHSTATUS_CHBUSY_Pos)
#define EVSYS_CHSTATUS_CHBUSY(value) (EVSYS_CHSTATUS_CHBUSY_Msk & ((value) << EVSYS_CHSTATUS_CHBUSY_Pos))
#define EVSYS_CHSTATUS_USRRDY8_Pos 16
#define EVSYS_CHSTATUS_USRRDY8 (_U_(1) << EVSYS_CHSTATUS_USRRDY8_Pos)
#define EVSYS_CHSTATUS_USRRDY9_Pos 17
#define EVSYS_CHSTATUS_USRRDY9 (_U_(1) << EVSYS_CHSTATUS_USRRDY9_Pos)
#define EVSYS_CHSTATUS_USRRDY10_Pos 18
#define EVSYS_CHSTATUS_USRRDY10 (_U_(1) << EVSYS_CHSTATUS_USRRDY10_Pos)
#define EVSYS_CHSTATUS_USRRDY11_Pos 19
#define EVSYS_CHSTATUS_USRRDY11 (_U_(1) << EVSYS_CHSTATUS_USRRDY11_Pos)
#define EVSYS_CHSTATUS_USRRDYp8_Pos 16
#define EVSYS_CHSTATUS_USRRDYp8_Msk (_U_(0xF) << EVSYS_CHSTATUS_USRRDYp8_Pos)
#define EVSYS_CHSTATUS_USRRDYp8(value) (EVSYS_CHSTATUS_USRRDYp8_Msk & ((value) << EVSYS_CHSTATUS_USRRDYp8_Pos))
#define EVSYS_CHSTATUS_CHBUSY8_Pos 24
#define EVSYS_CHSTATUS_CHBUSY8 (_U_(1) << EVSYS_CHSTATUS_CHBUSY8_Pos)
#define EVSYS_CHSTATUS_CHBUSY9_Pos 25
#define EVSYS_CHSTATUS_CHBUSY9 (_U_(1) << EVSYS_CHSTATUS_CHBUSY9_Pos)
#define EVSYS_CHSTATUS_CHBUSY10_Pos 26
#define EVSYS_CHSTATUS_CHBUSY10 (_U_(1) << EVSYS_CHSTATUS_CHBUSY10_Pos)
#define EVSYS_CHSTATUS_CHBUSY11_Pos 27
#define EVSYS_CHSTATUS_CHBUSY11 (_U_(1) << EVSYS_CHSTATUS_CHBUSY11_Pos)
#define EVSYS_CHSTATUS_CHBUSYp8_Pos 24
#define EVSYS_CHSTATUS_CHBUSYp8_Msk (_U_(0xF) << EVSYS_CHSTATUS_CHBUSYp8_Pos)
#define EVSYS_CHSTATUS_CHBUSYp8(value) (EVSYS_CHSTATUS_CHBUSYp8_Msk & ((value) << EVSYS_CHSTATUS_CHBUSYp8_Pos))
#define EVSYS_CHSTATUS_MASK _U_(0x0F0FFFFF)

/* -------- EVSYS_INTENCLR : (EVSYS Offset: 0x10) (R/W 32) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint32_t OVR0:1; /*!< bit:      0  Channel 0 Overrun Interrupt Enable */
    uint32_t OVR1:1; /*!< bit:      1  Channel 1 Overrun Interrupt Enable */
    uint32_t OVR2:1; /*!< bit:      2  Channel 2 Overrun Interrupt Enable */
    uint32_t OVR3:1; /*!< bit:      3  Channel 3 Overrun Interrupt Enable */
    uint32_t OVR4:1; /*!< bit:      4  Channel 4 Overrun Interrupt Enable */
    uint32_t OVR5:1; /*!< bit:      5  Channel 5 Overrun Interrupt Enable */
    uint32_t OVR6:1; /*!< bit:      6  Channel 6 Overrun Interrupt Enable */
    uint32_t OVR7:1; /*!< bit:      7  Channel 7 Overrun Interrupt Enable */
    uint32_t EVD0:1; /*!< bit:      8  Channel 0 Event Detection Interrupt Enable */
    uint32_t EVD1:1; /*!< bit:      9  Channel 1 Event Detection Interrupt Enable */
    uint32_t EVD2:1; /*!< bit:     10  Channel 2 Event Detection Interrupt Enable */
    uint32_t EVD3:1; /*!< bit:     11  Channel 3 Event Detection Interrupt Enable */
    uint32_t EVD4:1; /*!< bit:     12  Channel 4 Event Detection Interrupt Enable */
    uint32_t EVD5:1; /*!< bit:     13  Channel 5 Event Detection Interrupt Enable */
    uint32_t EVD6:1; /*!< bit:     14  Channel 6 Event Detection Interrupt Enable */
    uint32_t EVD7:1; /*!< bit:     15  Channel 7 Event Detection Interrupt Enable */
    uint32_t OVR8:1; /*!< bit:     16  Channel 8 Overrun Interrupt Enable */
    uint32_t OVR9:1; /*!< bit:     17  Channel 9 Overrun Interrupt Enable */
    uint32_t OVR10:1; /*!< bit:     18  Channel 10 Overrun Interrupt Enable */
    uint32_t OVR11:1; /*!< bit:     19  Channel 11 Overrun Interrupt Enable */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t EVD8:1; /*!< bit:     24  Channel 8 Event Detection Interrupt Enable */
    uint32_t EVD9:1; /*!< bit:     25  Channel 9 Event Detection Interrupt Enable */
    uint32_t EVD10:1; /*!< bit:     26  Channel 10 Event Detection Interrupt Enable */
    uint32_t EVD11:1; /*!< bit:     27  Channel 11 Event Detection Interrupt Enable */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t OVR:8; /*!< bit:  0.. 7  Channel x Overrun Interrupt Enable */
    uint32_t EVD:8; /*!< bit:  8..15  Channel x Event Detection Interrupt Enable */
    uint32_t OVRp8:4; /*!< bit: 16..19  Channel x+8 Overrun Interrupt Enable */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t EVDp8:4; /*!< bit: 24..27  Channel x+8 Event Detection Interrupt Enable */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EVSYS_INTENCLR_Type;


#define EVSYS_INTENCLR_OFFSET 0x10
#define EVSYS_INTENCLR_RESETVALUE _U_(0x00000000)

#define EVSYS_INTENCLR_OVR0_Pos 0
#define EVSYS_INTENCLR_OVR0 (_U_(1) << EVSYS_INTENCLR_OVR0_Pos)
#define EVSYS_INTENCLR_OVR1_Pos 1
#define EVSYS_INTENCLR_OVR1 (_U_(1) << EVSYS_INTENCLR_OVR1_Pos)
#define EVSYS_INTENCLR_OVR2_Pos 2
#define EVSYS_INTENCLR_OVR2 (_U_(1) << EVSYS_INTENCLR_OVR2_Pos)
#define EVSYS_INTENCLR_OVR3_Pos 3
#define EVSYS_INTENCLR_OVR3 (_U_(1) << EVSYS_INTENCLR_OVR3_Pos)
#define EVSYS_INTENCLR_OVR4_Pos 4
#define EVSYS_INTENCLR_OVR4 (_U_(1) << EVSYS_INTENCLR_OVR4_Pos)
#define EVSYS_INTENCLR_OVR5_Pos 5
#define EVSYS_INTENCLR_OVR5 (_U_(1) << EVSYS_INTENCLR_OVR5_Pos)
#define EVSYS_INTENCLR_OVR6_Pos 6
#define EVSYS_INTENCLR_OVR6 (_U_(1) << EVSYS_INTENCLR_OVR6_Pos)
#define EVSYS_INTENCLR_OVR7_Pos 7
#define EVSYS_INTENCLR_OVR7 (_U_(1) << EVSYS_INTENCLR_OVR7_Pos)
#define EVSYS_INTENCLR_OVR_Pos 0
#define EVSYS_INTENCLR_OVR_Msk (_U_(0xFF) << EVSYS_INTENCLR_OVR_Pos)
#define EVSYS_INTENCLR_OVR(value) (EVSYS_INTENCLR_OVR_Msk & ((value) << EVSYS_INTENCLR_OVR_Pos))
#define EVSYS_INTENCLR_EVD0_Pos 8
#define EVSYS_INTENCLR_EVD0 (_U_(1) << EVSYS_INTENCLR_EVD0_Pos)
#define EVSYS_INTENCLR_EVD1_Pos 9
#define EVSYS_INTENCLR_EVD1 (_U_(1) << EVSYS_INTENCLR_EVD1_Pos)
#define EVSYS_INTENCLR_EVD2_Pos 10
#define EVSYS_INTENCLR_EVD2 (_U_(1) << EVSYS_INTENCLR_EVD2_Pos)
#define EVSYS_INTENCLR_EVD3_Pos 11
#define EVSYS_INTENCLR_EVD3 (_U_(1) << EVSYS_INTENCLR_EVD3_Pos)
#define EVSYS_INTENCLR_EVD4_Pos 12
#define EVSYS_INTENCLR_EVD4 (_U_(1) << EVSYS_INTENCLR_EVD4_Pos)
#define EVSYS_INTENCLR_EVD5_Pos 13
#define EVSYS_INTENCLR_EVD5 (_U_(1) << EVSYS_INTENCLR_EVD5_Pos)
#define EVSYS_INTENCLR_EVD6_Pos 14
#define EVSYS_INTENCLR_EVD6 (_U_(1) << EVSYS_INTENCLR_EVD6_Pos)
#define EVSYS_INTENCLR_EVD7_Pos 15
#define EVSYS_INTENCLR_EVD7 (_U_(1) << EVSYS_INTENCLR_EVD7_Pos)
#define EVSYS_INTENCLR_EVD_Pos 8
#define EVSYS_INTENCLR_EVD_Msk (_U_(0xFF) << EVSYS_INTENCLR_EVD_Pos)
#define EVSYS_INTENCLR_EVD(value) (EVSYS_INTENCLR_EVD_Msk & ((value) << EVSYS_INTENCLR_EVD_Pos))
#define EVSYS_INTENCLR_OVR8_Pos 16
#define EVSYS_INTENCLR_OVR8 (_U_(1) << EVSYS_INTENCLR_OVR8_Pos)
#define EVSYS_INTENCLR_OVR9_Pos 17
#define EVSYS_INTENCLR_OVR9 (_U_(1) << EVSYS_INTENCLR_OVR9_Pos)
#define EVSYS_INTENCLR_OVR10_Pos 18
#define EVSYS_INTENCLR_OVR10 (_U_(1) << EVSYS_INTENCLR_OVR10_Pos)
#define EVSYS_INTENCLR_OVR11_Pos 19
#define EVSYS_INTENCLR_OVR11 (_U_(1) << EVSYS_INTENCLR_OVR11_Pos)
#define EVSYS_INTENCLR_OVRp8_Pos 16
#define EVSYS_INTENCLR_OVRp8_Msk (_U_(0xF) << EVSYS_INTENCLR_OVRp8_Pos)
#define EVSYS_INTENCLR_OVRp8(value) (EVSYS_INTENCLR_OVRp8_Msk & ((value) << EVSYS_INTENCLR_OVRp8_Pos))
#define EVSYS_INTENCLR_EVD8_Pos 24
#define EVSYS_INTENCLR_EVD8 (_U_(1) << EVSYS_INTENCLR_EVD8_Pos)
#define EVSYS_INTENCLR_EVD9_Pos 25
#define EVSYS_INTENCLR_EVD9 (_U_(1) << EVSYS_INTENCLR_EVD9_Pos)
#define EVSYS_INTENCLR_EVD10_Pos 26
#define EVSYS_INTENCLR_EVD10 (_U_(1) << EVSYS_INTENCLR_EVD10_Pos)
#define EVSYS_INTENCLR_EVD11_Pos 27
#define EVSYS_INTENCLR_EVD11 (_U_(1) << EVSYS_INTENCLR_EVD11_Pos)
#define EVSYS_INTENCLR_EVDp8_Pos 24
#define EVSYS_INTENCLR_EVDp8_Msk (_U_(0xF) << EVSYS_INTENCLR_EVDp8_Pos)
#define EVSYS_INTENCLR_EVDp8(value) (EVSYS_INTENCLR_EVDp8_Msk & ((value) << EVSYS_INTENCLR_EVDp8_Pos))
#define EVSYS_INTENCLR_MASK _U_(0x0F0FFFFF)

/* -------- EVSYS_INTENSET : (EVSYS Offset: 0x14) (R/W 32) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint32_t OVR0:1; /*!< bit:      0  Channel 0 Overrun Interrupt Enable */
    uint32_t OVR1:1; /*!< bit:      1  Channel 1 Overrun Interrupt Enable */
    uint32_t OVR2:1; /*!< bit:      2  Channel 2 Overrun Interrupt Enable */
    uint32_t OVR3:1; /*!< bit:      3  Channel 3 Overrun Interrupt Enable */
    uint32_t OVR4:1; /*!< bit:      4  Channel 4 Overrun Interrupt Enable */
    uint32_t OVR5:1; /*!< bit:      5  Channel 5 Overrun Interrupt Enable */
    uint32_t OVR6:1; /*!< bit:      6  Channel 6 Overrun Interrupt Enable */
    uint32_t OVR7:1; /*!< bit:      7  Channel 7 Overrun Interrupt Enable */
    uint32_t EVD0:1; /*!< bit:      8  Channel 0 Event Detection Interrupt Enable */
    uint32_t EVD1:1; /*!< bit:      9  Channel 1 Event Detection Interrupt Enable */
    uint32_t EVD2:1; /*!< bit:     10  Channel 2 Event Detection Interrupt Enable */
    uint32_t EVD3:1; /*!< bit:     11  Channel 3 Event Detection Interrupt Enable */
    uint32_t EVD4:1; /*!< bit:     12  Channel 4 Event Detection Interrupt Enable */
    uint32_t EVD5:1; /*!< bit:     13  Channel 5 Event Detection Interrupt Enable */
    uint32_t EVD6:1; /*!< bit:     14  Channel 6 Event Detection Interrupt Enable */
    uint32_t EVD7:1; /*!< bit:     15  Channel 7 Event Detection Interrupt Enable */
    uint32_t OVR8:1; /*!< bit:     16  Channel 8 Overrun Interrupt Enable */
    uint32_t OVR9:1; /*!< bit:     17  Channel 9 Overrun Interrupt Enable */
    uint32_t OVR10:1; /*!< bit:     18  Channel 10 Overrun Interrupt Enable */
    uint32_t OVR11:1; /*!< bit:     19  Channel 11 Overrun Interrupt Enable */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t EVD8:1; /*!< bit:     24  Channel 8 Event Detection Interrupt Enable */
    uint32_t EVD9:1; /*!< bit:     25  Channel 9 Event Detection Interrupt Enable */
    uint32_t EVD10:1; /*!< bit:     26  Channel 10 Event Detection Interrupt Enable */
    uint32_t EVD11:1; /*!< bit:     27  Channel 11 Event Detection Interrupt Enable */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t OVR:8; /*!< bit:  0.. 7  Channel x Overrun Interrupt Enable */
    uint32_t EVD:8; /*!< bit:  8..15  Channel x Event Detection Interrupt Enable */
    uint32_t OVRp8:4; /*!< bit: 16..19  Channel x+8 Overrun Interrupt Enable */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t EVDp8:4; /*!< bit: 24..27  Channel x+8 Event Detection Interrupt Enable */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EVSYS_INTENSET_Type;


#define EVSYS_INTENSET_OFFSET 0x14
#define EVSYS_INTENSET_RESETVALUE _U_(0x00000000)

#define EVSYS_INTENSET_OVR0_Pos 0
#define EVSYS_INTENSET_OVR0 (_U_(1) << EVSYS_INTENSET_OVR0_Pos)
#define EVSYS_INTENSET_OVR1_Pos 1
#define EVSYS_INTENSET_OVR1 (_U_(1) << EVSYS_INTENSET_OVR1_Pos)
#define EVSYS_INTENSET_OVR2_Pos 2
#define EVSYS_INTENSET_OVR2 (_U_(1) << EVSYS_INTENSET_OVR2_Pos)
#define EVSYS_INTENSET_OVR3_Pos 3
#define EVSYS_INTENSET_OVR3 (_U_(1) << EVSYS_INTENSET_OVR3_Pos)
#define EVSYS_INTENSET_OVR4_Pos 4
#define EVSYS_INTENSET_OVR4 (_U_(1) << EVSYS_INTENSET_OVR4_Pos)
#define EVSYS_INTENSET_OVR5_Pos 5
#define EVSYS_INTENSET_OVR5 (_U_(1) << EVSYS_INTENSET_OVR5_Pos)
#define EVSYS_INTENSET_OVR6_Pos 6
#define EVSYS_INTENSET_OVR6 (_U_(1) << EVSYS_INTENSET_OVR6_Pos)
#define EVSYS_INTENSET_OVR7_Pos 7
#define EVSYS_INTENSET_OVR7 (_U_(1) << EVSYS_INTENSET_OVR7_Pos)
#define EVSYS_INTENSET_OVR_Pos 0
#define EVSYS_INTENSET_OVR_Msk (_U_(0xFF) << EVSYS_INTENSET_OVR_Pos)
#define EVSYS_INTENSET_OVR(value) (EVSYS_INTENSET_OVR_Msk & ((value) << EVSYS_INTENSET_OVR_Pos))
#define EVSYS_INTENSET_EVD0_Pos 8
#define EVSYS_INTENSET_EVD0 (_U_(1) << EVSYS_INTENSET_EVD0_Pos)
#define EVSYS_INTENSET_EVD1_Pos 9
#define EVSYS_INTENSET_EVD1 (_U_(1) << EVSYS_INTENSET_EVD1_Pos)
#define EVSYS_INTENSET_EVD2_Pos 10
#define EVSYS_INTENSET_EVD2 (_U_(1) << EVSYS_INTENSET_EVD2_Pos)
#define EVSYS_INTENSET_EVD3_Pos 11
#define EVSYS_INTENSET_EVD3 (_U_(1) << EVSYS_INTENSET_EVD3_Pos)
#define EVSYS_INTENSET_EVD4_Pos 12
#define EVSYS_INTENSET_EVD4 (_U_(1) << EVSYS_INTENSET_EVD4_Pos)
#define EVSYS_INTENSET_EVD5_Pos 13
#define EVSYS_INTENSET_EVD5 (_U_(1) << EVSYS_INTENSET_EVD5_Pos)
#define EVSYS_INTENSET_EVD6_Pos 14
#define EVSYS_INTENSET_EVD6 (_U_(1) << EVSYS_INTENSET_EVD6_Pos)
#define EVSYS_INTENSET_EVD7_Pos 15
#define EVSYS_INTENSET_EVD7 (_U_(1) << EVSYS_INTENSET_EVD7_Pos)
#define EVSYS_INTENSET_EVD_Pos 8
#define EVSYS_INTENSET_EVD_Msk (_U_(0xFF) << EVSYS_INTENSET_EVD_Pos)
#define EVSYS_INTENSET_EVD(value) (EVSYS_INTENSET_EVD_Msk & ((value) << EVSYS_INTENSET_EVD_Pos))
#define EVSYS_INTENSET_OVR8_Pos 16
#define EVSYS_INTENSET_OVR8 (_U_(1) << EVSYS_INTENSET_OVR8_Pos)
#define EVSYS_INTENSET_OVR9_Pos 17
#define EVSYS_INTENSET_OVR9 (_U_(1) << EVSYS_INTENSET_OVR9_Pos)
#define EVSYS_INTENSET_OVR10_Pos 18
#define EVSYS_INTENSET_OVR10 (_U_(1) << EVSYS_INTENSET_OVR10_Pos)
#define EVSYS_INTENSET_OVR11_Pos 19
#define EVSYS_INTENSET_OVR11 (_U_(1) << EVSYS_INTENSET_OVR11_Pos)
#define EVSYS_INTENSET_OVRp8_Pos 16
#define EVSYS_INTENSET_OVRp8_Msk (_U_(0xF) << EVSYS_INTENSET_OVRp8_Pos)
#define EVSYS_INTENSET_OVRp8(value) (EVSYS_INTENSET_OVRp8_Msk & ((value) << EVSYS_INTENSET_OVRp8_Pos))
#define EVSYS_INTENSET_EVD8_Pos 24
#define EVSYS_INTENSET_EVD8 (_U_(1) << EVSYS_INTENSET_EVD8_Pos)
#define EVSYS_INTENSET_EVD9_Pos 25
#define EVSYS_INTENSET_EVD9 (_U_(1) << EVSYS_INTENSET_EVD9_Pos)
#define EVSYS_INTENSET_EVD10_Pos 26
#define EVSYS_INTENSET_EVD10 (_U_(1) << EVSYS_INTENSET_EVD10_Pos)
#define EVSYS_INTENSET_EVD11_Pos 27
#define EVSYS_INTENSET_EVD11 (_U_(1) << EVSYS_INTENSET_EVD11_Pos)
#define EVSYS_INTENSET_EVDp8_Pos 24
#define EVSYS_INTENSET_EVDp8_Msk (_U_(0xF) << EVSYS_INTENSET_EVDp8_Pos)
#define EVSYS_INTENSET_EVDp8(value) (EVSYS_INTENSET_EVDp8_Msk & ((value) << EVSYS_INTENSET_EVDp8_Pos))
#define EVSYS_INTENSET_MASK _U_(0x0F0FFFFF)

/* -------- EVSYS_INTFLAG : (EVSYS Offset: 0x18) (R/W 32) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint32_t OVR0:1; /*!< bit:      0  Channel 0 Overrun                  */
    volatile const uint32_t OVR1:1; /*!< bit:      1  Channel 1 Overrun                  */
    volatile const uint32_t OVR2:1; /*!< bit:      2  Channel 2 Overrun                  */
    volatile const uint32_t OVR3:1; /*!< bit:      3  Channel 3 Overrun                  */
    volatile const uint32_t OVR4:1; /*!< bit:      4  Channel 4 Overrun                  */
    volatile const uint32_t OVR5:1; /*!< bit:      5  Channel 5 Overrun                  */
    volatile const uint32_t OVR6:1; /*!< bit:      6  Channel 6 Overrun                  */
    volatile const uint32_t OVR7:1; /*!< bit:      7  Channel 7 Overrun                  */
    volatile const uint32_t EVD0:1; /*!< bit:      8  Channel 0 Event Detection          */
    volatile const uint32_t EVD1:1; /*!< bit:      9  Channel 1 Event Detection          */
    volatile const uint32_t EVD2:1; /*!< bit:     10  Channel 2 Event Detection          */
    volatile const uint32_t EVD3:1; /*!< bit:     11  Channel 3 Event Detection          */
    volatile const uint32_t EVD4:1; /*!< bit:     12  Channel 4 Event Detection          */
    volatile const uint32_t EVD5:1; /*!< bit:     13  Channel 5 Event Detection          */
    volatile const uint32_t EVD6:1; /*!< bit:     14  Channel 6 Event Detection          */
    volatile const uint32_t EVD7:1; /*!< bit:     15  Channel 7 Event Detection          */
    volatile const uint32_t OVR8:1; /*!< bit:     16  Channel 8 Overrun                  */
    volatile const uint32_t OVR9:1; /*!< bit:     17  Channel 9 Overrun                  */
    volatile const uint32_t OVR10:1; /*!< bit:     18  Channel 10 Overrun                 */
    volatile const uint32_t OVR11:1; /*!< bit:     19  Channel 11 Overrun                 */
    volatile const uint32_t :4; /*!< bit: 20..23  Reserved                           */
    volatile const uint32_t EVD8:1; /*!< bit:     24  Channel 8 Event Detection          */
    volatile const uint32_t EVD9:1; /*!< bit:     25  Channel 9 Event Detection          */
    volatile const uint32_t EVD10:1; /*!< bit:     26  Channel 10 Event Detection         */
    volatile const uint32_t EVD11:1; /*!< bit:     27  Channel 11 Event Detection         */
    volatile const uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint32_t OVR:8; /*!< bit:  0.. 7  Channel x Overrun                  */
    volatile const uint32_t EVD:8; /*!< bit:  8..15  Channel x Event Detection          */
    volatile const uint32_t OVRp8:4; /*!< bit: 16..19  Channel x+8 Overrun                */
    volatile const uint32_t :4; /*!< bit: 20..23  Reserved                           */
    volatile const uint32_t EVDp8:4; /*!< bit: 24..27  Channel x+8 Event Detection        */
    volatile const uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} EVSYS_INTFLAG_Type;


#define EVSYS_INTFLAG_OFFSET 0x18
#define EVSYS_INTFLAG_RESETVALUE _U_(0x00000000)

#define EVSYS_INTFLAG_OVR0_Pos 0
#define EVSYS_INTFLAG_OVR0 (_U_(1) << EVSYS_INTFLAG_OVR0_Pos)
#define EVSYS_INTFLAG_OVR1_Pos 1
#define EVSYS_INTFLAG_OVR1 (_U_(1) << EVSYS_INTFLAG_OVR1_Pos)
#define EVSYS_INTFLAG_OVR2_Pos 2
#define EVSYS_INTFLAG_OVR2 (_U_(1) << EVSYS_INTFLAG_OVR2_Pos)
#define EVSYS_INTFLAG_OVR3_Pos 3
#define EVSYS_INTFLAG_OVR3 (_U_(1) << EVSYS_INTFLAG_OVR3_Pos)
#define EVSYS_INTFLAG_OVR4_Pos 4
#define EVSYS_INTFLAG_OVR4 (_U_(1) << EVSYS_INTFLAG_OVR4_Pos)
#define EVSYS_INTFLAG_OVR5_Pos 5
#define EVSYS_INTFLAG_OVR5 (_U_(1) << EVSYS_INTFLAG_OVR5_Pos)
#define EVSYS_INTFLAG_OVR6_Pos 6
#define EVSYS_INTFLAG_OVR6 (_U_(1) << EVSYS_INTFLAG_OVR6_Pos)
#define EVSYS_INTFLAG_OVR7_Pos 7
#define EVSYS_INTFLAG_OVR7 (_U_(1) << EVSYS_INTFLAG_OVR7_Pos)
#define EVSYS_INTFLAG_OVR_Pos 0
#define EVSYS_INTFLAG_OVR_Msk (_U_(0xFF) << EVSYS_INTFLAG_OVR_Pos)
#define EVSYS_INTFLAG_OVR(value) (EVSYS_INTFLAG_OVR_Msk & ((value) << EVSYS_INTFLAG_OVR_Pos))
#define EVSYS_INTFLAG_EVD0_Pos 8
#define EVSYS_INTFLAG_EVD0 (_U_(1) << EVSYS_INTFLAG_EVD0_Pos)
#define EVSYS_INTFLAG_EVD1_Pos 9
#define EVSYS_INTFLAG_EVD1 (_U_(1) << EVSYS_INTFLAG_EVD1_Pos)
#define EVSYS_INTFLAG_EVD2_Pos 10
#define EVSYS_INTFLAG_EVD2 (_U_(1) << EVSYS_INTFLAG_EVD2_Pos)
#define EVSYS_INTFLAG_EVD3_Pos 11
#define EVSYS_INTFLAG_EVD3 (_U_(1) << EVSYS_INTFLAG_EVD3_Pos)
#define EVSYS_INTFLAG_EVD4_Pos 12
#define EVSYS_INTFLAG_EVD4 (_U_(1) << EVSYS_INTFLAG_EVD4_Pos)
#define EVSYS_INTFLAG_EVD5_Pos 13
#define EVSYS_INTFLAG_EVD5 (_U_(1) << EVSYS_INTFLAG_EVD5_Pos)
#define EVSYS_INTFLAG_EVD6_Pos 14
#define EVSYS_INTFLAG_EVD6 (_U_(1) << EVSYS_INTFLAG_EVD6_Pos)
#define EVSYS_INTFLAG_EVD7_Pos 15
#define EVSYS_INTFLAG_EVD7 (_U_(1) << EVSYS_INTFLAG_EVD7_Pos)
#define EVSYS_INTFLAG_EVD_Pos 8
#define EVSYS_INTFLAG_EVD_Msk (_U_(0xFF) << EVSYS_INTFLAG_EVD_Pos)
#define EVSYS_INTFLAG_EVD(value) (EVSYS_INTFLAG_EVD_Msk & ((value) << EVSYS_INTFLAG_EVD_Pos))
#define EVSYS_INTFLAG_OVR8_Pos 16
#define EVSYS_INTFLAG_OVR8 (_U_(1) << EVSYS_INTFLAG_OVR8_Pos)
#define EVSYS_INTFLAG_OVR9_Pos 17
#define EVSYS_INTFLAG_OVR9 (_U_(1) << EVSYS_INTFLAG_OVR9_Pos)
#define EVSYS_INTFLAG_OVR10_Pos 18
#define EVSYS_INTFLAG_OVR10 (_U_(1) << EVSYS_INTFLAG_OVR10_Pos)
#define EVSYS_INTFLAG_OVR11_Pos 19
#define EVSYS_INTFLAG_OVR11 (_U_(1) << EVSYS_INTFLAG_OVR11_Pos)
#define EVSYS_INTFLAG_OVRp8_Pos 16
#define EVSYS_INTFLAG_OVRp8_Msk (_U_(0xF) << EVSYS_INTFLAG_OVRp8_Pos)
#define EVSYS_INTFLAG_OVRp8(value) (EVSYS_INTFLAG_OVRp8_Msk & ((value) << EVSYS_INTFLAG_OVRp8_Pos))
#define EVSYS_INTFLAG_EVD8_Pos 24
#define EVSYS_INTFLAG_EVD8 (_U_(1) << EVSYS_INTFLAG_EVD8_Pos)
#define EVSYS_INTFLAG_EVD9_Pos 25
#define EVSYS_INTFLAG_EVD9 (_U_(1) << EVSYS_INTFLAG_EVD9_Pos)
#define EVSYS_INTFLAG_EVD10_Pos 26
#define EVSYS_INTFLAG_EVD10 (_U_(1) << EVSYS_INTFLAG_EVD10_Pos)
#define EVSYS_INTFLAG_EVD11_Pos 27
#define EVSYS_INTFLAG_EVD11 (_U_(1) << EVSYS_INTFLAG_EVD11_Pos)
#define EVSYS_INTFLAG_EVDp8_Pos 24
#define EVSYS_INTFLAG_EVDp8_Msk (_U_(0xF) << EVSYS_INTFLAG_EVDp8_Pos)
#define EVSYS_INTFLAG_EVDp8(value) (EVSYS_INTFLAG_EVDp8_Msk & ((value) << EVSYS_INTFLAG_EVDp8_Pos))
#define EVSYS_INTFLAG_MASK _U_(0x0F0FFFFF)

/** \brief EVSYS hardware registers */

typedef struct {
  volatile EVSYS_CTRL_Type CTRL; /**< \brief Offset: 0x00 ( /W  8) Control */
       RoReg8 Reserved1[0x3];
  volatile EVSYS_CHANNEL_Type CHANNEL; /**< \brief Offset: 0x04 (R/W 32) Channel */
  volatile EVSYS_USER_Type USER; /**< \brief Offset: 0x08 (R/W 16) User Multiplexer */
       RoReg8 Reserved2[0x2];
  volatile const EVSYS_CHSTATUS_Type CHSTATUS; /**< \brief Offset: 0x0C (R/  32) Channel Status */
  volatile EVSYS_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x10 (R/W 32) Interrupt Enable Clear */
  volatile EVSYS_INTENSET_Type INTENSET; /**< \brief Offset: 0x14 (R/W 32) Interrupt Enable Set */
  volatile EVSYS_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x18 (R/W 32) Interrupt Flag Status and Clear */
} Evsys;


/*@}*/
# 251 "asf4/samd21/include/samd21e18a.h" 2
#include "component/gclk.h"
# 251 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/gclk.h" 1
/**
 * \file
 *
 * \brief Component description for GCLK
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_GCLK_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR GCLK */
/* ========================================================================== */
/** \addtogroup SAMD21_GCLK Generic Clock Generator */
/*@{*/

#define GCLK_U2102 
#define REV_GCLK 0x210

/* -------- GCLK_CTRL : (GCLK Offset: 0x0) (R/W  8) Control -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} GCLK_CTRL_Type;


#define GCLK_CTRL_OFFSET 0x0
#define GCLK_CTRL_RESETVALUE _U_(0x00)

#define GCLK_CTRL_SWRST_Pos 0
#define GCLK_CTRL_SWRST (_U_(0x1) << GCLK_CTRL_SWRST_Pos)
#define GCLK_CTRL_MASK _U_(0x01)

/* -------- GCLK_STATUS : (GCLK Offset: 0x1) (R/   8) Status -------- */

typedef union {
  struct {
    uint8_t :7; /*!< bit:  0.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy Status        */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} GCLK_STATUS_Type;


#define GCLK_STATUS_OFFSET 0x1
#define GCLK_STATUS_RESETVALUE _U_(0x00)

#define GCLK_STATUS_SYNCBUSY_Pos 7
#define GCLK_STATUS_SYNCBUSY (_U_(0x1) << GCLK_STATUS_SYNCBUSY_Pos)
#define GCLK_STATUS_MASK _U_(0x80)

/* -------- GCLK_CLKCTRL : (GCLK Offset: 0x2) (R/W 16) Generic Clock Control -------- */

typedef union {
  struct {
    uint16_t ID:6; /*!< bit:  0.. 5  Generic Clock Selection ID         */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t GEN:4; /*!< bit:  8..11  Generic Clock Generator            */
    uint16_t :2; /*!< bit: 12..13  Reserved                           */
    uint16_t CLKEN:1; /*!< bit:     14  Clock Enable                       */
    uint16_t WRTLOCK:1; /*!< bit:     15  Write Lock                         */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} GCLK_CLKCTRL_Type;


#define GCLK_CLKCTRL_OFFSET 0x2
#define GCLK_CLKCTRL_RESETVALUE _U_(0x0000)

#define GCLK_CLKCTRL_ID_Pos 0
#define GCLK_CLKCTRL_ID_Msk (_U_(0x3F) << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID(value) (GCLK_CLKCTRL_ID_Msk & ((value) << GCLK_CLKCTRL_ID_Pos))
#define GCLK_CLKCTRL_ID_DFLL48_Val _U_(0x0)
#define GCLK_CLKCTRL_ID_FDPLL_Val _U_(0x1)
#define GCLK_CLKCTRL_ID_FDPLL32K_Val _U_(0x2)
#define GCLK_CLKCTRL_ID_WDT_Val _U_(0x3)
#define GCLK_CLKCTRL_ID_RTC_Val _U_(0x4)
#define GCLK_CLKCTRL_ID_EIC_Val _U_(0x5)
#define GCLK_CLKCTRL_ID_USB_Val _U_(0x6)
#define GCLK_CLKCTRL_ID_EVSYS_0_Val _U_(0x7)
#define GCLK_CLKCTRL_ID_EVSYS_1_Val _U_(0x8)
#define GCLK_CLKCTRL_ID_EVSYS_2_Val _U_(0x9)
#define GCLK_CLKCTRL_ID_EVSYS_3_Val _U_(0xA)
#define GCLK_CLKCTRL_ID_EVSYS_4_Val _U_(0xB)
#define GCLK_CLKCTRL_ID_EVSYS_5_Val _U_(0xC)
#define GCLK_CLKCTRL_ID_EVSYS_6_Val _U_(0xD)
#define GCLK_CLKCTRL_ID_EVSYS_7_Val _U_(0xE)
#define GCLK_CLKCTRL_ID_EVSYS_8_Val _U_(0xF)
#define GCLK_CLKCTRL_ID_EVSYS_9_Val _U_(0x10)
#define GCLK_CLKCTRL_ID_EVSYS_10_Val _U_(0x11)
#define GCLK_CLKCTRL_ID_EVSYS_11_Val _U_(0x12)
#define GCLK_CLKCTRL_ID_SERCOMX_SLOW_Val _U_(0x13)
#define GCLK_CLKCTRL_ID_SERCOM0_CORE_Val _U_(0x14)
#define GCLK_CLKCTRL_ID_SERCOM1_CORE_Val _U_(0x15)
#define GCLK_CLKCTRL_ID_SERCOM2_CORE_Val _U_(0x16)
#define GCLK_CLKCTRL_ID_SERCOM3_CORE_Val _U_(0x17)
#define GCLK_CLKCTRL_ID_SERCOM4_CORE_Val _U_(0x18)
#define GCLK_CLKCTRL_ID_SERCOM5_CORE_Val _U_(0x19)
#define GCLK_CLKCTRL_ID_TCC0_TCC1_Val _U_(0x1A)
#define GCLK_CLKCTRL_ID_TCC2_TC3_Val _U_(0x1B)
#define GCLK_CLKCTRL_ID_TC4_TC5_Val _U_(0x1C)
#define GCLK_CLKCTRL_ID_TC6_TC7_Val _U_(0x1D)
#define GCLK_CLKCTRL_ID_ADC_Val _U_(0x1E)
#define GCLK_CLKCTRL_ID_AC_DIG_Val _U_(0x1F)
#define GCLK_CLKCTRL_ID_AC_ANA_Val _U_(0x20)
#define GCLK_CLKCTRL_ID_DAC_Val _U_(0x21)
#define GCLK_CLKCTRL_ID_PTC_Val _U_(0x22)
#define GCLK_CLKCTRL_ID_I2S_0_Val _U_(0x23)
#define GCLK_CLKCTRL_ID_I2S_1_Val _U_(0x24)
#define GCLK_CLKCTRL_ID_DFLL48 (GCLK_CLKCTRL_ID_DFLL48_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_FDPLL (GCLK_CLKCTRL_ID_FDPLL_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_FDPLL32K (GCLK_CLKCTRL_ID_FDPLL32K_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_WDT (GCLK_CLKCTRL_ID_WDT_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_RTC (GCLK_CLKCTRL_ID_RTC_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EIC (GCLK_CLKCTRL_ID_EIC_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_USB (GCLK_CLKCTRL_ID_USB_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_0 (GCLK_CLKCTRL_ID_EVSYS_0_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_1 (GCLK_CLKCTRL_ID_EVSYS_1_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_2 (GCLK_CLKCTRL_ID_EVSYS_2_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_3 (GCLK_CLKCTRL_ID_EVSYS_3_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_4 (GCLK_CLKCTRL_ID_EVSYS_4_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_5 (GCLK_CLKCTRL_ID_EVSYS_5_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_6 (GCLK_CLKCTRL_ID_EVSYS_6_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_7 (GCLK_CLKCTRL_ID_EVSYS_7_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_8 (GCLK_CLKCTRL_ID_EVSYS_8_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_9 (GCLK_CLKCTRL_ID_EVSYS_9_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_10 (GCLK_CLKCTRL_ID_EVSYS_10_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_EVSYS_11 (GCLK_CLKCTRL_ID_EVSYS_11_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_SERCOMX_SLOW (GCLK_CLKCTRL_ID_SERCOMX_SLOW_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_SERCOM0_CORE (GCLK_CLKCTRL_ID_SERCOM0_CORE_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_SERCOM1_CORE (GCLK_CLKCTRL_ID_SERCOM1_CORE_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_SERCOM2_CORE (GCLK_CLKCTRL_ID_SERCOM2_CORE_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_SERCOM3_CORE (GCLK_CLKCTRL_ID_SERCOM3_CORE_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_SERCOM4_CORE (GCLK_CLKCTRL_ID_SERCOM4_CORE_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_SERCOM5_CORE (GCLK_CLKCTRL_ID_SERCOM5_CORE_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_TCC0_TCC1 (GCLK_CLKCTRL_ID_TCC0_TCC1_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_TCC2_TC3 (GCLK_CLKCTRL_ID_TCC2_TC3_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_TC4_TC5 (GCLK_CLKCTRL_ID_TC4_TC5_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_TC6_TC7 (GCLK_CLKCTRL_ID_TC6_TC7_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_ADC (GCLK_CLKCTRL_ID_ADC_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_AC_DIG (GCLK_CLKCTRL_ID_AC_DIG_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_AC_ANA (GCLK_CLKCTRL_ID_AC_ANA_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_DAC (GCLK_CLKCTRL_ID_DAC_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_PTC (GCLK_CLKCTRL_ID_PTC_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_I2S_0 (GCLK_CLKCTRL_ID_I2S_0_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_ID_I2S_1 (GCLK_CLKCTRL_ID_I2S_1_Val << GCLK_CLKCTRL_ID_Pos)
#define GCLK_CLKCTRL_GEN_Pos 8
#define GCLK_CLKCTRL_GEN_Msk (_U_(0xF) << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN(value) (GCLK_CLKCTRL_GEN_Msk & ((value) << GCLK_CLKCTRL_GEN_Pos))
#define GCLK_CLKCTRL_GEN_GCLK0_Val _U_(0x0)
#define GCLK_CLKCTRL_GEN_GCLK1_Val _U_(0x1)
#define GCLK_CLKCTRL_GEN_GCLK2_Val _U_(0x2)
#define GCLK_CLKCTRL_GEN_GCLK3_Val _U_(0x3)
#define GCLK_CLKCTRL_GEN_GCLK4_Val _U_(0x4)
#define GCLK_CLKCTRL_GEN_GCLK5_Val _U_(0x5)
#define GCLK_CLKCTRL_GEN_GCLK6_Val _U_(0x6)
#define GCLK_CLKCTRL_GEN_GCLK7_Val _U_(0x7)
#define GCLK_CLKCTRL_GEN_GCLK8_Val _U_(0x8)
#define GCLK_CLKCTRL_GEN_GCLK0 (GCLK_CLKCTRL_GEN_GCLK0_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK1 (GCLK_CLKCTRL_GEN_GCLK1_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK2 (GCLK_CLKCTRL_GEN_GCLK2_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK3 (GCLK_CLKCTRL_GEN_GCLK3_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK4 (GCLK_CLKCTRL_GEN_GCLK4_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK5 (GCLK_CLKCTRL_GEN_GCLK5_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK6 (GCLK_CLKCTRL_GEN_GCLK6_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK7 (GCLK_CLKCTRL_GEN_GCLK7_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_GEN_GCLK8 (GCLK_CLKCTRL_GEN_GCLK8_Val << GCLK_CLKCTRL_GEN_Pos)
#define GCLK_CLKCTRL_CLKEN_Pos 14
#define GCLK_CLKCTRL_CLKEN (_U_(0x1) << GCLK_CLKCTRL_CLKEN_Pos)
#define GCLK_CLKCTRL_WRTLOCK_Pos 15
#define GCLK_CLKCTRL_WRTLOCK (_U_(0x1) << GCLK_CLKCTRL_WRTLOCK_Pos)
#define GCLK_CLKCTRL_MASK _U_(0xCF3F)

/* -------- GCLK_GENCTRL : (GCLK Offset: 0x4) (R/W 32) Generic Clock Generator Control -------- */

typedef union {
  struct {
    uint32_t ID:4; /*!< bit:  0.. 3  Generic Clock Generator Selection  */
    uint32_t :4; /*!< bit:  4.. 7  Reserved                           */
    uint32_t SRC:5; /*!< bit:  8..12  Source Select                      */
    uint32_t :3; /*!< bit: 13..15  Reserved                           */
    uint32_t GENEN:1; /*!< bit:     16  Generic Clock Generator Enable     */
    uint32_t IDC:1; /*!< bit:     17  Improve Duty Cycle                 */
    uint32_t OOV:1; /*!< bit:     18  Output Off Value                   */
    uint32_t OE:1; /*!< bit:     19  Output Enable                      */
    uint32_t DIVSEL:1; /*!< bit:     20  Divide Selection                   */
    uint32_t RUNSTDBY:1; /*!< bit:     21  Run in Standby                     */
    uint32_t :10; /*!< bit: 22..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} GCLK_GENCTRL_Type;


#define GCLK_GENCTRL_OFFSET 0x4
#define GCLK_GENCTRL_RESETVALUE _U_(0x00000000)

#define GCLK_GENCTRL_ID_Pos 0
#define GCLK_GENCTRL_ID_Msk (_U_(0xF) << GCLK_GENCTRL_ID_Pos)
#define GCLK_GENCTRL_ID(value) (GCLK_GENCTRL_ID_Msk & ((value) << GCLK_GENCTRL_ID_Pos))
#define GCLK_GENCTRL_SRC_Pos 8
#define GCLK_GENCTRL_SRC_Msk (_U_(0x1F) << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC(value) (GCLK_GENCTRL_SRC_Msk & ((value) << GCLK_GENCTRL_SRC_Pos))
#define GCLK_GENCTRL_SRC_XOSC_Val _U_(0x0)
#define GCLK_GENCTRL_SRC_GCLKIN_Val _U_(0x1)
#define GCLK_GENCTRL_SRC_GCLKGEN1_Val _U_(0x2)
#define GCLK_GENCTRL_SRC_OSCULP32K_Val _U_(0x3)
#define GCLK_GENCTRL_SRC_OSC32K_Val _U_(0x4)
#define GCLK_GENCTRL_SRC_XOSC32K_Val _U_(0x5)
#define GCLK_GENCTRL_SRC_OSC8M_Val _U_(0x6)
#define GCLK_GENCTRL_SRC_DFLL48M_Val _U_(0x7)
#define GCLK_GENCTRL_SRC_DPLL96M_Val _U_(0x8)
#define GCLK_GENCTRL_SRC_XOSC (GCLK_GENCTRL_SRC_XOSC_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_GCLKIN (GCLK_GENCTRL_SRC_GCLKIN_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_GCLKGEN1 (GCLK_GENCTRL_SRC_GCLKGEN1_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_OSCULP32K (GCLK_GENCTRL_SRC_OSCULP32K_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_OSC32K (GCLK_GENCTRL_SRC_OSC32K_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_XOSC32K (GCLK_GENCTRL_SRC_XOSC32K_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_OSC8M (GCLK_GENCTRL_SRC_OSC8M_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_DFLL48M (GCLK_GENCTRL_SRC_DFLL48M_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_SRC_DPLL96M (GCLK_GENCTRL_SRC_DPLL96M_Val << GCLK_GENCTRL_SRC_Pos)
#define GCLK_GENCTRL_GENEN_Pos 16
#define GCLK_GENCTRL_GENEN (_U_(0x1) << GCLK_GENCTRL_GENEN_Pos)
#define GCLK_GENCTRL_IDC_Pos 17
#define GCLK_GENCTRL_IDC (_U_(0x1) << GCLK_GENCTRL_IDC_Pos)
#define GCLK_GENCTRL_OOV_Pos 18
#define GCLK_GENCTRL_OOV (_U_(0x1) << GCLK_GENCTRL_OOV_Pos)
#define GCLK_GENCTRL_OE_Pos 19
#define GCLK_GENCTRL_OE (_U_(0x1) << GCLK_GENCTRL_OE_Pos)
#define GCLK_GENCTRL_DIVSEL_Pos 20
#define GCLK_GENCTRL_DIVSEL (_U_(0x1) << GCLK_GENCTRL_DIVSEL_Pos)
#define GCLK_GENCTRL_RUNSTDBY_Pos 21
#define GCLK_GENCTRL_RUNSTDBY (_U_(0x1) << GCLK_GENCTRL_RUNSTDBY_Pos)
#define GCLK_GENCTRL_MASK _U_(0x003F1F0F)

/* -------- GCLK_GENDIV : (GCLK Offset: 0x8) (R/W 32) Generic Clock Generator Division -------- */

typedef union {
  struct {
    uint32_t ID:4; /*!< bit:  0.. 3  Generic Clock Generator Selection  */
    uint32_t :4; /*!< bit:  4.. 7  Reserved                           */
    uint32_t DIV:16; /*!< bit:  8..23  Division Factor                    */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} GCLK_GENDIV_Type;


#define GCLK_GENDIV_OFFSET 0x8
#define GCLK_GENDIV_RESETVALUE _U_(0x00000000)

#define GCLK_GENDIV_ID_Pos 0
#define GCLK_GENDIV_ID_Msk (_U_(0xF) << GCLK_GENDIV_ID_Pos)
#define GCLK_GENDIV_ID(value) (GCLK_GENDIV_ID_Msk & ((value) << GCLK_GENDIV_ID_Pos))
#define GCLK_GENDIV_DIV_Pos 8
#define GCLK_GENDIV_DIV_Msk (_U_(0xFFFF) << GCLK_GENDIV_DIV_Pos)
#define GCLK_GENDIV_DIV(value) (GCLK_GENDIV_DIV_Msk & ((value) << GCLK_GENDIV_DIV_Pos))
#define GCLK_GENDIV_MASK _U_(0x00FFFF0F)

/** \brief GCLK hardware registers */

typedef struct {
  volatile GCLK_CTRL_Type CTRL; /**< \brief Offset: 0x0 (R/W  8) Control */
  volatile const GCLK_STATUS_Type STATUS; /**< \brief Offset: 0x1 (R/   8) Status */
  volatile GCLK_CLKCTRL_Type CLKCTRL; /**< \brief Offset: 0x2 (R/W 16) Generic Clock Control */
  volatile GCLK_GENCTRL_Type GENCTRL; /**< \brief Offset: 0x4 (R/W 32) Generic Clock Generator Control */
  volatile GCLK_GENDIV_Type GENDIV; /**< \brief Offset: 0x8 (R/W 32) Generic Clock Generator Division */
} Gclk;


/*@}*/
# 252 "asf4/samd21/include/samd21e18a.h" 2
#include "component/hmatrixb.h"
# 252 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/hmatrixb.h" 1
/**
 * \file
 *
 * \brief Component description for HMATRIXB
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_HMATRIXB_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR HMATRIXB */
/* ========================================================================== */
/** \addtogroup SAMD21_HMATRIXB HSB Matrix */
/*@{*/

#define HMATRIXB_I7638 
#define REV_HMATRIXB 0x212

/* -------- HMATRIXB_PRAS : (HMATRIXB Offset: 0x080) (R/W 32) PRS Priority A for Slave -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} HMATRIXB_PRAS_Type;


#define HMATRIXB_PRAS_OFFSET 0x080
#define HMATRIXB_PRAS_RESETVALUE _U_(0x00000000)

#define HMATRIXB_PRAS_MASK _U_(0x00000000)

/* -------- HMATRIXB_PRBS : (HMATRIXB Offset: 0x084) (R/W 32) PRS Priority B for Slave -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} HMATRIXB_PRBS_Type;


#define HMATRIXB_PRBS_OFFSET 0x084
#define HMATRIXB_PRBS_RESETVALUE _U_(0x00000000)

#define HMATRIXB_PRBS_MASK _U_(0x00000000)

/* -------- HMATRIXB_SFR : (HMATRIXB Offset: 0x110) (R/W 32) Special Function -------- */

typedef union {
  struct {
    uint32_t SFR:32; /*!< bit:  0..31  Special Function Register          */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} HMATRIXB_SFR_Type;


#define HMATRIXB_SFR_OFFSET 0x110
#define HMATRIXB_SFR_RESETVALUE _U_(0x00000000)

#define HMATRIXB_SFR_SFR_Pos 0
#define HMATRIXB_SFR_SFR_Msk (_U_(0xFFFFFFFF) << HMATRIXB_SFR_SFR_Pos)
#define HMATRIXB_SFR_SFR(value) (HMATRIXB_SFR_SFR_Msk & ((value) << HMATRIXB_SFR_SFR_Pos))
#define HMATRIXB_SFR_MASK _U_(0xFFFFFFFF)

/** \brief HmatrixbPrs hardware registers */

typedef struct {
  volatile HMATRIXB_PRAS_Type PRAS; /**< \brief Offset: 0x000 (R/W 32) Priority A for Slave */
  volatile HMATRIXB_PRBS_Type PRBS; /**< \brief Offset: 0x004 (R/W 32) Priority B for Slave */
} HmatrixbPrs;


/** \brief HMATRIXB hardware registers */

typedef struct {
       RoReg8 Reserved1[0x80];
       HmatrixbPrs Prs[16]; /**< \brief Offset: 0x080 HmatrixbPrs groups */
       RoReg8 Reserved2[0x10];
  volatile HMATRIXB_SFR_Type SFR[16]; /**< \brief Offset: 0x110 (R/W 32) Special Function */
} Hmatrixb;


/*@}*/
# 253 "asf4/samd21/include/samd21e18a.h" 2
#include "component/i2s.h"
# 253 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/i2s.h" 1
/**
 * \file
 *
 * \brief Component description for I2S
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_I2S_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR I2S */
/* ========================================================================== */
/** \addtogroup SAMD21_I2S Inter-IC Sound Interface */
/*@{*/

#define I2S_U2224 
#define REV_I2S 0x102

/* -------- I2S_CTRLA : (I2S Offset: 0x00) (R/W  8) Control A -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint8_t CKEN0:1; /*!< bit:      2  Clock Unit 0 Enable                */
    uint8_t CKEN1:1; /*!< bit:      3  Clock Unit 1 Enable                */
    uint8_t SEREN0:1; /*!< bit:      4  Serializer 0 Enable                */
    uint8_t SEREN1:1; /*!< bit:      5  Serializer 1 Enable                */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint8_t CKEN:2; /*!< bit:  2.. 3  Clock Unit x Enable                */
    uint8_t SEREN:2; /*!< bit:  4.. 5  Serializer x Enable                */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} I2S_CTRLA_Type;


#define I2S_CTRLA_OFFSET 0x00
#define I2S_CTRLA_RESETVALUE _U_(0x00)

#define I2S_CTRLA_SWRST_Pos 0
#define I2S_CTRLA_SWRST (_U_(0x1) << I2S_CTRLA_SWRST_Pos)
#define I2S_CTRLA_ENABLE_Pos 1
#define I2S_CTRLA_ENABLE (_U_(0x1) << I2S_CTRLA_ENABLE_Pos)
#define I2S_CTRLA_CKEN0_Pos 2
#define I2S_CTRLA_CKEN0 (_U_(1) << I2S_CTRLA_CKEN0_Pos)
#define I2S_CTRLA_CKEN1_Pos 3
#define I2S_CTRLA_CKEN1 (_U_(1) << I2S_CTRLA_CKEN1_Pos)
#define I2S_CTRLA_CKEN_Pos 2
#define I2S_CTRLA_CKEN_Msk (_U_(0x3) << I2S_CTRLA_CKEN_Pos)
#define I2S_CTRLA_CKEN(value) (I2S_CTRLA_CKEN_Msk & ((value) << I2S_CTRLA_CKEN_Pos))
#define I2S_CTRLA_SEREN0_Pos 4
#define I2S_CTRLA_SEREN0 (_U_(1) << I2S_CTRLA_SEREN0_Pos)
#define I2S_CTRLA_SEREN1_Pos 5
#define I2S_CTRLA_SEREN1 (_U_(1) << I2S_CTRLA_SEREN1_Pos)
#define I2S_CTRLA_SEREN_Pos 4
#define I2S_CTRLA_SEREN_Msk (_U_(0x3) << I2S_CTRLA_SEREN_Pos)
#define I2S_CTRLA_SEREN(value) (I2S_CTRLA_SEREN_Msk & ((value) << I2S_CTRLA_SEREN_Pos))
#define I2S_CTRLA_MASK _U_(0x3F)

/* -------- I2S_CLKCTRL : (I2S Offset: 0x04) (R/W 32) Clock Unit n Control -------- */

typedef union {
  struct {
    uint32_t SLOTSIZE:2; /*!< bit:  0.. 1  Slot Size                          */
    uint32_t NBSLOTS:3; /*!< bit:  2.. 4  Number of Slots in Frame           */
    uint32_t FSWIDTH:2; /*!< bit:  5.. 6  Frame Sync Width                   */
    uint32_t BITDELAY:1; /*!< bit:      7  Data Delay from Frame Sync         */
    uint32_t FSSEL:1; /*!< bit:      8  Frame Sync Select                  */
    uint32_t :2; /*!< bit:  9..10  Reserved                           */
    uint32_t FSINV:1; /*!< bit:     11  Frame Sync Invert                  */
    uint32_t SCKSEL:1; /*!< bit:     12  Serial Clock Select                */
    uint32_t :3; /*!< bit: 13..15  Reserved                           */
    uint32_t MCKSEL:1; /*!< bit:     16  Master Clock Select                */
    uint32_t :1; /*!< bit:     17  Reserved                           */
    uint32_t MCKEN:1; /*!< bit:     18  Master Clock Enable                */
    uint32_t MCKDIV:5; /*!< bit: 19..23  Master Clock Division Factor       */
    uint32_t MCKOUTDIV:5; /*!< bit: 24..28  Master Clock Output Division Factor */
    uint32_t FSOUTINV:1; /*!< bit:     29  Frame Sync Output Invert           */
    uint32_t SCKOUTINV:1; /*!< bit:     30  Serial Clock Output Invert         */
    uint32_t MCKOUTINV:1; /*!< bit:     31  Master Clock Output Invert         */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} I2S_CLKCTRL_Type;


#define I2S_CLKCTRL_OFFSET 0x04
#define I2S_CLKCTRL_RESETVALUE _U_(0x00000000)

#define I2S_CLKCTRL_SLOTSIZE_Pos 0
#define I2S_CLKCTRL_SLOTSIZE_Msk (_U_(0x3) << I2S_CLKCTRL_SLOTSIZE_Pos)
#define I2S_CLKCTRL_SLOTSIZE(value) (I2S_CLKCTRL_SLOTSIZE_Msk & ((value) << I2S_CLKCTRL_SLOTSIZE_Pos))
#define I2S_CLKCTRL_SLOTSIZE_8_Val _U_(0x0)
#define I2S_CLKCTRL_SLOTSIZE_16_Val _U_(0x1)
#define I2S_CLKCTRL_SLOTSIZE_24_Val _U_(0x2)
#define I2S_CLKCTRL_SLOTSIZE_32_Val _U_(0x3)
#define I2S_CLKCTRL_SLOTSIZE_8 (I2S_CLKCTRL_SLOTSIZE_8_Val << I2S_CLKCTRL_SLOTSIZE_Pos)
#define I2S_CLKCTRL_SLOTSIZE_16 (I2S_CLKCTRL_SLOTSIZE_16_Val << I2S_CLKCTRL_SLOTSIZE_Pos)
#define I2S_CLKCTRL_SLOTSIZE_24 (I2S_CLKCTRL_SLOTSIZE_24_Val << I2S_CLKCTRL_SLOTSIZE_Pos)
#define I2S_CLKCTRL_SLOTSIZE_32 (I2S_CLKCTRL_SLOTSIZE_32_Val << I2S_CLKCTRL_SLOTSIZE_Pos)
#define I2S_CLKCTRL_NBSLOTS_Pos 2
#define I2S_CLKCTRL_NBSLOTS_Msk (_U_(0x7) << I2S_CLKCTRL_NBSLOTS_Pos)
#define I2S_CLKCTRL_NBSLOTS(value) (I2S_CLKCTRL_NBSLOTS_Msk & ((value) << I2S_CLKCTRL_NBSLOTS_Pos))
#define I2S_CLKCTRL_FSWIDTH_Pos 5
#define I2S_CLKCTRL_FSWIDTH_Msk (_U_(0x3) << I2S_CLKCTRL_FSWIDTH_Pos)
#define I2S_CLKCTRL_FSWIDTH(value) (I2S_CLKCTRL_FSWIDTH_Msk & ((value) << I2S_CLKCTRL_FSWIDTH_Pos))
#define I2S_CLKCTRL_FSWIDTH_SLOT_Val _U_(0x0)
#define I2S_CLKCTRL_FSWIDTH_HALF_Val _U_(0x1)
#define I2S_CLKCTRL_FSWIDTH_BIT_Val _U_(0x2)
#define I2S_CLKCTRL_FSWIDTH_BURST_Val _U_(0x3)
#define I2S_CLKCTRL_FSWIDTH_SLOT (I2S_CLKCTRL_FSWIDTH_SLOT_Val << I2S_CLKCTRL_FSWIDTH_Pos)
#define I2S_CLKCTRL_FSWIDTH_HALF (I2S_CLKCTRL_FSWIDTH_HALF_Val << I2S_CLKCTRL_FSWIDTH_Pos)
#define I2S_CLKCTRL_FSWIDTH_BIT (I2S_CLKCTRL_FSWIDTH_BIT_Val << I2S_CLKCTRL_FSWIDTH_Pos)
#define I2S_CLKCTRL_FSWIDTH_BURST (I2S_CLKCTRL_FSWIDTH_BURST_Val << I2S_CLKCTRL_FSWIDTH_Pos)
#define I2S_CLKCTRL_BITDELAY_Pos 7
#define I2S_CLKCTRL_BITDELAY (_U_(0x1) << I2S_CLKCTRL_BITDELAY_Pos)
#define I2S_CLKCTRL_BITDELAY_LJ_Val _U_(0x0)
#define I2S_CLKCTRL_BITDELAY_I2S_Val _U_(0x1)
#define I2S_CLKCTRL_BITDELAY_LJ (I2S_CLKCTRL_BITDELAY_LJ_Val << I2S_CLKCTRL_BITDELAY_Pos)
#define I2S_CLKCTRL_BITDELAY_I2S (I2S_CLKCTRL_BITDELAY_I2S_Val << I2S_CLKCTRL_BITDELAY_Pos)
#define I2S_CLKCTRL_FSSEL_Pos 8
#define I2S_CLKCTRL_FSSEL (_U_(0x1) << I2S_CLKCTRL_FSSEL_Pos)
#define I2S_CLKCTRL_FSSEL_SCKDIV_Val _U_(0x0)
#define I2S_CLKCTRL_FSSEL_FSPIN_Val _U_(0x1)
#define I2S_CLKCTRL_FSSEL_SCKDIV (I2S_CLKCTRL_FSSEL_SCKDIV_Val << I2S_CLKCTRL_FSSEL_Pos)
#define I2S_CLKCTRL_FSSEL_FSPIN (I2S_CLKCTRL_FSSEL_FSPIN_Val << I2S_CLKCTRL_FSSEL_Pos)
#define I2S_CLKCTRL_FSINV_Pos 11
#define I2S_CLKCTRL_FSINV (_U_(0x1) << I2S_CLKCTRL_FSINV_Pos)
#define I2S_CLKCTRL_SCKSEL_Pos 12
#define I2S_CLKCTRL_SCKSEL (_U_(0x1) << I2S_CLKCTRL_SCKSEL_Pos)
#define I2S_CLKCTRL_SCKSEL_MCKDIV_Val _U_(0x0)
#define I2S_CLKCTRL_SCKSEL_SCKPIN_Val _U_(0x1)
#define I2S_CLKCTRL_SCKSEL_MCKDIV (I2S_CLKCTRL_SCKSEL_MCKDIV_Val << I2S_CLKCTRL_SCKSEL_Pos)
#define I2S_CLKCTRL_SCKSEL_SCKPIN (I2S_CLKCTRL_SCKSEL_SCKPIN_Val << I2S_CLKCTRL_SCKSEL_Pos)
#define I2S_CLKCTRL_MCKSEL_Pos 16
#define I2S_CLKCTRL_MCKSEL (_U_(0x1) << I2S_CLKCTRL_MCKSEL_Pos)
#define I2S_CLKCTRL_MCKSEL_GCLK_Val _U_(0x0)
#define I2S_CLKCTRL_MCKSEL_MCKPIN_Val _U_(0x1)
#define I2S_CLKCTRL_MCKSEL_GCLK (I2S_CLKCTRL_MCKSEL_GCLK_Val << I2S_CLKCTRL_MCKSEL_Pos)
#define I2S_CLKCTRL_MCKSEL_MCKPIN (I2S_CLKCTRL_MCKSEL_MCKPIN_Val << I2S_CLKCTRL_MCKSEL_Pos)
#define I2S_CLKCTRL_MCKEN_Pos 18
#define I2S_CLKCTRL_MCKEN (_U_(0x1) << I2S_CLKCTRL_MCKEN_Pos)
#define I2S_CLKCTRL_MCKDIV_Pos 19
#define I2S_CLKCTRL_MCKDIV_Msk (_U_(0x1F) << I2S_CLKCTRL_MCKDIV_Pos)
#define I2S_CLKCTRL_MCKDIV(value) (I2S_CLKCTRL_MCKDIV_Msk & ((value) << I2S_CLKCTRL_MCKDIV_Pos))
#define I2S_CLKCTRL_MCKOUTDIV_Pos 24
#define I2S_CLKCTRL_MCKOUTDIV_Msk (_U_(0x1F) << I2S_CLKCTRL_MCKOUTDIV_Pos)
#define I2S_CLKCTRL_MCKOUTDIV(value) (I2S_CLKCTRL_MCKOUTDIV_Msk & ((value) << I2S_CLKCTRL_MCKOUTDIV_Pos))
#define I2S_CLKCTRL_FSOUTINV_Pos 29
#define I2S_CLKCTRL_FSOUTINV (_U_(0x1) << I2S_CLKCTRL_FSOUTINV_Pos)
#define I2S_CLKCTRL_SCKOUTINV_Pos 30
#define I2S_CLKCTRL_SCKOUTINV (_U_(0x1) << I2S_CLKCTRL_SCKOUTINV_Pos)
#define I2S_CLKCTRL_MCKOUTINV_Pos 31
#define I2S_CLKCTRL_MCKOUTINV (_U_(0x1) << I2S_CLKCTRL_MCKOUTINV_Pos)
#define I2S_CLKCTRL_MASK _U_(0xFFFD19FF)

/* -------- I2S_INTENCLR : (I2S Offset: 0x0C) (R/W 16) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint16_t RXRDY0:1; /*!< bit:      0  Receive Ready 0 Interrupt Enable   */
    uint16_t RXRDY1:1; /*!< bit:      1  Receive Ready 1 Interrupt Enable   */
    uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint16_t RXOR0:1; /*!< bit:      4  Receive Overrun 0 Interrupt Enable */
    uint16_t RXOR1:1; /*!< bit:      5  Receive Overrun 1 Interrupt Enable */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t TXRDY0:1; /*!< bit:      8  Transmit Ready 0 Interrupt Enable  */
    uint16_t TXRDY1:1; /*!< bit:      9  Transmit Ready 1 Interrupt Enable  */
    uint16_t :2; /*!< bit: 10..11  Reserved                           */
    uint16_t TXUR0:1; /*!< bit:     12  Transmit Underrun 0 Interrupt Enable */
    uint16_t TXUR1:1; /*!< bit:     13  Transmit Underrun 1 Interrupt Enable */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t RXRDY:2; /*!< bit:  0.. 1  Receive Ready x Interrupt Enable   */
    uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint16_t RXOR:2; /*!< bit:  4.. 5  Receive Overrun x Interrupt Enable */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t TXRDY:2; /*!< bit:  8.. 9  Transmit Ready x Interrupt Enable  */
    uint16_t :2; /*!< bit: 10..11  Reserved                           */
    uint16_t TXUR:2; /*!< bit: 12..13  Transmit Underrun x Interrupt Enable */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} I2S_INTENCLR_Type;


#define I2S_INTENCLR_OFFSET 0x0C
#define I2S_INTENCLR_RESETVALUE _U_(0x0000)

#define I2S_INTENCLR_RXRDY0_Pos 0
#define I2S_INTENCLR_RXRDY0 (_U_(1) << I2S_INTENCLR_RXRDY0_Pos)
#define I2S_INTENCLR_RXRDY1_Pos 1
#define I2S_INTENCLR_RXRDY1 (_U_(1) << I2S_INTENCLR_RXRDY1_Pos)
#define I2S_INTENCLR_RXRDY_Pos 0
#define I2S_INTENCLR_RXRDY_Msk (_U_(0x3) << I2S_INTENCLR_RXRDY_Pos)
#define I2S_INTENCLR_RXRDY(value) (I2S_INTENCLR_RXRDY_Msk & ((value) << I2S_INTENCLR_RXRDY_Pos))
#define I2S_INTENCLR_RXOR0_Pos 4
#define I2S_INTENCLR_RXOR0 (_U_(1) << I2S_INTENCLR_RXOR0_Pos)
#define I2S_INTENCLR_RXOR1_Pos 5
#define I2S_INTENCLR_RXOR1 (_U_(1) << I2S_INTENCLR_RXOR1_Pos)
#define I2S_INTENCLR_RXOR_Pos 4
#define I2S_INTENCLR_RXOR_Msk (_U_(0x3) << I2S_INTENCLR_RXOR_Pos)
#define I2S_INTENCLR_RXOR(value) (I2S_INTENCLR_RXOR_Msk & ((value) << I2S_INTENCLR_RXOR_Pos))
#define I2S_INTENCLR_TXRDY0_Pos 8
#define I2S_INTENCLR_TXRDY0 (_U_(1) << I2S_INTENCLR_TXRDY0_Pos)
#define I2S_INTENCLR_TXRDY1_Pos 9
#define I2S_INTENCLR_TXRDY1 (_U_(1) << I2S_INTENCLR_TXRDY1_Pos)
#define I2S_INTENCLR_TXRDY_Pos 8
#define I2S_INTENCLR_TXRDY_Msk (_U_(0x3) << I2S_INTENCLR_TXRDY_Pos)
#define I2S_INTENCLR_TXRDY(value) (I2S_INTENCLR_TXRDY_Msk & ((value) << I2S_INTENCLR_TXRDY_Pos))
#define I2S_INTENCLR_TXUR0_Pos 12
#define I2S_INTENCLR_TXUR0 (_U_(1) << I2S_INTENCLR_TXUR0_Pos)
#define I2S_INTENCLR_TXUR1_Pos 13
#define I2S_INTENCLR_TXUR1 (_U_(1) << I2S_INTENCLR_TXUR1_Pos)
#define I2S_INTENCLR_TXUR_Pos 12
#define I2S_INTENCLR_TXUR_Msk (_U_(0x3) << I2S_INTENCLR_TXUR_Pos)
#define I2S_INTENCLR_TXUR(value) (I2S_INTENCLR_TXUR_Msk & ((value) << I2S_INTENCLR_TXUR_Pos))
#define I2S_INTENCLR_MASK _U_(0x3333)

/* -------- I2S_INTENSET : (I2S Offset: 0x10) (R/W 16) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint16_t RXRDY0:1; /*!< bit:      0  Receive Ready 0 Interrupt Enable   */
    uint16_t RXRDY1:1; /*!< bit:      1  Receive Ready 1 Interrupt Enable   */
    uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint16_t RXOR0:1; /*!< bit:      4  Receive Overrun 0 Interrupt Enable */
    uint16_t RXOR1:1; /*!< bit:      5  Receive Overrun 1 Interrupt Enable */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t TXRDY0:1; /*!< bit:      8  Transmit Ready 0 Interrupt Enable  */
    uint16_t TXRDY1:1; /*!< bit:      9  Transmit Ready 1 Interrupt Enable  */
    uint16_t :2; /*!< bit: 10..11  Reserved                           */
    uint16_t TXUR0:1; /*!< bit:     12  Transmit Underrun 0 Interrupt Enable */
    uint16_t TXUR1:1; /*!< bit:     13  Transmit Underrun 1 Interrupt Enable */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t RXRDY:2; /*!< bit:  0.. 1  Receive Ready x Interrupt Enable   */
    uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint16_t RXOR:2; /*!< bit:  4.. 5  Receive Overrun x Interrupt Enable */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t TXRDY:2; /*!< bit:  8.. 9  Transmit Ready x Interrupt Enable  */
    uint16_t :2; /*!< bit: 10..11  Reserved                           */
    uint16_t TXUR:2; /*!< bit: 12..13  Transmit Underrun x Interrupt Enable */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} I2S_INTENSET_Type;


#define I2S_INTENSET_OFFSET 0x10
#define I2S_INTENSET_RESETVALUE _U_(0x0000)

#define I2S_INTENSET_RXRDY0_Pos 0
#define I2S_INTENSET_RXRDY0 (_U_(1) << I2S_INTENSET_RXRDY0_Pos)
#define I2S_INTENSET_RXRDY1_Pos 1
#define I2S_INTENSET_RXRDY1 (_U_(1) << I2S_INTENSET_RXRDY1_Pos)
#define I2S_INTENSET_RXRDY_Pos 0
#define I2S_INTENSET_RXRDY_Msk (_U_(0x3) << I2S_INTENSET_RXRDY_Pos)
#define I2S_INTENSET_RXRDY(value) (I2S_INTENSET_RXRDY_Msk & ((value) << I2S_INTENSET_RXRDY_Pos))
#define I2S_INTENSET_RXOR0_Pos 4
#define I2S_INTENSET_RXOR0 (_U_(1) << I2S_INTENSET_RXOR0_Pos)
#define I2S_INTENSET_RXOR1_Pos 5
#define I2S_INTENSET_RXOR1 (_U_(1) << I2S_INTENSET_RXOR1_Pos)
#define I2S_INTENSET_RXOR_Pos 4
#define I2S_INTENSET_RXOR_Msk (_U_(0x3) << I2S_INTENSET_RXOR_Pos)
#define I2S_INTENSET_RXOR(value) (I2S_INTENSET_RXOR_Msk & ((value) << I2S_INTENSET_RXOR_Pos))
#define I2S_INTENSET_TXRDY0_Pos 8
#define I2S_INTENSET_TXRDY0 (_U_(1) << I2S_INTENSET_TXRDY0_Pos)
#define I2S_INTENSET_TXRDY1_Pos 9
#define I2S_INTENSET_TXRDY1 (_U_(1) << I2S_INTENSET_TXRDY1_Pos)
#define I2S_INTENSET_TXRDY_Pos 8
#define I2S_INTENSET_TXRDY_Msk (_U_(0x3) << I2S_INTENSET_TXRDY_Pos)
#define I2S_INTENSET_TXRDY(value) (I2S_INTENSET_TXRDY_Msk & ((value) << I2S_INTENSET_TXRDY_Pos))
#define I2S_INTENSET_TXUR0_Pos 12
#define I2S_INTENSET_TXUR0 (_U_(1) << I2S_INTENSET_TXUR0_Pos)
#define I2S_INTENSET_TXUR1_Pos 13
#define I2S_INTENSET_TXUR1 (_U_(1) << I2S_INTENSET_TXUR1_Pos)
#define I2S_INTENSET_TXUR_Pos 12
#define I2S_INTENSET_TXUR_Msk (_U_(0x3) << I2S_INTENSET_TXUR_Pos)
#define I2S_INTENSET_TXUR(value) (I2S_INTENSET_TXUR_Msk & ((value) << I2S_INTENSET_TXUR_Pos))
#define I2S_INTENSET_MASK _U_(0x3333)

/* -------- I2S_INTFLAG : (I2S Offset: 0x14) (R/W 16) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint16_t RXRDY0:1; /*!< bit:      0  Receive Ready 0                    */
    volatile const uint16_t RXRDY1:1; /*!< bit:      1  Receive Ready 1                    */
    volatile const uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    volatile const uint16_t RXOR0:1; /*!< bit:      4  Receive Overrun 0                  */
    volatile const uint16_t RXOR1:1; /*!< bit:      5  Receive Overrun 1                  */
    volatile const uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    volatile const uint16_t TXRDY0:1; /*!< bit:      8  Transmit Ready 0                   */
    volatile const uint16_t TXRDY1:1; /*!< bit:      9  Transmit Ready 1                   */
    volatile const uint16_t :2; /*!< bit: 10..11  Reserved                           */
    volatile const uint16_t TXUR0:1; /*!< bit:     12  Transmit Underrun 0                */
    volatile const uint16_t TXUR1:1; /*!< bit:     13  Transmit Underrun 1                */
    volatile const uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint16_t RXRDY:2; /*!< bit:  0.. 1  Receive Ready x                    */
    volatile const uint16_t :2; /*!< bit:  2.. 3  Reserved                           */
    volatile const uint16_t RXOR:2; /*!< bit:  4.. 5  Receive Overrun x                  */
    volatile const uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    volatile const uint16_t TXRDY:2; /*!< bit:  8.. 9  Transmit Ready x                   */
    volatile const uint16_t :2; /*!< bit: 10..11  Reserved                           */
    volatile const uint16_t TXUR:2; /*!< bit: 12..13  Transmit Underrun x                */
    volatile const uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} I2S_INTFLAG_Type;


#define I2S_INTFLAG_OFFSET 0x14
#define I2S_INTFLAG_RESETVALUE _U_(0x0000)

#define I2S_INTFLAG_RXRDY0_Pos 0
#define I2S_INTFLAG_RXRDY0 (_U_(1) << I2S_INTFLAG_RXRDY0_Pos)
#define I2S_INTFLAG_RXRDY1_Pos 1
#define I2S_INTFLAG_RXRDY1 (_U_(1) << I2S_INTFLAG_RXRDY1_Pos)
#define I2S_INTFLAG_RXRDY_Pos 0
#define I2S_INTFLAG_RXRDY_Msk (_U_(0x3) << I2S_INTFLAG_RXRDY_Pos)
#define I2S_INTFLAG_RXRDY(value) (I2S_INTFLAG_RXRDY_Msk & ((value) << I2S_INTFLAG_RXRDY_Pos))
#define I2S_INTFLAG_RXOR0_Pos 4
#define I2S_INTFLAG_RXOR0 (_U_(1) << I2S_INTFLAG_RXOR0_Pos)
#define I2S_INTFLAG_RXOR1_Pos 5
#define I2S_INTFLAG_RXOR1 (_U_(1) << I2S_INTFLAG_RXOR1_Pos)
#define I2S_INTFLAG_RXOR_Pos 4
#define I2S_INTFLAG_RXOR_Msk (_U_(0x3) << I2S_INTFLAG_RXOR_Pos)
#define I2S_INTFLAG_RXOR(value) (I2S_INTFLAG_RXOR_Msk & ((value) << I2S_INTFLAG_RXOR_Pos))
#define I2S_INTFLAG_TXRDY0_Pos 8
#define I2S_INTFLAG_TXRDY0 (_U_(1) << I2S_INTFLAG_TXRDY0_Pos)
#define I2S_INTFLAG_TXRDY1_Pos 9
#define I2S_INTFLAG_TXRDY1 (_U_(1) << I2S_INTFLAG_TXRDY1_Pos)
#define I2S_INTFLAG_TXRDY_Pos 8
#define I2S_INTFLAG_TXRDY_Msk (_U_(0x3) << I2S_INTFLAG_TXRDY_Pos)
#define I2S_INTFLAG_TXRDY(value) (I2S_INTFLAG_TXRDY_Msk & ((value) << I2S_INTFLAG_TXRDY_Pos))
#define I2S_INTFLAG_TXUR0_Pos 12
#define I2S_INTFLAG_TXUR0 (_U_(1) << I2S_INTFLAG_TXUR0_Pos)
#define I2S_INTFLAG_TXUR1_Pos 13
#define I2S_INTFLAG_TXUR1 (_U_(1) << I2S_INTFLAG_TXUR1_Pos)
#define I2S_INTFLAG_TXUR_Pos 12
#define I2S_INTFLAG_TXUR_Msk (_U_(0x3) << I2S_INTFLAG_TXUR_Pos)
#define I2S_INTFLAG_TXUR(value) (I2S_INTFLAG_TXUR_Msk & ((value) << I2S_INTFLAG_TXUR_Pos))
#define I2S_INTFLAG_MASK _U_(0x3333)

/* -------- I2S_SYNCBUSY : (I2S Offset: 0x18) (R/  16) Synchronization Status -------- */

typedef union {
  struct {
    uint16_t SWRST:1; /*!< bit:      0  Software Reset Synchronization Status */
    uint16_t ENABLE:1; /*!< bit:      1  Enable Synchronization Status      */
    uint16_t CKEN0:1; /*!< bit:      2  Clock Unit 0 Enable Synchronization Status */
    uint16_t CKEN1:1; /*!< bit:      3  Clock Unit 1 Enable Synchronization Status */
    uint16_t SEREN0:1; /*!< bit:      4  Serializer 0 Enable Synchronization Status */
    uint16_t SEREN1:1; /*!< bit:      5  Serializer 1 Enable Synchronization Status */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t DATA0:1; /*!< bit:      8  Data 0 Synchronization Status      */
    uint16_t DATA1:1; /*!< bit:      9  Data 1 Synchronization Status      */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint16_t CKEN:2; /*!< bit:  2.. 3  Clock Unit x Enable Synchronization Status */
    uint16_t SEREN:2; /*!< bit:  4.. 5  Serializer x Enable Synchronization Status */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t DATA:2; /*!< bit:  8.. 9  Data x Synchronization Status      */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} I2S_SYNCBUSY_Type;


#define I2S_SYNCBUSY_OFFSET 0x18
#define I2S_SYNCBUSY_RESETVALUE _U_(0x0000)

#define I2S_SYNCBUSY_SWRST_Pos 0
#define I2S_SYNCBUSY_SWRST (_U_(0x1) << I2S_SYNCBUSY_SWRST_Pos)
#define I2S_SYNCBUSY_ENABLE_Pos 1
#define I2S_SYNCBUSY_ENABLE (_U_(0x1) << I2S_SYNCBUSY_ENABLE_Pos)
#define I2S_SYNCBUSY_CKEN0_Pos 2
#define I2S_SYNCBUSY_CKEN0 (_U_(1) << I2S_SYNCBUSY_CKEN0_Pos)
#define I2S_SYNCBUSY_CKEN1_Pos 3
#define I2S_SYNCBUSY_CKEN1 (_U_(1) << I2S_SYNCBUSY_CKEN1_Pos)
#define I2S_SYNCBUSY_CKEN_Pos 2
#define I2S_SYNCBUSY_CKEN_Msk (_U_(0x3) << I2S_SYNCBUSY_CKEN_Pos)
#define I2S_SYNCBUSY_CKEN(value) (I2S_SYNCBUSY_CKEN_Msk & ((value) << I2S_SYNCBUSY_CKEN_Pos))
#define I2S_SYNCBUSY_SEREN0_Pos 4
#define I2S_SYNCBUSY_SEREN0 (_U_(1) << I2S_SYNCBUSY_SEREN0_Pos)
#define I2S_SYNCBUSY_SEREN1_Pos 5
#define I2S_SYNCBUSY_SEREN1 (_U_(1) << I2S_SYNCBUSY_SEREN1_Pos)
#define I2S_SYNCBUSY_SEREN_Pos 4
#define I2S_SYNCBUSY_SEREN_Msk (_U_(0x3) << I2S_SYNCBUSY_SEREN_Pos)
#define I2S_SYNCBUSY_SEREN(value) (I2S_SYNCBUSY_SEREN_Msk & ((value) << I2S_SYNCBUSY_SEREN_Pos))
#define I2S_SYNCBUSY_DATA0_Pos 8
#define I2S_SYNCBUSY_DATA0 (_U_(1) << I2S_SYNCBUSY_DATA0_Pos)
#define I2S_SYNCBUSY_DATA1_Pos 9
#define I2S_SYNCBUSY_DATA1 (_U_(1) << I2S_SYNCBUSY_DATA1_Pos)
#define I2S_SYNCBUSY_DATA_Pos 8
#define I2S_SYNCBUSY_DATA_Msk (_U_(0x3) << I2S_SYNCBUSY_DATA_Pos)
#define I2S_SYNCBUSY_DATA(value) (I2S_SYNCBUSY_DATA_Msk & ((value) << I2S_SYNCBUSY_DATA_Pos))
#define I2S_SYNCBUSY_MASK _U_(0x033F)

/* -------- I2S_SERCTRL : (I2S Offset: 0x20) (R/W 32) Serializer n Control -------- */

typedef union {
  struct {
    uint32_t SERMODE:2; /*!< bit:  0.. 1  Serializer Mode                    */
    uint32_t TXDEFAULT:2; /*!< bit:  2.. 3  Line Default Line when Slot Disabled */
    uint32_t TXSAME:1; /*!< bit:      4  Transmit Data when Underrun        */
    uint32_t CLKSEL:1; /*!< bit:      5  Clock Unit Selection               */
    uint32_t :1; /*!< bit:      6  Reserved                           */
    uint32_t SLOTADJ:1; /*!< bit:      7  Data Slot Formatting Adjust        */
    uint32_t DATASIZE:3; /*!< bit:  8..10  Data Word Size                     */
    uint32_t :1; /*!< bit:     11  Reserved                           */
    uint32_t WORDADJ:1; /*!< bit:     12  Data Word Formatting Adjust        */
    uint32_t EXTEND:2; /*!< bit: 13..14  Data Formatting Bit Extension      */
    uint32_t BITREV:1; /*!< bit:     15  Data Formatting Bit Reverse        */
    uint32_t SLOTDIS0:1; /*!< bit:     16  Slot 0 Disabled for this Serializer */
    uint32_t SLOTDIS1:1; /*!< bit:     17  Slot 1 Disabled for this Serializer */
    uint32_t SLOTDIS2:1; /*!< bit:     18  Slot 2 Disabled for this Serializer */
    uint32_t SLOTDIS3:1; /*!< bit:     19  Slot 3 Disabled for this Serializer */
    uint32_t SLOTDIS4:1; /*!< bit:     20  Slot 4 Disabled for this Serializer */
    uint32_t SLOTDIS5:1; /*!< bit:     21  Slot 5 Disabled for this Serializer */
    uint32_t SLOTDIS6:1; /*!< bit:     22  Slot 6 Disabled for this Serializer */
    uint32_t SLOTDIS7:1; /*!< bit:     23  Slot 7 Disabled for this Serializer */
    uint32_t MONO:1; /*!< bit:     24  Mono Mode                          */
    uint32_t DMA:1; /*!< bit:     25  Single or Multiple DMA Channels    */
    uint32_t RXLOOP:1; /*!< bit:     26  Loop-back Test Mode                */
    uint32_t :5; /*!< bit: 27..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :16; /*!< bit:  0..15  Reserved                           */
    uint32_t SLOTDIS:8; /*!< bit: 16..23  Slot x Disabled for this Serializer */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} I2S_SERCTRL_Type;


#define I2S_SERCTRL_OFFSET 0x20
#define I2S_SERCTRL_RESETVALUE _U_(0x00000000)

#define I2S_SERCTRL_SERMODE_Pos 0
#define I2S_SERCTRL_SERMODE_Msk (_U_(0x3) << I2S_SERCTRL_SERMODE_Pos)
#define I2S_SERCTRL_SERMODE(value) (I2S_SERCTRL_SERMODE_Msk & ((value) << I2S_SERCTRL_SERMODE_Pos))
#define I2S_SERCTRL_SERMODE_RX_Val _U_(0x0)
#define I2S_SERCTRL_SERMODE_TX_Val _U_(0x1)
#define I2S_SERCTRL_SERMODE_PDM2_Val _U_(0x2)
#define I2S_SERCTRL_SERMODE_RX (I2S_SERCTRL_SERMODE_RX_Val << I2S_SERCTRL_SERMODE_Pos)
#define I2S_SERCTRL_SERMODE_TX (I2S_SERCTRL_SERMODE_TX_Val << I2S_SERCTRL_SERMODE_Pos)
#define I2S_SERCTRL_SERMODE_PDM2 (I2S_SERCTRL_SERMODE_PDM2_Val << I2S_SERCTRL_SERMODE_Pos)
#define I2S_SERCTRL_TXDEFAULT_Pos 2
#define I2S_SERCTRL_TXDEFAULT_Msk (_U_(0x3) << I2S_SERCTRL_TXDEFAULT_Pos)
#define I2S_SERCTRL_TXDEFAULT(value) (I2S_SERCTRL_TXDEFAULT_Msk & ((value) << I2S_SERCTRL_TXDEFAULT_Pos))
#define I2S_SERCTRL_TXDEFAULT_ZERO_Val _U_(0x0)
#define I2S_SERCTRL_TXDEFAULT_ONE_Val _U_(0x1)
#define I2S_SERCTRL_TXDEFAULT_HIZ_Val _U_(0x3)
#define I2S_SERCTRL_TXDEFAULT_ZERO (I2S_SERCTRL_TXDEFAULT_ZERO_Val << I2S_SERCTRL_TXDEFAULT_Pos)
#define I2S_SERCTRL_TXDEFAULT_ONE (I2S_SERCTRL_TXDEFAULT_ONE_Val << I2S_SERCTRL_TXDEFAULT_Pos)
#define I2S_SERCTRL_TXDEFAULT_HIZ (I2S_SERCTRL_TXDEFAULT_HIZ_Val << I2S_SERCTRL_TXDEFAULT_Pos)
#define I2S_SERCTRL_TXSAME_Pos 4
#define I2S_SERCTRL_TXSAME (_U_(0x1) << I2S_SERCTRL_TXSAME_Pos)
#define I2S_SERCTRL_TXSAME_ZERO_Val _U_(0x0)
#define I2S_SERCTRL_TXSAME_SAME_Val _U_(0x1)
#define I2S_SERCTRL_TXSAME_ZERO (I2S_SERCTRL_TXSAME_ZERO_Val << I2S_SERCTRL_TXSAME_Pos)
#define I2S_SERCTRL_TXSAME_SAME (I2S_SERCTRL_TXSAME_SAME_Val << I2S_SERCTRL_TXSAME_Pos)
#define I2S_SERCTRL_CLKSEL_Pos 5
#define I2S_SERCTRL_CLKSEL (_U_(0x1) << I2S_SERCTRL_CLKSEL_Pos)
#define I2S_SERCTRL_CLKSEL_CLK0_Val _U_(0x0)
#define I2S_SERCTRL_CLKSEL_CLK1_Val _U_(0x1)
#define I2S_SERCTRL_CLKSEL_CLK0 (I2S_SERCTRL_CLKSEL_CLK0_Val << I2S_SERCTRL_CLKSEL_Pos)
#define I2S_SERCTRL_CLKSEL_CLK1 (I2S_SERCTRL_CLKSEL_CLK1_Val << I2S_SERCTRL_CLKSEL_Pos)
#define I2S_SERCTRL_SLOTADJ_Pos 7
#define I2S_SERCTRL_SLOTADJ (_U_(0x1) << I2S_SERCTRL_SLOTADJ_Pos)
#define I2S_SERCTRL_SLOTADJ_RIGHT_Val _U_(0x0)
#define I2S_SERCTRL_SLOTADJ_LEFT_Val _U_(0x1)
#define I2S_SERCTRL_SLOTADJ_RIGHT (I2S_SERCTRL_SLOTADJ_RIGHT_Val << I2S_SERCTRL_SLOTADJ_Pos)
#define I2S_SERCTRL_SLOTADJ_LEFT (I2S_SERCTRL_SLOTADJ_LEFT_Val << I2S_SERCTRL_SLOTADJ_Pos)
#define I2S_SERCTRL_DATASIZE_Pos 8
#define I2S_SERCTRL_DATASIZE_Msk (_U_(0x7) << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE(value) (I2S_SERCTRL_DATASIZE_Msk & ((value) << I2S_SERCTRL_DATASIZE_Pos))
#define I2S_SERCTRL_DATASIZE_32_Val _U_(0x0)
#define I2S_SERCTRL_DATASIZE_24_Val _U_(0x1)
#define I2S_SERCTRL_DATASIZE_20_Val _U_(0x2)
#define I2S_SERCTRL_DATASIZE_18_Val _U_(0x3)
#define I2S_SERCTRL_DATASIZE_16_Val _U_(0x4)
#define I2S_SERCTRL_DATASIZE_16C_Val _U_(0x5)
#define I2S_SERCTRL_DATASIZE_8_Val _U_(0x6)
#define I2S_SERCTRL_DATASIZE_8C_Val _U_(0x7)
#define I2S_SERCTRL_DATASIZE_32 (I2S_SERCTRL_DATASIZE_32_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE_24 (I2S_SERCTRL_DATASIZE_24_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE_20 (I2S_SERCTRL_DATASIZE_20_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE_18 (I2S_SERCTRL_DATASIZE_18_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE_16 (I2S_SERCTRL_DATASIZE_16_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE_16C (I2S_SERCTRL_DATASIZE_16C_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE_8 (I2S_SERCTRL_DATASIZE_8_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_DATASIZE_8C (I2S_SERCTRL_DATASIZE_8C_Val << I2S_SERCTRL_DATASIZE_Pos)
#define I2S_SERCTRL_WORDADJ_Pos 12
#define I2S_SERCTRL_WORDADJ (_U_(0x1) << I2S_SERCTRL_WORDADJ_Pos)
#define I2S_SERCTRL_WORDADJ_RIGHT_Val _U_(0x0)
#define I2S_SERCTRL_WORDADJ_LEFT_Val _U_(0x1)
#define I2S_SERCTRL_WORDADJ_RIGHT (I2S_SERCTRL_WORDADJ_RIGHT_Val << I2S_SERCTRL_WORDADJ_Pos)
#define I2S_SERCTRL_WORDADJ_LEFT (I2S_SERCTRL_WORDADJ_LEFT_Val << I2S_SERCTRL_WORDADJ_Pos)
#define I2S_SERCTRL_EXTEND_Pos 13
#define I2S_SERCTRL_EXTEND_Msk (_U_(0x3) << I2S_SERCTRL_EXTEND_Pos)
#define I2S_SERCTRL_EXTEND(value) (I2S_SERCTRL_EXTEND_Msk & ((value) << I2S_SERCTRL_EXTEND_Pos))
#define I2S_SERCTRL_EXTEND_ZERO_Val _U_(0x0)
#define I2S_SERCTRL_EXTEND_ONE_Val _U_(0x1)
#define I2S_SERCTRL_EXTEND_MSBIT_Val _U_(0x2)
#define I2S_SERCTRL_EXTEND_LSBIT_Val _U_(0x3)
#define I2S_SERCTRL_EXTEND_ZERO (I2S_SERCTRL_EXTEND_ZERO_Val << I2S_SERCTRL_EXTEND_Pos)
#define I2S_SERCTRL_EXTEND_ONE (I2S_SERCTRL_EXTEND_ONE_Val << I2S_SERCTRL_EXTEND_Pos)
#define I2S_SERCTRL_EXTEND_MSBIT (I2S_SERCTRL_EXTEND_MSBIT_Val << I2S_SERCTRL_EXTEND_Pos)
#define I2S_SERCTRL_EXTEND_LSBIT (I2S_SERCTRL_EXTEND_LSBIT_Val << I2S_SERCTRL_EXTEND_Pos)
#define I2S_SERCTRL_BITREV_Pos 15
#define I2S_SERCTRL_BITREV (_U_(0x1) << I2S_SERCTRL_BITREV_Pos)
#define I2S_SERCTRL_BITREV_MSBIT_Val _U_(0x0)
#define I2S_SERCTRL_BITREV_LSBIT_Val _U_(0x1)
#define I2S_SERCTRL_BITREV_MSBIT (I2S_SERCTRL_BITREV_MSBIT_Val << I2S_SERCTRL_BITREV_Pos)
#define I2S_SERCTRL_BITREV_LSBIT (I2S_SERCTRL_BITREV_LSBIT_Val << I2S_SERCTRL_BITREV_Pos)
#define I2S_SERCTRL_SLOTDIS0_Pos 16
#define I2S_SERCTRL_SLOTDIS0 (_U_(1) << I2S_SERCTRL_SLOTDIS0_Pos)
#define I2S_SERCTRL_SLOTDIS1_Pos 17
#define I2S_SERCTRL_SLOTDIS1 (_U_(1) << I2S_SERCTRL_SLOTDIS1_Pos)
#define I2S_SERCTRL_SLOTDIS2_Pos 18
#define I2S_SERCTRL_SLOTDIS2 (_U_(1) << I2S_SERCTRL_SLOTDIS2_Pos)
#define I2S_SERCTRL_SLOTDIS3_Pos 19
#define I2S_SERCTRL_SLOTDIS3 (_U_(1) << I2S_SERCTRL_SLOTDIS3_Pos)
#define I2S_SERCTRL_SLOTDIS4_Pos 20
#define I2S_SERCTRL_SLOTDIS4 (_U_(1) << I2S_SERCTRL_SLOTDIS4_Pos)
#define I2S_SERCTRL_SLOTDIS5_Pos 21
#define I2S_SERCTRL_SLOTDIS5 (_U_(1) << I2S_SERCTRL_SLOTDIS5_Pos)
#define I2S_SERCTRL_SLOTDIS6_Pos 22
#define I2S_SERCTRL_SLOTDIS6 (_U_(1) << I2S_SERCTRL_SLOTDIS6_Pos)
#define I2S_SERCTRL_SLOTDIS7_Pos 23
#define I2S_SERCTRL_SLOTDIS7 (_U_(1) << I2S_SERCTRL_SLOTDIS7_Pos)
#define I2S_SERCTRL_SLOTDIS_Pos 16
#define I2S_SERCTRL_SLOTDIS_Msk (_U_(0xFF) << I2S_SERCTRL_SLOTDIS_Pos)
#define I2S_SERCTRL_SLOTDIS(value) (I2S_SERCTRL_SLOTDIS_Msk & ((value) << I2S_SERCTRL_SLOTDIS_Pos))
#define I2S_SERCTRL_MONO_Pos 24
#define I2S_SERCTRL_MONO (_U_(0x1) << I2S_SERCTRL_MONO_Pos)
#define I2S_SERCTRL_MONO_STEREO_Val _U_(0x0)
#define I2S_SERCTRL_MONO_MONO_Val _U_(0x1)
#define I2S_SERCTRL_MONO_STEREO (I2S_SERCTRL_MONO_STEREO_Val << I2S_SERCTRL_MONO_Pos)
#define I2S_SERCTRL_MONO_MONO (I2S_SERCTRL_MONO_MONO_Val << I2S_SERCTRL_MONO_Pos)
#define I2S_SERCTRL_DMA_Pos 25
#define I2S_SERCTRL_DMA (_U_(0x1) << I2S_SERCTRL_DMA_Pos)
#define I2S_SERCTRL_DMA_SINGLE_Val _U_(0x0)
#define I2S_SERCTRL_DMA_MULTIPLE_Val _U_(0x1)
#define I2S_SERCTRL_DMA_SINGLE (I2S_SERCTRL_DMA_SINGLE_Val << I2S_SERCTRL_DMA_Pos)
#define I2S_SERCTRL_DMA_MULTIPLE (I2S_SERCTRL_DMA_MULTIPLE_Val << I2S_SERCTRL_DMA_Pos)
#define I2S_SERCTRL_RXLOOP_Pos 26
#define I2S_SERCTRL_RXLOOP (_U_(0x1) << I2S_SERCTRL_RXLOOP_Pos)
#define I2S_SERCTRL_MASK _U_(0x07FFF7BF)

/* -------- I2S_DATA : (I2S Offset: 0x30) (R/W 32) Data n -------- */

typedef union {
  struct {
    uint32_t DATA:32; /*!< bit:  0..31  Sample Data                        */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} I2S_DATA_Type;


#define I2S_DATA_OFFSET 0x30
#define I2S_DATA_RESETVALUE _U_(0x00000000)

#define I2S_DATA_DATA_Pos 0
#define I2S_DATA_DATA_Msk (_U_(0xFFFFFFFF) << I2S_DATA_DATA_Pos)
#define I2S_DATA_DATA(value) (I2S_DATA_DATA_Msk & ((value) << I2S_DATA_DATA_Pos))
#define I2S_DATA_MASK _U_(0xFFFFFFFF)

/** \brief I2S hardware registers */

typedef struct {
  volatile I2S_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W  8) Control A */
       RoReg8 Reserved1[0x3];
  volatile I2S_CLKCTRL_Type CLKCTRL[2]; /**< \brief Offset: 0x04 (R/W 32) Clock Unit n Control */
  volatile I2S_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x0C (R/W 16) Interrupt Enable Clear */
       RoReg8 Reserved2[0x2];
  volatile I2S_INTENSET_Type INTENSET; /**< \brief Offset: 0x10 (R/W 16) Interrupt Enable Set */
       RoReg8 Reserved3[0x2];
  volatile I2S_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x14 (R/W 16) Interrupt Flag Status and Clear */
       RoReg8 Reserved4[0x2];
  volatile const I2S_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x18 (R/  16) Synchronization Status */
       RoReg8 Reserved5[0x6];
  volatile I2S_SERCTRL_Type SERCTRL[2]; /**< \brief Offset: 0x20 (R/W 32) Serializer n Control */
       RoReg8 Reserved6[0x8];
  volatile I2S_DATA_Type DATA[2]; /**< \brief Offset: 0x30 (R/W 32) Data n */
} I2s;


/*@}*/
# 254 "asf4/samd21/include/samd21e18a.h" 2
#include "component/mtb.h"
# 254 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/mtb.h" 1
/**
 * \file
 *
 * \brief Component description for MTB
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_MTB_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR MTB */
/* ========================================================================== */
/** \addtogroup SAMD21_MTB Cortex-M0+ Micro-Trace Buffer */
/*@{*/

#define MTB_U2002 
#define REV_MTB 0x100

/* -------- MTB_POSITION : (MTB Offset: 0x000) (R/W 32) MTB Position -------- */

typedef union {
  struct {
    uint32_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint32_t WRAP:1; /*!< bit:      2  Pointer Value Wraps                */
    uint32_t POINTER:29; /*!< bit:  3..31  Trace Packet Location Pointer      */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} MTB_POSITION_Type;


#define MTB_POSITION_OFFSET 0x000

#define MTB_POSITION_WRAP_Pos 2
#define MTB_POSITION_WRAP (_U_(0x1) << MTB_POSITION_WRAP_Pos)
#define MTB_POSITION_POINTER_Pos 3
#define MTB_POSITION_POINTER_Msk (_U_(0x1FFFFFFF) << MTB_POSITION_POINTER_Pos)
#define MTB_POSITION_POINTER(value) (MTB_POSITION_POINTER_Msk & ((value) << MTB_POSITION_POINTER_Pos))
#define MTB_POSITION_MASK _U_(0xFFFFFFFC)

/* -------- MTB_MASTER : (MTB Offset: 0x004) (R/W 32) MTB Master -------- */

typedef union {
  struct {
    uint32_t MASK:5; /*!< bit:  0.. 4  Maximum Value of the Trace Buffer in SRAM */
    uint32_t TSTARTEN:1; /*!< bit:      5  Trace Start Input Enable           */
    uint32_t TSTOPEN:1; /*!< bit:      6  Trace Stop Input Enable            */
    uint32_t SFRWPRIV:1; /*!< bit:      7  Special Function Register Write Privilege */
    uint32_t RAMPRIV:1; /*!< bit:      8  SRAM Privilege                     */
    uint32_t HALTREQ:1; /*!< bit:      9  Halt Request                       */
    uint32_t :21; /*!< bit: 10..30  Reserved                           */
    uint32_t EN:1; /*!< bit:     31  Main Trace Enable                  */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} MTB_MASTER_Type;


#define MTB_MASTER_OFFSET 0x004
#define MTB_MASTER_RESETVALUE _U_(0x00000000)

#define MTB_MASTER_MASK_Pos 0
#define MTB_MASTER_MASK_Msk (_U_(0x1F) << MTB_MASTER_MASK_Pos)
#define MTB_MASTER_MASK(value) (MTB_MASTER_MASK_Msk & ((value) << MTB_MASTER_MASK_Pos))
#define MTB_MASTER_TSTARTEN_Pos 5
#define MTB_MASTER_TSTARTEN (_U_(0x1) << MTB_MASTER_TSTARTEN_Pos)
#define MTB_MASTER_TSTOPEN_Pos 6
#define MTB_MASTER_TSTOPEN (_U_(0x1) << MTB_MASTER_TSTOPEN_Pos)
#define MTB_MASTER_SFRWPRIV_Pos 7
#define MTB_MASTER_SFRWPRIV (_U_(0x1) << MTB_MASTER_SFRWPRIV_Pos)
#define MTB_MASTER_RAMPRIV_Pos 8
#define MTB_MASTER_RAMPRIV (_U_(0x1) << MTB_MASTER_RAMPRIV_Pos)
#define MTB_MASTER_HALTREQ_Pos 9
#define MTB_MASTER_HALTREQ (_U_(0x1) << MTB_MASTER_HALTREQ_Pos)
#define MTB_MASTER_EN_Pos 31
#define MTB_MASTER_EN (_U_(0x1) << MTB_MASTER_EN_Pos)
#define MTB_MASTER_MASK_ _U_(0x800003FF)

/* -------- MTB_FLOW : (MTB Offset: 0x008) (R/W 32) MTB Flow -------- */

typedef union {
  struct {
    uint32_t AUTOSTOP:1; /*!< bit:      0  Auto Stop Tracing                  */
    uint32_t AUTOHALT:1; /*!< bit:      1  Auto Halt Request                  */
    uint32_t :1; /*!< bit:      2  Reserved                           */
    uint32_t WATERMARK:29; /*!< bit:  3..31  Watermark value                    */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} MTB_FLOW_Type;


#define MTB_FLOW_OFFSET 0x008
#define MTB_FLOW_RESETVALUE _U_(0x00000000)

#define MTB_FLOW_AUTOSTOP_Pos 0
#define MTB_FLOW_AUTOSTOP (_U_(0x1) << MTB_FLOW_AUTOSTOP_Pos)
#define MTB_FLOW_AUTOHALT_Pos 1
#define MTB_FLOW_AUTOHALT (_U_(0x1) << MTB_FLOW_AUTOHALT_Pos)
#define MTB_FLOW_WATERMARK_Pos 3
#define MTB_FLOW_WATERMARK_Msk (_U_(0x1FFFFFFF) << MTB_FLOW_WATERMARK_Pos)
#define MTB_FLOW_WATERMARK(value) (MTB_FLOW_WATERMARK_Msk & ((value) << MTB_FLOW_WATERMARK_Pos))
#define MTB_FLOW_MASK _U_(0xFFFFFFFB)

/* -------- MTB_BASE : (MTB Offset: 0x00C) (R/  32) MTB Base -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_BASE_Type;


#define MTB_BASE_OFFSET 0x00C
#define MTB_BASE_MASK _U_(0xFFFFFFFF)

/* -------- MTB_ITCTRL : (MTB Offset: 0xF00) (R/W 32) MTB Integration Mode Control -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_ITCTRL_Type;


#define MTB_ITCTRL_OFFSET 0xF00
#define MTB_ITCTRL_MASK _U_(0xFFFFFFFF)

/* -------- MTB_CLAIMSET : (MTB Offset: 0xFA0) (R/W 32) MTB Claim Set -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_CLAIMSET_Type;


#define MTB_CLAIMSET_OFFSET 0xFA0
#define MTB_CLAIMSET_MASK _U_(0xFFFFFFFF)

/* -------- MTB_CLAIMCLR : (MTB Offset: 0xFA4) (R/W 32) MTB Claim Clear -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_CLAIMCLR_Type;


#define MTB_CLAIMCLR_OFFSET 0xFA4
#define MTB_CLAIMCLR_MASK _U_(0xFFFFFFFF)

/* -------- MTB_LOCKACCESS : (MTB Offset: 0xFB0) (R/W 32) MTB Lock Access -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_LOCKACCESS_Type;


#define MTB_LOCKACCESS_OFFSET 0xFB0
#define MTB_LOCKACCESS_MASK _U_(0xFFFFFFFF)

/* -------- MTB_LOCKSTATUS : (MTB Offset: 0xFB4) (R/  32) MTB Lock Status -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_LOCKSTATUS_Type;


#define MTB_LOCKSTATUS_OFFSET 0xFB4
#define MTB_LOCKSTATUS_MASK _U_(0xFFFFFFFF)

/* -------- MTB_AUTHSTATUS : (MTB Offset: 0xFB8) (R/  32) MTB Authentication Status -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_AUTHSTATUS_Type;


#define MTB_AUTHSTATUS_OFFSET 0xFB8
#define MTB_AUTHSTATUS_MASK _U_(0xFFFFFFFF)

/* -------- MTB_DEVARCH : (MTB Offset: 0xFBC) (R/  32) MTB Device Architecture -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_DEVARCH_Type;


#define MTB_DEVARCH_OFFSET 0xFBC
#define MTB_DEVARCH_MASK _U_(0xFFFFFFFF)

/* -------- MTB_DEVID : (MTB Offset: 0xFC8) (R/  32) MTB Device Configuration -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_DEVID_Type;


#define MTB_DEVID_OFFSET 0xFC8
#define MTB_DEVID_MASK _U_(0xFFFFFFFF)

/* -------- MTB_DEVTYPE : (MTB Offset: 0xFCC) (R/  32) MTB Device Type -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_DEVTYPE_Type;


#define MTB_DEVTYPE_OFFSET 0xFCC
#define MTB_DEVTYPE_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID4 : (MTB Offset: 0xFD0) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID4_Type;


#define MTB_PID4_OFFSET 0xFD0
#define MTB_PID4_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID5 : (MTB Offset: 0xFD4) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID5_Type;


#define MTB_PID5_OFFSET 0xFD4
#define MTB_PID5_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID6 : (MTB Offset: 0xFD8) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID6_Type;


#define MTB_PID6_OFFSET 0xFD8
#define MTB_PID6_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID7 : (MTB Offset: 0xFDC) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID7_Type;


#define MTB_PID7_OFFSET 0xFDC
#define MTB_PID7_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID0 : (MTB Offset: 0xFE0) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID0_Type;


#define MTB_PID0_OFFSET 0xFE0
#define MTB_PID0_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID1 : (MTB Offset: 0xFE4) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID1_Type;


#define MTB_PID1_OFFSET 0xFE4
#define MTB_PID1_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID2 : (MTB Offset: 0xFE8) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID2_Type;


#define MTB_PID2_OFFSET 0xFE8
#define MTB_PID2_MASK _U_(0xFFFFFFFF)

/* -------- MTB_PID3 : (MTB Offset: 0xFEC) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_PID3_Type;


#define MTB_PID3_OFFSET 0xFEC
#define MTB_PID3_MASK _U_(0xFFFFFFFF)

/* -------- MTB_CID0 : (MTB Offset: 0xFF0) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_CID0_Type;


#define MTB_CID0_OFFSET 0xFF0
#define MTB_CID0_MASK _U_(0xFFFFFFFF)

/* -------- MTB_CID1 : (MTB Offset: 0xFF4) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_CID1_Type;


#define MTB_CID1_OFFSET 0xFF4
#define MTB_CID1_MASK _U_(0xFFFFFFFF)

/* -------- MTB_CID2 : (MTB Offset: 0xFF8) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_CID2_Type;


#define MTB_CID2_OFFSET 0xFF8
#define MTB_CID2_MASK _U_(0xFFFFFFFF)

/* -------- MTB_CID3 : (MTB Offset: 0xFFC) (R/  32) CoreSight -------- */

typedef union {
  uint32_t reg; /*!< Type      used for register access              */
} MTB_CID3_Type;


#define MTB_CID3_OFFSET 0xFFC
#define MTB_CID3_MASK _U_(0xFFFFFFFF)

/** \brief MTB hardware registers */

typedef struct {
  volatile MTB_POSITION_Type POSITION; /**< \brief Offset: 0x000 (R/W 32) MTB Position */
  volatile MTB_MASTER_Type MASTER; /**< \brief Offset: 0x004 (R/W 32) MTB Master */
  volatile MTB_FLOW_Type FLOW; /**< \brief Offset: 0x008 (R/W 32) MTB Flow */
  volatile const MTB_BASE_Type BASE; /**< \brief Offset: 0x00C (R/  32) MTB Base */
       RoReg8 Reserved1[0xEF0];
  volatile MTB_ITCTRL_Type ITCTRL; /**< \brief Offset: 0xF00 (R/W 32) MTB Integration Mode Control */
       RoReg8 Reserved2[0x9C];
  volatile MTB_CLAIMSET_Type CLAIMSET; /**< \brief Offset: 0xFA0 (R/W 32) MTB Claim Set */
  volatile MTB_CLAIMCLR_Type CLAIMCLR; /**< \brief Offset: 0xFA4 (R/W 32) MTB Claim Clear */
       RoReg8 Reserved3[0x8];
  volatile MTB_LOCKACCESS_Type LOCKACCESS; /**< \brief Offset: 0xFB0 (R/W 32) MTB Lock Access */
  volatile const MTB_LOCKSTATUS_Type LOCKSTATUS; /**< \brief Offset: 0xFB4 (R/  32) MTB Lock Status */
  volatile const MTB_AUTHSTATUS_Type AUTHSTATUS; /**< \brief Offset: 0xFB8 (R/  32) MTB Authentication Status */
  volatile const MTB_DEVARCH_Type DEVARCH; /**< \brief Offset: 0xFBC (R/  32) MTB Device Architecture */
       RoReg8 Reserved4[0x8];
  volatile const MTB_DEVID_Type DEVID; /**< \brief Offset: 0xFC8 (R/  32) MTB Device Configuration */
  volatile const MTB_DEVTYPE_Type DEVTYPE; /**< \brief Offset: 0xFCC (R/  32) MTB Device Type */
  volatile const MTB_PID4_Type PID4; /**< \brief Offset: 0xFD0 (R/  32) CoreSight */
  volatile const MTB_PID5_Type PID5; /**< \brief Offset: 0xFD4 (R/  32) CoreSight */
  volatile const MTB_PID6_Type PID6; /**< \brief Offset: 0xFD8 (R/  32) CoreSight */
  volatile const MTB_PID7_Type PID7; /**< \brief Offset: 0xFDC (R/  32) CoreSight */
  volatile const MTB_PID0_Type PID0; /**< \brief Offset: 0xFE0 (R/  32) CoreSight */
  volatile const MTB_PID1_Type PID1; /**< \brief Offset: 0xFE4 (R/  32) CoreSight */
  volatile const MTB_PID2_Type PID2; /**< \brief Offset: 0xFE8 (R/  32) CoreSight */
  volatile const MTB_PID3_Type PID3; /**< \brief Offset: 0xFEC (R/  32) CoreSight */
  volatile const MTB_CID0_Type CID0; /**< \brief Offset: 0xFF0 (R/  32) CoreSight */
  volatile const MTB_CID1_Type CID1; /**< \brief Offset: 0xFF4 (R/  32) CoreSight */
  volatile const MTB_CID2_Type CID2; /**< \brief Offset: 0xFF8 (R/  32) CoreSight */
  volatile const MTB_CID3_Type CID3; /**< \brief Offset: 0xFFC (R/  32) CoreSight */
} Mtb;


/*@}*/
# 255 "asf4/samd21/include/samd21e18a.h" 2
#include "component/nvmctrl.h"
# 255 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/nvmctrl.h" 1
/**
 * \file
 *
 * \brief Component description for NVMCTRL
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_NVMCTRL_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR NVMCTRL */
/* ========================================================================== */
/** \addtogroup SAMD21_NVMCTRL Non-Volatile Memory Controller */
/*@{*/

#define NVMCTRL_U2207 
#define REV_NVMCTRL 0x106

/* -------- NVMCTRL_CTRLA : (NVMCTRL Offset: 0x00) (R/W 16) Control A -------- */

typedef union {
  struct {
    uint16_t CMD:7; /*!< bit:  0.. 6  Command                            */
    uint16_t :1; /*!< bit:      7  Reserved                           */
    uint16_t CMDEX:8; /*!< bit:  8..15  Command Execution                  */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} NVMCTRL_CTRLA_Type;


#define NVMCTRL_CTRLA_OFFSET 0x00
#define NVMCTRL_CTRLA_RESETVALUE _U_(0x0000)

#define NVMCTRL_CTRLA_CMD_Pos 0
#define NVMCTRL_CTRLA_CMD_Msk (_U_(0x7F) << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD(value) (NVMCTRL_CTRLA_CMD_Msk & ((value) << NVMCTRL_CTRLA_CMD_Pos))
#define NVMCTRL_CTRLA_CMD_ER_Val _U_(0x2)
#define NVMCTRL_CTRLA_CMD_WP_Val _U_(0x4)
#define NVMCTRL_CTRLA_CMD_EAR_Val _U_(0x5)
#define NVMCTRL_CTRLA_CMD_WAP_Val _U_(0x6)
#define NVMCTRL_CTRLA_CMD_SF_Val _U_(0xA)
#define NVMCTRL_CTRLA_CMD_WL_Val _U_(0xF)
#define NVMCTRL_CTRLA_CMD_LR_Val _U_(0x40)
#define NVMCTRL_CTRLA_CMD_UR_Val _U_(0x41)
#define NVMCTRL_CTRLA_CMD_SPRM_Val _U_(0x42)
#define NVMCTRL_CTRLA_CMD_CPRM_Val _U_(0x43)
#define NVMCTRL_CTRLA_CMD_PBC_Val _U_(0x44)
#define NVMCTRL_CTRLA_CMD_SSB_Val _U_(0x45)
#define NVMCTRL_CTRLA_CMD_INVALL_Val _U_(0x46)
#define NVMCTRL_CTRLA_CMD_ER (NVMCTRL_CTRLA_CMD_ER_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_WP (NVMCTRL_CTRLA_CMD_WP_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_EAR (NVMCTRL_CTRLA_CMD_EAR_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_WAP (NVMCTRL_CTRLA_CMD_WAP_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_SF (NVMCTRL_CTRLA_CMD_SF_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_WL (NVMCTRL_CTRLA_CMD_WL_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_LR (NVMCTRL_CTRLA_CMD_LR_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_UR (NVMCTRL_CTRLA_CMD_UR_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_SPRM (NVMCTRL_CTRLA_CMD_SPRM_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_CPRM (NVMCTRL_CTRLA_CMD_CPRM_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_PBC (NVMCTRL_CTRLA_CMD_PBC_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_SSB (NVMCTRL_CTRLA_CMD_SSB_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMD_INVALL (NVMCTRL_CTRLA_CMD_INVALL_Val << NVMCTRL_CTRLA_CMD_Pos)
#define NVMCTRL_CTRLA_CMDEX_Pos 8
#define NVMCTRL_CTRLA_CMDEX_Msk (_U_(0xFF) << NVMCTRL_CTRLA_CMDEX_Pos)
#define NVMCTRL_CTRLA_CMDEX(value) (NVMCTRL_CTRLA_CMDEX_Msk & ((value) << NVMCTRL_CTRLA_CMDEX_Pos))
#define NVMCTRL_CTRLA_CMDEX_KEY_Val _U_(0xA5)
#define NVMCTRL_CTRLA_CMDEX_KEY (NVMCTRL_CTRLA_CMDEX_KEY_Val << NVMCTRL_CTRLA_CMDEX_Pos)
#define NVMCTRL_CTRLA_MASK _U_(0xFF7F)

/* -------- NVMCTRL_CTRLB : (NVMCTRL Offset: 0x04) (R/W 32) Control B -------- */

typedef union {
  struct {
    uint32_t :1; /*!< bit:      0  Reserved                           */
    uint32_t RWS:4; /*!< bit:  1.. 4  NVM Read Wait States               */
    uint32_t :2; /*!< bit:  5.. 6  Reserved                           */
    uint32_t MANW:1; /*!< bit:      7  Manual Write                       */
    uint32_t SLEEPPRM:2; /*!< bit:  8.. 9  Power Reduction Mode during Sleep  */
    uint32_t :6; /*!< bit: 10..15  Reserved                           */
    uint32_t READMODE:2; /*!< bit: 16..17  NVMCTRL Read Mode                  */
    uint32_t CACHEDIS:1; /*!< bit:     18  Cache Disable                      */
    uint32_t :13; /*!< bit: 19..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} NVMCTRL_CTRLB_Type;


#define NVMCTRL_CTRLB_OFFSET 0x04
#define NVMCTRL_CTRLB_RESETVALUE _U_(0x00000000)

#define NVMCTRL_CTRLB_RWS_Pos 1
#define NVMCTRL_CTRLB_RWS_Msk (_U_(0xF) << NVMCTRL_CTRLB_RWS_Pos)
#define NVMCTRL_CTRLB_RWS(value) (NVMCTRL_CTRLB_RWS_Msk & ((value) << NVMCTRL_CTRLB_RWS_Pos))
#define NVMCTRL_CTRLB_RWS_SINGLE_Val _U_(0x0)
#define NVMCTRL_CTRLB_RWS_HALF_Val _U_(0x1)
#define NVMCTRL_CTRLB_RWS_DUAL_Val _U_(0x2)
#define NVMCTRL_CTRLB_RWS_SINGLE (NVMCTRL_CTRLB_RWS_SINGLE_Val << NVMCTRL_CTRLB_RWS_Pos)
#define NVMCTRL_CTRLB_RWS_HALF (NVMCTRL_CTRLB_RWS_HALF_Val << NVMCTRL_CTRLB_RWS_Pos)
#define NVMCTRL_CTRLB_RWS_DUAL (NVMCTRL_CTRLB_RWS_DUAL_Val << NVMCTRL_CTRLB_RWS_Pos)
#define NVMCTRL_CTRLB_MANW_Pos 7
#define NVMCTRL_CTRLB_MANW (_U_(0x1) << NVMCTRL_CTRLB_MANW_Pos)
#define NVMCTRL_CTRLB_SLEEPPRM_Pos 8
#define NVMCTRL_CTRLB_SLEEPPRM_Msk (_U_(0x3) << NVMCTRL_CTRLB_SLEEPPRM_Pos)
#define NVMCTRL_CTRLB_SLEEPPRM(value) (NVMCTRL_CTRLB_SLEEPPRM_Msk & ((value) << NVMCTRL_CTRLB_SLEEPPRM_Pos))
#define NVMCTRL_CTRLB_SLEEPPRM_WAKEONACCESS_Val _U_(0x0)
#define NVMCTRL_CTRLB_SLEEPPRM_WAKEUPINSTANT_Val _U_(0x1)
#define NVMCTRL_CTRLB_SLEEPPRM_DISABLED_Val _U_(0x3)
#define NVMCTRL_CTRLB_SLEEPPRM_WAKEONACCESS (NVMCTRL_CTRLB_SLEEPPRM_WAKEONACCESS_Val << NVMCTRL_CTRLB_SLEEPPRM_Pos)
#define NVMCTRL_CTRLB_SLEEPPRM_WAKEUPINSTANT (NVMCTRL_CTRLB_SLEEPPRM_WAKEUPINSTANT_Val << NVMCTRL_CTRLB_SLEEPPRM_Pos)
#define NVMCTRL_CTRLB_SLEEPPRM_DISABLED (NVMCTRL_CTRLB_SLEEPPRM_DISABLED_Val << NVMCTRL_CTRLB_SLEEPPRM_Pos)
#define NVMCTRL_CTRLB_READMODE_Pos 16
#define NVMCTRL_CTRLB_READMODE_Msk (_U_(0x3) << NVMCTRL_CTRLB_READMODE_Pos)
#define NVMCTRL_CTRLB_READMODE(value) (NVMCTRL_CTRLB_READMODE_Msk & ((value) << NVMCTRL_CTRLB_READMODE_Pos))
#define NVMCTRL_CTRLB_READMODE_NO_MISS_PENALTY_Val _U_(0x0)
#define NVMCTRL_CTRLB_READMODE_LOW_POWER_Val _U_(0x1)
#define NVMCTRL_CTRLB_READMODE_DETERMINISTIC_Val _U_(0x2)
#define NVMCTRL_CTRLB_READMODE_NO_MISS_PENALTY (NVMCTRL_CTRLB_READMODE_NO_MISS_PENALTY_Val << NVMCTRL_CTRLB_READMODE_Pos)
#define NVMCTRL_CTRLB_READMODE_LOW_POWER (NVMCTRL_CTRLB_READMODE_LOW_POWER_Val << NVMCTRL_CTRLB_READMODE_Pos)
#define NVMCTRL_CTRLB_READMODE_DETERMINISTIC (NVMCTRL_CTRLB_READMODE_DETERMINISTIC_Val << NVMCTRL_CTRLB_READMODE_Pos)
#define NVMCTRL_CTRLB_CACHEDIS_Pos 18
#define NVMCTRL_CTRLB_CACHEDIS (_U_(0x1) << NVMCTRL_CTRLB_CACHEDIS_Pos)
#define NVMCTRL_CTRLB_MASK _U_(0x0007039E)

/* -------- NVMCTRL_PARAM : (NVMCTRL Offset: 0x08) (R/W 32) NVM Parameter -------- */

typedef union {
  struct {
    uint32_t NVMP:16; /*!< bit:  0..15  NVM Pages                          */
    uint32_t PSZ:3; /*!< bit: 16..18  Page Size                          */
    uint32_t :13; /*!< bit: 19..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} NVMCTRL_PARAM_Type;


#define NVMCTRL_PARAM_OFFSET 0x08
#define NVMCTRL_PARAM_RESETVALUE _U_(0x00000000)

#define NVMCTRL_PARAM_NVMP_Pos 0
#define NVMCTRL_PARAM_NVMP_Msk (_U_(0xFFFF) << NVMCTRL_PARAM_NVMP_Pos)
#define NVMCTRL_PARAM_NVMP(value) (NVMCTRL_PARAM_NVMP_Msk & ((value) << NVMCTRL_PARAM_NVMP_Pos))
#define NVMCTRL_PARAM_PSZ_Pos 16
#define NVMCTRL_PARAM_PSZ_Msk (_U_(0x7) << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ(value) (NVMCTRL_PARAM_PSZ_Msk & ((value) << NVMCTRL_PARAM_PSZ_Pos))
#define NVMCTRL_PARAM_PSZ_8_Val _U_(0x0)
#define NVMCTRL_PARAM_PSZ_16_Val _U_(0x1)
#define NVMCTRL_PARAM_PSZ_32_Val _U_(0x2)
#define NVMCTRL_PARAM_PSZ_64_Val _U_(0x3)
#define NVMCTRL_PARAM_PSZ_128_Val _U_(0x4)
#define NVMCTRL_PARAM_PSZ_256_Val _U_(0x5)
#define NVMCTRL_PARAM_PSZ_512_Val _U_(0x6)
#define NVMCTRL_PARAM_PSZ_1024_Val _U_(0x7)
#define NVMCTRL_PARAM_PSZ_8 (NVMCTRL_PARAM_PSZ_8_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ_16 (NVMCTRL_PARAM_PSZ_16_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ_32 (NVMCTRL_PARAM_PSZ_32_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ_64 (NVMCTRL_PARAM_PSZ_64_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ_128 (NVMCTRL_PARAM_PSZ_128_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ_256 (NVMCTRL_PARAM_PSZ_256_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ_512 (NVMCTRL_PARAM_PSZ_512_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_PSZ_1024 (NVMCTRL_PARAM_PSZ_1024_Val << NVMCTRL_PARAM_PSZ_Pos)
#define NVMCTRL_PARAM_MASK _U_(0x0007FFFF)

/* -------- NVMCTRL_INTENCLR : (NVMCTRL Offset: 0x0C) (R/W  8) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t READY:1; /*!< bit:      0  NVM Ready Interrupt Enable         */
    uint8_t ERROR:1; /*!< bit:      1  Error Interrupt Enable             */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} NVMCTRL_INTENCLR_Type;


#define NVMCTRL_INTENCLR_OFFSET 0x0C
#define NVMCTRL_INTENCLR_RESETVALUE _U_(0x00)

#define NVMCTRL_INTENCLR_READY_Pos 0
#define NVMCTRL_INTENCLR_READY (_U_(0x1) << NVMCTRL_INTENCLR_READY_Pos)
#define NVMCTRL_INTENCLR_ERROR_Pos 1
#define NVMCTRL_INTENCLR_ERROR (_U_(0x1) << NVMCTRL_INTENCLR_ERROR_Pos)
#define NVMCTRL_INTENCLR_MASK _U_(0x03)

/* -------- NVMCTRL_INTENSET : (NVMCTRL Offset: 0x10) (R/W  8) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t READY:1; /*!< bit:      0  NVM Ready Interrupt Enable         */
    uint8_t ERROR:1; /*!< bit:      1  Error Interrupt Enable             */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} NVMCTRL_INTENSET_Type;


#define NVMCTRL_INTENSET_OFFSET 0x10
#define NVMCTRL_INTENSET_RESETVALUE _U_(0x00)

#define NVMCTRL_INTENSET_READY_Pos 0
#define NVMCTRL_INTENSET_READY (_U_(0x1) << NVMCTRL_INTENSET_READY_Pos)
#define NVMCTRL_INTENSET_ERROR_Pos 1
#define NVMCTRL_INTENSET_ERROR (_U_(0x1) << NVMCTRL_INTENSET_ERROR_Pos)
#define NVMCTRL_INTENSET_MASK _U_(0x03)

/* -------- NVMCTRL_INTFLAG : (NVMCTRL Offset: 0x14) (R/W  8) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t READY:1; /*!< bit:      0  NVM Ready                          */
    volatile const uint8_t ERROR:1; /*!< bit:      1  Error                              */
    volatile const uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} NVMCTRL_INTFLAG_Type;


#define NVMCTRL_INTFLAG_OFFSET 0x14
#define NVMCTRL_INTFLAG_RESETVALUE _U_(0x00)

#define NVMCTRL_INTFLAG_READY_Pos 0
#define NVMCTRL_INTFLAG_READY (_U_(0x1) << NVMCTRL_INTFLAG_READY_Pos)
#define NVMCTRL_INTFLAG_ERROR_Pos 1
#define NVMCTRL_INTFLAG_ERROR (_U_(0x1) << NVMCTRL_INTFLAG_ERROR_Pos)
#define NVMCTRL_INTFLAG_MASK _U_(0x03)

/* -------- NVMCTRL_STATUS : (NVMCTRL Offset: 0x18) (R/W 16) Status -------- */

typedef union {
  struct {
    uint16_t PRM:1; /*!< bit:      0  Power Reduction Mode               */
    uint16_t LOAD:1; /*!< bit:      1  NVM Page Buffer Active Loading     */
    uint16_t PROGE:1; /*!< bit:      2  Programming Error Status           */
    uint16_t LOCKE:1; /*!< bit:      3  Lock Error Status                  */
    uint16_t NVME:1; /*!< bit:      4  NVM Error                          */
    uint16_t :3; /*!< bit:  5.. 7  Reserved                           */
    uint16_t SB:1; /*!< bit:      8  Security Bit Status                */
    uint16_t :7; /*!< bit:  9..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} NVMCTRL_STATUS_Type;


#define NVMCTRL_STATUS_OFFSET 0x18
#define NVMCTRL_STATUS_RESETVALUE _U_(0x0000)

#define NVMCTRL_STATUS_PRM_Pos 0
#define NVMCTRL_STATUS_PRM (_U_(0x1) << NVMCTRL_STATUS_PRM_Pos)
#define NVMCTRL_STATUS_LOAD_Pos 1
#define NVMCTRL_STATUS_LOAD (_U_(0x1) << NVMCTRL_STATUS_LOAD_Pos)
#define NVMCTRL_STATUS_PROGE_Pos 2
#define NVMCTRL_STATUS_PROGE (_U_(0x1) << NVMCTRL_STATUS_PROGE_Pos)
#define NVMCTRL_STATUS_LOCKE_Pos 3
#define NVMCTRL_STATUS_LOCKE (_U_(0x1) << NVMCTRL_STATUS_LOCKE_Pos)
#define NVMCTRL_STATUS_NVME_Pos 4
#define NVMCTRL_STATUS_NVME (_U_(0x1) << NVMCTRL_STATUS_NVME_Pos)
#define NVMCTRL_STATUS_SB_Pos 8
#define NVMCTRL_STATUS_SB (_U_(0x1) << NVMCTRL_STATUS_SB_Pos)
#define NVMCTRL_STATUS_MASK _U_(0x011F)

/* -------- NVMCTRL_ADDR : (NVMCTRL Offset: 0x1C) (R/W 32) Address -------- */

typedef union {
  struct {
    uint32_t ADDR:22; /*!< bit:  0..21  NVM Address                        */
    uint32_t :10; /*!< bit: 22..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} NVMCTRL_ADDR_Type;


#define NVMCTRL_ADDR_OFFSET 0x1C
#define NVMCTRL_ADDR_RESETVALUE _U_(0x00000000)

#define NVMCTRL_ADDR_ADDR_Pos 0
#define NVMCTRL_ADDR_ADDR_Msk (_U_(0x3FFFFF) << NVMCTRL_ADDR_ADDR_Pos)
#define NVMCTRL_ADDR_ADDR(value) (NVMCTRL_ADDR_ADDR_Msk & ((value) << NVMCTRL_ADDR_ADDR_Pos))
#define NVMCTRL_ADDR_MASK _U_(0x003FFFFF)

/* -------- NVMCTRL_LOCK : (NVMCTRL Offset: 0x20) (R/W 16) Lock Section -------- */

typedef union {
  struct {
    uint16_t LOCK:16; /*!< bit:  0..15  Region Lock Bits                   */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} NVMCTRL_LOCK_Type;


#define NVMCTRL_LOCK_OFFSET 0x20

#define NVMCTRL_LOCK_LOCK_Pos 0
#define NVMCTRL_LOCK_LOCK_Msk (_U_(0xFFFF) << NVMCTRL_LOCK_LOCK_Pos)
#define NVMCTRL_LOCK_LOCK(value) (NVMCTRL_LOCK_LOCK_Msk & ((value) << NVMCTRL_LOCK_LOCK_Pos))
#define NVMCTRL_LOCK_MASK _U_(0xFFFF)

/** \brief NVMCTRL APB hardware registers */

typedef struct {
  volatile NVMCTRL_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 16) Control A */
       RoReg8 Reserved1[0x2];
  volatile NVMCTRL_CTRLB_Type CTRLB; /**< \brief Offset: 0x04 (R/W 32) Control B */
  volatile NVMCTRL_PARAM_Type PARAM; /**< \brief Offset: 0x08 (R/W 32) NVM Parameter */
  volatile NVMCTRL_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x0C (R/W  8) Interrupt Enable Clear */
       RoReg8 Reserved2[0x3];
  volatile NVMCTRL_INTENSET_Type INTENSET; /**< \brief Offset: 0x10 (R/W  8) Interrupt Enable Set */
       RoReg8 Reserved3[0x3];
  volatile NVMCTRL_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x14 (R/W  8) Interrupt Flag Status and Clear */
       RoReg8 Reserved4[0x3];
  volatile NVMCTRL_STATUS_Type STATUS; /**< \brief Offset: 0x18 (R/W 16) Status */
       RoReg8 Reserved5[0x2];
  volatile NVMCTRL_ADDR_Type ADDR; /**< \brief Offset: 0x1C (R/W 32) Address */
  volatile NVMCTRL_LOCK_Type LOCK; /**< \brief Offset: 0x20 (R/W 16) Lock Section */
} Nvmctrl;


#define SECTION_NVMCTRL_CAL 

#define SECTION_NVMCTRL_LOCKBIT 

#define SECTION_NVMCTRL_OTP1 

#define SECTION_NVMCTRL_OTP2 

#define SECTION_NVMCTRL_OTP4 

#define SECTION_NVMCTRL_TEMP_LOG 

#define SECTION_NVMCTRL_USER 

/*@}*/

/* ************************************************************************** */
/**  SOFTWARE PERIPHERAL API DEFINITION FOR NON-VOLATILE FUSES */
/* ************************************************************************** */
/** \addtogroup fuses_api Peripheral Software API */
/*@{*/


#define ADC_FUSES_BIASCAL_ADDR (NVMCTRL_OTP4 + 4)
#define ADC_FUSES_BIASCAL_Pos 3
#define ADC_FUSES_BIASCAL_Msk (_U_(0x7) << ADC_FUSES_BIASCAL_Pos)
#define ADC_FUSES_BIASCAL(value) (ADC_FUSES_BIASCAL_Msk & ((value) << ADC_FUSES_BIASCAL_Pos))

#define ADC_FUSES_LINEARITY_0_ADDR NVMCTRL_OTP4
#define ADC_FUSES_LINEARITY_0_Pos 27
#define ADC_FUSES_LINEARITY_0_Msk (_U_(0x1F) << ADC_FUSES_LINEARITY_0_Pos)
#define ADC_FUSES_LINEARITY_0(value) (ADC_FUSES_LINEARITY_0_Msk & ((value) << ADC_FUSES_LINEARITY_0_Pos))

#define ADC_FUSES_LINEARITY_1_ADDR (NVMCTRL_OTP4 + 4)
#define ADC_FUSES_LINEARITY_1_Pos 0
#define ADC_FUSES_LINEARITY_1_Msk (_U_(0x7) << ADC_FUSES_LINEARITY_1_Pos)
#define ADC_FUSES_LINEARITY_1(value) (ADC_FUSES_LINEARITY_1_Msk & ((value) << ADC_FUSES_LINEARITY_1_Pos))

#define FUSES_BOD33USERLEVEL_ADDR NVMCTRL_USER
#define FUSES_BOD33USERLEVEL_Pos 8
#define FUSES_BOD33USERLEVEL_Msk (_U_(0x3F) << FUSES_BOD33USERLEVEL_Pos)
#define FUSES_BOD33USERLEVEL(value) (FUSES_BOD33USERLEVEL_Msk & ((value) << FUSES_BOD33USERLEVEL_Pos))

#define FUSES_BOD33_ACTION_ADDR NVMCTRL_USER
#define FUSES_BOD33_ACTION_Pos 15
#define FUSES_BOD33_ACTION_Msk (_U_(0x3) << FUSES_BOD33_ACTION_Pos)
#define FUSES_BOD33_ACTION(value) (FUSES_BOD33_ACTION_Msk & ((value) << FUSES_BOD33_ACTION_Pos))

#define FUSES_BOD33_EN_ADDR NVMCTRL_USER
#define FUSES_BOD33_EN_Pos 14
#define FUSES_BOD33_EN_Msk (_U_(0x1) << FUSES_BOD33_EN_Pos)

#define FUSES_BOD33_HYST_ADDR (NVMCTRL_USER + 4)
#define FUSES_BOD33_HYST_Pos 8
#define FUSES_BOD33_HYST_Msk (_U_(0x1) << FUSES_BOD33_HYST_Pos)

#define FUSES_DFLL48M_COARSE_CAL_ADDR (NVMCTRL_OTP4 + 4)
#define FUSES_DFLL48M_COARSE_CAL_Pos 26
#define FUSES_DFLL48M_COARSE_CAL_Msk (_U_(0x3F) << FUSES_DFLL48M_COARSE_CAL_Pos)
#define FUSES_DFLL48M_COARSE_CAL(value) (FUSES_DFLL48M_COARSE_CAL_Msk & ((value) << FUSES_DFLL48M_COARSE_CAL_Pos))

#define FUSES_DFLL48M_FINE_CAL_ADDR (NVMCTRL_OTP4 + 8)
#define FUSES_DFLL48M_FINE_CAL_Pos 0
#define FUSES_DFLL48M_FINE_CAL_Msk (_U_(0x3FF) << FUSES_DFLL48M_FINE_CAL_Pos)
#define FUSES_DFLL48M_FINE_CAL(value) (FUSES_DFLL48M_FINE_CAL_Msk & ((value) << FUSES_DFLL48M_FINE_CAL_Pos))

#define FUSES_HOT_ADC_VAL_ADDR (NVMCTRL_TEMP_LOG + 4)
#define FUSES_HOT_ADC_VAL_Pos 20
#define FUSES_HOT_ADC_VAL_Msk (_U_(0xFFF) << FUSES_HOT_ADC_VAL_Pos)
#define FUSES_HOT_ADC_VAL(value) (FUSES_HOT_ADC_VAL_Msk & ((value) << FUSES_HOT_ADC_VAL_Pos))

#define FUSES_HOT_INT1V_VAL_ADDR (NVMCTRL_TEMP_LOG + 4)
#define FUSES_HOT_INT1V_VAL_Pos 0
#define FUSES_HOT_INT1V_VAL_Msk (_U_(0xFF) << FUSES_HOT_INT1V_VAL_Pos)
#define FUSES_HOT_INT1V_VAL(value) (FUSES_HOT_INT1V_VAL_Msk & ((value) << FUSES_HOT_INT1V_VAL_Pos))

#define FUSES_HOT_TEMP_VAL_DEC_ADDR NVMCTRL_TEMP_LOG
#define FUSES_HOT_TEMP_VAL_DEC_Pos 20
#define FUSES_HOT_TEMP_VAL_DEC_Msk (_U_(0xF) << FUSES_HOT_TEMP_VAL_DEC_Pos)
#define FUSES_HOT_TEMP_VAL_DEC(value) (FUSES_HOT_TEMP_VAL_DEC_Msk & ((value) << FUSES_HOT_TEMP_VAL_DEC_Pos))

#define FUSES_HOT_TEMP_VAL_INT_ADDR NVMCTRL_TEMP_LOG
#define FUSES_HOT_TEMP_VAL_INT_Pos 12
#define FUSES_HOT_TEMP_VAL_INT_Msk (_U_(0xFF) << FUSES_HOT_TEMP_VAL_INT_Pos)
#define FUSES_HOT_TEMP_VAL_INT(value) (FUSES_HOT_TEMP_VAL_INT_Msk & ((value) << FUSES_HOT_TEMP_VAL_INT_Pos))

#define FUSES_OSC32K_CAL_ADDR (NVMCTRL_OTP4 + 4)
#define FUSES_OSC32K_CAL_Pos 6
#define FUSES_OSC32K_CAL_Msk (_U_(0x7F) << FUSES_OSC32K_CAL_Pos)
#define FUSES_OSC32K_CAL(value) (FUSES_OSC32K_CAL_Msk & ((value) << FUSES_OSC32K_CAL_Pos))

#define FUSES_ROOM_ADC_VAL_ADDR (NVMCTRL_TEMP_LOG + 4)
#define FUSES_ROOM_ADC_VAL_Pos 8
#define FUSES_ROOM_ADC_VAL_Msk (_U_(0xFFF) << FUSES_ROOM_ADC_VAL_Pos)
#define FUSES_ROOM_ADC_VAL(value) (FUSES_ROOM_ADC_VAL_Msk & ((value) << FUSES_ROOM_ADC_VAL_Pos))

#define FUSES_ROOM_INT1V_VAL_ADDR NVMCTRL_TEMP_LOG
#define FUSES_ROOM_INT1V_VAL_Pos 24
#define FUSES_ROOM_INT1V_VAL_Msk (_U_(0xFF) << FUSES_ROOM_INT1V_VAL_Pos)
#define FUSES_ROOM_INT1V_VAL(value) (FUSES_ROOM_INT1V_VAL_Msk & ((value) << FUSES_ROOM_INT1V_VAL_Pos))

#define FUSES_ROOM_TEMP_VAL_DEC_ADDR NVMCTRL_TEMP_LOG
#define FUSES_ROOM_TEMP_VAL_DEC_Pos 8
#define FUSES_ROOM_TEMP_VAL_DEC_Msk (_U_(0xF) << FUSES_ROOM_TEMP_VAL_DEC_Pos)
#define FUSES_ROOM_TEMP_VAL_DEC(value) (FUSES_ROOM_TEMP_VAL_DEC_Msk & ((value) << FUSES_ROOM_TEMP_VAL_DEC_Pos))

#define FUSES_ROOM_TEMP_VAL_INT_ADDR NVMCTRL_TEMP_LOG
#define FUSES_ROOM_TEMP_VAL_INT_Pos 0
#define FUSES_ROOM_TEMP_VAL_INT_Msk (_U_(0xFF) << FUSES_ROOM_TEMP_VAL_INT_Pos)
#define FUSES_ROOM_TEMP_VAL_INT(value) (FUSES_ROOM_TEMP_VAL_INT_Msk & ((value) << FUSES_ROOM_TEMP_VAL_INT_Pos))

#define NVMCTRL_FUSES_BOOTPROT_ADDR NVMCTRL_USER
#define NVMCTRL_FUSES_BOOTPROT_Pos 0
#define NVMCTRL_FUSES_BOOTPROT_Msk (_U_(0x7) << NVMCTRL_FUSES_BOOTPROT_Pos)
#define NVMCTRL_FUSES_BOOTPROT(value) (NVMCTRL_FUSES_BOOTPROT_Msk & ((value) << NVMCTRL_FUSES_BOOTPROT_Pos))

#define NVMCTRL_FUSES_EEPROM_SIZE_ADDR NVMCTRL_USER
#define NVMCTRL_FUSES_EEPROM_SIZE_Pos 4
#define NVMCTRL_FUSES_EEPROM_SIZE_Msk (_U_(0x7) << NVMCTRL_FUSES_EEPROM_SIZE_Pos)
#define NVMCTRL_FUSES_EEPROM_SIZE(value) (NVMCTRL_FUSES_EEPROM_SIZE_Msk & ((value) << NVMCTRL_FUSES_EEPROM_SIZE_Pos))

#define NVMCTRL_FUSES_REGION_LOCKS_ADDR (NVMCTRL_USER + 4)
#define NVMCTRL_FUSES_REGION_LOCKS_Pos 16
#define NVMCTRL_FUSES_REGION_LOCKS_Msk (_U_(0xFFFF) << NVMCTRL_FUSES_REGION_LOCKS_Pos)
#define NVMCTRL_FUSES_REGION_LOCKS(value) (NVMCTRL_FUSES_REGION_LOCKS_Msk & ((value) << NVMCTRL_FUSES_REGION_LOCKS_Pos))

#define USB_FUSES_TRANSN_ADDR (NVMCTRL_OTP4 + 4)
#define USB_FUSES_TRANSN_Pos 13
#define USB_FUSES_TRANSN_Msk (_U_(0x1F) << USB_FUSES_TRANSN_Pos)
#define USB_FUSES_TRANSN(value) (USB_FUSES_TRANSN_Msk & ((value) << USB_FUSES_TRANSN_Pos))

#define USB_FUSES_TRANSP_ADDR (NVMCTRL_OTP4 + 4)
#define USB_FUSES_TRANSP_Pos 18
#define USB_FUSES_TRANSP_Msk (_U_(0x1F) << USB_FUSES_TRANSP_Pos)
#define USB_FUSES_TRANSP(value) (USB_FUSES_TRANSP_Msk & ((value) << USB_FUSES_TRANSP_Pos))

#define USB_FUSES_TRIM_ADDR (NVMCTRL_OTP4 + 4)
#define USB_FUSES_TRIM_Pos 23
#define USB_FUSES_TRIM_Msk (_U_(0x7) << USB_FUSES_TRIM_Pos)
#define USB_FUSES_TRIM(value) (USB_FUSES_TRIM_Msk & ((value) << USB_FUSES_TRIM_Pos))

#define WDT_FUSES_ALWAYSON_ADDR NVMCTRL_USER
#define WDT_FUSES_ALWAYSON_Pos 26
#define WDT_FUSES_ALWAYSON_Msk (_U_(0x1) << WDT_FUSES_ALWAYSON_Pos)

#define WDT_FUSES_ENABLE_ADDR NVMCTRL_USER
#define WDT_FUSES_ENABLE_Pos 25
#define WDT_FUSES_ENABLE_Msk (_U_(0x1) << WDT_FUSES_ENABLE_Pos)

#define WDT_FUSES_EWOFFSET_ADDR (NVMCTRL_USER + 4)
#define WDT_FUSES_EWOFFSET_Pos 3
#define WDT_FUSES_EWOFFSET_Msk (_U_(0xF) << WDT_FUSES_EWOFFSET_Pos)
#define WDT_FUSES_EWOFFSET(value) (WDT_FUSES_EWOFFSET_Msk & ((value) << WDT_FUSES_EWOFFSET_Pos))

#define WDT_FUSES_PER_ADDR NVMCTRL_USER
#define WDT_FUSES_PER_Pos 27
#define WDT_FUSES_PER_Msk (_U_(0xF) << WDT_FUSES_PER_Pos)
#define WDT_FUSES_PER(value) (WDT_FUSES_PER_Msk & ((value) << WDT_FUSES_PER_Pos))

#define WDT_FUSES_WEN_ADDR (NVMCTRL_USER + 4)
#define WDT_FUSES_WEN_Pos 7
#define WDT_FUSES_WEN_Msk (_U_(0x1) << WDT_FUSES_WEN_Pos)

#define WDT_FUSES_WINDOW_0_ADDR NVMCTRL_USER
#define WDT_FUSES_WINDOW_0_Pos 31
#define WDT_FUSES_WINDOW_0_Msk (_U_(0x1) << WDT_FUSES_WINDOW_0_Pos)

#define WDT_FUSES_WINDOW_1_ADDR (NVMCTRL_USER + 4)
#define WDT_FUSES_WINDOW_1_Pos 0
#define WDT_FUSES_WINDOW_1_Msk (_U_(0x7) << WDT_FUSES_WINDOW_1_Pos)
#define WDT_FUSES_WINDOW_1(value) (WDT_FUSES_WINDOW_1_Msk & ((value) << WDT_FUSES_WINDOW_1_Pos))

/*@}*/
# 256 "asf4/samd21/include/samd21e18a.h" 2
#include "component/pac.h"
# 256 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/pac.h" 1
/**
 * \file
 *
 * \brief Component description for PAC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PAC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR PAC */
/* ========================================================================== */
/** \addtogroup SAMD21_PAC Peripheral Access Controller */
/*@{*/

#define PAC_U2211 
#define REV_PAC 0x101

/* -------- PAC_WPCLR : (PAC Offset: 0x0) (R/W 32) Write Protection Clear -------- */

typedef union {
  struct {
    uint32_t :1; /*!< bit:      0  Reserved                           */
    uint32_t WP:31; /*!< bit:  1..31  Write Protection Clear             */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PAC_WPCLR_Type;


#define PAC_WPCLR_OFFSET 0x0
#define PAC_WPCLR_RESETVALUE _U_(0x00000000)

#define PAC_WPCLR_WP_Pos 1
#define PAC_WPCLR_WP_Msk (_U_(0x7FFFFFFF) << PAC_WPCLR_WP_Pos)
#define PAC_WPCLR_WP(value) (PAC_WPCLR_WP_Msk & ((value) << PAC_WPCLR_WP_Pos))
#define PAC_WPCLR_MASK _U_(0xFFFFFFFE)

/* -------- PAC_WPSET : (PAC Offset: 0x4) (R/W 32) Write Protection Set -------- */

typedef union {
  struct {
    uint32_t :1; /*!< bit:      0  Reserved                           */
    uint32_t WP:31; /*!< bit:  1..31  Write Protection Set               */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PAC_WPSET_Type;


#define PAC_WPSET_OFFSET 0x4
#define PAC_WPSET_RESETVALUE _U_(0x00000000)

#define PAC_WPSET_WP_Pos 1
#define PAC_WPSET_WP_Msk (_U_(0x7FFFFFFF) << PAC_WPSET_WP_Pos)
#define PAC_WPSET_WP(value) (PAC_WPSET_WP_Msk & ((value) << PAC_WPSET_WP_Pos))
#define PAC_WPSET_MASK _U_(0xFFFFFFFE)

/** \brief PAC hardware registers */

typedef struct {
  volatile PAC_WPCLR_Type WPCLR; /**< \brief Offset: 0x0 (R/W 32) Write Protection Clear */
  volatile PAC_WPSET_Type WPSET; /**< \brief Offset: 0x4 (R/W 32) Write Protection Set */
} Pac;


/*@}*/
# 257 "asf4/samd21/include/samd21e18a.h" 2
#include "component/pm.h"
# 257 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/pm.h" 1
/**
 * \file
 *
 * \brief Component description for PM
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PM_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR PM */
/* ========================================================================== */
/** \addtogroup SAMD21_PM Power Manager */
/*@{*/

#define PM_U2206 
#define REV_PM 0x201

/* -------- PM_CTRL : (PM Offset: 0x00) (R/W  8) Control -------- */

typedef union {
  uint8_t reg; /*!< Type      used for register access              */
} PM_CTRL_Type;


#define PM_CTRL_OFFSET 0x00
#define PM_CTRL_RESETVALUE _U_(0x00)

#define PM_CTRL_MASK _U_(0x00)

/* -------- PM_SLEEP : (PM Offset: 0x01) (R/W  8) Sleep Mode -------- */

typedef union {
  struct {
    uint8_t IDLE:2; /*!< bit:  0.. 1  Idle Mode Configuration            */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_SLEEP_Type;


#define PM_SLEEP_OFFSET 0x01
#define PM_SLEEP_RESETVALUE _U_(0x00)

#define PM_SLEEP_IDLE_Pos 0
#define PM_SLEEP_IDLE_Msk (_U_(0x3) << PM_SLEEP_IDLE_Pos)
#define PM_SLEEP_IDLE(value) (PM_SLEEP_IDLE_Msk & ((value) << PM_SLEEP_IDLE_Pos))
#define PM_SLEEP_IDLE_CPU_Val _U_(0x0)
#define PM_SLEEP_IDLE_AHB_Val _U_(0x1)
#define PM_SLEEP_IDLE_APB_Val _U_(0x2)
#define PM_SLEEP_IDLE_CPU (PM_SLEEP_IDLE_CPU_Val << PM_SLEEP_IDLE_Pos)
#define PM_SLEEP_IDLE_AHB (PM_SLEEP_IDLE_AHB_Val << PM_SLEEP_IDLE_Pos)
#define PM_SLEEP_IDLE_APB (PM_SLEEP_IDLE_APB_Val << PM_SLEEP_IDLE_Pos)
#define PM_SLEEP_MASK _U_(0x03)

/* -------- PM_CPUSEL : (PM Offset: 0x08) (R/W  8) CPU Clock Select -------- */

typedef union {
  struct {
    uint8_t CPUDIV:3; /*!< bit:  0.. 2  CPU Prescaler Selection            */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_CPUSEL_Type;


#define PM_CPUSEL_OFFSET 0x08
#define PM_CPUSEL_RESETVALUE _U_(0x00)

#define PM_CPUSEL_CPUDIV_Pos 0
#define PM_CPUSEL_CPUDIV_Msk (_U_(0x7) << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV(value) (PM_CPUSEL_CPUDIV_Msk & ((value) << PM_CPUSEL_CPUDIV_Pos))
#define PM_CPUSEL_CPUDIV_DIV1_Val _U_(0x0)
#define PM_CPUSEL_CPUDIV_DIV2_Val _U_(0x1)
#define PM_CPUSEL_CPUDIV_DIV4_Val _U_(0x2)
#define PM_CPUSEL_CPUDIV_DIV8_Val _U_(0x3)
#define PM_CPUSEL_CPUDIV_DIV16_Val _U_(0x4)
#define PM_CPUSEL_CPUDIV_DIV32_Val _U_(0x5)
#define PM_CPUSEL_CPUDIV_DIV64_Val _U_(0x6)
#define PM_CPUSEL_CPUDIV_DIV128_Val _U_(0x7)
#define PM_CPUSEL_CPUDIV_DIV1 (PM_CPUSEL_CPUDIV_DIV1_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV_DIV2 (PM_CPUSEL_CPUDIV_DIV2_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV_DIV4 (PM_CPUSEL_CPUDIV_DIV4_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV_DIV8 (PM_CPUSEL_CPUDIV_DIV8_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV_DIV16 (PM_CPUSEL_CPUDIV_DIV16_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV_DIV32 (PM_CPUSEL_CPUDIV_DIV32_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV_DIV64 (PM_CPUSEL_CPUDIV_DIV64_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_CPUDIV_DIV128 (PM_CPUSEL_CPUDIV_DIV128_Val << PM_CPUSEL_CPUDIV_Pos)
#define PM_CPUSEL_MASK _U_(0x07)

/* -------- PM_APBASEL : (PM Offset: 0x09) (R/W  8) APBA Clock Select -------- */

typedef union {
  struct {
    uint8_t APBADIV:3; /*!< bit:  0.. 2  APBA Prescaler Selection           */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_APBASEL_Type;


#define PM_APBASEL_OFFSET 0x09
#define PM_APBASEL_RESETVALUE _U_(0x00)

#define PM_APBASEL_APBADIV_Pos 0
#define PM_APBASEL_APBADIV_Msk (_U_(0x7) << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV(value) (PM_APBASEL_APBADIV_Msk & ((value) << PM_APBASEL_APBADIV_Pos))
#define PM_APBASEL_APBADIV_DIV1_Val _U_(0x0)
#define PM_APBASEL_APBADIV_DIV2_Val _U_(0x1)
#define PM_APBASEL_APBADIV_DIV4_Val _U_(0x2)
#define PM_APBASEL_APBADIV_DIV8_Val _U_(0x3)
#define PM_APBASEL_APBADIV_DIV16_Val _U_(0x4)
#define PM_APBASEL_APBADIV_DIV32_Val _U_(0x5)
#define PM_APBASEL_APBADIV_DIV64_Val _U_(0x6)
#define PM_APBASEL_APBADIV_DIV128_Val _U_(0x7)
#define PM_APBASEL_APBADIV_DIV1 (PM_APBASEL_APBADIV_DIV1_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV_DIV2 (PM_APBASEL_APBADIV_DIV2_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV_DIV4 (PM_APBASEL_APBADIV_DIV4_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV_DIV8 (PM_APBASEL_APBADIV_DIV8_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV_DIV16 (PM_APBASEL_APBADIV_DIV16_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV_DIV32 (PM_APBASEL_APBADIV_DIV32_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV_DIV64 (PM_APBASEL_APBADIV_DIV64_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_APBADIV_DIV128 (PM_APBASEL_APBADIV_DIV128_Val << PM_APBASEL_APBADIV_Pos)
#define PM_APBASEL_MASK _U_(0x07)

/* -------- PM_APBBSEL : (PM Offset: 0x0A) (R/W  8) APBB Clock Select -------- */

typedef union {
  struct {
    uint8_t APBBDIV:3; /*!< bit:  0.. 2  APBB Prescaler Selection           */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_APBBSEL_Type;


#define PM_APBBSEL_OFFSET 0x0A
#define PM_APBBSEL_RESETVALUE _U_(0x00)

#define PM_APBBSEL_APBBDIV_Pos 0
#define PM_APBBSEL_APBBDIV_Msk (_U_(0x7) << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV(value) (PM_APBBSEL_APBBDIV_Msk & ((value) << PM_APBBSEL_APBBDIV_Pos))
#define PM_APBBSEL_APBBDIV_DIV1_Val _U_(0x0)
#define PM_APBBSEL_APBBDIV_DIV2_Val _U_(0x1)
#define PM_APBBSEL_APBBDIV_DIV4_Val _U_(0x2)
#define PM_APBBSEL_APBBDIV_DIV8_Val _U_(0x3)
#define PM_APBBSEL_APBBDIV_DIV16_Val _U_(0x4)
#define PM_APBBSEL_APBBDIV_DIV32_Val _U_(0x5)
#define PM_APBBSEL_APBBDIV_DIV64_Val _U_(0x6)
#define PM_APBBSEL_APBBDIV_DIV128_Val _U_(0x7)
#define PM_APBBSEL_APBBDIV_DIV1 (PM_APBBSEL_APBBDIV_DIV1_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV_DIV2 (PM_APBBSEL_APBBDIV_DIV2_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV_DIV4 (PM_APBBSEL_APBBDIV_DIV4_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV_DIV8 (PM_APBBSEL_APBBDIV_DIV8_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV_DIV16 (PM_APBBSEL_APBBDIV_DIV16_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV_DIV32 (PM_APBBSEL_APBBDIV_DIV32_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV_DIV64 (PM_APBBSEL_APBBDIV_DIV64_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_APBBDIV_DIV128 (PM_APBBSEL_APBBDIV_DIV128_Val << PM_APBBSEL_APBBDIV_Pos)
#define PM_APBBSEL_MASK _U_(0x07)

/* -------- PM_APBCSEL : (PM Offset: 0x0B) (R/W  8) APBC Clock Select -------- */

typedef union {
  struct {
    uint8_t APBCDIV:3; /*!< bit:  0.. 2  APBC Prescaler Selection           */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_APBCSEL_Type;


#define PM_APBCSEL_OFFSET 0x0B
#define PM_APBCSEL_RESETVALUE _U_(0x00)

#define PM_APBCSEL_APBCDIV_Pos 0
#define PM_APBCSEL_APBCDIV_Msk (_U_(0x7) << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV(value) (PM_APBCSEL_APBCDIV_Msk & ((value) << PM_APBCSEL_APBCDIV_Pos))
#define PM_APBCSEL_APBCDIV_DIV1_Val _U_(0x0)
#define PM_APBCSEL_APBCDIV_DIV2_Val _U_(0x1)
#define PM_APBCSEL_APBCDIV_DIV4_Val _U_(0x2)
#define PM_APBCSEL_APBCDIV_DIV8_Val _U_(0x3)
#define PM_APBCSEL_APBCDIV_DIV16_Val _U_(0x4)
#define PM_APBCSEL_APBCDIV_DIV32_Val _U_(0x5)
#define PM_APBCSEL_APBCDIV_DIV64_Val _U_(0x6)
#define PM_APBCSEL_APBCDIV_DIV128_Val _U_(0x7)
#define PM_APBCSEL_APBCDIV_DIV1 (PM_APBCSEL_APBCDIV_DIV1_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV_DIV2 (PM_APBCSEL_APBCDIV_DIV2_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV_DIV4 (PM_APBCSEL_APBCDIV_DIV4_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV_DIV8 (PM_APBCSEL_APBCDIV_DIV8_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV_DIV16 (PM_APBCSEL_APBCDIV_DIV16_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV_DIV32 (PM_APBCSEL_APBCDIV_DIV32_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV_DIV64 (PM_APBCSEL_APBCDIV_DIV64_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_APBCDIV_DIV128 (PM_APBCSEL_APBCDIV_DIV128_Val << PM_APBCSEL_APBCDIV_Pos)
#define PM_APBCSEL_MASK _U_(0x07)

/* -------- PM_AHBMASK : (PM Offset: 0x14) (R/W 32) AHB Mask -------- */

typedef union {
  struct {
    uint32_t HPB0_:1; /*!< bit:      0  HPB0 AHB Clock Mask                */
    uint32_t HPB1_:1; /*!< bit:      1  HPB1 AHB Clock Mask                */
    uint32_t HPB2_:1; /*!< bit:      2  HPB2 AHB Clock Mask                */
    uint32_t DSU_:1; /*!< bit:      3  DSU AHB Clock Mask                 */
    uint32_t NVMCTRL_:1; /*!< bit:      4  NVMCTRL AHB Clock Mask             */
    uint32_t DMAC_:1; /*!< bit:      5  DMAC AHB Clock Mask                */
    uint32_t USB_:1; /*!< bit:      6  USB AHB Clock Mask                 */
    uint32_t :25; /*!< bit:  7..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PM_AHBMASK_Type;


#define PM_AHBMASK_OFFSET 0x14
#define PM_AHBMASK_RESETVALUE _U_(0x0000007F)

#define PM_AHBMASK_HPB0_Pos 0
#define PM_AHBMASK_HPB0 (_U_(0x1) << PM_AHBMASK_HPB0_Pos)
#define PM_AHBMASK_HPB1_Pos 1
#define PM_AHBMASK_HPB1 (_U_(0x1) << PM_AHBMASK_HPB1_Pos)
#define PM_AHBMASK_HPB2_Pos 2
#define PM_AHBMASK_HPB2 (_U_(0x1) << PM_AHBMASK_HPB2_Pos)
#define PM_AHBMASK_DSU_Pos 3
#define PM_AHBMASK_DSU (_U_(0x1) << PM_AHBMASK_DSU_Pos)
#define PM_AHBMASK_NVMCTRL_Pos 4
#define PM_AHBMASK_NVMCTRL (_U_(0x1) << PM_AHBMASK_NVMCTRL_Pos)
#define PM_AHBMASK_DMAC_Pos 5
#define PM_AHBMASK_DMAC (_U_(0x1) << PM_AHBMASK_DMAC_Pos)
#define PM_AHBMASK_USB_Pos 6
#define PM_AHBMASK_USB (_U_(0x1) << PM_AHBMASK_USB_Pos)
#define PM_AHBMASK_MASK _U_(0x0000007F)

/* -------- PM_APBAMASK : (PM Offset: 0x18) (R/W 32) APBA Mask -------- */

typedef union {
  struct {
    uint32_t PAC0_:1; /*!< bit:      0  PAC0 APB Clock Enable              */
    uint32_t PM_:1; /*!< bit:      1  PM APB Clock Enable                */
    uint32_t SYSCTRL_:1; /*!< bit:      2  SYSCTRL APB Clock Enable           */
    uint32_t GCLK_:1; /*!< bit:      3  GCLK APB Clock Enable              */
    uint32_t WDT_:1; /*!< bit:      4  WDT APB Clock Enable               */
    uint32_t RTC_:1; /*!< bit:      5  RTC APB Clock Enable               */
    uint32_t EIC_:1; /*!< bit:      6  EIC APB Clock Enable               */
    uint32_t :25; /*!< bit:  7..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PM_APBAMASK_Type;


#define PM_APBAMASK_OFFSET 0x18
#define PM_APBAMASK_RESETVALUE _U_(0x0000007F)

#define PM_APBAMASK_PAC0_Pos 0
#define PM_APBAMASK_PAC0 (_U_(0x1) << PM_APBAMASK_PAC0_Pos)
#define PM_APBAMASK_PM_Pos 1
#define PM_APBAMASK_PM (_U_(0x1) << PM_APBAMASK_PM_Pos)
#define PM_APBAMASK_SYSCTRL_Pos 2
#define PM_APBAMASK_SYSCTRL (_U_(0x1) << PM_APBAMASK_SYSCTRL_Pos)
#define PM_APBAMASK_GCLK_Pos 3
#define PM_APBAMASK_GCLK (_U_(0x1) << PM_APBAMASK_GCLK_Pos)
#define PM_APBAMASK_WDT_Pos 4
#define PM_APBAMASK_WDT (_U_(0x1) << PM_APBAMASK_WDT_Pos)
#define PM_APBAMASK_RTC_Pos 5
#define PM_APBAMASK_RTC (_U_(0x1) << PM_APBAMASK_RTC_Pos)
#define PM_APBAMASK_EIC_Pos 6
#define PM_APBAMASK_EIC (_U_(0x1) << PM_APBAMASK_EIC_Pos)
#define PM_APBAMASK_MASK _U_(0x0000007F)

/* -------- PM_APBBMASK : (PM Offset: 0x1C) (R/W 32) APBB Mask -------- */

typedef union {
  struct {
    uint32_t PAC1_:1; /*!< bit:      0  PAC1 APB Clock Enable              */
    uint32_t DSU_:1; /*!< bit:      1  DSU APB Clock Enable               */
    uint32_t NVMCTRL_:1; /*!< bit:      2  NVMCTRL APB Clock Enable           */
    uint32_t PORT_:1; /*!< bit:      3  PORT APB Clock Enable              */
    uint32_t DMAC_:1; /*!< bit:      4  DMAC APB Clock Enable              */
    uint32_t USB_:1; /*!< bit:      5  USB APB Clock Enable               */
    uint32_t HMATRIX_:1; /*!< bit:      6  HMATRIX APB Clock Enable           */
    uint32_t :25; /*!< bit:  7..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PM_APBBMASK_Type;


#define PM_APBBMASK_OFFSET 0x1C
#define PM_APBBMASK_RESETVALUE _U_(0x0000007F)

#define PM_APBBMASK_PAC1_Pos 0
#define PM_APBBMASK_PAC1 (_U_(0x1) << PM_APBBMASK_PAC1_Pos)
#define PM_APBBMASK_DSU_Pos 1
#define PM_APBBMASK_DSU (_U_(0x1) << PM_APBBMASK_DSU_Pos)
#define PM_APBBMASK_NVMCTRL_Pos 2
#define PM_APBBMASK_NVMCTRL (_U_(0x1) << PM_APBBMASK_NVMCTRL_Pos)
#define PM_APBBMASK_PORT_Pos 3
#define PM_APBBMASK_PORT (_U_(0x1) << PM_APBBMASK_PORT_Pos)
#define PM_APBBMASK_DMAC_Pos 4
#define PM_APBBMASK_DMAC (_U_(0x1) << PM_APBBMASK_DMAC_Pos)
#define PM_APBBMASK_USB_Pos 5
#define PM_APBBMASK_USB (_U_(0x1) << PM_APBBMASK_USB_Pos)
#define PM_APBBMASK_HMATRIX_Pos 6
#define PM_APBBMASK_HMATRIX (_U_(0x1) << PM_APBBMASK_HMATRIX_Pos)
#define PM_APBBMASK_MASK _U_(0x0000007F)

/* -------- PM_APBCMASK : (PM Offset: 0x20) (R/W 32) APBC Mask -------- */

typedef union {
  struct {
    uint32_t PAC2_:1; /*!< bit:      0  PAC2 APB Clock Enable              */
    uint32_t EVSYS_:1; /*!< bit:      1  EVSYS APB Clock Enable             */
    uint32_t SERCOM0_:1; /*!< bit:      2  SERCOM0 APB Clock Enable           */
    uint32_t SERCOM1_:1; /*!< bit:      3  SERCOM1 APB Clock Enable           */
    uint32_t SERCOM2_:1; /*!< bit:      4  SERCOM2 APB Clock Enable           */
    uint32_t SERCOM3_:1; /*!< bit:      5  SERCOM3 APB Clock Enable           */
    uint32_t SERCOM4_:1; /*!< bit:      6  SERCOM4 APB Clock Enable           */
    uint32_t SERCOM5_:1; /*!< bit:      7  SERCOM5 APB Clock Enable           */
    uint32_t TCC0_:1; /*!< bit:      8  TCC0 APB Clock Enable              */
    uint32_t TCC1_:1; /*!< bit:      9  TCC1 APB Clock Enable              */
    uint32_t TCC2_:1; /*!< bit:     10  TCC2 APB Clock Enable              */
    uint32_t TC3_:1; /*!< bit:     11  TC3 APB Clock Enable               */
    uint32_t TC4_:1; /*!< bit:     12  TC4 APB Clock Enable               */
    uint32_t TC5_:1; /*!< bit:     13  TC5 APB Clock Enable               */
    uint32_t TC6_:1; /*!< bit:     14  TC6 APB Clock Enable               */
    uint32_t TC7_:1; /*!< bit:     15  TC7 APB Clock Enable               */
    uint32_t ADC_:1; /*!< bit:     16  ADC APB Clock Enable               */
    uint32_t AC_:1; /*!< bit:     17  AC APB Clock Enable                */
    uint32_t DAC_:1; /*!< bit:     18  DAC APB Clock Enable               */
    uint32_t PTC_:1; /*!< bit:     19  PTC APB Clock Enable               */
    uint32_t I2S_:1; /*!< bit:     20  I2S APB Clock Enable               */
    uint32_t :11; /*!< bit: 21..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PM_APBCMASK_Type;


#define PM_APBCMASK_OFFSET 0x20
#define PM_APBCMASK_RESETVALUE _U_(0x00010000)

#define PM_APBCMASK_PAC2_Pos 0
#define PM_APBCMASK_PAC2 (_U_(0x1) << PM_APBCMASK_PAC2_Pos)
#define PM_APBCMASK_EVSYS_Pos 1
#define PM_APBCMASK_EVSYS (_U_(0x1) << PM_APBCMASK_EVSYS_Pos)
#define PM_APBCMASK_SERCOM0_Pos 2
#define PM_APBCMASK_SERCOM0 (_U_(0x1) << PM_APBCMASK_SERCOM0_Pos)
#define PM_APBCMASK_SERCOM1_Pos 3
#define PM_APBCMASK_SERCOM1 (_U_(0x1) << PM_APBCMASK_SERCOM1_Pos)
#define PM_APBCMASK_SERCOM2_Pos 4
#define PM_APBCMASK_SERCOM2 (_U_(0x1) << PM_APBCMASK_SERCOM2_Pos)
#define PM_APBCMASK_SERCOM3_Pos 5
#define PM_APBCMASK_SERCOM3 (_U_(0x1) << PM_APBCMASK_SERCOM3_Pos)
#define PM_APBCMASK_SERCOM4_Pos 6
#define PM_APBCMASK_SERCOM4 (_U_(0x1) << PM_APBCMASK_SERCOM4_Pos)
#define PM_APBCMASK_SERCOM5_Pos 7
#define PM_APBCMASK_SERCOM5 (_U_(0x1) << PM_APBCMASK_SERCOM5_Pos)
#define PM_APBCMASK_TCC0_Pos 8
#define PM_APBCMASK_TCC0 (_U_(0x1) << PM_APBCMASK_TCC0_Pos)
#define PM_APBCMASK_TCC1_Pos 9
#define PM_APBCMASK_TCC1 (_U_(0x1) << PM_APBCMASK_TCC1_Pos)
#define PM_APBCMASK_TCC2_Pos 10
#define PM_APBCMASK_TCC2 (_U_(0x1) << PM_APBCMASK_TCC2_Pos)
#define PM_APBCMASK_TC3_Pos 11
#define PM_APBCMASK_TC3 (_U_(0x1) << PM_APBCMASK_TC3_Pos)
#define PM_APBCMASK_TC4_Pos 12
#define PM_APBCMASK_TC4 (_U_(0x1) << PM_APBCMASK_TC4_Pos)
#define PM_APBCMASK_TC5_Pos 13
#define PM_APBCMASK_TC5 (_U_(0x1) << PM_APBCMASK_TC5_Pos)
#define PM_APBCMASK_TC6_Pos 14
#define PM_APBCMASK_TC6 (_U_(0x1) << PM_APBCMASK_TC6_Pos)
#define PM_APBCMASK_TC7_Pos 15
#define PM_APBCMASK_TC7 (_U_(0x1) << PM_APBCMASK_TC7_Pos)
#define PM_APBCMASK_ADC_Pos 16
#define PM_APBCMASK_ADC (_U_(0x1) << PM_APBCMASK_ADC_Pos)
#define PM_APBCMASK_AC_Pos 17
#define PM_APBCMASK_AC (_U_(0x1) << PM_APBCMASK_AC_Pos)
#define PM_APBCMASK_DAC_Pos 18
#define PM_APBCMASK_DAC (_U_(0x1) << PM_APBCMASK_DAC_Pos)
#define PM_APBCMASK_PTC_Pos 19
#define PM_APBCMASK_PTC (_U_(0x1) << PM_APBCMASK_PTC_Pos)
#define PM_APBCMASK_I2S_Pos 20
#define PM_APBCMASK_I2S (_U_(0x1) << PM_APBCMASK_I2S_Pos)
#define PM_APBCMASK_MASK _U_(0x001FFFFF)

/* -------- PM_INTENCLR : (PM Offset: 0x34) (R/W  8) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t CKRDY:1; /*!< bit:      0  Clock Ready Interrupt Enable       */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_INTENCLR_Type;


#define PM_INTENCLR_OFFSET 0x34
#define PM_INTENCLR_RESETVALUE _U_(0x00)

#define PM_INTENCLR_CKRDY_Pos 0
#define PM_INTENCLR_CKRDY (_U_(0x1) << PM_INTENCLR_CKRDY_Pos)
#define PM_INTENCLR_MASK _U_(0x01)

/* -------- PM_INTENSET : (PM Offset: 0x35) (R/W  8) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t CKRDY:1; /*!< bit:      0  Clock Ready Interrupt Enable       */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_INTENSET_Type;


#define PM_INTENSET_OFFSET 0x35
#define PM_INTENSET_RESETVALUE _U_(0x00)

#define PM_INTENSET_CKRDY_Pos 0
#define PM_INTENSET_CKRDY (_U_(0x1) << PM_INTENSET_CKRDY_Pos)
#define PM_INTENSET_MASK _U_(0x01)

/* -------- PM_INTFLAG : (PM Offset: 0x36) (R/W  8) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t CKRDY:1; /*!< bit:      0  Clock Ready                        */
    volatile const uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_INTFLAG_Type;


#define PM_INTFLAG_OFFSET 0x36
#define PM_INTFLAG_RESETVALUE _U_(0x00)

#define PM_INTFLAG_CKRDY_Pos 0
#define PM_INTFLAG_CKRDY (_U_(0x1) << PM_INTFLAG_CKRDY_Pos)
#define PM_INTFLAG_MASK _U_(0x01)

/* -------- PM_RCAUSE : (PM Offset: 0x38) (R/   8) Reset Cause -------- */

typedef union {
  struct {
    uint8_t POR:1; /*!< bit:      0  Power On Reset                     */
    uint8_t BOD12:1; /*!< bit:      1  Brown Out 12 Detector Reset        */
    uint8_t BOD33:1; /*!< bit:      2  Brown Out 33 Detector Reset        */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t EXT:1; /*!< bit:      4  External Reset                     */
    uint8_t WDT:1; /*!< bit:      5  Watchdog Reset                     */
    uint8_t SYST:1; /*!< bit:      6  System Reset Request               */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PM_RCAUSE_Type;


#define PM_RCAUSE_OFFSET 0x38
#define PM_RCAUSE_RESETVALUE _U_(0x01)

#define PM_RCAUSE_POR_Pos 0
#define PM_RCAUSE_POR (_U_(0x1) << PM_RCAUSE_POR_Pos)
#define PM_RCAUSE_BOD12_Pos 1
#define PM_RCAUSE_BOD12 (_U_(0x1) << PM_RCAUSE_BOD12_Pos)
#define PM_RCAUSE_BOD33_Pos 2
#define PM_RCAUSE_BOD33 (_U_(0x1) << PM_RCAUSE_BOD33_Pos)
#define PM_RCAUSE_EXT_Pos 4
#define PM_RCAUSE_EXT (_U_(0x1) << PM_RCAUSE_EXT_Pos)
#define PM_RCAUSE_WDT_Pos 5
#define PM_RCAUSE_WDT (_U_(0x1) << PM_RCAUSE_WDT_Pos)
#define PM_RCAUSE_SYST_Pos 6
#define PM_RCAUSE_SYST (_U_(0x1) << PM_RCAUSE_SYST_Pos)
#define PM_RCAUSE_MASK _U_(0x77)

/** \brief PM hardware registers */

typedef struct {
  volatile PM_CTRL_Type CTRL; /**< \brief Offset: 0x00 (R/W  8) Control */
  volatile PM_SLEEP_Type SLEEP; /**< \brief Offset: 0x01 (R/W  8) Sleep Mode */
       RoReg8 Reserved1[0x6];
  volatile PM_CPUSEL_Type CPUSEL; /**< \brief Offset: 0x08 (R/W  8) CPU Clock Select */
  volatile PM_APBASEL_Type APBASEL; /**< \brief Offset: 0x09 (R/W  8) APBA Clock Select */
  volatile PM_APBBSEL_Type APBBSEL; /**< \brief Offset: 0x0A (R/W  8) APBB Clock Select */
  volatile PM_APBCSEL_Type APBCSEL; /**< \brief Offset: 0x0B (R/W  8) APBC Clock Select */
       RoReg8 Reserved2[0x8];
  volatile PM_AHBMASK_Type AHBMASK; /**< \brief Offset: 0x14 (R/W 32) AHB Mask */
  volatile PM_APBAMASK_Type APBAMASK; /**< \brief Offset: 0x18 (R/W 32) APBA Mask */
  volatile PM_APBBMASK_Type APBBMASK; /**< \brief Offset: 0x1C (R/W 32) APBB Mask */
  volatile PM_APBCMASK_Type APBCMASK; /**< \brief Offset: 0x20 (R/W 32) APBC Mask */
       RoReg8 Reserved3[0x10];
  volatile PM_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x34 (R/W  8) Interrupt Enable Clear */
  volatile PM_INTENSET_Type INTENSET; /**< \brief Offset: 0x35 (R/W  8) Interrupt Enable Set */
  volatile PM_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x36 (R/W  8) Interrupt Flag Status and Clear */
       RoReg8 Reserved4[0x1];
  volatile const PM_RCAUSE_Type RCAUSE; /**< \brief Offset: 0x38 (R/   8) Reset Cause */
} Pm;


/*@}*/
# 258 "asf4/samd21/include/samd21e18a.h" 2
#include "component/port.h"
# 258 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/port.h" 1
/**
 * \file
 *
 * \brief Component description for PORT
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PORT_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR PORT */
/* ========================================================================== */
/** \addtogroup SAMD21_PORT Port Module */
/*@{*/

#define PORT_U2210 
#define REV_PORT 0x100

/* -------- PORT_DIR : (PORT Offset: 0x00) (R/W 32) GROUP Data Direction -------- */

typedef union {
  struct {
    uint32_t DIR:32; /*!< bit:  0..31  Port Data Direction                */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_DIR_Type;


#define PORT_DIR_OFFSET 0x00
#define PORT_DIR_RESETVALUE _U_(0x00000000)

#define PORT_DIR_DIR_Pos 0
#define PORT_DIR_DIR_Msk (_U_(0xFFFFFFFF) << PORT_DIR_DIR_Pos)
#define PORT_DIR_DIR(value) (PORT_DIR_DIR_Msk & ((value) << PORT_DIR_DIR_Pos))
#define PORT_DIR_MASK _U_(0xFFFFFFFF)

/* -------- PORT_DIRCLR : (PORT Offset: 0x04) (R/W 32) GROUP Data Direction Clear -------- */

typedef union {
  struct {
    uint32_t DIRCLR:32; /*!< bit:  0..31  Port Data Direction Clear          */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_DIRCLR_Type;


#define PORT_DIRCLR_OFFSET 0x04
#define PORT_DIRCLR_RESETVALUE _U_(0x00000000)

#define PORT_DIRCLR_DIRCLR_Pos 0
#define PORT_DIRCLR_DIRCLR_Msk (_U_(0xFFFFFFFF) << PORT_DIRCLR_DIRCLR_Pos)
#define PORT_DIRCLR_DIRCLR(value) (PORT_DIRCLR_DIRCLR_Msk & ((value) << PORT_DIRCLR_DIRCLR_Pos))
#define PORT_DIRCLR_MASK _U_(0xFFFFFFFF)

/* -------- PORT_DIRSET : (PORT Offset: 0x08) (R/W 32) GROUP Data Direction Set -------- */

typedef union {
  struct {
    uint32_t DIRSET:32; /*!< bit:  0..31  Port Data Direction Set            */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_DIRSET_Type;


#define PORT_DIRSET_OFFSET 0x08
#define PORT_DIRSET_RESETVALUE _U_(0x00000000)

#define PORT_DIRSET_DIRSET_Pos 0
#define PORT_DIRSET_DIRSET_Msk (_U_(0xFFFFFFFF) << PORT_DIRSET_DIRSET_Pos)
#define PORT_DIRSET_DIRSET(value) (PORT_DIRSET_DIRSET_Msk & ((value) << PORT_DIRSET_DIRSET_Pos))
#define PORT_DIRSET_MASK _U_(0xFFFFFFFF)

/* -------- PORT_DIRTGL : (PORT Offset: 0x0C) (R/W 32) GROUP Data Direction Toggle -------- */

typedef union {
  struct {
    uint32_t DIRTGL:32; /*!< bit:  0..31  Port Data Direction Toggle         */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_DIRTGL_Type;


#define PORT_DIRTGL_OFFSET 0x0C
#define PORT_DIRTGL_RESETVALUE _U_(0x00000000)

#define PORT_DIRTGL_DIRTGL_Pos 0
#define PORT_DIRTGL_DIRTGL_Msk (_U_(0xFFFFFFFF) << PORT_DIRTGL_DIRTGL_Pos)
#define PORT_DIRTGL_DIRTGL(value) (PORT_DIRTGL_DIRTGL_Msk & ((value) << PORT_DIRTGL_DIRTGL_Pos))
#define PORT_DIRTGL_MASK _U_(0xFFFFFFFF)

/* -------- PORT_OUT : (PORT Offset: 0x10) (R/W 32) GROUP Data Output Value -------- */

typedef union {
  struct {
    uint32_t OUT:32; /*!< bit:  0..31  Port Data Output Value             */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_OUT_Type;


#define PORT_OUT_OFFSET 0x10
#define PORT_OUT_RESETVALUE _U_(0x00000000)

#define PORT_OUT_OUT_Pos 0
#define PORT_OUT_OUT_Msk (_U_(0xFFFFFFFF) << PORT_OUT_OUT_Pos)
#define PORT_OUT_OUT(value) (PORT_OUT_OUT_Msk & ((value) << PORT_OUT_OUT_Pos))
#define PORT_OUT_MASK _U_(0xFFFFFFFF)

/* -------- PORT_OUTCLR : (PORT Offset: 0x14) (R/W 32) GROUP Data Output Value Clear -------- */

typedef union {
  struct {
    uint32_t OUTCLR:32; /*!< bit:  0..31  Port Data Output Value Clear       */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_OUTCLR_Type;


#define PORT_OUTCLR_OFFSET 0x14
#define PORT_OUTCLR_RESETVALUE _U_(0x00000000)

#define PORT_OUTCLR_OUTCLR_Pos 0
#define PORT_OUTCLR_OUTCLR_Msk (_U_(0xFFFFFFFF) << PORT_OUTCLR_OUTCLR_Pos)
#define PORT_OUTCLR_OUTCLR(value) (PORT_OUTCLR_OUTCLR_Msk & ((value) << PORT_OUTCLR_OUTCLR_Pos))
#define PORT_OUTCLR_MASK _U_(0xFFFFFFFF)

/* -------- PORT_OUTSET : (PORT Offset: 0x18) (R/W 32) GROUP Data Output Value Set -------- */

typedef union {
  struct {
    uint32_t OUTSET:32; /*!< bit:  0..31  Port Data Output Value Set         */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_OUTSET_Type;


#define PORT_OUTSET_OFFSET 0x18
#define PORT_OUTSET_RESETVALUE _U_(0x00000000)

#define PORT_OUTSET_OUTSET_Pos 0
#define PORT_OUTSET_OUTSET_Msk (_U_(0xFFFFFFFF) << PORT_OUTSET_OUTSET_Pos)
#define PORT_OUTSET_OUTSET(value) (PORT_OUTSET_OUTSET_Msk & ((value) << PORT_OUTSET_OUTSET_Pos))
#define PORT_OUTSET_MASK _U_(0xFFFFFFFF)

/* -------- PORT_OUTTGL : (PORT Offset: 0x1C) (R/W 32) GROUP Data Output Value Toggle -------- */

typedef union {
  struct {
    uint32_t OUTTGL:32; /*!< bit:  0..31  Port Data Output Value Toggle      */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_OUTTGL_Type;


#define PORT_OUTTGL_OFFSET 0x1C
#define PORT_OUTTGL_RESETVALUE _U_(0x00000000)

#define PORT_OUTTGL_OUTTGL_Pos 0
#define PORT_OUTTGL_OUTTGL_Msk (_U_(0xFFFFFFFF) << PORT_OUTTGL_OUTTGL_Pos)
#define PORT_OUTTGL_OUTTGL(value) (PORT_OUTTGL_OUTTGL_Msk & ((value) << PORT_OUTTGL_OUTTGL_Pos))
#define PORT_OUTTGL_MASK _U_(0xFFFFFFFF)

/* -------- PORT_IN : (PORT Offset: 0x20) (R/  32) GROUP Data Input Value -------- */

typedef union {
  struct {
    uint32_t IN:32; /*!< bit:  0..31  Port Data Input Value              */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_IN_Type;


#define PORT_IN_OFFSET 0x20
#define PORT_IN_RESETVALUE _U_(0x00000000)

#define PORT_IN_IN_Pos 0
#define PORT_IN_IN_Msk (_U_(0xFFFFFFFF) << PORT_IN_IN_Pos)
#define PORT_IN_IN(value) (PORT_IN_IN_Msk & ((value) << PORT_IN_IN_Pos))
#define PORT_IN_MASK _U_(0xFFFFFFFF)

/* -------- PORT_CTRL : (PORT Offset: 0x24) (R/W 32) GROUP Control -------- */

typedef union {
  struct {
    uint32_t SAMPLING:32; /*!< bit:  0..31  Input Sampling Mode                */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_CTRL_Type;


#define PORT_CTRL_OFFSET 0x24
#define PORT_CTRL_RESETVALUE _U_(0x00000000)

#define PORT_CTRL_SAMPLING_Pos 0
#define PORT_CTRL_SAMPLING_Msk (_U_(0xFFFFFFFF) << PORT_CTRL_SAMPLING_Pos)
#define PORT_CTRL_SAMPLING(value) (PORT_CTRL_SAMPLING_Msk & ((value) << PORT_CTRL_SAMPLING_Pos))
#define PORT_CTRL_MASK _U_(0xFFFFFFFF)

/* -------- PORT_WRCONFIG : (PORT Offset: 0x28) ( /W 32) GROUP Write Configuration -------- */

typedef union {
  struct {
    uint32_t PINMASK:16; /*!< bit:  0..15  Pin Mask for Multiple Pin Configuration */
    uint32_t PMUXEN:1; /*!< bit:     16  Peripheral Multiplexer Enable      */
    uint32_t INEN:1; /*!< bit:     17  Input Enable                       */
    uint32_t PULLEN:1; /*!< bit:     18  Pull Enable                        */
    uint32_t :3; /*!< bit: 19..21  Reserved                           */
    uint32_t DRVSTR:1; /*!< bit:     22  Output Driver Strength Selection   */
    uint32_t :1; /*!< bit:     23  Reserved                           */
    uint32_t PMUX:4; /*!< bit: 24..27  Peripheral Multiplexing            */
    uint32_t WRPMUX:1; /*!< bit:     28  Write PMUX                         */
    uint32_t :1; /*!< bit:     29  Reserved                           */
    uint32_t WRPINCFG:1; /*!< bit:     30  Write PINCFG                       */
    uint32_t HWSEL:1; /*!< bit:     31  Half-Word Select                   */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} PORT_WRCONFIG_Type;


#define PORT_WRCONFIG_OFFSET 0x28
#define PORT_WRCONFIG_RESETVALUE _U_(0x00000000)

#define PORT_WRCONFIG_PINMASK_Pos 0
#define PORT_WRCONFIG_PINMASK_Msk (_U_(0xFFFF) << PORT_WRCONFIG_PINMASK_Pos)
#define PORT_WRCONFIG_PINMASK(value) (PORT_WRCONFIG_PINMASK_Msk & ((value) << PORT_WRCONFIG_PINMASK_Pos))
#define PORT_WRCONFIG_PMUXEN_Pos 16
#define PORT_WRCONFIG_PMUXEN (_U_(0x1) << PORT_WRCONFIG_PMUXEN_Pos)
#define PORT_WRCONFIG_INEN_Pos 17
#define PORT_WRCONFIG_INEN (_U_(0x1) << PORT_WRCONFIG_INEN_Pos)
#define PORT_WRCONFIG_PULLEN_Pos 18
#define PORT_WRCONFIG_PULLEN (_U_(0x1) << PORT_WRCONFIG_PULLEN_Pos)
#define PORT_WRCONFIG_DRVSTR_Pos 22
#define PORT_WRCONFIG_DRVSTR (_U_(0x1) << PORT_WRCONFIG_DRVSTR_Pos)
#define PORT_WRCONFIG_PMUX_Pos 24
#define PORT_WRCONFIG_PMUX_Msk (_U_(0xF) << PORT_WRCONFIG_PMUX_Pos)
#define PORT_WRCONFIG_PMUX(value) (PORT_WRCONFIG_PMUX_Msk & ((value) << PORT_WRCONFIG_PMUX_Pos))
#define PORT_WRCONFIG_WRPMUX_Pos 28
#define PORT_WRCONFIG_WRPMUX (_U_(0x1) << PORT_WRCONFIG_WRPMUX_Pos)
#define PORT_WRCONFIG_WRPINCFG_Pos 30
#define PORT_WRCONFIG_WRPINCFG (_U_(0x1) << PORT_WRCONFIG_WRPINCFG_Pos)
#define PORT_WRCONFIG_HWSEL_Pos 31
#define PORT_WRCONFIG_HWSEL (_U_(0x1) << PORT_WRCONFIG_HWSEL_Pos)
#define PORT_WRCONFIG_MASK _U_(0xDF47FFFF)

/* -------- PORT_PMUX : (PORT Offset: 0x30) (R/W  8) GROUP Peripheral Multiplexing n -------- */

typedef union {
  struct {
    uint8_t PMUXE:4; /*!< bit:  0.. 3  Peripheral Multiplexing Even       */
    uint8_t PMUXO:4; /*!< bit:  4.. 7  Peripheral Multiplexing Odd        */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PORT_PMUX_Type;


#define PORT_PMUX_OFFSET 0x30
#define PORT_PMUX_RESETVALUE _U_(0x00)

#define PORT_PMUX_PMUXE_Pos 0
#define PORT_PMUX_PMUXE_Msk (_U_(0xF) << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE(value) (PORT_PMUX_PMUXE_Msk & ((value) << PORT_PMUX_PMUXE_Pos))
#define PORT_PMUX_PMUXE_A_Val _U_(0x0)
#define PORT_PMUX_PMUXE_B_Val _U_(0x1)
#define PORT_PMUX_PMUXE_C_Val _U_(0x2)
#define PORT_PMUX_PMUXE_D_Val _U_(0x3)
#define PORT_PMUX_PMUXE_E_Val _U_(0x4)
#define PORT_PMUX_PMUXE_F_Val _U_(0x5)
#define PORT_PMUX_PMUXE_G_Val _U_(0x6)
#define PORT_PMUX_PMUXE_H_Val _U_(0x7)
#define PORT_PMUX_PMUXE_A (PORT_PMUX_PMUXE_A_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE_B (PORT_PMUX_PMUXE_B_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE_C (PORT_PMUX_PMUXE_C_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE_D (PORT_PMUX_PMUXE_D_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE_E (PORT_PMUX_PMUXE_E_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE_F (PORT_PMUX_PMUXE_F_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE_G (PORT_PMUX_PMUXE_G_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXE_H (PORT_PMUX_PMUXE_H_Val << PORT_PMUX_PMUXE_Pos)
#define PORT_PMUX_PMUXO_Pos 4
#define PORT_PMUX_PMUXO_Msk (_U_(0xF) << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO(value) (PORT_PMUX_PMUXO_Msk & ((value) << PORT_PMUX_PMUXO_Pos))
#define PORT_PMUX_PMUXO_A_Val _U_(0x0)
#define PORT_PMUX_PMUXO_B_Val _U_(0x1)
#define PORT_PMUX_PMUXO_C_Val _U_(0x2)
#define PORT_PMUX_PMUXO_D_Val _U_(0x3)
#define PORT_PMUX_PMUXO_E_Val _U_(0x4)
#define PORT_PMUX_PMUXO_F_Val _U_(0x5)
#define PORT_PMUX_PMUXO_G_Val _U_(0x6)
#define PORT_PMUX_PMUXO_H_Val _U_(0x7)
#define PORT_PMUX_PMUXO_A (PORT_PMUX_PMUXO_A_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO_B (PORT_PMUX_PMUXO_B_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO_C (PORT_PMUX_PMUXO_C_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO_D (PORT_PMUX_PMUXO_D_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO_E (PORT_PMUX_PMUXO_E_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO_F (PORT_PMUX_PMUXO_F_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO_G (PORT_PMUX_PMUXO_G_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_PMUXO_H (PORT_PMUX_PMUXO_H_Val << PORT_PMUX_PMUXO_Pos)
#define PORT_PMUX_MASK _U_(0xFF)

/* -------- PORT_PINCFG : (PORT Offset: 0x40) (R/W  8) GROUP Pin Configuration n -------- */

typedef union {
  struct {
    uint8_t PMUXEN:1; /*!< bit:      0  Peripheral Multiplexer Enable      */
    uint8_t INEN:1; /*!< bit:      1  Input Enable                       */
    uint8_t PULLEN:1; /*!< bit:      2  Pull Enable                        */
    uint8_t :3; /*!< bit:  3.. 5  Reserved                           */
    uint8_t DRVSTR:1; /*!< bit:      6  Output Driver Strength Selection   */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} PORT_PINCFG_Type;


#define PORT_PINCFG_OFFSET 0x40
#define PORT_PINCFG_RESETVALUE _U_(0x00)

#define PORT_PINCFG_PMUXEN_Pos 0
#define PORT_PINCFG_PMUXEN (_U_(0x1) << PORT_PINCFG_PMUXEN_Pos)
#define PORT_PINCFG_INEN_Pos 1
#define PORT_PINCFG_INEN (_U_(0x1) << PORT_PINCFG_INEN_Pos)
#define PORT_PINCFG_PULLEN_Pos 2
#define PORT_PINCFG_PULLEN (_U_(0x1) << PORT_PINCFG_PULLEN_Pos)
#define PORT_PINCFG_DRVSTR_Pos 6
#define PORT_PINCFG_DRVSTR (_U_(0x1) << PORT_PINCFG_DRVSTR_Pos)
#define PORT_PINCFG_MASK _U_(0x47)

/** \brief PortGroup hardware registers */

typedef struct {
  volatile PORT_DIR_Type DIR; /**< \brief Offset: 0x00 (R/W 32) Data Direction */
  volatile PORT_DIRCLR_Type DIRCLR; /**< \brief Offset: 0x04 (R/W 32) Data Direction Clear */
  volatile PORT_DIRSET_Type DIRSET; /**< \brief Offset: 0x08 (R/W 32) Data Direction Set */
  volatile PORT_DIRTGL_Type DIRTGL; /**< \brief Offset: 0x0C (R/W 32) Data Direction Toggle */
  volatile PORT_OUT_Type OUT; /**< \brief Offset: 0x10 (R/W 32) Data Output Value */
  volatile PORT_OUTCLR_Type OUTCLR; /**< \brief Offset: 0x14 (R/W 32) Data Output Value Clear */
  volatile PORT_OUTSET_Type OUTSET; /**< \brief Offset: 0x18 (R/W 32) Data Output Value Set */
  volatile PORT_OUTTGL_Type OUTTGL; /**< \brief Offset: 0x1C (R/W 32) Data Output Value Toggle */
  volatile const PORT_IN_Type IN; /**< \brief Offset: 0x20 (R/  32) Data Input Value */
  volatile PORT_CTRL_Type CTRL; /**< \brief Offset: 0x24 (R/W 32) Control */
  volatile PORT_WRCONFIG_Type WRCONFIG; /**< \brief Offset: 0x28 ( /W 32) Write Configuration */
       RoReg8 Reserved1[0x4];
  volatile PORT_PMUX_Type PMUX[16]; /**< \brief Offset: 0x30 (R/W  8) Peripheral Multiplexing n */
  volatile PORT_PINCFG_Type PINCFG[32]; /**< \brief Offset: 0x40 (R/W  8) Pin Configuration n */
       RoReg8 Reserved2[0x20];
} PortGroup;


/** \brief PORT hardware registers */

typedef struct {
       PortGroup Group[2]; /**< \brief Offset: 0x00 PortGroup groups [GROUPS] */
} Port;


/*@}*/
# 259 "asf4/samd21/include/samd21e18a.h" 2
#include "component/rtc.h"
# 259 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/rtc.h" 1
/**
 * \file
 *
 * \brief Component description for RTC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_RTC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR RTC */
/* ========================================================================== */
/** \addtogroup SAMD21_RTC Real-Time Counter */
/*@{*/

#define RTC_U2202 
#define REV_RTC 0x101

/* -------- RTC_MODE0_CTRL : (RTC Offset: 0x00) (R/W 16) MODE0 MODE0 Control -------- */

typedef union {
  struct {
    uint16_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint16_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint16_t MODE:2; /*!< bit:  2.. 3  Operating Mode                     */
    uint16_t :3; /*!< bit:  4.. 6  Reserved                           */
    uint16_t MATCHCLR:1; /*!< bit:      7  Clear on Match                     */
    uint16_t PRESCALER:4; /*!< bit:  8..11  Prescaler                          */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE0_CTRL_Type;


#define RTC_MODE0_CTRL_OFFSET 0x00
#define RTC_MODE0_CTRL_RESETVALUE _U_(0x0000)

#define RTC_MODE0_CTRL_SWRST_Pos 0
#define RTC_MODE0_CTRL_SWRST (_U_(0x1) << RTC_MODE0_CTRL_SWRST_Pos)
#define RTC_MODE0_CTRL_ENABLE_Pos 1
#define RTC_MODE0_CTRL_ENABLE (_U_(0x1) << RTC_MODE0_CTRL_ENABLE_Pos)
#define RTC_MODE0_CTRL_MODE_Pos 2
#define RTC_MODE0_CTRL_MODE_Msk (_U_(0x3) << RTC_MODE0_CTRL_MODE_Pos)
#define RTC_MODE0_CTRL_MODE(value) (RTC_MODE0_CTRL_MODE_Msk & ((value) << RTC_MODE0_CTRL_MODE_Pos))
#define RTC_MODE0_CTRL_MODE_COUNT32_Val _U_(0x0)
#define RTC_MODE0_CTRL_MODE_COUNT16_Val _U_(0x1)
#define RTC_MODE0_CTRL_MODE_CLOCK_Val _U_(0x2)
#define RTC_MODE0_CTRL_MODE_COUNT32 (RTC_MODE0_CTRL_MODE_COUNT32_Val << RTC_MODE0_CTRL_MODE_Pos)
#define RTC_MODE0_CTRL_MODE_COUNT16 (RTC_MODE0_CTRL_MODE_COUNT16_Val << RTC_MODE0_CTRL_MODE_Pos)
#define RTC_MODE0_CTRL_MODE_CLOCK (RTC_MODE0_CTRL_MODE_CLOCK_Val << RTC_MODE0_CTRL_MODE_Pos)
#define RTC_MODE0_CTRL_MATCHCLR_Pos 7
#define RTC_MODE0_CTRL_MATCHCLR (_U_(0x1) << RTC_MODE0_CTRL_MATCHCLR_Pos)
#define RTC_MODE0_CTRL_PRESCALER_Pos 8
#define RTC_MODE0_CTRL_PRESCALER_Msk (_U_(0xF) << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER(value) (RTC_MODE0_CTRL_PRESCALER_Msk & ((value) << RTC_MODE0_CTRL_PRESCALER_Pos))
#define RTC_MODE0_CTRL_PRESCALER_DIV1_Val _U_(0x0)
#define RTC_MODE0_CTRL_PRESCALER_DIV2_Val _U_(0x1)
#define RTC_MODE0_CTRL_PRESCALER_DIV4_Val _U_(0x2)
#define RTC_MODE0_CTRL_PRESCALER_DIV8_Val _U_(0x3)
#define RTC_MODE0_CTRL_PRESCALER_DIV16_Val _U_(0x4)
#define RTC_MODE0_CTRL_PRESCALER_DIV32_Val _U_(0x5)
#define RTC_MODE0_CTRL_PRESCALER_DIV64_Val _U_(0x6)
#define RTC_MODE0_CTRL_PRESCALER_DIV128_Val _U_(0x7)
#define RTC_MODE0_CTRL_PRESCALER_DIV256_Val _U_(0x8)
#define RTC_MODE0_CTRL_PRESCALER_DIV512_Val _U_(0x9)
#define RTC_MODE0_CTRL_PRESCALER_DIV1024_Val _U_(0xA)
#define RTC_MODE0_CTRL_PRESCALER_DIV1 (RTC_MODE0_CTRL_PRESCALER_DIV1_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV2 (RTC_MODE0_CTRL_PRESCALER_DIV2_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV4 (RTC_MODE0_CTRL_PRESCALER_DIV4_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV8 (RTC_MODE0_CTRL_PRESCALER_DIV8_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV16 (RTC_MODE0_CTRL_PRESCALER_DIV16_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV32 (RTC_MODE0_CTRL_PRESCALER_DIV32_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV64 (RTC_MODE0_CTRL_PRESCALER_DIV64_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV128 (RTC_MODE0_CTRL_PRESCALER_DIV128_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV256 (RTC_MODE0_CTRL_PRESCALER_DIV256_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV512 (RTC_MODE0_CTRL_PRESCALER_DIV512_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_PRESCALER_DIV1024 (RTC_MODE0_CTRL_PRESCALER_DIV1024_Val << RTC_MODE0_CTRL_PRESCALER_Pos)
#define RTC_MODE0_CTRL_MASK _U_(0x0F8F)

/* -------- RTC_MODE1_CTRL : (RTC Offset: 0x00) (R/W 16) MODE1 MODE1 Control -------- */

typedef union {
  struct {
    uint16_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint16_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint16_t MODE:2; /*!< bit:  2.. 3  Operating Mode                     */
    uint16_t :4; /*!< bit:  4.. 7  Reserved                           */
    uint16_t PRESCALER:4; /*!< bit:  8..11  Prescaler                          */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE1_CTRL_Type;


#define RTC_MODE1_CTRL_OFFSET 0x00
#define RTC_MODE1_CTRL_RESETVALUE _U_(0x0000)

#define RTC_MODE1_CTRL_SWRST_Pos 0
#define RTC_MODE1_CTRL_SWRST (_U_(0x1) << RTC_MODE1_CTRL_SWRST_Pos)
#define RTC_MODE1_CTRL_ENABLE_Pos 1
#define RTC_MODE1_CTRL_ENABLE (_U_(0x1) << RTC_MODE1_CTRL_ENABLE_Pos)
#define RTC_MODE1_CTRL_MODE_Pos 2
#define RTC_MODE1_CTRL_MODE_Msk (_U_(0x3) << RTC_MODE1_CTRL_MODE_Pos)
#define RTC_MODE1_CTRL_MODE(value) (RTC_MODE1_CTRL_MODE_Msk & ((value) << RTC_MODE1_CTRL_MODE_Pos))
#define RTC_MODE1_CTRL_MODE_COUNT32_Val _U_(0x0)
#define RTC_MODE1_CTRL_MODE_COUNT16_Val _U_(0x1)
#define RTC_MODE1_CTRL_MODE_CLOCK_Val _U_(0x2)
#define RTC_MODE1_CTRL_MODE_COUNT32 (RTC_MODE1_CTRL_MODE_COUNT32_Val << RTC_MODE1_CTRL_MODE_Pos)
#define RTC_MODE1_CTRL_MODE_COUNT16 (RTC_MODE1_CTRL_MODE_COUNT16_Val << RTC_MODE1_CTRL_MODE_Pos)
#define RTC_MODE1_CTRL_MODE_CLOCK (RTC_MODE1_CTRL_MODE_CLOCK_Val << RTC_MODE1_CTRL_MODE_Pos)
#define RTC_MODE1_CTRL_PRESCALER_Pos 8
#define RTC_MODE1_CTRL_PRESCALER_Msk (_U_(0xF) << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER(value) (RTC_MODE1_CTRL_PRESCALER_Msk & ((value) << RTC_MODE1_CTRL_PRESCALER_Pos))
#define RTC_MODE1_CTRL_PRESCALER_DIV1_Val _U_(0x0)
#define RTC_MODE1_CTRL_PRESCALER_DIV2_Val _U_(0x1)
#define RTC_MODE1_CTRL_PRESCALER_DIV4_Val _U_(0x2)
#define RTC_MODE1_CTRL_PRESCALER_DIV8_Val _U_(0x3)
#define RTC_MODE1_CTRL_PRESCALER_DIV16_Val _U_(0x4)
#define RTC_MODE1_CTRL_PRESCALER_DIV32_Val _U_(0x5)
#define RTC_MODE1_CTRL_PRESCALER_DIV64_Val _U_(0x6)
#define RTC_MODE1_CTRL_PRESCALER_DIV128_Val _U_(0x7)
#define RTC_MODE1_CTRL_PRESCALER_DIV256_Val _U_(0x8)
#define RTC_MODE1_CTRL_PRESCALER_DIV512_Val _U_(0x9)
#define RTC_MODE1_CTRL_PRESCALER_DIV1024_Val _U_(0xA)
#define RTC_MODE1_CTRL_PRESCALER_DIV1 (RTC_MODE1_CTRL_PRESCALER_DIV1_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV2 (RTC_MODE1_CTRL_PRESCALER_DIV2_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV4 (RTC_MODE1_CTRL_PRESCALER_DIV4_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV8 (RTC_MODE1_CTRL_PRESCALER_DIV8_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV16 (RTC_MODE1_CTRL_PRESCALER_DIV16_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV32 (RTC_MODE1_CTRL_PRESCALER_DIV32_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV64 (RTC_MODE1_CTRL_PRESCALER_DIV64_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV128 (RTC_MODE1_CTRL_PRESCALER_DIV128_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV256 (RTC_MODE1_CTRL_PRESCALER_DIV256_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV512 (RTC_MODE1_CTRL_PRESCALER_DIV512_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_PRESCALER_DIV1024 (RTC_MODE1_CTRL_PRESCALER_DIV1024_Val << RTC_MODE1_CTRL_PRESCALER_Pos)
#define RTC_MODE1_CTRL_MASK _U_(0x0F0F)

/* -------- RTC_MODE2_CTRL : (RTC Offset: 0x00) (R/W 16) MODE2 MODE2 Control -------- */

typedef union {
  struct {
    uint16_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint16_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint16_t MODE:2; /*!< bit:  2.. 3  Operating Mode                     */
    uint16_t :2; /*!< bit:  4.. 5  Reserved                           */
    uint16_t CLKREP:1; /*!< bit:      6  Clock Representation               */
    uint16_t MATCHCLR:1; /*!< bit:      7  Clear on Match                     */
    uint16_t PRESCALER:4; /*!< bit:  8..11  Prescaler                          */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE2_CTRL_Type;


#define RTC_MODE2_CTRL_OFFSET 0x00
#define RTC_MODE2_CTRL_RESETVALUE _U_(0x0000)

#define RTC_MODE2_CTRL_SWRST_Pos 0
#define RTC_MODE2_CTRL_SWRST (_U_(0x1) << RTC_MODE2_CTRL_SWRST_Pos)
#define RTC_MODE2_CTRL_ENABLE_Pos 1
#define RTC_MODE2_CTRL_ENABLE (_U_(0x1) << RTC_MODE2_CTRL_ENABLE_Pos)
#define RTC_MODE2_CTRL_MODE_Pos 2
#define RTC_MODE2_CTRL_MODE_Msk (_U_(0x3) << RTC_MODE2_CTRL_MODE_Pos)
#define RTC_MODE2_CTRL_MODE(value) (RTC_MODE2_CTRL_MODE_Msk & ((value) << RTC_MODE2_CTRL_MODE_Pos))
#define RTC_MODE2_CTRL_MODE_COUNT32_Val _U_(0x0)
#define RTC_MODE2_CTRL_MODE_COUNT16_Val _U_(0x1)
#define RTC_MODE2_CTRL_MODE_CLOCK_Val _U_(0x2)
#define RTC_MODE2_CTRL_MODE_COUNT32 (RTC_MODE2_CTRL_MODE_COUNT32_Val << RTC_MODE2_CTRL_MODE_Pos)
#define RTC_MODE2_CTRL_MODE_COUNT16 (RTC_MODE2_CTRL_MODE_COUNT16_Val << RTC_MODE2_CTRL_MODE_Pos)
#define RTC_MODE2_CTRL_MODE_CLOCK (RTC_MODE2_CTRL_MODE_CLOCK_Val << RTC_MODE2_CTRL_MODE_Pos)
#define RTC_MODE2_CTRL_CLKREP_Pos 6
#define RTC_MODE2_CTRL_CLKREP (_U_(0x1) << RTC_MODE2_CTRL_CLKREP_Pos)
#define RTC_MODE2_CTRL_MATCHCLR_Pos 7
#define RTC_MODE2_CTRL_MATCHCLR (_U_(0x1) << RTC_MODE2_CTRL_MATCHCLR_Pos)
#define RTC_MODE2_CTRL_PRESCALER_Pos 8
#define RTC_MODE2_CTRL_PRESCALER_Msk (_U_(0xF) << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER(value) (RTC_MODE2_CTRL_PRESCALER_Msk & ((value) << RTC_MODE2_CTRL_PRESCALER_Pos))
#define RTC_MODE2_CTRL_PRESCALER_DIV1_Val _U_(0x0)
#define RTC_MODE2_CTRL_PRESCALER_DIV2_Val _U_(0x1)
#define RTC_MODE2_CTRL_PRESCALER_DIV4_Val _U_(0x2)
#define RTC_MODE2_CTRL_PRESCALER_DIV8_Val _U_(0x3)
#define RTC_MODE2_CTRL_PRESCALER_DIV16_Val _U_(0x4)
#define RTC_MODE2_CTRL_PRESCALER_DIV32_Val _U_(0x5)
#define RTC_MODE2_CTRL_PRESCALER_DIV64_Val _U_(0x6)
#define RTC_MODE2_CTRL_PRESCALER_DIV128_Val _U_(0x7)
#define RTC_MODE2_CTRL_PRESCALER_DIV256_Val _U_(0x8)
#define RTC_MODE2_CTRL_PRESCALER_DIV512_Val _U_(0x9)
#define RTC_MODE2_CTRL_PRESCALER_DIV1024_Val _U_(0xA)
#define RTC_MODE2_CTRL_PRESCALER_DIV1 (RTC_MODE2_CTRL_PRESCALER_DIV1_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV2 (RTC_MODE2_CTRL_PRESCALER_DIV2_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV4 (RTC_MODE2_CTRL_PRESCALER_DIV4_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV8 (RTC_MODE2_CTRL_PRESCALER_DIV8_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV16 (RTC_MODE2_CTRL_PRESCALER_DIV16_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV32 (RTC_MODE2_CTRL_PRESCALER_DIV32_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV64 (RTC_MODE2_CTRL_PRESCALER_DIV64_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV128 (RTC_MODE2_CTRL_PRESCALER_DIV128_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV256 (RTC_MODE2_CTRL_PRESCALER_DIV256_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV512 (RTC_MODE2_CTRL_PRESCALER_DIV512_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_PRESCALER_DIV1024 (RTC_MODE2_CTRL_PRESCALER_DIV1024_Val << RTC_MODE2_CTRL_PRESCALER_Pos)
#define RTC_MODE2_CTRL_MASK _U_(0x0FCF)

/* -------- RTC_READREQ : (RTC Offset: 0x02) (R/W 16) Read Request -------- */

typedef union {
  struct {
    uint16_t ADDR:6; /*!< bit:  0.. 5  Address                            */
    uint16_t :8; /*!< bit:  6..13  Reserved                           */
    uint16_t RCONT:1; /*!< bit:     14  Read Continuously                  */
    uint16_t RREQ:1; /*!< bit:     15  Read Request                       */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_READREQ_Type;


#define RTC_READREQ_OFFSET 0x02
#define RTC_READREQ_RESETVALUE _U_(0x0010)

#define RTC_READREQ_ADDR_Pos 0
#define RTC_READREQ_ADDR_Msk (_U_(0x3F) << RTC_READREQ_ADDR_Pos)
#define RTC_READREQ_ADDR(value) (RTC_READREQ_ADDR_Msk & ((value) << RTC_READREQ_ADDR_Pos))
#define RTC_READREQ_RCONT_Pos 14
#define RTC_READREQ_RCONT (_U_(0x1) << RTC_READREQ_RCONT_Pos)
#define RTC_READREQ_RREQ_Pos 15
#define RTC_READREQ_RREQ (_U_(0x1) << RTC_READREQ_RREQ_Pos)
#define RTC_READREQ_MASK _U_(0xC03F)

/* -------- RTC_MODE0_EVCTRL : (RTC Offset: 0x04) (R/W 16) MODE0 MODE0 Event Control -------- */

typedef union {
  struct {
    uint16_t PEREO0:1; /*!< bit:      0  Periodic Interval 0 Event Output Enable */
    uint16_t PEREO1:1; /*!< bit:      1  Periodic Interval 1 Event Output Enable */
    uint16_t PEREO2:1; /*!< bit:      2  Periodic Interval 2 Event Output Enable */
    uint16_t PEREO3:1; /*!< bit:      3  Periodic Interval 3 Event Output Enable */
    uint16_t PEREO4:1; /*!< bit:      4  Periodic Interval 4 Event Output Enable */
    uint16_t PEREO5:1; /*!< bit:      5  Periodic Interval 5 Event Output Enable */
    uint16_t PEREO6:1; /*!< bit:      6  Periodic Interval 6 Event Output Enable */
    uint16_t PEREO7:1; /*!< bit:      7  Periodic Interval 7 Event Output Enable */
    uint16_t CMPEO0:1; /*!< bit:      8  Compare 0 Event Output Enable      */
    uint16_t :6; /*!< bit:  9..14  Reserved                           */
    uint16_t OVFEO:1; /*!< bit:     15  Overflow Event Output Enable       */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t PEREO:8; /*!< bit:  0.. 7  Periodic Interval x Event Output Enable */
    uint16_t CMPEO:1; /*!< bit:      8  Compare x Event Output Enable      */
    uint16_t :7; /*!< bit:  9..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE0_EVCTRL_Type;


#define RTC_MODE0_EVCTRL_OFFSET 0x04
#define RTC_MODE0_EVCTRL_RESETVALUE _U_(0x0000)

#define RTC_MODE0_EVCTRL_PEREO0_Pos 0
#define RTC_MODE0_EVCTRL_PEREO0 (_U_(1) << RTC_MODE0_EVCTRL_PEREO0_Pos)
#define RTC_MODE0_EVCTRL_PEREO1_Pos 1
#define RTC_MODE0_EVCTRL_PEREO1 (_U_(1) << RTC_MODE0_EVCTRL_PEREO1_Pos)
#define RTC_MODE0_EVCTRL_PEREO2_Pos 2
#define RTC_MODE0_EVCTRL_PEREO2 (_U_(1) << RTC_MODE0_EVCTRL_PEREO2_Pos)
#define RTC_MODE0_EVCTRL_PEREO3_Pos 3
#define RTC_MODE0_EVCTRL_PEREO3 (_U_(1) << RTC_MODE0_EVCTRL_PEREO3_Pos)
#define RTC_MODE0_EVCTRL_PEREO4_Pos 4
#define RTC_MODE0_EVCTRL_PEREO4 (_U_(1) << RTC_MODE0_EVCTRL_PEREO4_Pos)
#define RTC_MODE0_EVCTRL_PEREO5_Pos 5
#define RTC_MODE0_EVCTRL_PEREO5 (_U_(1) << RTC_MODE0_EVCTRL_PEREO5_Pos)
#define RTC_MODE0_EVCTRL_PEREO6_Pos 6
#define RTC_MODE0_EVCTRL_PEREO6 (_U_(1) << RTC_MODE0_EVCTRL_PEREO6_Pos)
#define RTC_MODE0_EVCTRL_PEREO7_Pos 7
#define RTC_MODE0_EVCTRL_PEREO7 (_U_(1) << RTC_MODE0_EVCTRL_PEREO7_Pos)
#define RTC_MODE0_EVCTRL_PEREO_Pos 0
#define RTC_MODE0_EVCTRL_PEREO_Msk (_U_(0xFF) << RTC_MODE0_EVCTRL_PEREO_Pos)
#define RTC_MODE0_EVCTRL_PEREO(value) (RTC_MODE0_EVCTRL_PEREO_Msk & ((value) << RTC_MODE0_EVCTRL_PEREO_Pos))
#define RTC_MODE0_EVCTRL_CMPEO0_Pos 8
#define RTC_MODE0_EVCTRL_CMPEO0 (_U_(1) << RTC_MODE0_EVCTRL_CMPEO0_Pos)
#define RTC_MODE0_EVCTRL_CMPEO_Pos 8
#define RTC_MODE0_EVCTRL_CMPEO_Msk (_U_(0x1) << RTC_MODE0_EVCTRL_CMPEO_Pos)
#define RTC_MODE0_EVCTRL_CMPEO(value) (RTC_MODE0_EVCTRL_CMPEO_Msk & ((value) << RTC_MODE0_EVCTRL_CMPEO_Pos))
#define RTC_MODE0_EVCTRL_OVFEO_Pos 15
#define RTC_MODE0_EVCTRL_OVFEO (_U_(0x1) << RTC_MODE0_EVCTRL_OVFEO_Pos)
#define RTC_MODE0_EVCTRL_MASK _U_(0x81FF)

/* -------- RTC_MODE1_EVCTRL : (RTC Offset: 0x04) (R/W 16) MODE1 MODE1 Event Control -------- */

typedef union {
  struct {
    uint16_t PEREO0:1; /*!< bit:      0  Periodic Interval 0 Event Output Enable */
    uint16_t PEREO1:1; /*!< bit:      1  Periodic Interval 1 Event Output Enable */
    uint16_t PEREO2:1; /*!< bit:      2  Periodic Interval 2 Event Output Enable */
    uint16_t PEREO3:1; /*!< bit:      3  Periodic Interval 3 Event Output Enable */
    uint16_t PEREO4:1; /*!< bit:      4  Periodic Interval 4 Event Output Enable */
    uint16_t PEREO5:1; /*!< bit:      5  Periodic Interval 5 Event Output Enable */
    uint16_t PEREO6:1; /*!< bit:      6  Periodic Interval 6 Event Output Enable */
    uint16_t PEREO7:1; /*!< bit:      7  Periodic Interval 7 Event Output Enable */
    uint16_t CMPEO0:1; /*!< bit:      8  Compare 0 Event Output Enable      */
    uint16_t CMPEO1:1; /*!< bit:      9  Compare 1 Event Output Enable      */
    uint16_t :5; /*!< bit: 10..14  Reserved                           */
    uint16_t OVFEO:1; /*!< bit:     15  Overflow Event Output Enable       */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t PEREO:8; /*!< bit:  0.. 7  Periodic Interval x Event Output Enable */
    uint16_t CMPEO:2; /*!< bit:  8.. 9  Compare x Event Output Enable      */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE1_EVCTRL_Type;


#define RTC_MODE1_EVCTRL_OFFSET 0x04
#define RTC_MODE1_EVCTRL_RESETVALUE _U_(0x0000)

#define RTC_MODE1_EVCTRL_PEREO0_Pos 0
#define RTC_MODE1_EVCTRL_PEREO0 (_U_(1) << RTC_MODE1_EVCTRL_PEREO0_Pos)
#define RTC_MODE1_EVCTRL_PEREO1_Pos 1
#define RTC_MODE1_EVCTRL_PEREO1 (_U_(1) << RTC_MODE1_EVCTRL_PEREO1_Pos)
#define RTC_MODE1_EVCTRL_PEREO2_Pos 2
#define RTC_MODE1_EVCTRL_PEREO2 (_U_(1) << RTC_MODE1_EVCTRL_PEREO2_Pos)
#define RTC_MODE1_EVCTRL_PEREO3_Pos 3
#define RTC_MODE1_EVCTRL_PEREO3 (_U_(1) << RTC_MODE1_EVCTRL_PEREO3_Pos)
#define RTC_MODE1_EVCTRL_PEREO4_Pos 4
#define RTC_MODE1_EVCTRL_PEREO4 (_U_(1) << RTC_MODE1_EVCTRL_PEREO4_Pos)
#define RTC_MODE1_EVCTRL_PEREO5_Pos 5
#define RTC_MODE1_EVCTRL_PEREO5 (_U_(1) << RTC_MODE1_EVCTRL_PEREO5_Pos)
#define RTC_MODE1_EVCTRL_PEREO6_Pos 6
#define RTC_MODE1_EVCTRL_PEREO6 (_U_(1) << RTC_MODE1_EVCTRL_PEREO6_Pos)
#define RTC_MODE1_EVCTRL_PEREO7_Pos 7
#define RTC_MODE1_EVCTRL_PEREO7 (_U_(1) << RTC_MODE1_EVCTRL_PEREO7_Pos)
#define RTC_MODE1_EVCTRL_PEREO_Pos 0
#define RTC_MODE1_EVCTRL_PEREO_Msk (_U_(0xFF) << RTC_MODE1_EVCTRL_PEREO_Pos)
#define RTC_MODE1_EVCTRL_PEREO(value) (RTC_MODE1_EVCTRL_PEREO_Msk & ((value) << RTC_MODE1_EVCTRL_PEREO_Pos))
#define RTC_MODE1_EVCTRL_CMPEO0_Pos 8
#define RTC_MODE1_EVCTRL_CMPEO0 (_U_(1) << RTC_MODE1_EVCTRL_CMPEO0_Pos)
#define RTC_MODE1_EVCTRL_CMPEO1_Pos 9
#define RTC_MODE1_EVCTRL_CMPEO1 (_U_(1) << RTC_MODE1_EVCTRL_CMPEO1_Pos)
#define RTC_MODE1_EVCTRL_CMPEO_Pos 8
#define RTC_MODE1_EVCTRL_CMPEO_Msk (_U_(0x3) << RTC_MODE1_EVCTRL_CMPEO_Pos)
#define RTC_MODE1_EVCTRL_CMPEO(value) (RTC_MODE1_EVCTRL_CMPEO_Msk & ((value) << RTC_MODE1_EVCTRL_CMPEO_Pos))
#define RTC_MODE1_EVCTRL_OVFEO_Pos 15
#define RTC_MODE1_EVCTRL_OVFEO (_U_(0x1) << RTC_MODE1_EVCTRL_OVFEO_Pos)
#define RTC_MODE1_EVCTRL_MASK _U_(0x83FF)

/* -------- RTC_MODE2_EVCTRL : (RTC Offset: 0x04) (R/W 16) MODE2 MODE2 Event Control -------- */

typedef union {
  struct {
    uint16_t PEREO0:1; /*!< bit:      0  Periodic Interval 0 Event Output Enable */
    uint16_t PEREO1:1; /*!< bit:      1  Periodic Interval 1 Event Output Enable */
    uint16_t PEREO2:1; /*!< bit:      2  Periodic Interval 2 Event Output Enable */
    uint16_t PEREO3:1; /*!< bit:      3  Periodic Interval 3 Event Output Enable */
    uint16_t PEREO4:1; /*!< bit:      4  Periodic Interval 4 Event Output Enable */
    uint16_t PEREO5:1; /*!< bit:      5  Periodic Interval 5 Event Output Enable */
    uint16_t PEREO6:1; /*!< bit:      6  Periodic Interval 6 Event Output Enable */
    uint16_t PEREO7:1; /*!< bit:      7  Periodic Interval 7 Event Output Enable */
    uint16_t ALARMEO0:1; /*!< bit:      8  Alarm 0 Event Output Enable        */
    uint16_t :6; /*!< bit:  9..14  Reserved                           */
    uint16_t OVFEO:1; /*!< bit:     15  Overflow Event Output Enable       */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t PEREO:8; /*!< bit:  0.. 7  Periodic Interval x Event Output Enable */
    uint16_t ALARMEO:1; /*!< bit:      8  Alarm x Event Output Enable        */
    uint16_t :7; /*!< bit:  9..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE2_EVCTRL_Type;


#define RTC_MODE2_EVCTRL_OFFSET 0x04
#define RTC_MODE2_EVCTRL_RESETVALUE _U_(0x0000)

#define RTC_MODE2_EVCTRL_PEREO0_Pos 0
#define RTC_MODE2_EVCTRL_PEREO0 (_U_(1) << RTC_MODE2_EVCTRL_PEREO0_Pos)
#define RTC_MODE2_EVCTRL_PEREO1_Pos 1
#define RTC_MODE2_EVCTRL_PEREO1 (_U_(1) << RTC_MODE2_EVCTRL_PEREO1_Pos)
#define RTC_MODE2_EVCTRL_PEREO2_Pos 2
#define RTC_MODE2_EVCTRL_PEREO2 (_U_(1) << RTC_MODE2_EVCTRL_PEREO2_Pos)
#define RTC_MODE2_EVCTRL_PEREO3_Pos 3
#define RTC_MODE2_EVCTRL_PEREO3 (_U_(1) << RTC_MODE2_EVCTRL_PEREO3_Pos)
#define RTC_MODE2_EVCTRL_PEREO4_Pos 4
#define RTC_MODE2_EVCTRL_PEREO4 (_U_(1) << RTC_MODE2_EVCTRL_PEREO4_Pos)
#define RTC_MODE2_EVCTRL_PEREO5_Pos 5
#define RTC_MODE2_EVCTRL_PEREO5 (_U_(1) << RTC_MODE2_EVCTRL_PEREO5_Pos)
#define RTC_MODE2_EVCTRL_PEREO6_Pos 6
#define RTC_MODE2_EVCTRL_PEREO6 (_U_(1) << RTC_MODE2_EVCTRL_PEREO6_Pos)
#define RTC_MODE2_EVCTRL_PEREO7_Pos 7
#define RTC_MODE2_EVCTRL_PEREO7 (_U_(1) << RTC_MODE2_EVCTRL_PEREO7_Pos)
#define RTC_MODE2_EVCTRL_PEREO_Pos 0
#define RTC_MODE2_EVCTRL_PEREO_Msk (_U_(0xFF) << RTC_MODE2_EVCTRL_PEREO_Pos)
#define RTC_MODE2_EVCTRL_PEREO(value) (RTC_MODE2_EVCTRL_PEREO_Msk & ((value) << RTC_MODE2_EVCTRL_PEREO_Pos))
#define RTC_MODE2_EVCTRL_ALARMEO0_Pos 8
#define RTC_MODE2_EVCTRL_ALARMEO0 (_U_(1) << RTC_MODE2_EVCTRL_ALARMEO0_Pos)
#define RTC_MODE2_EVCTRL_ALARMEO_Pos 8
#define RTC_MODE2_EVCTRL_ALARMEO_Msk (_U_(0x1) << RTC_MODE2_EVCTRL_ALARMEO_Pos)
#define RTC_MODE2_EVCTRL_ALARMEO(value) (RTC_MODE2_EVCTRL_ALARMEO_Msk & ((value) << RTC_MODE2_EVCTRL_ALARMEO_Pos))
#define RTC_MODE2_EVCTRL_OVFEO_Pos 15
#define RTC_MODE2_EVCTRL_OVFEO (_U_(0x1) << RTC_MODE2_EVCTRL_OVFEO_Pos)
#define RTC_MODE2_EVCTRL_MASK _U_(0x81FF)

/* -------- RTC_MODE0_INTENCLR : (RTC Offset: 0x06) (R/W  8) MODE0 MODE0 Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t CMP0:1; /*!< bit:      0  Compare 0 Interrupt Enable         */
    uint8_t :5; /*!< bit:  1.. 5  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready Interrupt Enable */
    uint8_t OVF:1; /*!< bit:      7  Overflow Interrupt Enable          */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t CMP:1; /*!< bit:      0  Compare x Interrupt Enable         */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE0_INTENCLR_Type;


#define RTC_MODE0_INTENCLR_OFFSET 0x06
#define RTC_MODE0_INTENCLR_RESETVALUE _U_(0x00)

#define RTC_MODE0_INTENCLR_CMP0_Pos 0
#define RTC_MODE0_INTENCLR_CMP0 (_U_(1) << RTC_MODE0_INTENCLR_CMP0_Pos)
#define RTC_MODE0_INTENCLR_CMP_Pos 0
#define RTC_MODE0_INTENCLR_CMP_Msk (_U_(0x1) << RTC_MODE0_INTENCLR_CMP_Pos)
#define RTC_MODE0_INTENCLR_CMP(value) (RTC_MODE0_INTENCLR_CMP_Msk & ((value) << RTC_MODE0_INTENCLR_CMP_Pos))
#define RTC_MODE0_INTENCLR_SYNCRDY_Pos 6
#define RTC_MODE0_INTENCLR_SYNCRDY (_U_(0x1) << RTC_MODE0_INTENCLR_SYNCRDY_Pos)
#define RTC_MODE0_INTENCLR_OVF_Pos 7
#define RTC_MODE0_INTENCLR_OVF (_U_(0x1) << RTC_MODE0_INTENCLR_OVF_Pos)
#define RTC_MODE0_INTENCLR_MASK _U_(0xC1)

/* -------- RTC_MODE1_INTENCLR : (RTC Offset: 0x06) (R/W  8) MODE1 MODE1 Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t CMP0:1; /*!< bit:      0  Compare 0 Interrupt Enable         */
    uint8_t CMP1:1; /*!< bit:      1  Compare 1 Interrupt Enable         */
    uint8_t :4; /*!< bit:  2.. 5  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready Interrupt Enable */
    uint8_t OVF:1; /*!< bit:      7  Overflow Interrupt Enable          */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t CMP:2; /*!< bit:  0.. 1  Compare x Interrupt Enable         */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE1_INTENCLR_Type;


#define RTC_MODE1_INTENCLR_OFFSET 0x06
#define RTC_MODE1_INTENCLR_RESETVALUE _U_(0x00)

#define RTC_MODE1_INTENCLR_CMP0_Pos 0
#define RTC_MODE1_INTENCLR_CMP0 (_U_(1) << RTC_MODE1_INTENCLR_CMP0_Pos)
#define RTC_MODE1_INTENCLR_CMP1_Pos 1
#define RTC_MODE1_INTENCLR_CMP1 (_U_(1) << RTC_MODE1_INTENCLR_CMP1_Pos)
#define RTC_MODE1_INTENCLR_CMP_Pos 0
#define RTC_MODE1_INTENCLR_CMP_Msk (_U_(0x3) << RTC_MODE1_INTENCLR_CMP_Pos)
#define RTC_MODE1_INTENCLR_CMP(value) (RTC_MODE1_INTENCLR_CMP_Msk & ((value) << RTC_MODE1_INTENCLR_CMP_Pos))
#define RTC_MODE1_INTENCLR_SYNCRDY_Pos 6
#define RTC_MODE1_INTENCLR_SYNCRDY (_U_(0x1) << RTC_MODE1_INTENCLR_SYNCRDY_Pos)
#define RTC_MODE1_INTENCLR_OVF_Pos 7
#define RTC_MODE1_INTENCLR_OVF (_U_(0x1) << RTC_MODE1_INTENCLR_OVF_Pos)
#define RTC_MODE1_INTENCLR_MASK _U_(0xC3)

/* -------- RTC_MODE2_INTENCLR : (RTC Offset: 0x06) (R/W  8) MODE2 MODE2 Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t ALARM0:1; /*!< bit:      0  Alarm 0 Interrupt Enable           */
    uint8_t :5; /*!< bit:  1.. 5  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready Interrupt Enable */
    uint8_t OVF:1; /*!< bit:      7  Overflow Interrupt Enable          */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t ALARM:1; /*!< bit:      0  Alarm x Interrupt Enable           */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE2_INTENCLR_Type;


#define RTC_MODE2_INTENCLR_OFFSET 0x06
#define RTC_MODE2_INTENCLR_RESETVALUE _U_(0x00)

#define RTC_MODE2_INTENCLR_ALARM0_Pos 0
#define RTC_MODE2_INTENCLR_ALARM0 (_U_(1) << RTC_MODE2_INTENCLR_ALARM0_Pos)
#define RTC_MODE2_INTENCLR_ALARM_Pos 0
#define RTC_MODE2_INTENCLR_ALARM_Msk (_U_(0x1) << RTC_MODE2_INTENCLR_ALARM_Pos)
#define RTC_MODE2_INTENCLR_ALARM(value) (RTC_MODE2_INTENCLR_ALARM_Msk & ((value) << RTC_MODE2_INTENCLR_ALARM_Pos))
#define RTC_MODE2_INTENCLR_SYNCRDY_Pos 6
#define RTC_MODE2_INTENCLR_SYNCRDY (_U_(0x1) << RTC_MODE2_INTENCLR_SYNCRDY_Pos)
#define RTC_MODE2_INTENCLR_OVF_Pos 7
#define RTC_MODE2_INTENCLR_OVF (_U_(0x1) << RTC_MODE2_INTENCLR_OVF_Pos)
#define RTC_MODE2_INTENCLR_MASK _U_(0xC1)

/* -------- RTC_MODE0_INTENSET : (RTC Offset: 0x07) (R/W  8) MODE0 MODE0 Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t CMP0:1; /*!< bit:      0  Compare 0 Interrupt Enable         */
    uint8_t :5; /*!< bit:  1.. 5  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready Interrupt Enable */
    uint8_t OVF:1; /*!< bit:      7  Overflow Interrupt Enable          */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t CMP:1; /*!< bit:      0  Compare x Interrupt Enable         */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE0_INTENSET_Type;


#define RTC_MODE0_INTENSET_OFFSET 0x07
#define RTC_MODE0_INTENSET_RESETVALUE _U_(0x00)

#define RTC_MODE0_INTENSET_CMP0_Pos 0
#define RTC_MODE0_INTENSET_CMP0 (_U_(1) << RTC_MODE0_INTENSET_CMP0_Pos)
#define RTC_MODE0_INTENSET_CMP_Pos 0
#define RTC_MODE0_INTENSET_CMP_Msk (_U_(0x1) << RTC_MODE0_INTENSET_CMP_Pos)
#define RTC_MODE0_INTENSET_CMP(value) (RTC_MODE0_INTENSET_CMP_Msk & ((value) << RTC_MODE0_INTENSET_CMP_Pos))
#define RTC_MODE0_INTENSET_SYNCRDY_Pos 6
#define RTC_MODE0_INTENSET_SYNCRDY (_U_(0x1) << RTC_MODE0_INTENSET_SYNCRDY_Pos)
#define RTC_MODE0_INTENSET_OVF_Pos 7
#define RTC_MODE0_INTENSET_OVF (_U_(0x1) << RTC_MODE0_INTENSET_OVF_Pos)
#define RTC_MODE0_INTENSET_MASK _U_(0xC1)

/* -------- RTC_MODE1_INTENSET : (RTC Offset: 0x07) (R/W  8) MODE1 MODE1 Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t CMP0:1; /*!< bit:      0  Compare 0 Interrupt Enable         */
    uint8_t CMP1:1; /*!< bit:      1  Compare 1 Interrupt Enable         */
    uint8_t :4; /*!< bit:  2.. 5  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready Interrupt Enable */
    uint8_t OVF:1; /*!< bit:      7  Overflow Interrupt Enable          */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t CMP:2; /*!< bit:  0.. 1  Compare x Interrupt Enable         */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE1_INTENSET_Type;


#define RTC_MODE1_INTENSET_OFFSET 0x07
#define RTC_MODE1_INTENSET_RESETVALUE _U_(0x00)

#define RTC_MODE1_INTENSET_CMP0_Pos 0
#define RTC_MODE1_INTENSET_CMP0 (_U_(1) << RTC_MODE1_INTENSET_CMP0_Pos)
#define RTC_MODE1_INTENSET_CMP1_Pos 1
#define RTC_MODE1_INTENSET_CMP1 (_U_(1) << RTC_MODE1_INTENSET_CMP1_Pos)
#define RTC_MODE1_INTENSET_CMP_Pos 0
#define RTC_MODE1_INTENSET_CMP_Msk (_U_(0x3) << RTC_MODE1_INTENSET_CMP_Pos)
#define RTC_MODE1_INTENSET_CMP(value) (RTC_MODE1_INTENSET_CMP_Msk & ((value) << RTC_MODE1_INTENSET_CMP_Pos))
#define RTC_MODE1_INTENSET_SYNCRDY_Pos 6
#define RTC_MODE1_INTENSET_SYNCRDY (_U_(0x1) << RTC_MODE1_INTENSET_SYNCRDY_Pos)
#define RTC_MODE1_INTENSET_OVF_Pos 7
#define RTC_MODE1_INTENSET_OVF (_U_(0x1) << RTC_MODE1_INTENSET_OVF_Pos)
#define RTC_MODE1_INTENSET_MASK _U_(0xC3)

/* -------- RTC_MODE2_INTENSET : (RTC Offset: 0x07) (R/W  8) MODE2 MODE2 Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t ALARM0:1; /*!< bit:      0  Alarm 0 Interrupt Enable           */
    uint8_t :5; /*!< bit:  1.. 5  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready Interrupt Enable */
    uint8_t OVF:1; /*!< bit:      7  Overflow Interrupt Enable          */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t ALARM:1; /*!< bit:      0  Alarm x Interrupt Enable           */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE2_INTENSET_Type;


#define RTC_MODE2_INTENSET_OFFSET 0x07
#define RTC_MODE2_INTENSET_RESETVALUE _U_(0x00)

#define RTC_MODE2_INTENSET_ALARM0_Pos 0
#define RTC_MODE2_INTENSET_ALARM0 (_U_(1) << RTC_MODE2_INTENSET_ALARM0_Pos)
#define RTC_MODE2_INTENSET_ALARM_Pos 0
#define RTC_MODE2_INTENSET_ALARM_Msk (_U_(0x1) << RTC_MODE2_INTENSET_ALARM_Pos)
#define RTC_MODE2_INTENSET_ALARM(value) (RTC_MODE2_INTENSET_ALARM_Msk & ((value) << RTC_MODE2_INTENSET_ALARM_Pos))
#define RTC_MODE2_INTENSET_SYNCRDY_Pos 6
#define RTC_MODE2_INTENSET_SYNCRDY (_U_(0x1) << RTC_MODE2_INTENSET_SYNCRDY_Pos)
#define RTC_MODE2_INTENSET_OVF_Pos 7
#define RTC_MODE2_INTENSET_OVF (_U_(0x1) << RTC_MODE2_INTENSET_OVF_Pos)
#define RTC_MODE2_INTENSET_MASK _U_(0xC1)

/* -------- RTC_MODE0_INTFLAG : (RTC Offset: 0x08) (R/W  8) MODE0 MODE0 Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t CMP0:1; /*!< bit:      0  Compare 0                          */
    volatile const uint8_t :5; /*!< bit:  1.. 5  Reserved                           */
    volatile const uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready              */
    volatile const uint8_t OVF:1; /*!< bit:      7  Overflow                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint8_t CMP:1; /*!< bit:      0  Compare x                          */
    volatile const uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE0_INTFLAG_Type;


#define RTC_MODE0_INTFLAG_OFFSET 0x08
#define RTC_MODE0_INTFLAG_RESETVALUE _U_(0x00)

#define RTC_MODE0_INTFLAG_CMP0_Pos 0
#define RTC_MODE0_INTFLAG_CMP0 (_U_(1) << RTC_MODE0_INTFLAG_CMP0_Pos)
#define RTC_MODE0_INTFLAG_CMP_Pos 0
#define RTC_MODE0_INTFLAG_CMP_Msk (_U_(0x1) << RTC_MODE0_INTFLAG_CMP_Pos)
#define RTC_MODE0_INTFLAG_CMP(value) (RTC_MODE0_INTFLAG_CMP_Msk & ((value) << RTC_MODE0_INTFLAG_CMP_Pos))
#define RTC_MODE0_INTFLAG_SYNCRDY_Pos 6
#define RTC_MODE0_INTFLAG_SYNCRDY (_U_(0x1) << RTC_MODE0_INTFLAG_SYNCRDY_Pos)
#define RTC_MODE0_INTFLAG_OVF_Pos 7
#define RTC_MODE0_INTFLAG_OVF (_U_(0x1) << RTC_MODE0_INTFLAG_OVF_Pos)
#define RTC_MODE0_INTFLAG_MASK _U_(0xC1)

/* -------- RTC_MODE1_INTFLAG : (RTC Offset: 0x08) (R/W  8) MODE1 MODE1 Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t CMP0:1; /*!< bit:      0  Compare 0                          */
    volatile const uint8_t CMP1:1; /*!< bit:      1  Compare 1                          */
    volatile const uint8_t :4; /*!< bit:  2.. 5  Reserved                           */
    volatile const uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready              */
    volatile const uint8_t OVF:1; /*!< bit:      7  Overflow                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint8_t CMP:2; /*!< bit:  0.. 1  Compare x                          */
    volatile const uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE1_INTFLAG_Type;


#define RTC_MODE1_INTFLAG_OFFSET 0x08
#define RTC_MODE1_INTFLAG_RESETVALUE _U_(0x00)

#define RTC_MODE1_INTFLAG_CMP0_Pos 0
#define RTC_MODE1_INTFLAG_CMP0 (_U_(1) << RTC_MODE1_INTFLAG_CMP0_Pos)
#define RTC_MODE1_INTFLAG_CMP1_Pos 1
#define RTC_MODE1_INTFLAG_CMP1 (_U_(1) << RTC_MODE1_INTFLAG_CMP1_Pos)
#define RTC_MODE1_INTFLAG_CMP_Pos 0
#define RTC_MODE1_INTFLAG_CMP_Msk (_U_(0x3) << RTC_MODE1_INTFLAG_CMP_Pos)
#define RTC_MODE1_INTFLAG_CMP(value) (RTC_MODE1_INTFLAG_CMP_Msk & ((value) << RTC_MODE1_INTFLAG_CMP_Pos))
#define RTC_MODE1_INTFLAG_SYNCRDY_Pos 6
#define RTC_MODE1_INTFLAG_SYNCRDY (_U_(0x1) << RTC_MODE1_INTFLAG_SYNCRDY_Pos)
#define RTC_MODE1_INTFLAG_OVF_Pos 7
#define RTC_MODE1_INTFLAG_OVF (_U_(0x1) << RTC_MODE1_INTFLAG_OVF_Pos)
#define RTC_MODE1_INTFLAG_MASK _U_(0xC3)

/* -------- RTC_MODE2_INTFLAG : (RTC Offset: 0x08) (R/W  8) MODE2 MODE2 Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t ALARM0:1; /*!< bit:      0  Alarm 0                            */
    volatile const uint8_t :5; /*!< bit:  1.. 5  Reserved                           */
    volatile const uint8_t SYNCRDY:1; /*!< bit:      6  Synchronization Ready              */
    volatile const uint8_t OVF:1; /*!< bit:      7  Overflow                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint8_t ALARM:1; /*!< bit:      0  Alarm x                            */
    volatile const uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE2_INTFLAG_Type;


#define RTC_MODE2_INTFLAG_OFFSET 0x08
#define RTC_MODE2_INTFLAG_RESETVALUE _U_(0x00)

#define RTC_MODE2_INTFLAG_ALARM0_Pos 0
#define RTC_MODE2_INTFLAG_ALARM0 (_U_(1) << RTC_MODE2_INTFLAG_ALARM0_Pos)
#define RTC_MODE2_INTFLAG_ALARM_Pos 0
#define RTC_MODE2_INTFLAG_ALARM_Msk (_U_(0x1) << RTC_MODE2_INTFLAG_ALARM_Pos)
#define RTC_MODE2_INTFLAG_ALARM(value) (RTC_MODE2_INTFLAG_ALARM_Msk & ((value) << RTC_MODE2_INTFLAG_ALARM_Pos))
#define RTC_MODE2_INTFLAG_SYNCRDY_Pos 6
#define RTC_MODE2_INTFLAG_SYNCRDY (_U_(0x1) << RTC_MODE2_INTFLAG_SYNCRDY_Pos)
#define RTC_MODE2_INTFLAG_OVF_Pos 7
#define RTC_MODE2_INTFLAG_OVF (_U_(0x1) << RTC_MODE2_INTFLAG_OVF_Pos)
#define RTC_MODE2_INTFLAG_MASK _U_(0xC1)

/* -------- RTC_STATUS : (RTC Offset: 0x0A) (R/W  8) Status -------- */

typedef union {
  struct {
    uint8_t :7; /*!< bit:  0.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy               */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_STATUS_Type;


#define RTC_STATUS_OFFSET 0x0A
#define RTC_STATUS_RESETVALUE _U_(0x00)

#define RTC_STATUS_SYNCBUSY_Pos 7
#define RTC_STATUS_SYNCBUSY (_U_(0x1) << RTC_STATUS_SYNCBUSY_Pos)
#define RTC_STATUS_MASK _U_(0x80)

/* -------- RTC_DBGCTRL : (RTC Offset: 0x0B) (R/W  8) Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGRUN:1; /*!< bit:      0  Run During Debug                   */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_DBGCTRL_Type;


#define RTC_DBGCTRL_OFFSET 0x0B
#define RTC_DBGCTRL_RESETVALUE _U_(0x00)

#define RTC_DBGCTRL_DBGRUN_Pos 0
#define RTC_DBGCTRL_DBGRUN (_U_(0x1) << RTC_DBGCTRL_DBGRUN_Pos)
#define RTC_DBGCTRL_MASK _U_(0x01)

/* -------- RTC_FREQCORR : (RTC Offset: 0x0C) (R/W  8) Frequency Correction -------- */

typedef union {
  struct {
    uint8_t VALUE:7; /*!< bit:  0.. 6  Correction Value                   */
    uint8_t SIGN:1; /*!< bit:      7  Correction Sign                    */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_FREQCORR_Type;


#define RTC_FREQCORR_OFFSET 0x0C
#define RTC_FREQCORR_RESETVALUE _U_(0x00)

#define RTC_FREQCORR_VALUE_Pos 0
#define RTC_FREQCORR_VALUE_Msk (_U_(0x7F) << RTC_FREQCORR_VALUE_Pos)
#define RTC_FREQCORR_VALUE(value) (RTC_FREQCORR_VALUE_Msk & ((value) << RTC_FREQCORR_VALUE_Pos))
#define RTC_FREQCORR_SIGN_Pos 7
#define RTC_FREQCORR_SIGN (_U_(0x1) << RTC_FREQCORR_SIGN_Pos)
#define RTC_FREQCORR_MASK _U_(0xFF)

/* -------- RTC_MODE0_COUNT : (RTC Offset: 0x10) (R/W 32) MODE0 MODE0 Counter Value -------- */

typedef union {
  struct {
    uint32_t COUNT:32; /*!< bit:  0..31  Counter Value                      */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} RTC_MODE0_COUNT_Type;


#define RTC_MODE0_COUNT_OFFSET 0x10
#define RTC_MODE0_COUNT_RESETVALUE _U_(0x00000000)

#define RTC_MODE0_COUNT_COUNT_Pos 0
#define RTC_MODE0_COUNT_COUNT_Msk (_U_(0xFFFFFFFF) << RTC_MODE0_COUNT_COUNT_Pos)
#define RTC_MODE0_COUNT_COUNT(value) (RTC_MODE0_COUNT_COUNT_Msk & ((value) << RTC_MODE0_COUNT_COUNT_Pos))
#define RTC_MODE0_COUNT_MASK _U_(0xFFFFFFFF)

/* -------- RTC_MODE1_COUNT : (RTC Offset: 0x10) (R/W 16) MODE1 MODE1 Counter Value -------- */

typedef union {
  struct {
    uint16_t COUNT:16; /*!< bit:  0..15  Counter Value                      */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE1_COUNT_Type;


#define RTC_MODE1_COUNT_OFFSET 0x10
#define RTC_MODE1_COUNT_RESETVALUE _U_(0x0000)

#define RTC_MODE1_COUNT_COUNT_Pos 0
#define RTC_MODE1_COUNT_COUNT_Msk (_U_(0xFFFF) << RTC_MODE1_COUNT_COUNT_Pos)
#define RTC_MODE1_COUNT_COUNT(value) (RTC_MODE1_COUNT_COUNT_Msk & ((value) << RTC_MODE1_COUNT_COUNT_Pos))
#define RTC_MODE1_COUNT_MASK _U_(0xFFFF)

/* -------- RTC_MODE2_CLOCK : (RTC Offset: 0x10) (R/W 32) MODE2 MODE2 Clock Value -------- */

typedef union {
  struct {
    uint32_t SECOND:6; /*!< bit:  0.. 5  Second                             */
    uint32_t MINUTE:6; /*!< bit:  6..11  Minute                             */
    uint32_t HOUR:5; /*!< bit: 12..16  Hour                               */
    uint32_t DAY:5; /*!< bit: 17..21  Day                                */
    uint32_t MONTH:4; /*!< bit: 22..25  Month                              */
    uint32_t YEAR:6; /*!< bit: 26..31  Year                               */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} RTC_MODE2_CLOCK_Type;


#define RTC_MODE2_CLOCK_OFFSET 0x10
#define RTC_MODE2_CLOCK_RESETVALUE _U_(0x00000000)

#define RTC_MODE2_CLOCK_SECOND_Pos 0
#define RTC_MODE2_CLOCK_SECOND_Msk (_U_(0x3F) << RTC_MODE2_CLOCK_SECOND_Pos)
#define RTC_MODE2_CLOCK_SECOND(value) (RTC_MODE2_CLOCK_SECOND_Msk & ((value) << RTC_MODE2_CLOCK_SECOND_Pos))
#define RTC_MODE2_CLOCK_MINUTE_Pos 6
#define RTC_MODE2_CLOCK_MINUTE_Msk (_U_(0x3F) << RTC_MODE2_CLOCK_MINUTE_Pos)
#define RTC_MODE2_CLOCK_MINUTE(value) (RTC_MODE2_CLOCK_MINUTE_Msk & ((value) << RTC_MODE2_CLOCK_MINUTE_Pos))
#define RTC_MODE2_CLOCK_HOUR_Pos 12
#define RTC_MODE2_CLOCK_HOUR_Msk (_U_(0x1F) << RTC_MODE2_CLOCK_HOUR_Pos)
#define RTC_MODE2_CLOCK_HOUR(value) (RTC_MODE2_CLOCK_HOUR_Msk & ((value) << RTC_MODE2_CLOCK_HOUR_Pos))
#define RTC_MODE2_CLOCK_HOUR_AM_Val _U_(0x0)
#define RTC_MODE2_CLOCK_HOUR_PM_Val _U_(0x10)
#define RTC_MODE2_CLOCK_HOUR_AM (RTC_MODE2_CLOCK_HOUR_AM_Val << RTC_MODE2_CLOCK_HOUR_Pos)
#define RTC_MODE2_CLOCK_HOUR_PM (RTC_MODE2_CLOCK_HOUR_PM_Val << RTC_MODE2_CLOCK_HOUR_Pos)
#define RTC_MODE2_CLOCK_DAY_Pos 17
#define RTC_MODE2_CLOCK_DAY_Msk (_U_(0x1F) << RTC_MODE2_CLOCK_DAY_Pos)
#define RTC_MODE2_CLOCK_DAY(value) (RTC_MODE2_CLOCK_DAY_Msk & ((value) << RTC_MODE2_CLOCK_DAY_Pos))
#define RTC_MODE2_CLOCK_MONTH_Pos 22
#define RTC_MODE2_CLOCK_MONTH_Msk (_U_(0xF) << RTC_MODE2_CLOCK_MONTH_Pos)
#define RTC_MODE2_CLOCK_MONTH(value) (RTC_MODE2_CLOCK_MONTH_Msk & ((value) << RTC_MODE2_CLOCK_MONTH_Pos))
#define RTC_MODE2_CLOCK_YEAR_Pos 26
#define RTC_MODE2_CLOCK_YEAR_Msk (_U_(0x3F) << RTC_MODE2_CLOCK_YEAR_Pos)
#define RTC_MODE2_CLOCK_YEAR(value) (RTC_MODE2_CLOCK_YEAR_Msk & ((value) << RTC_MODE2_CLOCK_YEAR_Pos))
#define RTC_MODE2_CLOCK_MASK _U_(0xFFFFFFFF)

/* -------- RTC_MODE1_PER : (RTC Offset: 0x14) (R/W 16) MODE1 MODE1 Counter Period -------- */

typedef union {
  struct {
    uint16_t PER:16; /*!< bit:  0..15  Counter Period                     */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE1_PER_Type;


#define RTC_MODE1_PER_OFFSET 0x14
#define RTC_MODE1_PER_RESETVALUE _U_(0x0000)

#define RTC_MODE1_PER_PER_Pos 0
#define RTC_MODE1_PER_PER_Msk (_U_(0xFFFF) << RTC_MODE1_PER_PER_Pos)
#define RTC_MODE1_PER_PER(value) (RTC_MODE1_PER_PER_Msk & ((value) << RTC_MODE1_PER_PER_Pos))
#define RTC_MODE1_PER_MASK _U_(0xFFFF)

/* -------- RTC_MODE0_COMP : (RTC Offset: 0x18) (R/W 32) MODE0 MODE0 Compare n Value -------- */

typedef union {
  struct {
    uint32_t COMP:32; /*!< bit:  0..31  Compare Value                      */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} RTC_MODE0_COMP_Type;


#define RTC_MODE0_COMP_OFFSET 0x18
#define RTC_MODE0_COMP_RESETVALUE _U_(0x00000000)

#define RTC_MODE0_COMP_COMP_Pos 0
#define RTC_MODE0_COMP_COMP_Msk (_U_(0xFFFFFFFF) << RTC_MODE0_COMP_COMP_Pos)
#define RTC_MODE0_COMP_COMP(value) (RTC_MODE0_COMP_COMP_Msk & ((value) << RTC_MODE0_COMP_COMP_Pos))
#define RTC_MODE0_COMP_MASK _U_(0xFFFFFFFF)

/* -------- RTC_MODE1_COMP : (RTC Offset: 0x18) (R/W 16) MODE1 MODE1 Compare n Value -------- */

typedef union {
  struct {
    uint16_t COMP:16; /*!< bit:  0..15  Compare Value                      */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} RTC_MODE1_COMP_Type;


#define RTC_MODE1_COMP_OFFSET 0x18
#define RTC_MODE1_COMP_RESETVALUE _U_(0x0000)

#define RTC_MODE1_COMP_COMP_Pos 0
#define RTC_MODE1_COMP_COMP_Msk (_U_(0xFFFF) << RTC_MODE1_COMP_COMP_Pos)
#define RTC_MODE1_COMP_COMP(value) (RTC_MODE1_COMP_COMP_Msk & ((value) << RTC_MODE1_COMP_COMP_Pos))
#define RTC_MODE1_COMP_MASK _U_(0xFFFF)

/* -------- RTC_MODE2_ALARM : (RTC Offset: 0x18) (R/W 32) MODE2 MODE2_ALARM Alarm n Value -------- */

typedef union {
  struct {
    uint32_t SECOND:6; /*!< bit:  0.. 5  Second                             */
    uint32_t MINUTE:6; /*!< bit:  6..11  Minute                             */
    uint32_t HOUR:5; /*!< bit: 12..16  Hour                               */
    uint32_t DAY:5; /*!< bit: 17..21  Day                                */
    uint32_t MONTH:4; /*!< bit: 22..25  Month                              */
    uint32_t YEAR:6; /*!< bit: 26..31  Year                               */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} RTC_MODE2_ALARM_Type;


#define RTC_MODE2_ALARM_OFFSET 0x18
#define RTC_MODE2_ALARM_RESETVALUE _U_(0x00000000)

#define RTC_MODE2_ALARM_SECOND_Pos 0
#define RTC_MODE2_ALARM_SECOND_Msk (_U_(0x3F) << RTC_MODE2_ALARM_SECOND_Pos)
#define RTC_MODE2_ALARM_SECOND(value) (RTC_MODE2_ALARM_SECOND_Msk & ((value) << RTC_MODE2_ALARM_SECOND_Pos))
#define RTC_MODE2_ALARM_MINUTE_Pos 6
#define RTC_MODE2_ALARM_MINUTE_Msk (_U_(0x3F) << RTC_MODE2_ALARM_MINUTE_Pos)
#define RTC_MODE2_ALARM_MINUTE(value) (RTC_MODE2_ALARM_MINUTE_Msk & ((value) << RTC_MODE2_ALARM_MINUTE_Pos))
#define RTC_MODE2_ALARM_HOUR_Pos 12
#define RTC_MODE2_ALARM_HOUR_Msk (_U_(0x1F) << RTC_MODE2_ALARM_HOUR_Pos)
#define RTC_MODE2_ALARM_HOUR(value) (RTC_MODE2_ALARM_HOUR_Msk & ((value) << RTC_MODE2_ALARM_HOUR_Pos))
#define RTC_MODE2_ALARM_HOUR_AM_Val _U_(0x0)
#define RTC_MODE2_ALARM_HOUR_PM_Val _U_(0x10)
#define RTC_MODE2_ALARM_HOUR_AM (RTC_MODE2_ALARM_HOUR_AM_Val << RTC_MODE2_ALARM_HOUR_Pos)
#define RTC_MODE2_ALARM_HOUR_PM (RTC_MODE2_ALARM_HOUR_PM_Val << RTC_MODE2_ALARM_HOUR_Pos)
#define RTC_MODE2_ALARM_DAY_Pos 17
#define RTC_MODE2_ALARM_DAY_Msk (_U_(0x1F) << RTC_MODE2_ALARM_DAY_Pos)
#define RTC_MODE2_ALARM_DAY(value) (RTC_MODE2_ALARM_DAY_Msk & ((value) << RTC_MODE2_ALARM_DAY_Pos))
#define RTC_MODE2_ALARM_MONTH_Pos 22
#define RTC_MODE2_ALARM_MONTH_Msk (_U_(0xF) << RTC_MODE2_ALARM_MONTH_Pos)
#define RTC_MODE2_ALARM_MONTH(value) (RTC_MODE2_ALARM_MONTH_Msk & ((value) << RTC_MODE2_ALARM_MONTH_Pos))
#define RTC_MODE2_ALARM_YEAR_Pos 26
#define RTC_MODE2_ALARM_YEAR_Msk (_U_(0x3F) << RTC_MODE2_ALARM_YEAR_Pos)
#define RTC_MODE2_ALARM_YEAR(value) (RTC_MODE2_ALARM_YEAR_Msk & ((value) << RTC_MODE2_ALARM_YEAR_Pos))
#define RTC_MODE2_ALARM_MASK _U_(0xFFFFFFFF)

/* -------- RTC_MODE2_MASK : (RTC Offset: 0x1C) (R/W  8) MODE2 MODE2_ALARM Alarm n Mask -------- */

typedef union {
  struct {
    uint8_t SEL:3; /*!< bit:  0.. 2  Alarm Mask Selection               */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} RTC_MODE2_MASK_Type;


#define RTC_MODE2_MASK_OFFSET 0x1C
#define RTC_MODE2_MASK_RESETVALUE _U_(0x00)

#define RTC_MODE2_MASK_SEL_Pos 0
#define RTC_MODE2_MASK_SEL_Msk (_U_(0x7) << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_SEL(value) (RTC_MODE2_MASK_SEL_Msk & ((value) << RTC_MODE2_MASK_SEL_Pos))
#define RTC_MODE2_MASK_SEL_OFF_Val _U_(0x0)
#define RTC_MODE2_MASK_SEL_SS_Val _U_(0x1)
#define RTC_MODE2_MASK_SEL_MMSS_Val _U_(0x2)
#define RTC_MODE2_MASK_SEL_HHMMSS_Val _U_(0x3)
#define RTC_MODE2_MASK_SEL_DDHHMMSS_Val _U_(0x4)
#define RTC_MODE2_MASK_SEL_MMDDHHMMSS_Val _U_(0x5)
#define RTC_MODE2_MASK_SEL_YYMMDDHHMMSS_Val _U_(0x6)
#define RTC_MODE2_MASK_SEL_OFF (RTC_MODE2_MASK_SEL_OFF_Val << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_SEL_SS (RTC_MODE2_MASK_SEL_SS_Val << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_SEL_MMSS (RTC_MODE2_MASK_SEL_MMSS_Val << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_SEL_HHMMSS (RTC_MODE2_MASK_SEL_HHMMSS_Val << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_SEL_DDHHMMSS (RTC_MODE2_MASK_SEL_DDHHMMSS_Val << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_SEL_MMDDHHMMSS (RTC_MODE2_MASK_SEL_MMDDHHMMSS_Val << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_SEL_YYMMDDHHMMSS (RTC_MODE2_MASK_SEL_YYMMDDHHMMSS_Val << RTC_MODE2_MASK_SEL_Pos)
#define RTC_MODE2_MASK_MASK _U_(0x07)

/** \brief RtcMode2Alarm hardware registers */

typedef struct {
  volatile RTC_MODE2_ALARM_Type ALARM; /**< \brief Offset: 0x00 (R/W 32) MODE2_ALARM Alarm n Value */
  volatile RTC_MODE2_MASK_Type MASK; /**< \brief Offset: 0x04 (R/W  8) MODE2_ALARM Alarm n Mask */
       RoReg8 Reserved1[0x3];
} RtcMode2Alarm;


/** \brief RTC_MODE0 hardware registers */

typedef struct { /* 32-bit Counter with Single 32-bit Compare */
  volatile RTC_MODE0_CTRL_Type CTRL; /**< \brief Offset: 0x00 (R/W 16) MODE0 Control */
  volatile RTC_READREQ_Type READREQ; /**< \brief Offset: 0x02 (R/W 16) Read Request */
  volatile RTC_MODE0_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x04 (R/W 16) MODE0 Event Control */
  volatile RTC_MODE0_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x06 (R/W  8) MODE0 Interrupt Enable Clear */
  volatile RTC_MODE0_INTENSET_Type INTENSET; /**< \brief Offset: 0x07 (R/W  8) MODE0 Interrupt Enable Set */
  volatile RTC_MODE0_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x08 (R/W  8) MODE0 Interrupt Flag Status and Clear */
       RoReg8 Reserved1[0x1];
  volatile RTC_STATUS_Type STATUS; /**< \brief Offset: 0x0A (R/W  8) Status */
  volatile RTC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x0B (R/W  8) Debug Control */
  volatile RTC_FREQCORR_Type FREQCORR; /**< \brief Offset: 0x0C (R/W  8) Frequency Correction */
       RoReg8 Reserved2[0x3];
  volatile RTC_MODE0_COUNT_Type COUNT; /**< \brief Offset: 0x10 (R/W 32) MODE0 Counter Value */
       RoReg8 Reserved3[0x4];
  volatile RTC_MODE0_COMP_Type COMP[1]; /**< \brief Offset: 0x18 (R/W 32) MODE0 Compare n Value */
} RtcMode0;


/** \brief RTC_MODE1 hardware registers */

typedef struct { /* 16-bit Counter with Two 16-bit Compares */
  volatile RTC_MODE1_CTRL_Type CTRL; /**< \brief Offset: 0x00 (R/W 16) MODE1 Control */
  volatile RTC_READREQ_Type READREQ; /**< \brief Offset: 0x02 (R/W 16) Read Request */
  volatile RTC_MODE1_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x04 (R/W 16) MODE1 Event Control */
  volatile RTC_MODE1_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x06 (R/W  8) MODE1 Interrupt Enable Clear */
  volatile RTC_MODE1_INTENSET_Type INTENSET; /**< \brief Offset: 0x07 (R/W  8) MODE1 Interrupt Enable Set */
  volatile RTC_MODE1_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x08 (R/W  8) MODE1 Interrupt Flag Status and Clear */
       RoReg8 Reserved1[0x1];
  volatile RTC_STATUS_Type STATUS; /**< \brief Offset: 0x0A (R/W  8) Status */
  volatile RTC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x0B (R/W  8) Debug Control */
  volatile RTC_FREQCORR_Type FREQCORR; /**< \brief Offset: 0x0C (R/W  8) Frequency Correction */
       RoReg8 Reserved2[0x3];
  volatile RTC_MODE1_COUNT_Type COUNT; /**< \brief Offset: 0x10 (R/W 16) MODE1 Counter Value */
       RoReg8 Reserved3[0x2];
  volatile RTC_MODE1_PER_Type PER; /**< \brief Offset: 0x14 (R/W 16) MODE1 Counter Period */
       RoReg8 Reserved4[0x2];
  volatile RTC_MODE1_COMP_Type COMP[2]; /**< \brief Offset: 0x18 (R/W 16) MODE1 Compare n Value */
} RtcMode1;


/** \brief RTC_MODE2 hardware registers */

typedef struct { /* Clock/Calendar with Alarm */
  volatile RTC_MODE2_CTRL_Type CTRL; /**< \brief Offset: 0x00 (R/W 16) MODE2 Control */
  volatile RTC_READREQ_Type READREQ; /**< \brief Offset: 0x02 (R/W 16) Read Request */
  volatile RTC_MODE2_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x04 (R/W 16) MODE2 Event Control */
  volatile RTC_MODE2_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x06 (R/W  8) MODE2 Interrupt Enable Clear */
  volatile RTC_MODE2_INTENSET_Type INTENSET; /**< \brief Offset: 0x07 (R/W  8) MODE2 Interrupt Enable Set */
  volatile RTC_MODE2_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x08 (R/W  8) MODE2 Interrupt Flag Status and Clear */
       RoReg8 Reserved1[0x1];
  volatile RTC_STATUS_Type STATUS; /**< \brief Offset: 0x0A (R/W  8) Status */
  volatile RTC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x0B (R/W  8) Debug Control */
  volatile RTC_FREQCORR_Type FREQCORR; /**< \brief Offset: 0x0C (R/W  8) Frequency Correction */
       RoReg8 Reserved2[0x3];
  volatile RTC_MODE2_CLOCK_Type CLOCK; /**< \brief Offset: 0x10 (R/W 32) MODE2 Clock Value */
       RoReg8 Reserved3[0x4];
       RtcMode2Alarm Mode2Alarm[1]; /**< \brief Offset: 0x18 RtcMode2Alarm groups [ALARM_NUM] */
} RtcMode2;



typedef union {
       RtcMode0 MODE0; /**< \brief Offset: 0x00 32-bit Counter with Single 32-bit Compare */
       RtcMode1 MODE1; /**< \brief Offset: 0x00 16-bit Counter with Two 16-bit Compares */
       RtcMode2 MODE2; /**< \brief Offset: 0x00 Clock/Calendar with Alarm */
} Rtc;


/*@}*/
# 260 "asf4/samd21/include/samd21e18a.h" 2
#include "component/sercom.h"
# 260 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/sercom.h" 1
/**
 * \file
 *
 * \brief Component description for SERCOM
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SERCOM_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR SERCOM */
/* ========================================================================== */
/** \addtogroup SAMD21_SERCOM Serial Communication Interface */
/*@{*/

#define SERCOM_U2201 
#define REV_SERCOM 0x200

/* -------- SERCOM_I2CM_CTRLA : (SERCOM Offset: 0x00) (R/W 32) I2CM I2CM Control A -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint32_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint32_t MODE:3; /*!< bit:  2.. 4  Operating Mode                     */
    uint32_t :2; /*!< bit:  5.. 6  Reserved                           */
    uint32_t RUNSTDBY:1; /*!< bit:      7  Run in Standby                     */
    uint32_t :8; /*!< bit:  8..15  Reserved                           */
    uint32_t PINOUT:1; /*!< bit:     16  Pin Usage                          */
    uint32_t :3; /*!< bit: 17..19  Reserved                           */
    uint32_t SDAHOLD:2; /*!< bit: 20..21  SDA Hold Time                      */
    uint32_t MEXTTOEN:1; /*!< bit:     22  Master SCL Low Extend Timeout      */
    uint32_t SEXTTOEN:1; /*!< bit:     23  Slave SCL Low Extend Timeout       */
    uint32_t SPEED:2; /*!< bit: 24..25  Transfer Speed                     */
    uint32_t :1; /*!< bit:     26  Reserved                           */
    uint32_t SCLSM:1; /*!< bit:     27  SCL Clock Stretch Mode             */
    uint32_t INACTOUT:2; /*!< bit: 28..29  Inactive Time-Out                  */
    uint32_t LOWTOUTEN:1; /*!< bit:     30  SCL Low Timeout Enable             */
    uint32_t :1; /*!< bit:     31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_CTRLA_Type;


#define SERCOM_I2CM_CTRLA_OFFSET 0x00
#define SERCOM_I2CM_CTRLA_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CM_CTRLA_SWRST_Pos 0
#define SERCOM_I2CM_CTRLA_SWRST (_U_(0x1) << SERCOM_I2CM_CTRLA_SWRST_Pos)
#define SERCOM_I2CM_CTRLA_ENABLE_Pos 1
#define SERCOM_I2CM_CTRLA_ENABLE (_U_(0x1) << SERCOM_I2CM_CTRLA_ENABLE_Pos)
#define SERCOM_I2CM_CTRLA_MODE_Pos 2
#define SERCOM_I2CM_CTRLA_MODE_Msk (_U_(0x7) << SERCOM_I2CM_CTRLA_MODE_Pos)
#define SERCOM_I2CM_CTRLA_MODE(value) (SERCOM_I2CM_CTRLA_MODE_Msk & ((value) << SERCOM_I2CM_CTRLA_MODE_Pos))
#define SERCOM_I2CM_CTRLA_MODE_USART_EXT_CLK_Val _U_(0x0)
#define SERCOM_I2CM_CTRLA_MODE_USART_INT_CLK_Val _U_(0x1)
#define SERCOM_I2CM_CTRLA_MODE_SPI_SLAVE_Val _U_(0x2)
#define SERCOM_I2CM_CTRLA_MODE_SPI_MASTER_Val _U_(0x3)
#define SERCOM_I2CM_CTRLA_MODE_I2C_SLAVE_Val _U_(0x4)
#define SERCOM_I2CM_CTRLA_MODE_I2C_MASTER_Val _U_(0x5)
#define SERCOM_I2CM_CTRLA_MODE_USART_EXT_CLK (SERCOM_I2CM_CTRLA_MODE_USART_EXT_CLK_Val << SERCOM_I2CM_CTRLA_MODE_Pos)
#define SERCOM_I2CM_CTRLA_MODE_USART_INT_CLK (SERCOM_I2CM_CTRLA_MODE_USART_INT_CLK_Val << SERCOM_I2CM_CTRLA_MODE_Pos)
#define SERCOM_I2CM_CTRLA_MODE_SPI_SLAVE (SERCOM_I2CM_CTRLA_MODE_SPI_SLAVE_Val << SERCOM_I2CM_CTRLA_MODE_Pos)
#define SERCOM_I2CM_CTRLA_MODE_SPI_MASTER (SERCOM_I2CM_CTRLA_MODE_SPI_MASTER_Val << SERCOM_I2CM_CTRLA_MODE_Pos)
#define SERCOM_I2CM_CTRLA_MODE_I2C_SLAVE (SERCOM_I2CM_CTRLA_MODE_I2C_SLAVE_Val << SERCOM_I2CM_CTRLA_MODE_Pos)
#define SERCOM_I2CM_CTRLA_MODE_I2C_MASTER (SERCOM_I2CM_CTRLA_MODE_I2C_MASTER_Val << SERCOM_I2CM_CTRLA_MODE_Pos)
#define SERCOM_I2CM_CTRLA_RUNSTDBY_Pos 7
#define SERCOM_I2CM_CTRLA_RUNSTDBY (_U_(0x1) << SERCOM_I2CM_CTRLA_RUNSTDBY_Pos)
#define SERCOM_I2CM_CTRLA_PINOUT_Pos 16
#define SERCOM_I2CM_CTRLA_PINOUT (_U_(0x1) << SERCOM_I2CM_CTRLA_PINOUT_Pos)
#define SERCOM_I2CM_CTRLA_SDAHOLD_Pos 20
#define SERCOM_I2CM_CTRLA_SDAHOLD_Msk (_U_(0x3) << SERCOM_I2CM_CTRLA_SDAHOLD_Pos)
#define SERCOM_I2CM_CTRLA_SDAHOLD(value) (SERCOM_I2CM_CTRLA_SDAHOLD_Msk & ((value) << SERCOM_I2CM_CTRLA_SDAHOLD_Pos))
#define SERCOM_I2CM_CTRLA_MEXTTOEN_Pos 22
#define SERCOM_I2CM_CTRLA_MEXTTOEN (_U_(0x1) << SERCOM_I2CM_CTRLA_MEXTTOEN_Pos)
#define SERCOM_I2CM_CTRLA_SEXTTOEN_Pos 23
#define SERCOM_I2CM_CTRLA_SEXTTOEN (_U_(0x1) << SERCOM_I2CM_CTRLA_SEXTTOEN_Pos)
#define SERCOM_I2CM_CTRLA_SPEED_Pos 24
#define SERCOM_I2CM_CTRLA_SPEED_Msk (_U_(0x3) << SERCOM_I2CM_CTRLA_SPEED_Pos)
#define SERCOM_I2CM_CTRLA_SPEED(value) (SERCOM_I2CM_CTRLA_SPEED_Msk & ((value) << SERCOM_I2CM_CTRLA_SPEED_Pos))
#define SERCOM_I2CM_CTRLA_SCLSM_Pos 27
#define SERCOM_I2CM_CTRLA_SCLSM (_U_(0x1) << SERCOM_I2CM_CTRLA_SCLSM_Pos)
#define SERCOM_I2CM_CTRLA_INACTOUT_Pos 28
#define SERCOM_I2CM_CTRLA_INACTOUT_Msk (_U_(0x3) << SERCOM_I2CM_CTRLA_INACTOUT_Pos)
#define SERCOM_I2CM_CTRLA_INACTOUT(value) (SERCOM_I2CM_CTRLA_INACTOUT_Msk & ((value) << SERCOM_I2CM_CTRLA_INACTOUT_Pos))
#define SERCOM_I2CM_CTRLA_LOWTOUTEN_Pos 30
#define SERCOM_I2CM_CTRLA_LOWTOUTEN (_U_(0x1) << SERCOM_I2CM_CTRLA_LOWTOUTEN_Pos)
#define SERCOM_I2CM_CTRLA_MASK _U_(0x7BF1009F)

/* -------- SERCOM_I2CS_CTRLA : (SERCOM Offset: 0x00) (R/W 32) I2CS I2CS Control A -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint32_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint32_t MODE:3; /*!< bit:  2.. 4  Operating Mode                     */
    uint32_t :2; /*!< bit:  5.. 6  Reserved                           */
    uint32_t RUNSTDBY:1; /*!< bit:      7  Run during Standby                 */
    uint32_t :8; /*!< bit:  8..15  Reserved                           */
    uint32_t PINOUT:1; /*!< bit:     16  Pin Usage                          */
    uint32_t :3; /*!< bit: 17..19  Reserved                           */
    uint32_t SDAHOLD:2; /*!< bit: 20..21  SDA Hold Time                      */
    uint32_t :1; /*!< bit:     22  Reserved                           */
    uint32_t SEXTTOEN:1; /*!< bit:     23  Slave SCL Low Extend Timeout       */
    uint32_t SPEED:2; /*!< bit: 24..25  Transfer Speed                     */
    uint32_t :1; /*!< bit:     26  Reserved                           */
    uint32_t SCLSM:1; /*!< bit:     27  SCL Clock Stretch Mode             */
    uint32_t :2; /*!< bit: 28..29  Reserved                           */
    uint32_t LOWTOUTEN:1; /*!< bit:     30  SCL Low Timeout Enable             */
    uint32_t :1; /*!< bit:     31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_CTRLA_Type;


#define SERCOM_I2CS_CTRLA_OFFSET 0x00
#define SERCOM_I2CS_CTRLA_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CS_CTRLA_SWRST_Pos 0
#define SERCOM_I2CS_CTRLA_SWRST (_U_(0x1) << SERCOM_I2CS_CTRLA_SWRST_Pos)
#define SERCOM_I2CS_CTRLA_ENABLE_Pos 1
#define SERCOM_I2CS_CTRLA_ENABLE (_U_(0x1) << SERCOM_I2CS_CTRLA_ENABLE_Pos)
#define SERCOM_I2CS_CTRLA_MODE_Pos 2
#define SERCOM_I2CS_CTRLA_MODE_Msk (_U_(0x7) << SERCOM_I2CS_CTRLA_MODE_Pos)
#define SERCOM_I2CS_CTRLA_MODE(value) (SERCOM_I2CS_CTRLA_MODE_Msk & ((value) << SERCOM_I2CS_CTRLA_MODE_Pos))
#define SERCOM_I2CS_CTRLA_MODE_USART_EXT_CLK_Val _U_(0x0)
#define SERCOM_I2CS_CTRLA_MODE_USART_INT_CLK_Val _U_(0x1)
#define SERCOM_I2CS_CTRLA_MODE_SPI_SLAVE_Val _U_(0x2)
#define SERCOM_I2CS_CTRLA_MODE_SPI_MASTER_Val _U_(0x3)
#define SERCOM_I2CS_CTRLA_MODE_I2C_SLAVE_Val _U_(0x4)
#define SERCOM_I2CS_CTRLA_MODE_I2C_MASTER_Val _U_(0x5)
#define SERCOM_I2CS_CTRLA_MODE_USART_EXT_CLK (SERCOM_I2CS_CTRLA_MODE_USART_EXT_CLK_Val << SERCOM_I2CS_CTRLA_MODE_Pos)
#define SERCOM_I2CS_CTRLA_MODE_USART_INT_CLK (SERCOM_I2CS_CTRLA_MODE_USART_INT_CLK_Val << SERCOM_I2CS_CTRLA_MODE_Pos)
#define SERCOM_I2CS_CTRLA_MODE_SPI_SLAVE (SERCOM_I2CS_CTRLA_MODE_SPI_SLAVE_Val << SERCOM_I2CS_CTRLA_MODE_Pos)
#define SERCOM_I2CS_CTRLA_MODE_SPI_MASTER (SERCOM_I2CS_CTRLA_MODE_SPI_MASTER_Val << SERCOM_I2CS_CTRLA_MODE_Pos)
#define SERCOM_I2CS_CTRLA_MODE_I2C_SLAVE (SERCOM_I2CS_CTRLA_MODE_I2C_SLAVE_Val << SERCOM_I2CS_CTRLA_MODE_Pos)
#define SERCOM_I2CS_CTRLA_MODE_I2C_MASTER (SERCOM_I2CS_CTRLA_MODE_I2C_MASTER_Val << SERCOM_I2CS_CTRLA_MODE_Pos)
#define SERCOM_I2CS_CTRLA_RUNSTDBY_Pos 7
#define SERCOM_I2CS_CTRLA_RUNSTDBY (_U_(0x1) << SERCOM_I2CS_CTRLA_RUNSTDBY_Pos)
#define SERCOM_I2CS_CTRLA_PINOUT_Pos 16
#define SERCOM_I2CS_CTRLA_PINOUT (_U_(0x1) << SERCOM_I2CS_CTRLA_PINOUT_Pos)
#define SERCOM_I2CS_CTRLA_SDAHOLD_Pos 20
#define SERCOM_I2CS_CTRLA_SDAHOLD_Msk (_U_(0x3) << SERCOM_I2CS_CTRLA_SDAHOLD_Pos)
#define SERCOM_I2CS_CTRLA_SDAHOLD(value) (SERCOM_I2CS_CTRLA_SDAHOLD_Msk & ((value) << SERCOM_I2CS_CTRLA_SDAHOLD_Pos))
#define SERCOM_I2CS_CTRLA_SEXTTOEN_Pos 23
#define SERCOM_I2CS_CTRLA_SEXTTOEN (_U_(0x1) << SERCOM_I2CS_CTRLA_SEXTTOEN_Pos)
#define SERCOM_I2CS_CTRLA_SPEED_Pos 24
#define SERCOM_I2CS_CTRLA_SPEED_Msk (_U_(0x3) << SERCOM_I2CS_CTRLA_SPEED_Pos)
#define SERCOM_I2CS_CTRLA_SPEED(value) (SERCOM_I2CS_CTRLA_SPEED_Msk & ((value) << SERCOM_I2CS_CTRLA_SPEED_Pos))
#define SERCOM_I2CS_CTRLA_SCLSM_Pos 27
#define SERCOM_I2CS_CTRLA_SCLSM (_U_(0x1) << SERCOM_I2CS_CTRLA_SCLSM_Pos)
#define SERCOM_I2CS_CTRLA_LOWTOUTEN_Pos 30
#define SERCOM_I2CS_CTRLA_LOWTOUTEN (_U_(0x1) << SERCOM_I2CS_CTRLA_LOWTOUTEN_Pos)
#define SERCOM_I2CS_CTRLA_MASK _U_(0x4BB1009F)

/* -------- SERCOM_SPI_CTRLA : (SERCOM Offset: 0x00) (R/W 32) SPI SPI Control A -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint32_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint32_t MODE:3; /*!< bit:  2.. 4  Operating Mode                     */
    uint32_t :2; /*!< bit:  5.. 6  Reserved                           */
    uint32_t RUNSTDBY:1; /*!< bit:      7  Run during Standby                 */
    uint32_t IBON:1; /*!< bit:      8  Immediate Buffer Overflow Notification */
    uint32_t :7; /*!< bit:  9..15  Reserved                           */
    uint32_t DOPO:2; /*!< bit: 16..17  Data Out Pinout                    */
    uint32_t :2; /*!< bit: 18..19  Reserved                           */
    uint32_t DIPO:2; /*!< bit: 20..21  Data In Pinout                     */
    uint32_t :2; /*!< bit: 22..23  Reserved                           */
    uint32_t FORM:4; /*!< bit: 24..27  Frame Format                       */
    uint32_t CPHA:1; /*!< bit:     28  Clock Phase                        */
    uint32_t CPOL:1; /*!< bit:     29  Clock Polarity                     */
    uint32_t DORD:1; /*!< bit:     30  Data Order                         */
    uint32_t :1; /*!< bit:     31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_CTRLA_Type;


#define SERCOM_SPI_CTRLA_OFFSET 0x00
#define SERCOM_SPI_CTRLA_RESETVALUE _U_(0x00000000)

#define SERCOM_SPI_CTRLA_SWRST_Pos 0
#define SERCOM_SPI_CTRLA_SWRST (_U_(0x1) << SERCOM_SPI_CTRLA_SWRST_Pos)
#define SERCOM_SPI_CTRLA_ENABLE_Pos 1
#define SERCOM_SPI_CTRLA_ENABLE (_U_(0x1) << SERCOM_SPI_CTRLA_ENABLE_Pos)
#define SERCOM_SPI_CTRLA_MODE_Pos 2
#define SERCOM_SPI_CTRLA_MODE_Msk (_U_(0x7) << SERCOM_SPI_CTRLA_MODE_Pos)
#define SERCOM_SPI_CTRLA_MODE(value) (SERCOM_SPI_CTRLA_MODE_Msk & ((value) << SERCOM_SPI_CTRLA_MODE_Pos))
#define SERCOM_SPI_CTRLA_MODE_USART_EXT_CLK_Val _U_(0x0)
#define SERCOM_SPI_CTRLA_MODE_USART_INT_CLK_Val _U_(0x1)
#define SERCOM_SPI_CTRLA_MODE_SPI_SLAVE_Val _U_(0x2)
#define SERCOM_SPI_CTRLA_MODE_SPI_MASTER_Val _U_(0x3)
#define SERCOM_SPI_CTRLA_MODE_I2C_SLAVE_Val _U_(0x4)
#define SERCOM_SPI_CTRLA_MODE_I2C_MASTER_Val _U_(0x5)
#define SERCOM_SPI_CTRLA_MODE_USART_EXT_CLK (SERCOM_SPI_CTRLA_MODE_USART_EXT_CLK_Val << SERCOM_SPI_CTRLA_MODE_Pos)
#define SERCOM_SPI_CTRLA_MODE_USART_INT_CLK (SERCOM_SPI_CTRLA_MODE_USART_INT_CLK_Val << SERCOM_SPI_CTRLA_MODE_Pos)
#define SERCOM_SPI_CTRLA_MODE_SPI_SLAVE (SERCOM_SPI_CTRLA_MODE_SPI_SLAVE_Val << SERCOM_SPI_CTRLA_MODE_Pos)
#define SERCOM_SPI_CTRLA_MODE_SPI_MASTER (SERCOM_SPI_CTRLA_MODE_SPI_MASTER_Val << SERCOM_SPI_CTRLA_MODE_Pos)
#define SERCOM_SPI_CTRLA_MODE_I2C_SLAVE (SERCOM_SPI_CTRLA_MODE_I2C_SLAVE_Val << SERCOM_SPI_CTRLA_MODE_Pos)
#define SERCOM_SPI_CTRLA_MODE_I2C_MASTER (SERCOM_SPI_CTRLA_MODE_I2C_MASTER_Val << SERCOM_SPI_CTRLA_MODE_Pos)
#define SERCOM_SPI_CTRLA_RUNSTDBY_Pos 7
#define SERCOM_SPI_CTRLA_RUNSTDBY (_U_(0x1) << SERCOM_SPI_CTRLA_RUNSTDBY_Pos)
#define SERCOM_SPI_CTRLA_IBON_Pos 8
#define SERCOM_SPI_CTRLA_IBON (_U_(0x1) << SERCOM_SPI_CTRLA_IBON_Pos)
#define SERCOM_SPI_CTRLA_DOPO_Pos 16
#define SERCOM_SPI_CTRLA_DOPO_Msk (_U_(0x3) << SERCOM_SPI_CTRLA_DOPO_Pos)
#define SERCOM_SPI_CTRLA_DOPO(value) (SERCOM_SPI_CTRLA_DOPO_Msk & ((value) << SERCOM_SPI_CTRLA_DOPO_Pos))
#define SERCOM_SPI_CTRLA_DIPO_Pos 20
#define SERCOM_SPI_CTRLA_DIPO_Msk (_U_(0x3) << SERCOM_SPI_CTRLA_DIPO_Pos)
#define SERCOM_SPI_CTRLA_DIPO(value) (SERCOM_SPI_CTRLA_DIPO_Msk & ((value) << SERCOM_SPI_CTRLA_DIPO_Pos))
#define SERCOM_SPI_CTRLA_FORM_Pos 24
#define SERCOM_SPI_CTRLA_FORM_Msk (_U_(0xF) << SERCOM_SPI_CTRLA_FORM_Pos)
#define SERCOM_SPI_CTRLA_FORM(value) (SERCOM_SPI_CTRLA_FORM_Msk & ((value) << SERCOM_SPI_CTRLA_FORM_Pos))
#define SERCOM_SPI_CTRLA_CPHA_Pos 28
#define SERCOM_SPI_CTRLA_CPHA (_U_(0x1) << SERCOM_SPI_CTRLA_CPHA_Pos)
#define SERCOM_SPI_CTRLA_CPOL_Pos 29
#define SERCOM_SPI_CTRLA_CPOL (_U_(0x1) << SERCOM_SPI_CTRLA_CPOL_Pos)
#define SERCOM_SPI_CTRLA_DORD_Pos 30
#define SERCOM_SPI_CTRLA_DORD (_U_(0x1) << SERCOM_SPI_CTRLA_DORD_Pos)
#define SERCOM_SPI_CTRLA_MASK _U_(0x7F33019F)

/* -------- SERCOM_USART_CTRLA : (SERCOM Offset: 0x00) (R/W 32) USART USART Control A -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint32_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint32_t MODE:3; /*!< bit:  2.. 4  Operating Mode                     */
    uint32_t :2; /*!< bit:  5.. 6  Reserved                           */
    uint32_t RUNSTDBY:1; /*!< bit:      7  Run during Standby                 */
    uint32_t IBON:1; /*!< bit:      8  Immediate Buffer Overflow Notification */
    uint32_t :4; /*!< bit:  9..12  Reserved                           */
    uint32_t SAMPR:3; /*!< bit: 13..15  Sample                             */
    uint32_t TXPO:2; /*!< bit: 16..17  Transmit Data Pinout               */
    uint32_t :2; /*!< bit: 18..19  Reserved                           */
    uint32_t RXPO:2; /*!< bit: 20..21  Receive Data Pinout                */
    uint32_t SAMPA:2; /*!< bit: 22..23  Sample Adjustment                  */
    uint32_t FORM:4; /*!< bit: 24..27  Frame Format                       */
    uint32_t CMODE:1; /*!< bit:     28  Communication Mode                 */
    uint32_t CPOL:1; /*!< bit:     29  Clock Polarity                     */
    uint32_t DORD:1; /*!< bit:     30  Data Order                         */
    uint32_t :1; /*!< bit:     31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_USART_CTRLA_Type;


#define SERCOM_USART_CTRLA_OFFSET 0x00
#define SERCOM_USART_CTRLA_RESETVALUE _U_(0x00000000)

#define SERCOM_USART_CTRLA_SWRST_Pos 0
#define SERCOM_USART_CTRLA_SWRST (_U_(0x1) << SERCOM_USART_CTRLA_SWRST_Pos)
#define SERCOM_USART_CTRLA_ENABLE_Pos 1
#define SERCOM_USART_CTRLA_ENABLE (_U_(0x1) << SERCOM_USART_CTRLA_ENABLE_Pos)
#define SERCOM_USART_CTRLA_MODE_Pos 2
#define SERCOM_USART_CTRLA_MODE_Msk (_U_(0x7) << SERCOM_USART_CTRLA_MODE_Pos)
#define SERCOM_USART_CTRLA_MODE(value) (SERCOM_USART_CTRLA_MODE_Msk & ((value) << SERCOM_USART_CTRLA_MODE_Pos))
#define SERCOM_USART_CTRLA_MODE_USART_EXT_CLK_Val _U_(0x0)
#define SERCOM_USART_CTRLA_MODE_USART_INT_CLK_Val _U_(0x1)
#define SERCOM_USART_CTRLA_MODE_SPI_SLAVE_Val _U_(0x2)
#define SERCOM_USART_CTRLA_MODE_SPI_MASTER_Val _U_(0x3)
#define SERCOM_USART_CTRLA_MODE_I2C_SLAVE_Val _U_(0x4)
#define SERCOM_USART_CTRLA_MODE_I2C_MASTER_Val _U_(0x5)
#define SERCOM_USART_CTRLA_MODE_USART_EXT_CLK (SERCOM_USART_CTRLA_MODE_USART_EXT_CLK_Val << SERCOM_USART_CTRLA_MODE_Pos)
#define SERCOM_USART_CTRLA_MODE_USART_INT_CLK (SERCOM_USART_CTRLA_MODE_USART_INT_CLK_Val << SERCOM_USART_CTRLA_MODE_Pos)
#define SERCOM_USART_CTRLA_MODE_SPI_SLAVE (SERCOM_USART_CTRLA_MODE_SPI_SLAVE_Val << SERCOM_USART_CTRLA_MODE_Pos)
#define SERCOM_USART_CTRLA_MODE_SPI_MASTER (SERCOM_USART_CTRLA_MODE_SPI_MASTER_Val << SERCOM_USART_CTRLA_MODE_Pos)
#define SERCOM_USART_CTRLA_MODE_I2C_SLAVE (SERCOM_USART_CTRLA_MODE_I2C_SLAVE_Val << SERCOM_USART_CTRLA_MODE_Pos)
#define SERCOM_USART_CTRLA_MODE_I2C_MASTER (SERCOM_USART_CTRLA_MODE_I2C_MASTER_Val << SERCOM_USART_CTRLA_MODE_Pos)
#define SERCOM_USART_CTRLA_RUNSTDBY_Pos 7
#define SERCOM_USART_CTRLA_RUNSTDBY (_U_(0x1) << SERCOM_USART_CTRLA_RUNSTDBY_Pos)
#define SERCOM_USART_CTRLA_IBON_Pos 8
#define SERCOM_USART_CTRLA_IBON (_U_(0x1) << SERCOM_USART_CTRLA_IBON_Pos)
#define SERCOM_USART_CTRLA_SAMPR_Pos 13
#define SERCOM_USART_CTRLA_SAMPR_Msk (_U_(0x7) << SERCOM_USART_CTRLA_SAMPR_Pos)
#define SERCOM_USART_CTRLA_SAMPR(value) (SERCOM_USART_CTRLA_SAMPR_Msk & ((value) << SERCOM_USART_CTRLA_SAMPR_Pos))
#define SERCOM_USART_CTRLA_TXPO_Pos 16
#define SERCOM_USART_CTRLA_TXPO_Msk (_U_(0x3) << SERCOM_USART_CTRLA_TXPO_Pos)
#define SERCOM_USART_CTRLA_TXPO(value) (SERCOM_USART_CTRLA_TXPO_Msk & ((value) << SERCOM_USART_CTRLA_TXPO_Pos))
#define SERCOM_USART_CTRLA_RXPO_Pos 20
#define SERCOM_USART_CTRLA_RXPO_Msk (_U_(0x3) << SERCOM_USART_CTRLA_RXPO_Pos)
#define SERCOM_USART_CTRLA_RXPO(value) (SERCOM_USART_CTRLA_RXPO_Msk & ((value) << SERCOM_USART_CTRLA_RXPO_Pos))
#define SERCOM_USART_CTRLA_SAMPA_Pos 22
#define SERCOM_USART_CTRLA_SAMPA_Msk (_U_(0x3) << SERCOM_USART_CTRLA_SAMPA_Pos)
#define SERCOM_USART_CTRLA_SAMPA(value) (SERCOM_USART_CTRLA_SAMPA_Msk & ((value) << SERCOM_USART_CTRLA_SAMPA_Pos))
#define SERCOM_USART_CTRLA_FORM_Pos 24
#define SERCOM_USART_CTRLA_FORM_Msk (_U_(0xF) << SERCOM_USART_CTRLA_FORM_Pos)
#define SERCOM_USART_CTRLA_FORM(value) (SERCOM_USART_CTRLA_FORM_Msk & ((value) << SERCOM_USART_CTRLA_FORM_Pos))
#define SERCOM_USART_CTRLA_CMODE_Pos 28
#define SERCOM_USART_CTRLA_CMODE (_U_(0x1) << SERCOM_USART_CTRLA_CMODE_Pos)
#define SERCOM_USART_CTRLA_CPOL_Pos 29
#define SERCOM_USART_CTRLA_CPOL (_U_(0x1) << SERCOM_USART_CTRLA_CPOL_Pos)
#define SERCOM_USART_CTRLA_DORD_Pos 30
#define SERCOM_USART_CTRLA_DORD (_U_(0x1) << SERCOM_USART_CTRLA_DORD_Pos)
#define SERCOM_USART_CTRLA_MASK _U_(0x7FF3E19F)

/* -------- SERCOM_I2CM_CTRLB : (SERCOM Offset: 0x04) (R/W 32) I2CM I2CM Control B -------- */

typedef union {
  struct {
    uint32_t :8; /*!< bit:  0.. 7  Reserved                           */
    uint32_t SMEN:1; /*!< bit:      8  Smart Mode Enable                  */
    uint32_t QCEN:1; /*!< bit:      9  Quick Command Enable               */
    uint32_t :6; /*!< bit: 10..15  Reserved                           */
    uint32_t CMD:2; /*!< bit: 16..17  Command                            */
    uint32_t ACKACT:1; /*!< bit:     18  Acknowledge Action                 */
    uint32_t :13; /*!< bit: 19..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_CTRLB_Type;


#define SERCOM_I2CM_CTRLB_OFFSET 0x04
#define SERCOM_I2CM_CTRLB_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CM_CTRLB_SMEN_Pos 8
#define SERCOM_I2CM_CTRLB_SMEN (_U_(0x1) << SERCOM_I2CM_CTRLB_SMEN_Pos)
#define SERCOM_I2CM_CTRLB_QCEN_Pos 9
#define SERCOM_I2CM_CTRLB_QCEN (_U_(0x1) << SERCOM_I2CM_CTRLB_QCEN_Pos)
#define SERCOM_I2CM_CTRLB_CMD_Pos 16
#define SERCOM_I2CM_CTRLB_CMD_Msk (_U_(0x3) << SERCOM_I2CM_CTRLB_CMD_Pos)
#define SERCOM_I2CM_CTRLB_CMD(value) (SERCOM_I2CM_CTRLB_CMD_Msk & ((value) << SERCOM_I2CM_CTRLB_CMD_Pos))
#define SERCOM_I2CM_CTRLB_ACKACT_Pos 18
#define SERCOM_I2CM_CTRLB_ACKACT (_U_(0x1) << SERCOM_I2CM_CTRLB_ACKACT_Pos)
#define SERCOM_I2CM_CTRLB_MASK _U_(0x00070300)

/* -------- SERCOM_I2CS_CTRLB : (SERCOM Offset: 0x04) (R/W 32) I2CS I2CS Control B -------- */

typedef union {
  struct {
    uint32_t :8; /*!< bit:  0.. 7  Reserved                           */
    uint32_t SMEN:1; /*!< bit:      8  Smart Mode Enable                  */
    uint32_t GCMD:1; /*!< bit:      9  PMBus Group Command                */
    uint32_t AACKEN:1; /*!< bit:     10  Automatic Address Acknowledge      */
    uint32_t :3; /*!< bit: 11..13  Reserved                           */
    uint32_t AMODE:2; /*!< bit: 14..15  Address Mode                       */
    uint32_t CMD:2; /*!< bit: 16..17  Command                            */
    uint32_t ACKACT:1; /*!< bit:     18  Acknowledge Action                 */
    uint32_t :13; /*!< bit: 19..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_CTRLB_Type;


#define SERCOM_I2CS_CTRLB_OFFSET 0x04
#define SERCOM_I2CS_CTRLB_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CS_CTRLB_SMEN_Pos 8
#define SERCOM_I2CS_CTRLB_SMEN (_U_(0x1) << SERCOM_I2CS_CTRLB_SMEN_Pos)
#define SERCOM_I2CS_CTRLB_GCMD_Pos 9
#define SERCOM_I2CS_CTRLB_GCMD (_U_(0x1) << SERCOM_I2CS_CTRLB_GCMD_Pos)
#define SERCOM_I2CS_CTRLB_AACKEN_Pos 10
#define SERCOM_I2CS_CTRLB_AACKEN (_U_(0x1) << SERCOM_I2CS_CTRLB_AACKEN_Pos)
#define SERCOM_I2CS_CTRLB_AMODE_Pos 14
#define SERCOM_I2CS_CTRLB_AMODE_Msk (_U_(0x3) << SERCOM_I2CS_CTRLB_AMODE_Pos)
#define SERCOM_I2CS_CTRLB_AMODE(value) (SERCOM_I2CS_CTRLB_AMODE_Msk & ((value) << SERCOM_I2CS_CTRLB_AMODE_Pos))
#define SERCOM_I2CS_CTRLB_CMD_Pos 16
#define SERCOM_I2CS_CTRLB_CMD_Msk (_U_(0x3) << SERCOM_I2CS_CTRLB_CMD_Pos)
#define SERCOM_I2CS_CTRLB_CMD(value) (SERCOM_I2CS_CTRLB_CMD_Msk & ((value) << SERCOM_I2CS_CTRLB_CMD_Pos))
#define SERCOM_I2CS_CTRLB_ACKACT_Pos 18
#define SERCOM_I2CS_CTRLB_ACKACT (_U_(0x1) << SERCOM_I2CS_CTRLB_ACKACT_Pos)
#define SERCOM_I2CS_CTRLB_MASK _U_(0x0007C700)

/* -------- SERCOM_SPI_CTRLB : (SERCOM Offset: 0x04) (R/W 32) SPI SPI Control B -------- */

typedef union {
  struct {
    uint32_t CHSIZE:3; /*!< bit:  0.. 2  Character Size                     */
    uint32_t :3; /*!< bit:  3.. 5  Reserved                           */
    uint32_t PLOADEN:1; /*!< bit:      6  Data Preload Enable                */
    uint32_t :2; /*!< bit:  7.. 8  Reserved                           */
    uint32_t SSDE:1; /*!< bit:      9  Slave Select Low Detect Enable     */
    uint32_t :3; /*!< bit: 10..12  Reserved                           */
    uint32_t MSSEN:1; /*!< bit:     13  Master Slave Select Enable         */
    uint32_t AMODE:2; /*!< bit: 14..15  Address Mode                       */
    uint32_t :1; /*!< bit:     16  Reserved                           */
    uint32_t RXEN:1; /*!< bit:     17  Receiver Enable                    */
    uint32_t :14; /*!< bit: 18..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_CTRLB_Type;


#define SERCOM_SPI_CTRLB_OFFSET 0x04
#define SERCOM_SPI_CTRLB_RESETVALUE _U_(0x00000000)

#define SERCOM_SPI_CTRLB_CHSIZE_Pos 0
#define SERCOM_SPI_CTRLB_CHSIZE_Msk (_U_(0x7) << SERCOM_SPI_CTRLB_CHSIZE_Pos)
#define SERCOM_SPI_CTRLB_CHSIZE(value) (SERCOM_SPI_CTRLB_CHSIZE_Msk & ((value) << SERCOM_SPI_CTRLB_CHSIZE_Pos))
#define SERCOM_SPI_CTRLB_PLOADEN_Pos 6
#define SERCOM_SPI_CTRLB_PLOADEN (_U_(0x1) << SERCOM_SPI_CTRLB_PLOADEN_Pos)
#define SERCOM_SPI_CTRLB_SSDE_Pos 9
#define SERCOM_SPI_CTRLB_SSDE (_U_(0x1) << SERCOM_SPI_CTRLB_SSDE_Pos)
#define SERCOM_SPI_CTRLB_MSSEN_Pos 13
#define SERCOM_SPI_CTRLB_MSSEN (_U_(0x1) << SERCOM_SPI_CTRLB_MSSEN_Pos)
#define SERCOM_SPI_CTRLB_AMODE_Pos 14
#define SERCOM_SPI_CTRLB_AMODE_Msk (_U_(0x3) << SERCOM_SPI_CTRLB_AMODE_Pos)
#define SERCOM_SPI_CTRLB_AMODE(value) (SERCOM_SPI_CTRLB_AMODE_Msk & ((value) << SERCOM_SPI_CTRLB_AMODE_Pos))
#define SERCOM_SPI_CTRLB_RXEN_Pos 17
#define SERCOM_SPI_CTRLB_RXEN (_U_(0x1) << SERCOM_SPI_CTRLB_RXEN_Pos)
#define SERCOM_SPI_CTRLB_MASK _U_(0x0002E247)

/* -------- SERCOM_USART_CTRLB : (SERCOM Offset: 0x04) (R/W 32) USART USART Control B -------- */

typedef union {
  struct {
    uint32_t CHSIZE:3; /*!< bit:  0.. 2  Character Size                     */
    uint32_t :3; /*!< bit:  3.. 5  Reserved                           */
    uint32_t SBMODE:1; /*!< bit:      6  Stop Bit Mode                      */
    uint32_t :1; /*!< bit:      7  Reserved                           */
    uint32_t COLDEN:1; /*!< bit:      8  Collision Detection Enable         */
    uint32_t SFDE:1; /*!< bit:      9  Start of Frame Detection Enable    */
    uint32_t ENC:1; /*!< bit:     10  Encoding Format                    */
    uint32_t :2; /*!< bit: 11..12  Reserved                           */
    uint32_t PMODE:1; /*!< bit:     13  Parity Mode                        */
    uint32_t :2; /*!< bit: 14..15  Reserved                           */
    uint32_t TXEN:1; /*!< bit:     16  Transmitter Enable                 */
    uint32_t RXEN:1; /*!< bit:     17  Receiver Enable                    */
    uint32_t :14; /*!< bit: 18..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_USART_CTRLB_Type;


#define SERCOM_USART_CTRLB_OFFSET 0x04
#define SERCOM_USART_CTRLB_RESETVALUE _U_(0x00000000)

#define SERCOM_USART_CTRLB_CHSIZE_Pos 0
#define SERCOM_USART_CTRLB_CHSIZE_Msk (_U_(0x7) << SERCOM_USART_CTRLB_CHSIZE_Pos)
#define SERCOM_USART_CTRLB_CHSIZE(value) (SERCOM_USART_CTRLB_CHSIZE_Msk & ((value) << SERCOM_USART_CTRLB_CHSIZE_Pos))
#define SERCOM_USART_CTRLB_SBMODE_Pos 6
#define SERCOM_USART_CTRLB_SBMODE (_U_(0x1) << SERCOM_USART_CTRLB_SBMODE_Pos)
#define SERCOM_USART_CTRLB_COLDEN_Pos 8
#define SERCOM_USART_CTRLB_COLDEN (_U_(0x1) << SERCOM_USART_CTRLB_COLDEN_Pos)
#define SERCOM_USART_CTRLB_SFDE_Pos 9
#define SERCOM_USART_CTRLB_SFDE (_U_(0x1) << SERCOM_USART_CTRLB_SFDE_Pos)
#define SERCOM_USART_CTRLB_ENC_Pos 10
#define SERCOM_USART_CTRLB_ENC (_U_(0x1) << SERCOM_USART_CTRLB_ENC_Pos)
#define SERCOM_USART_CTRLB_PMODE_Pos 13
#define SERCOM_USART_CTRLB_PMODE (_U_(0x1) << SERCOM_USART_CTRLB_PMODE_Pos)
#define SERCOM_USART_CTRLB_TXEN_Pos 16
#define SERCOM_USART_CTRLB_TXEN (_U_(0x1) << SERCOM_USART_CTRLB_TXEN_Pos)
#define SERCOM_USART_CTRLB_RXEN_Pos 17
#define SERCOM_USART_CTRLB_RXEN (_U_(0x1) << SERCOM_USART_CTRLB_RXEN_Pos)
#define SERCOM_USART_CTRLB_MASK _U_(0x00032747)

/* -------- SERCOM_I2CM_BAUD : (SERCOM Offset: 0x0C) (R/W 32) I2CM I2CM Baud Rate -------- */

typedef union {
  struct {
    uint32_t BAUD:8; /*!< bit:  0.. 7  Baud Rate Value                    */
    uint32_t BAUDLOW:8; /*!< bit:  8..15  Baud Rate Value Low                */
    uint32_t HSBAUD:8; /*!< bit: 16..23  High Speed Baud Rate Value         */
    uint32_t HSBAUDLOW:8; /*!< bit: 24..31  High Speed Baud Rate Value Low     */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_BAUD_Type;


#define SERCOM_I2CM_BAUD_OFFSET 0x0C
#define SERCOM_I2CM_BAUD_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CM_BAUD_BAUD_Pos 0
#define SERCOM_I2CM_BAUD_BAUD_Msk (_U_(0xFF) << SERCOM_I2CM_BAUD_BAUD_Pos)
#define SERCOM_I2CM_BAUD_BAUD(value) (SERCOM_I2CM_BAUD_BAUD_Msk & ((value) << SERCOM_I2CM_BAUD_BAUD_Pos))
#define SERCOM_I2CM_BAUD_BAUDLOW_Pos 8
#define SERCOM_I2CM_BAUD_BAUDLOW_Msk (_U_(0xFF) << SERCOM_I2CM_BAUD_BAUDLOW_Pos)
#define SERCOM_I2CM_BAUD_BAUDLOW(value) (SERCOM_I2CM_BAUD_BAUDLOW_Msk & ((value) << SERCOM_I2CM_BAUD_BAUDLOW_Pos))
#define SERCOM_I2CM_BAUD_HSBAUD_Pos 16
#define SERCOM_I2CM_BAUD_HSBAUD_Msk (_U_(0xFF) << SERCOM_I2CM_BAUD_HSBAUD_Pos)
#define SERCOM_I2CM_BAUD_HSBAUD(value) (SERCOM_I2CM_BAUD_HSBAUD_Msk & ((value) << SERCOM_I2CM_BAUD_HSBAUD_Pos))
#define SERCOM_I2CM_BAUD_HSBAUDLOW_Pos 24
#define SERCOM_I2CM_BAUD_HSBAUDLOW_Msk (_U_(0xFF) << SERCOM_I2CM_BAUD_HSBAUDLOW_Pos)
#define SERCOM_I2CM_BAUD_HSBAUDLOW(value) (SERCOM_I2CM_BAUD_HSBAUDLOW_Msk & ((value) << SERCOM_I2CM_BAUD_HSBAUDLOW_Pos))
#define SERCOM_I2CM_BAUD_MASK _U_(0xFFFFFFFF)

/* -------- SERCOM_SPI_BAUD : (SERCOM Offset: 0x0C) (R/W  8) SPI SPI Baud Rate -------- */

typedef union {
  struct {
    uint8_t BAUD:8; /*!< bit:  0.. 7  Baud Rate Value                    */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_BAUD_Type;


#define SERCOM_SPI_BAUD_OFFSET 0x0C
#define SERCOM_SPI_BAUD_RESETVALUE _U_(0x00)

#define SERCOM_SPI_BAUD_BAUD_Pos 0
#define SERCOM_SPI_BAUD_BAUD_Msk (_U_(0xFF) << SERCOM_SPI_BAUD_BAUD_Pos)
#define SERCOM_SPI_BAUD_BAUD(value) (SERCOM_SPI_BAUD_BAUD_Msk & ((value) << SERCOM_SPI_BAUD_BAUD_Pos))
#define SERCOM_SPI_BAUD_MASK _U_(0xFF)

/* -------- SERCOM_USART_BAUD : (SERCOM Offset: 0x0C) (R/W 16) USART USART Baud Rate -------- */

typedef union {
  struct {
    uint16_t BAUD:16; /*!< bit:  0..15  Baud Rate Value                    */
  } bit; /*!< Structure used for bit  access                  */
  struct { // FRAC mode
    uint16_t BAUD:13; /*!< bit:  0..12  Baud Rate Value                    */
    uint16_t FP:3; /*!< bit: 13..15  Fractional Part                    */
  } FRAC; /*!< Structure used for FRAC                         */
  struct { // FRACFP mode
    uint16_t BAUD:13; /*!< bit:  0..12  Baud Rate Value                    */
    uint16_t FP:3; /*!< bit: 13..15  Fractional Part                    */
  } FRACFP; /*!< Structure used for FRACFP                       */
  struct { // USARTFP mode
    uint16_t BAUD:16; /*!< bit:  0..15  Baud Rate Value                    */
  } USARTFP; /*!< Structure used for USARTFP                      */
  uint16_t reg; /*!< Type      used for register access              */
} SERCOM_USART_BAUD_Type;


#define SERCOM_USART_BAUD_OFFSET 0x0C
#define SERCOM_USART_BAUD_RESETVALUE _U_(0x0000)

#define SERCOM_USART_BAUD_BAUD_Pos 0
#define SERCOM_USART_BAUD_BAUD_Msk (_U_(0xFFFF) << SERCOM_USART_BAUD_BAUD_Pos)
#define SERCOM_USART_BAUD_BAUD(value) (SERCOM_USART_BAUD_BAUD_Msk & ((value) << SERCOM_USART_BAUD_BAUD_Pos))
#define SERCOM_USART_BAUD_MASK _U_(0xFFFF)

// FRAC mode
#define SERCOM_USART_BAUD_FRAC_BAUD_Pos 0
#define SERCOM_USART_BAUD_FRAC_BAUD_Msk (_U_(0x1FFF) << SERCOM_USART_BAUD_FRAC_BAUD_Pos)
#define SERCOM_USART_BAUD_FRAC_BAUD(value) (SERCOM_USART_BAUD_FRAC_BAUD_Msk & ((value) << SERCOM_USART_BAUD_FRAC_BAUD_Pos))
#define SERCOM_USART_BAUD_FRAC_FP_Pos 13
#define SERCOM_USART_BAUD_FRAC_FP_Msk (_U_(0x7) << SERCOM_USART_BAUD_FRAC_FP_Pos)
#define SERCOM_USART_BAUD_FRAC_FP(value) (SERCOM_USART_BAUD_FRAC_FP_Msk & ((value) << SERCOM_USART_BAUD_FRAC_FP_Pos))
#define SERCOM_USART_BAUD_FRAC_MASK _U_(0xFFFF)

// FRACFP mode
#define SERCOM_USART_BAUD_FRACFP_BAUD_Pos 0
#define SERCOM_USART_BAUD_FRACFP_BAUD_Msk (_U_(0x1FFF) << SERCOM_USART_BAUD_FRACFP_BAUD_Pos)
#define SERCOM_USART_BAUD_FRACFP_BAUD(value) (SERCOM_USART_BAUD_FRACFP_BAUD_Msk & ((value) << SERCOM_USART_BAUD_FRACFP_BAUD_Pos))
#define SERCOM_USART_BAUD_FRACFP_FP_Pos 13
#define SERCOM_USART_BAUD_FRACFP_FP_Msk (_U_(0x7) << SERCOM_USART_BAUD_FRACFP_FP_Pos)
#define SERCOM_USART_BAUD_FRACFP_FP(value) (SERCOM_USART_BAUD_FRACFP_FP_Msk & ((value) << SERCOM_USART_BAUD_FRACFP_FP_Pos))
#define SERCOM_USART_BAUD_FRACFP_MASK _U_(0xFFFF)

// USARTFP mode
#define SERCOM_USART_BAUD_USARTFP_BAUD_Pos 0
#define SERCOM_USART_BAUD_USARTFP_BAUD_Msk (_U_(0xFFFF) << SERCOM_USART_BAUD_USARTFP_BAUD_Pos)
#define SERCOM_USART_BAUD_USARTFP_BAUD(value) (SERCOM_USART_BAUD_USARTFP_BAUD_Msk & ((value) << SERCOM_USART_BAUD_USARTFP_BAUD_Pos))
#define SERCOM_USART_BAUD_USARTFP_MASK _U_(0xFFFF)

/* -------- SERCOM_USART_RXPL : (SERCOM Offset: 0x0E) (R/W  8) USART USART Receive Pulse Length -------- */

typedef union {
  struct {
    uint8_t RXPL:8; /*!< bit:  0.. 7  Receive Pulse Length               */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_USART_RXPL_Type;


#define SERCOM_USART_RXPL_OFFSET 0x0E
#define SERCOM_USART_RXPL_RESETVALUE _U_(0x00)

#define SERCOM_USART_RXPL_RXPL_Pos 0
#define SERCOM_USART_RXPL_RXPL_Msk (_U_(0xFF) << SERCOM_USART_RXPL_RXPL_Pos)
#define SERCOM_USART_RXPL_RXPL(value) (SERCOM_USART_RXPL_RXPL_Msk & ((value) << SERCOM_USART_RXPL_RXPL_Pos))
#define SERCOM_USART_RXPL_MASK _U_(0xFF)

/* -------- SERCOM_I2CM_INTENCLR : (SERCOM Offset: 0x14) (R/W  8) I2CM I2CM Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t MB:1; /*!< bit:      0  Master On Bus Interrupt Disable    */
    uint8_t SB:1; /*!< bit:      1  Slave On Bus Interrupt Disable     */
    uint8_t :5; /*!< bit:  2.. 6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Disable   */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_INTENCLR_Type;


#define SERCOM_I2CM_INTENCLR_OFFSET 0x14
#define SERCOM_I2CM_INTENCLR_RESETVALUE _U_(0x00)

#define SERCOM_I2CM_INTENCLR_MB_Pos 0
#define SERCOM_I2CM_INTENCLR_MB (_U_(0x1) << SERCOM_I2CM_INTENCLR_MB_Pos)
#define SERCOM_I2CM_INTENCLR_SB_Pos 1
#define SERCOM_I2CM_INTENCLR_SB (_U_(0x1) << SERCOM_I2CM_INTENCLR_SB_Pos)
#define SERCOM_I2CM_INTENCLR_ERROR_Pos 7
#define SERCOM_I2CM_INTENCLR_ERROR (_U_(0x1) << SERCOM_I2CM_INTENCLR_ERROR_Pos)
#define SERCOM_I2CM_INTENCLR_MASK _U_(0x83)

/* -------- SERCOM_I2CS_INTENCLR : (SERCOM Offset: 0x14) (R/W  8) I2CS I2CS Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t PREC:1; /*!< bit:      0  Stop Received Interrupt Disable    */
    uint8_t AMATCH:1; /*!< bit:      1  Address Match Interrupt Disable    */
    uint8_t DRDY:1; /*!< bit:      2  Data Interrupt Disable             */
    uint8_t :4; /*!< bit:  3.. 6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Disable   */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_INTENCLR_Type;


#define SERCOM_I2CS_INTENCLR_OFFSET 0x14
#define SERCOM_I2CS_INTENCLR_RESETVALUE _U_(0x00)

#define SERCOM_I2CS_INTENCLR_PREC_Pos 0
#define SERCOM_I2CS_INTENCLR_PREC (_U_(0x1) << SERCOM_I2CS_INTENCLR_PREC_Pos)
#define SERCOM_I2CS_INTENCLR_AMATCH_Pos 1
#define SERCOM_I2CS_INTENCLR_AMATCH (_U_(0x1) << SERCOM_I2CS_INTENCLR_AMATCH_Pos)
#define SERCOM_I2CS_INTENCLR_DRDY_Pos 2
#define SERCOM_I2CS_INTENCLR_DRDY (_U_(0x1) << SERCOM_I2CS_INTENCLR_DRDY_Pos)
#define SERCOM_I2CS_INTENCLR_ERROR_Pos 7
#define SERCOM_I2CS_INTENCLR_ERROR (_U_(0x1) << SERCOM_I2CS_INTENCLR_ERROR_Pos)
#define SERCOM_I2CS_INTENCLR_MASK _U_(0x87)

/* -------- SERCOM_SPI_INTENCLR : (SERCOM Offset: 0x14) (R/W  8) SPI SPI Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t DRE:1; /*!< bit:      0  Data Register Empty Interrupt Disable */
    uint8_t TXC:1; /*!< bit:      1  Transmit Complete Interrupt Disable */
    uint8_t RXC:1; /*!< bit:      2  Receive Complete Interrupt Disable */
    uint8_t SSL:1; /*!< bit:      3  Slave Select Low Interrupt Disable */
    uint8_t :3; /*!< bit:  4.. 6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Disable   */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_INTENCLR_Type;


#define SERCOM_SPI_INTENCLR_OFFSET 0x14
#define SERCOM_SPI_INTENCLR_RESETVALUE _U_(0x00)

#define SERCOM_SPI_INTENCLR_DRE_Pos 0
#define SERCOM_SPI_INTENCLR_DRE (_U_(0x1) << SERCOM_SPI_INTENCLR_DRE_Pos)
#define SERCOM_SPI_INTENCLR_TXC_Pos 1
#define SERCOM_SPI_INTENCLR_TXC (_U_(0x1) << SERCOM_SPI_INTENCLR_TXC_Pos)
#define SERCOM_SPI_INTENCLR_RXC_Pos 2
#define SERCOM_SPI_INTENCLR_RXC (_U_(0x1) << SERCOM_SPI_INTENCLR_RXC_Pos)
#define SERCOM_SPI_INTENCLR_SSL_Pos 3
#define SERCOM_SPI_INTENCLR_SSL (_U_(0x1) << SERCOM_SPI_INTENCLR_SSL_Pos)
#define SERCOM_SPI_INTENCLR_ERROR_Pos 7
#define SERCOM_SPI_INTENCLR_ERROR (_U_(0x1) << SERCOM_SPI_INTENCLR_ERROR_Pos)
#define SERCOM_SPI_INTENCLR_MASK _U_(0x8F)

/* -------- SERCOM_USART_INTENCLR : (SERCOM Offset: 0x14) (R/W  8) USART USART Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t DRE:1; /*!< bit:      0  Data Register Empty Interrupt Disable */
    uint8_t TXC:1; /*!< bit:      1  Transmit Complete Interrupt Disable */
    uint8_t RXC:1; /*!< bit:      2  Receive Complete Interrupt Disable */
    uint8_t RXS:1; /*!< bit:      3  Receive Start Interrupt Disable    */
    uint8_t CTSIC:1; /*!< bit:      4  Clear To Send Input Change Interrupt Disable */
    uint8_t RXBRK:1; /*!< bit:      5  Break Received Interrupt Disable   */
    uint8_t :1; /*!< bit:      6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Disable   */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_USART_INTENCLR_Type;


#define SERCOM_USART_INTENCLR_OFFSET 0x14
#define SERCOM_USART_INTENCLR_RESETVALUE _U_(0x00)

#define SERCOM_USART_INTENCLR_DRE_Pos 0
#define SERCOM_USART_INTENCLR_DRE (_U_(0x1) << SERCOM_USART_INTENCLR_DRE_Pos)
#define SERCOM_USART_INTENCLR_TXC_Pos 1
#define SERCOM_USART_INTENCLR_TXC (_U_(0x1) << SERCOM_USART_INTENCLR_TXC_Pos)
#define SERCOM_USART_INTENCLR_RXC_Pos 2
#define SERCOM_USART_INTENCLR_RXC (_U_(0x1) << SERCOM_USART_INTENCLR_RXC_Pos)
#define SERCOM_USART_INTENCLR_RXS_Pos 3
#define SERCOM_USART_INTENCLR_RXS (_U_(0x1) << SERCOM_USART_INTENCLR_RXS_Pos)
#define SERCOM_USART_INTENCLR_CTSIC_Pos 4
#define SERCOM_USART_INTENCLR_CTSIC (_U_(0x1) << SERCOM_USART_INTENCLR_CTSIC_Pos)
#define SERCOM_USART_INTENCLR_RXBRK_Pos 5
#define SERCOM_USART_INTENCLR_RXBRK (_U_(0x1) << SERCOM_USART_INTENCLR_RXBRK_Pos)
#define SERCOM_USART_INTENCLR_ERROR_Pos 7
#define SERCOM_USART_INTENCLR_ERROR (_U_(0x1) << SERCOM_USART_INTENCLR_ERROR_Pos)
#define SERCOM_USART_INTENCLR_MASK _U_(0xBF)

/* -------- SERCOM_I2CM_INTENSET : (SERCOM Offset: 0x16) (R/W  8) I2CM I2CM Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t MB:1; /*!< bit:      0  Master On Bus Interrupt Enable     */
    uint8_t SB:1; /*!< bit:      1  Slave On Bus Interrupt Enable      */
    uint8_t :5; /*!< bit:  2.. 6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Enable    */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_INTENSET_Type;


#define SERCOM_I2CM_INTENSET_OFFSET 0x16
#define SERCOM_I2CM_INTENSET_RESETVALUE _U_(0x00)

#define SERCOM_I2CM_INTENSET_MB_Pos 0
#define SERCOM_I2CM_INTENSET_MB (_U_(0x1) << SERCOM_I2CM_INTENSET_MB_Pos)
#define SERCOM_I2CM_INTENSET_SB_Pos 1
#define SERCOM_I2CM_INTENSET_SB (_U_(0x1) << SERCOM_I2CM_INTENSET_SB_Pos)
#define SERCOM_I2CM_INTENSET_ERROR_Pos 7
#define SERCOM_I2CM_INTENSET_ERROR (_U_(0x1) << SERCOM_I2CM_INTENSET_ERROR_Pos)
#define SERCOM_I2CM_INTENSET_MASK _U_(0x83)

/* -------- SERCOM_I2CS_INTENSET : (SERCOM Offset: 0x16) (R/W  8) I2CS I2CS Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t PREC:1; /*!< bit:      0  Stop Received Interrupt Enable     */
    uint8_t AMATCH:1; /*!< bit:      1  Address Match Interrupt Enable     */
    uint8_t DRDY:1; /*!< bit:      2  Data Interrupt Enable              */
    uint8_t :4; /*!< bit:  3.. 6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Enable    */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_INTENSET_Type;


#define SERCOM_I2CS_INTENSET_OFFSET 0x16
#define SERCOM_I2CS_INTENSET_RESETVALUE _U_(0x00)

#define SERCOM_I2CS_INTENSET_PREC_Pos 0
#define SERCOM_I2CS_INTENSET_PREC (_U_(0x1) << SERCOM_I2CS_INTENSET_PREC_Pos)
#define SERCOM_I2CS_INTENSET_AMATCH_Pos 1
#define SERCOM_I2CS_INTENSET_AMATCH (_U_(0x1) << SERCOM_I2CS_INTENSET_AMATCH_Pos)
#define SERCOM_I2CS_INTENSET_DRDY_Pos 2
#define SERCOM_I2CS_INTENSET_DRDY (_U_(0x1) << SERCOM_I2CS_INTENSET_DRDY_Pos)
#define SERCOM_I2CS_INTENSET_ERROR_Pos 7
#define SERCOM_I2CS_INTENSET_ERROR (_U_(0x1) << SERCOM_I2CS_INTENSET_ERROR_Pos)
#define SERCOM_I2CS_INTENSET_MASK _U_(0x87)

/* -------- SERCOM_SPI_INTENSET : (SERCOM Offset: 0x16) (R/W  8) SPI SPI Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t DRE:1; /*!< bit:      0  Data Register Empty Interrupt Enable */
    uint8_t TXC:1; /*!< bit:      1  Transmit Complete Interrupt Enable */
    uint8_t RXC:1; /*!< bit:      2  Receive Complete Interrupt Enable  */
    uint8_t SSL:1; /*!< bit:      3  Slave Select Low Interrupt Enable  */
    uint8_t :3; /*!< bit:  4.. 6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Enable    */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_INTENSET_Type;


#define SERCOM_SPI_INTENSET_OFFSET 0x16
#define SERCOM_SPI_INTENSET_RESETVALUE _U_(0x00)

#define SERCOM_SPI_INTENSET_DRE_Pos 0
#define SERCOM_SPI_INTENSET_DRE (_U_(0x1) << SERCOM_SPI_INTENSET_DRE_Pos)
#define SERCOM_SPI_INTENSET_TXC_Pos 1
#define SERCOM_SPI_INTENSET_TXC (_U_(0x1) << SERCOM_SPI_INTENSET_TXC_Pos)
#define SERCOM_SPI_INTENSET_RXC_Pos 2
#define SERCOM_SPI_INTENSET_RXC (_U_(0x1) << SERCOM_SPI_INTENSET_RXC_Pos)
#define SERCOM_SPI_INTENSET_SSL_Pos 3
#define SERCOM_SPI_INTENSET_SSL (_U_(0x1) << SERCOM_SPI_INTENSET_SSL_Pos)
#define SERCOM_SPI_INTENSET_ERROR_Pos 7
#define SERCOM_SPI_INTENSET_ERROR (_U_(0x1) << SERCOM_SPI_INTENSET_ERROR_Pos)
#define SERCOM_SPI_INTENSET_MASK _U_(0x8F)

/* -------- SERCOM_USART_INTENSET : (SERCOM Offset: 0x16) (R/W  8) USART USART Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t DRE:1; /*!< bit:      0  Data Register Empty Interrupt Enable */
    uint8_t TXC:1; /*!< bit:      1  Transmit Complete Interrupt Enable */
    uint8_t RXC:1; /*!< bit:      2  Receive Complete Interrupt Enable  */
    uint8_t RXS:1; /*!< bit:      3  Receive Start Interrupt Enable     */
    uint8_t CTSIC:1; /*!< bit:      4  Clear To Send Input Change Interrupt Enable */
    uint8_t RXBRK:1; /*!< bit:      5  Break Received Interrupt Enable    */
    uint8_t :1; /*!< bit:      6  Reserved                           */
    uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt Enable    */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_USART_INTENSET_Type;


#define SERCOM_USART_INTENSET_OFFSET 0x16
#define SERCOM_USART_INTENSET_RESETVALUE _U_(0x00)

#define SERCOM_USART_INTENSET_DRE_Pos 0
#define SERCOM_USART_INTENSET_DRE (_U_(0x1) << SERCOM_USART_INTENSET_DRE_Pos)
#define SERCOM_USART_INTENSET_TXC_Pos 1
#define SERCOM_USART_INTENSET_TXC (_U_(0x1) << SERCOM_USART_INTENSET_TXC_Pos)
#define SERCOM_USART_INTENSET_RXC_Pos 2
#define SERCOM_USART_INTENSET_RXC (_U_(0x1) << SERCOM_USART_INTENSET_RXC_Pos)
#define SERCOM_USART_INTENSET_RXS_Pos 3
#define SERCOM_USART_INTENSET_RXS (_U_(0x1) << SERCOM_USART_INTENSET_RXS_Pos)
#define SERCOM_USART_INTENSET_CTSIC_Pos 4
#define SERCOM_USART_INTENSET_CTSIC (_U_(0x1) << SERCOM_USART_INTENSET_CTSIC_Pos)
#define SERCOM_USART_INTENSET_RXBRK_Pos 5
#define SERCOM_USART_INTENSET_RXBRK (_U_(0x1) << SERCOM_USART_INTENSET_RXBRK_Pos)
#define SERCOM_USART_INTENSET_ERROR_Pos 7
#define SERCOM_USART_INTENSET_ERROR (_U_(0x1) << SERCOM_USART_INTENSET_ERROR_Pos)
#define SERCOM_USART_INTENSET_MASK _U_(0xBF)

/* -------- SERCOM_I2CM_INTFLAG : (SERCOM Offset: 0x18) (R/W  8) I2CM I2CM Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t MB:1; /*!< bit:      0  Master On Bus Interrupt            */
    volatile const uint8_t SB:1; /*!< bit:      1  Slave On Bus Interrupt             */
    volatile const uint8_t :5; /*!< bit:  2.. 6  Reserved                           */
    volatile const uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_INTFLAG_Type;


#define SERCOM_I2CM_INTFLAG_OFFSET 0x18
#define SERCOM_I2CM_INTFLAG_RESETVALUE _U_(0x00)

#define SERCOM_I2CM_INTFLAG_MB_Pos 0
#define SERCOM_I2CM_INTFLAG_MB (_U_(0x1) << SERCOM_I2CM_INTFLAG_MB_Pos)
#define SERCOM_I2CM_INTFLAG_SB_Pos 1
#define SERCOM_I2CM_INTFLAG_SB (_U_(0x1) << SERCOM_I2CM_INTFLAG_SB_Pos)
#define SERCOM_I2CM_INTFLAG_ERROR_Pos 7
#define SERCOM_I2CM_INTFLAG_ERROR (_U_(0x1) << SERCOM_I2CM_INTFLAG_ERROR_Pos)
#define SERCOM_I2CM_INTFLAG_MASK _U_(0x83)

/* -------- SERCOM_I2CS_INTFLAG : (SERCOM Offset: 0x18) (R/W  8) I2CS I2CS Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t PREC:1; /*!< bit:      0  Stop Received Interrupt            */
    volatile const uint8_t AMATCH:1; /*!< bit:      1  Address Match Interrupt            */
    volatile const uint8_t DRDY:1; /*!< bit:      2  Data Interrupt                     */
    volatile const uint8_t :4; /*!< bit:  3.. 6  Reserved                           */
    volatile const uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_INTFLAG_Type;


#define SERCOM_I2CS_INTFLAG_OFFSET 0x18
#define SERCOM_I2CS_INTFLAG_RESETVALUE _U_(0x00)

#define SERCOM_I2CS_INTFLAG_PREC_Pos 0
#define SERCOM_I2CS_INTFLAG_PREC (_U_(0x1) << SERCOM_I2CS_INTFLAG_PREC_Pos)
#define SERCOM_I2CS_INTFLAG_AMATCH_Pos 1
#define SERCOM_I2CS_INTFLAG_AMATCH (_U_(0x1) << SERCOM_I2CS_INTFLAG_AMATCH_Pos)
#define SERCOM_I2CS_INTFLAG_DRDY_Pos 2
#define SERCOM_I2CS_INTFLAG_DRDY (_U_(0x1) << SERCOM_I2CS_INTFLAG_DRDY_Pos)
#define SERCOM_I2CS_INTFLAG_ERROR_Pos 7
#define SERCOM_I2CS_INTFLAG_ERROR (_U_(0x1) << SERCOM_I2CS_INTFLAG_ERROR_Pos)
#define SERCOM_I2CS_INTFLAG_MASK _U_(0x87)

/* -------- SERCOM_SPI_INTFLAG : (SERCOM Offset: 0x18) (R/W  8) SPI SPI Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t DRE:1; /*!< bit:      0  Data Register Empty Interrupt      */
    volatile const uint8_t TXC:1; /*!< bit:      1  Transmit Complete Interrupt        */
    volatile const uint8_t RXC:1; /*!< bit:      2  Receive Complete Interrupt         */
    volatile const uint8_t SSL:1; /*!< bit:      3  Slave Select Low Interrupt Flag    */
    volatile const uint8_t :3; /*!< bit:  4.. 6  Reserved                           */
    volatile const uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_INTFLAG_Type;


#define SERCOM_SPI_INTFLAG_OFFSET 0x18
#define SERCOM_SPI_INTFLAG_RESETVALUE _U_(0x00)

#define SERCOM_SPI_INTFLAG_DRE_Pos 0
#define SERCOM_SPI_INTFLAG_DRE (_U_(0x1) << SERCOM_SPI_INTFLAG_DRE_Pos)
#define SERCOM_SPI_INTFLAG_TXC_Pos 1
#define SERCOM_SPI_INTFLAG_TXC (_U_(0x1) << SERCOM_SPI_INTFLAG_TXC_Pos)
#define SERCOM_SPI_INTFLAG_RXC_Pos 2
#define SERCOM_SPI_INTFLAG_RXC (_U_(0x1) << SERCOM_SPI_INTFLAG_RXC_Pos)
#define SERCOM_SPI_INTFLAG_SSL_Pos 3
#define SERCOM_SPI_INTFLAG_SSL (_U_(0x1) << SERCOM_SPI_INTFLAG_SSL_Pos)
#define SERCOM_SPI_INTFLAG_ERROR_Pos 7
#define SERCOM_SPI_INTFLAG_ERROR (_U_(0x1) << SERCOM_SPI_INTFLAG_ERROR_Pos)
#define SERCOM_SPI_INTFLAG_MASK _U_(0x8F)

/* -------- SERCOM_USART_INTFLAG : (SERCOM Offset: 0x18) (R/W  8) USART USART Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t DRE:1; /*!< bit:      0  Data Register Empty Interrupt      */
    volatile const uint8_t TXC:1; /*!< bit:      1  Transmit Complete Interrupt        */
    volatile const uint8_t RXC:1; /*!< bit:      2  Receive Complete Interrupt         */
    volatile const uint8_t RXS:1; /*!< bit:      3  Receive Start Interrupt            */
    volatile const uint8_t CTSIC:1; /*!< bit:      4  Clear To Send Input Change Interrupt */
    volatile const uint8_t RXBRK:1; /*!< bit:      5  Break Received Interrupt           */
    volatile const uint8_t :1; /*!< bit:      6  Reserved                           */
    volatile const uint8_t ERROR:1; /*!< bit:      7  Combined Error Interrupt           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_USART_INTFLAG_Type;


#define SERCOM_USART_INTFLAG_OFFSET 0x18
#define SERCOM_USART_INTFLAG_RESETVALUE _U_(0x00)

#define SERCOM_USART_INTFLAG_DRE_Pos 0
#define SERCOM_USART_INTFLAG_DRE (_U_(0x1) << SERCOM_USART_INTFLAG_DRE_Pos)
#define SERCOM_USART_INTFLAG_TXC_Pos 1
#define SERCOM_USART_INTFLAG_TXC (_U_(0x1) << SERCOM_USART_INTFLAG_TXC_Pos)
#define SERCOM_USART_INTFLAG_RXC_Pos 2
#define SERCOM_USART_INTFLAG_RXC (_U_(0x1) << SERCOM_USART_INTFLAG_RXC_Pos)
#define SERCOM_USART_INTFLAG_RXS_Pos 3
#define SERCOM_USART_INTFLAG_RXS (_U_(0x1) << SERCOM_USART_INTFLAG_RXS_Pos)
#define SERCOM_USART_INTFLAG_CTSIC_Pos 4
#define SERCOM_USART_INTFLAG_CTSIC (_U_(0x1) << SERCOM_USART_INTFLAG_CTSIC_Pos)
#define SERCOM_USART_INTFLAG_RXBRK_Pos 5
#define SERCOM_USART_INTFLAG_RXBRK (_U_(0x1) << SERCOM_USART_INTFLAG_RXBRK_Pos)
#define SERCOM_USART_INTFLAG_ERROR_Pos 7
#define SERCOM_USART_INTFLAG_ERROR (_U_(0x1) << SERCOM_USART_INTFLAG_ERROR_Pos)
#define SERCOM_USART_INTFLAG_MASK _U_(0xBF)

/* -------- SERCOM_I2CM_STATUS : (SERCOM Offset: 0x1A) (R/W 16) I2CM I2CM Status -------- */

typedef union {
  struct {
    uint16_t BUSERR:1; /*!< bit:      0  Bus Error                          */
    uint16_t ARBLOST:1; /*!< bit:      1  Arbitration Lost                   */
    uint16_t RXNACK:1; /*!< bit:      2  Received Not Acknowledge           */
    uint16_t :1; /*!< bit:      3  Reserved                           */
    uint16_t BUSSTATE:2; /*!< bit:  4.. 5  Bus State                          */
    uint16_t LOWTOUT:1; /*!< bit:      6  SCL Low Timeout                    */
    uint16_t CLKHOLD:1; /*!< bit:      7  Clock Hold                         */
    uint16_t MEXTTOUT:1; /*!< bit:      8  Master SCL Low Extend Timeout      */
    uint16_t SEXTTOUT:1; /*!< bit:      9  Slave SCL Low Extend Timeout       */
    uint16_t LENERR:1; /*!< bit:     10  Length Error                       */
    uint16_t :5; /*!< bit: 11..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_STATUS_Type;


#define SERCOM_I2CM_STATUS_OFFSET 0x1A
#define SERCOM_I2CM_STATUS_RESETVALUE _U_(0x0000)

#define SERCOM_I2CM_STATUS_BUSERR_Pos 0
#define SERCOM_I2CM_STATUS_BUSERR (_U_(0x1) << SERCOM_I2CM_STATUS_BUSERR_Pos)
#define SERCOM_I2CM_STATUS_ARBLOST_Pos 1
#define SERCOM_I2CM_STATUS_ARBLOST (_U_(0x1) << SERCOM_I2CM_STATUS_ARBLOST_Pos)
#define SERCOM_I2CM_STATUS_RXNACK_Pos 2
#define SERCOM_I2CM_STATUS_RXNACK (_U_(0x1) << SERCOM_I2CM_STATUS_RXNACK_Pos)
#define SERCOM_I2CM_STATUS_BUSSTATE_Pos 4
#define SERCOM_I2CM_STATUS_BUSSTATE_Msk (_U_(0x3) << SERCOM_I2CM_STATUS_BUSSTATE_Pos)
#define SERCOM_I2CM_STATUS_BUSSTATE(value) (SERCOM_I2CM_STATUS_BUSSTATE_Msk & ((value) << SERCOM_I2CM_STATUS_BUSSTATE_Pos))
#define SERCOM_I2CM_STATUS_LOWTOUT_Pos 6
#define SERCOM_I2CM_STATUS_LOWTOUT (_U_(0x1) << SERCOM_I2CM_STATUS_LOWTOUT_Pos)
#define SERCOM_I2CM_STATUS_CLKHOLD_Pos 7
#define SERCOM_I2CM_STATUS_CLKHOLD (_U_(0x1) << SERCOM_I2CM_STATUS_CLKHOLD_Pos)
#define SERCOM_I2CM_STATUS_MEXTTOUT_Pos 8
#define SERCOM_I2CM_STATUS_MEXTTOUT (_U_(0x1) << SERCOM_I2CM_STATUS_MEXTTOUT_Pos)
#define SERCOM_I2CM_STATUS_SEXTTOUT_Pos 9
#define SERCOM_I2CM_STATUS_SEXTTOUT (_U_(0x1) << SERCOM_I2CM_STATUS_SEXTTOUT_Pos)
#define SERCOM_I2CM_STATUS_LENERR_Pos 10
#define SERCOM_I2CM_STATUS_LENERR (_U_(0x1) << SERCOM_I2CM_STATUS_LENERR_Pos)
#define SERCOM_I2CM_STATUS_MASK _U_(0x07F7)

/* -------- SERCOM_I2CS_STATUS : (SERCOM Offset: 0x1A) (R/W 16) I2CS I2CS Status -------- */

typedef union {
  struct {
    uint16_t BUSERR:1; /*!< bit:      0  Bus Error                          */
    uint16_t COLL:1; /*!< bit:      1  Transmit Collision                 */
    uint16_t RXNACK:1; /*!< bit:      2  Received Not Acknowledge           */
    uint16_t DIR:1; /*!< bit:      3  Read/Write Direction               */
    uint16_t SR:1; /*!< bit:      4  Repeated Start                     */
    uint16_t :1; /*!< bit:      5  Reserved                           */
    uint16_t LOWTOUT:1; /*!< bit:      6  SCL Low Timeout                    */
    uint16_t CLKHOLD:1; /*!< bit:      7  Clock Hold                         */
    uint16_t :1; /*!< bit:      8  Reserved                           */
    uint16_t SEXTTOUT:1; /*!< bit:      9  Slave SCL Low Extend Timeout       */
    uint16_t HS:1; /*!< bit:     10  High Speed                         */
    uint16_t :5; /*!< bit: 11..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_STATUS_Type;


#define SERCOM_I2CS_STATUS_OFFSET 0x1A
#define SERCOM_I2CS_STATUS_RESETVALUE _U_(0x0000)

#define SERCOM_I2CS_STATUS_BUSERR_Pos 0
#define SERCOM_I2CS_STATUS_BUSERR (_U_(0x1) << SERCOM_I2CS_STATUS_BUSERR_Pos)
#define SERCOM_I2CS_STATUS_COLL_Pos 1
#define SERCOM_I2CS_STATUS_COLL (_U_(0x1) << SERCOM_I2CS_STATUS_COLL_Pos)
#define SERCOM_I2CS_STATUS_RXNACK_Pos 2
#define SERCOM_I2CS_STATUS_RXNACK (_U_(0x1) << SERCOM_I2CS_STATUS_RXNACK_Pos)
#define SERCOM_I2CS_STATUS_DIR_Pos 3
#define SERCOM_I2CS_STATUS_DIR (_U_(0x1) << SERCOM_I2CS_STATUS_DIR_Pos)
#define SERCOM_I2CS_STATUS_SR_Pos 4
#define SERCOM_I2CS_STATUS_SR (_U_(0x1) << SERCOM_I2CS_STATUS_SR_Pos)
#define SERCOM_I2CS_STATUS_LOWTOUT_Pos 6
#define SERCOM_I2CS_STATUS_LOWTOUT (_U_(0x1) << SERCOM_I2CS_STATUS_LOWTOUT_Pos)
#define SERCOM_I2CS_STATUS_CLKHOLD_Pos 7
#define SERCOM_I2CS_STATUS_CLKHOLD (_U_(0x1) << SERCOM_I2CS_STATUS_CLKHOLD_Pos)
#define SERCOM_I2CS_STATUS_SEXTTOUT_Pos 9
#define SERCOM_I2CS_STATUS_SEXTTOUT (_U_(0x1) << SERCOM_I2CS_STATUS_SEXTTOUT_Pos)
#define SERCOM_I2CS_STATUS_HS_Pos 10
#define SERCOM_I2CS_STATUS_HS (_U_(0x1) << SERCOM_I2CS_STATUS_HS_Pos)
#define SERCOM_I2CS_STATUS_MASK _U_(0x06DF)

/* -------- SERCOM_SPI_STATUS : (SERCOM Offset: 0x1A) (R/W 16) SPI SPI Status -------- */

typedef union {
  struct {
    uint16_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint16_t BUFOVF:1; /*!< bit:      2  Buffer Overflow                    */
    uint16_t :13; /*!< bit:  3..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_STATUS_Type;


#define SERCOM_SPI_STATUS_OFFSET 0x1A
#define SERCOM_SPI_STATUS_RESETVALUE _U_(0x0000)

#define SERCOM_SPI_STATUS_BUFOVF_Pos 2
#define SERCOM_SPI_STATUS_BUFOVF (_U_(0x1) << SERCOM_SPI_STATUS_BUFOVF_Pos)
#define SERCOM_SPI_STATUS_MASK _U_(0x0004)

/* -------- SERCOM_USART_STATUS : (SERCOM Offset: 0x1A) (R/W 16) USART USART Status -------- */

typedef union {
  struct {
    uint16_t PERR:1; /*!< bit:      0  Parity Error                       */
    uint16_t FERR:1; /*!< bit:      1  Frame Error                        */
    uint16_t BUFOVF:1; /*!< bit:      2  Buffer Overflow                    */
    uint16_t CTS:1; /*!< bit:      3  Clear To Send                      */
    uint16_t ISF:1; /*!< bit:      4  Inconsistent Sync Field            */
    uint16_t COLL:1; /*!< bit:      5  Collision Detected                 */
    uint16_t :10; /*!< bit:  6..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SERCOM_USART_STATUS_Type;


#define SERCOM_USART_STATUS_OFFSET 0x1A
#define SERCOM_USART_STATUS_RESETVALUE _U_(0x0000)

#define SERCOM_USART_STATUS_PERR_Pos 0
#define SERCOM_USART_STATUS_PERR (_U_(0x1) << SERCOM_USART_STATUS_PERR_Pos)
#define SERCOM_USART_STATUS_FERR_Pos 1
#define SERCOM_USART_STATUS_FERR (_U_(0x1) << SERCOM_USART_STATUS_FERR_Pos)
#define SERCOM_USART_STATUS_BUFOVF_Pos 2
#define SERCOM_USART_STATUS_BUFOVF (_U_(0x1) << SERCOM_USART_STATUS_BUFOVF_Pos)
#define SERCOM_USART_STATUS_CTS_Pos 3
#define SERCOM_USART_STATUS_CTS (_U_(0x1) << SERCOM_USART_STATUS_CTS_Pos)
#define SERCOM_USART_STATUS_ISF_Pos 4
#define SERCOM_USART_STATUS_ISF (_U_(0x1) << SERCOM_USART_STATUS_ISF_Pos)
#define SERCOM_USART_STATUS_COLL_Pos 5
#define SERCOM_USART_STATUS_COLL (_U_(0x1) << SERCOM_USART_STATUS_COLL_Pos)
#define SERCOM_USART_STATUS_MASK _U_(0x003F)

/* -------- SERCOM_I2CM_SYNCBUSY : (SERCOM Offset: 0x1C) (R/  32) I2CM I2CM Syncbusy -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset Synchronization Busy */
    uint32_t ENABLE:1; /*!< bit:      1  SERCOM Enable Synchronization Busy */
    uint32_t SYSOP:1; /*!< bit:      2  System Operation Synchronization Busy */
    uint32_t :29; /*!< bit:  3..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_SYNCBUSY_Type;


#define SERCOM_I2CM_SYNCBUSY_OFFSET 0x1C
#define SERCOM_I2CM_SYNCBUSY_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CM_SYNCBUSY_SWRST_Pos 0
#define SERCOM_I2CM_SYNCBUSY_SWRST (_U_(0x1) << SERCOM_I2CM_SYNCBUSY_SWRST_Pos)
#define SERCOM_I2CM_SYNCBUSY_ENABLE_Pos 1
#define SERCOM_I2CM_SYNCBUSY_ENABLE (_U_(0x1) << SERCOM_I2CM_SYNCBUSY_ENABLE_Pos)
#define SERCOM_I2CM_SYNCBUSY_SYSOP_Pos 2
#define SERCOM_I2CM_SYNCBUSY_SYSOP (_U_(0x1) << SERCOM_I2CM_SYNCBUSY_SYSOP_Pos)
#define SERCOM_I2CM_SYNCBUSY_MASK _U_(0x00000007)

/* -------- SERCOM_I2CS_SYNCBUSY : (SERCOM Offset: 0x1C) (R/  32) I2CS I2CS Syncbusy -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset Synchronization Busy */
    uint32_t ENABLE:1; /*!< bit:      1  SERCOM Enable Synchronization Busy */
    uint32_t :30; /*!< bit:  2..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_SYNCBUSY_Type;


#define SERCOM_I2CS_SYNCBUSY_OFFSET 0x1C
#define SERCOM_I2CS_SYNCBUSY_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CS_SYNCBUSY_SWRST_Pos 0
#define SERCOM_I2CS_SYNCBUSY_SWRST (_U_(0x1) << SERCOM_I2CS_SYNCBUSY_SWRST_Pos)
#define SERCOM_I2CS_SYNCBUSY_ENABLE_Pos 1
#define SERCOM_I2CS_SYNCBUSY_ENABLE (_U_(0x1) << SERCOM_I2CS_SYNCBUSY_ENABLE_Pos)
#define SERCOM_I2CS_SYNCBUSY_MASK _U_(0x00000003)

/* -------- SERCOM_SPI_SYNCBUSY : (SERCOM Offset: 0x1C) (R/  32) SPI SPI Syncbusy -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset Synchronization Busy */
    uint32_t ENABLE:1; /*!< bit:      1  SERCOM Enable Synchronization Busy */
    uint32_t CTRLB:1; /*!< bit:      2  CTRLB Synchronization Busy         */
    uint32_t :29; /*!< bit:  3..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_SYNCBUSY_Type;


#define SERCOM_SPI_SYNCBUSY_OFFSET 0x1C
#define SERCOM_SPI_SYNCBUSY_RESETVALUE _U_(0x00000000)

#define SERCOM_SPI_SYNCBUSY_SWRST_Pos 0
#define SERCOM_SPI_SYNCBUSY_SWRST (_U_(0x1) << SERCOM_SPI_SYNCBUSY_SWRST_Pos)
#define SERCOM_SPI_SYNCBUSY_ENABLE_Pos 1
#define SERCOM_SPI_SYNCBUSY_ENABLE (_U_(0x1) << SERCOM_SPI_SYNCBUSY_ENABLE_Pos)
#define SERCOM_SPI_SYNCBUSY_CTRLB_Pos 2
#define SERCOM_SPI_SYNCBUSY_CTRLB (_U_(0x1) << SERCOM_SPI_SYNCBUSY_CTRLB_Pos)
#define SERCOM_SPI_SYNCBUSY_MASK _U_(0x00000007)

/* -------- SERCOM_USART_SYNCBUSY : (SERCOM Offset: 0x1C) (R/  32) USART USART Syncbusy -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset Synchronization Busy */
    uint32_t ENABLE:1; /*!< bit:      1  SERCOM Enable Synchronization Busy */
    uint32_t CTRLB:1; /*!< bit:      2  CTRLB Synchronization Busy         */
    uint32_t :29; /*!< bit:  3..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_USART_SYNCBUSY_Type;


#define SERCOM_USART_SYNCBUSY_OFFSET 0x1C
#define SERCOM_USART_SYNCBUSY_RESETVALUE _U_(0x00000000)

#define SERCOM_USART_SYNCBUSY_SWRST_Pos 0
#define SERCOM_USART_SYNCBUSY_SWRST (_U_(0x1) << SERCOM_USART_SYNCBUSY_SWRST_Pos)
#define SERCOM_USART_SYNCBUSY_ENABLE_Pos 1
#define SERCOM_USART_SYNCBUSY_ENABLE (_U_(0x1) << SERCOM_USART_SYNCBUSY_ENABLE_Pos)
#define SERCOM_USART_SYNCBUSY_CTRLB_Pos 2
#define SERCOM_USART_SYNCBUSY_CTRLB (_U_(0x1) << SERCOM_USART_SYNCBUSY_CTRLB_Pos)
#define SERCOM_USART_SYNCBUSY_MASK _U_(0x00000007)

/* -------- SERCOM_I2CM_ADDR : (SERCOM Offset: 0x24) (R/W 32) I2CM I2CM Address -------- */

typedef union {
  struct {
    uint32_t ADDR:11; /*!< bit:  0..10  Address Value                      */
    uint32_t :2; /*!< bit: 11..12  Reserved                           */
    uint32_t LENEN:1; /*!< bit:     13  Length Enable                      */
    uint32_t HS:1; /*!< bit:     14  High Speed Mode                    */
    uint32_t TENBITEN:1; /*!< bit:     15  Ten Bit Addressing Enable          */
    uint32_t LEN:8; /*!< bit: 16..23  Length                             */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_ADDR_Type;


#define SERCOM_I2CM_ADDR_OFFSET 0x24
#define SERCOM_I2CM_ADDR_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CM_ADDR_ADDR_Pos 0
#define SERCOM_I2CM_ADDR_ADDR_Msk (_U_(0x7FF) << SERCOM_I2CM_ADDR_ADDR_Pos)
#define SERCOM_I2CM_ADDR_ADDR(value) (SERCOM_I2CM_ADDR_ADDR_Msk & ((value) << SERCOM_I2CM_ADDR_ADDR_Pos))
#define SERCOM_I2CM_ADDR_LENEN_Pos 13
#define SERCOM_I2CM_ADDR_LENEN (_U_(0x1) << SERCOM_I2CM_ADDR_LENEN_Pos)
#define SERCOM_I2CM_ADDR_HS_Pos 14
#define SERCOM_I2CM_ADDR_HS (_U_(0x1) << SERCOM_I2CM_ADDR_HS_Pos)
#define SERCOM_I2CM_ADDR_TENBITEN_Pos 15
#define SERCOM_I2CM_ADDR_TENBITEN (_U_(0x1) << SERCOM_I2CM_ADDR_TENBITEN_Pos)
#define SERCOM_I2CM_ADDR_LEN_Pos 16
#define SERCOM_I2CM_ADDR_LEN_Msk (_U_(0xFF) << SERCOM_I2CM_ADDR_LEN_Pos)
#define SERCOM_I2CM_ADDR_LEN(value) (SERCOM_I2CM_ADDR_LEN_Msk & ((value) << SERCOM_I2CM_ADDR_LEN_Pos))
#define SERCOM_I2CM_ADDR_MASK _U_(0x00FFE7FF)

/* -------- SERCOM_I2CS_ADDR : (SERCOM Offset: 0x24) (R/W 32) I2CS I2CS Address -------- */

typedef union {
  struct {
    uint32_t GENCEN:1; /*!< bit:      0  General Call Address Enable        */
    uint32_t ADDR:10; /*!< bit:  1..10  Address Value                      */
    uint32_t :4; /*!< bit: 11..14  Reserved                           */
    uint32_t TENBITEN:1; /*!< bit:     15  Ten Bit Addressing Enable          */
    uint32_t :1; /*!< bit:     16  Reserved                           */
    uint32_t ADDRMASK:10; /*!< bit: 17..26  Address Mask                       */
    uint32_t :5; /*!< bit: 27..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_ADDR_Type;


#define SERCOM_I2CS_ADDR_OFFSET 0x24
#define SERCOM_I2CS_ADDR_RESETVALUE _U_(0x00000000)

#define SERCOM_I2CS_ADDR_GENCEN_Pos 0
#define SERCOM_I2CS_ADDR_GENCEN (_U_(0x1) << SERCOM_I2CS_ADDR_GENCEN_Pos)
#define SERCOM_I2CS_ADDR_ADDR_Pos 1
#define SERCOM_I2CS_ADDR_ADDR_Msk (_U_(0x3FF) << SERCOM_I2CS_ADDR_ADDR_Pos)
#define SERCOM_I2CS_ADDR_ADDR(value) (SERCOM_I2CS_ADDR_ADDR_Msk & ((value) << SERCOM_I2CS_ADDR_ADDR_Pos))
#define SERCOM_I2CS_ADDR_TENBITEN_Pos 15
#define SERCOM_I2CS_ADDR_TENBITEN (_U_(0x1) << SERCOM_I2CS_ADDR_TENBITEN_Pos)
#define SERCOM_I2CS_ADDR_ADDRMASK_Pos 17
#define SERCOM_I2CS_ADDR_ADDRMASK_Msk (_U_(0x3FF) << SERCOM_I2CS_ADDR_ADDRMASK_Pos)
#define SERCOM_I2CS_ADDR_ADDRMASK(value) (SERCOM_I2CS_ADDR_ADDRMASK_Msk & ((value) << SERCOM_I2CS_ADDR_ADDRMASK_Pos))
#define SERCOM_I2CS_ADDR_MASK _U_(0x07FE87FF)

/* -------- SERCOM_SPI_ADDR : (SERCOM Offset: 0x24) (R/W 32) SPI SPI Address -------- */

typedef union {
  struct {
    uint32_t ADDR:8; /*!< bit:  0.. 7  Address Value                      */
    uint32_t :8; /*!< bit:  8..15  Reserved                           */
    uint32_t ADDRMASK:8; /*!< bit: 16..23  Address Mask                       */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_ADDR_Type;


#define SERCOM_SPI_ADDR_OFFSET 0x24
#define SERCOM_SPI_ADDR_RESETVALUE _U_(0x00000000)

#define SERCOM_SPI_ADDR_ADDR_Pos 0
#define SERCOM_SPI_ADDR_ADDR_Msk (_U_(0xFF) << SERCOM_SPI_ADDR_ADDR_Pos)
#define SERCOM_SPI_ADDR_ADDR(value) (SERCOM_SPI_ADDR_ADDR_Msk & ((value) << SERCOM_SPI_ADDR_ADDR_Pos))
#define SERCOM_SPI_ADDR_ADDRMASK_Pos 16
#define SERCOM_SPI_ADDR_ADDRMASK_Msk (_U_(0xFF) << SERCOM_SPI_ADDR_ADDRMASK_Pos)
#define SERCOM_SPI_ADDR_ADDRMASK(value) (SERCOM_SPI_ADDR_ADDRMASK_Msk & ((value) << SERCOM_SPI_ADDR_ADDRMASK_Pos))
#define SERCOM_SPI_ADDR_MASK _U_(0x00FF00FF)

/* -------- SERCOM_I2CM_DATA : (SERCOM Offset: 0x28) (R/W  8) I2CM I2CM Data -------- */

typedef union {
  struct {
    uint8_t DATA:8; /*!< bit:  0.. 7  Data Value                         */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_DATA_Type;


#define SERCOM_I2CM_DATA_OFFSET 0x28
#define SERCOM_I2CM_DATA_RESETVALUE _U_(0x00)

#define SERCOM_I2CM_DATA_DATA_Pos 0
#define SERCOM_I2CM_DATA_DATA_Msk (_U_(0xFF) << SERCOM_I2CM_DATA_DATA_Pos)
#define SERCOM_I2CM_DATA_DATA(value) (SERCOM_I2CM_DATA_DATA_Msk & ((value) << SERCOM_I2CM_DATA_DATA_Pos))
#define SERCOM_I2CM_DATA_MASK _U_(0xFF)

/* -------- SERCOM_I2CS_DATA : (SERCOM Offset: 0x28) (R/W  8) I2CS I2CS Data -------- */

typedef union {
  struct {
    uint8_t DATA:8; /*!< bit:  0.. 7  Data Value                         */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CS_DATA_Type;


#define SERCOM_I2CS_DATA_OFFSET 0x28
#define SERCOM_I2CS_DATA_RESETVALUE _U_(0x00)

#define SERCOM_I2CS_DATA_DATA_Pos 0
#define SERCOM_I2CS_DATA_DATA_Msk (_U_(0xFF) << SERCOM_I2CS_DATA_DATA_Pos)
#define SERCOM_I2CS_DATA_DATA(value) (SERCOM_I2CS_DATA_DATA_Msk & ((value) << SERCOM_I2CS_DATA_DATA_Pos))
#define SERCOM_I2CS_DATA_MASK _U_(0xFF)

/* -------- SERCOM_SPI_DATA : (SERCOM Offset: 0x28) (R/W 32) SPI SPI Data -------- */

typedef union {
  struct {
    uint32_t DATA:9; /*!< bit:  0.. 8  Data Value                         */
    uint32_t :23; /*!< bit:  9..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_DATA_Type;


#define SERCOM_SPI_DATA_OFFSET 0x28
#define SERCOM_SPI_DATA_RESETVALUE _U_(0x00000000)

#define SERCOM_SPI_DATA_DATA_Pos 0
#define SERCOM_SPI_DATA_DATA_Msk (_U_(0x1FF) << SERCOM_SPI_DATA_DATA_Pos)
#define SERCOM_SPI_DATA_DATA(value) (SERCOM_SPI_DATA_DATA_Msk & ((value) << SERCOM_SPI_DATA_DATA_Pos))
#define SERCOM_SPI_DATA_MASK _U_(0x000001FF)

/* -------- SERCOM_USART_DATA : (SERCOM Offset: 0x28) (R/W 16) USART USART Data -------- */

typedef union {
  struct {
    uint16_t DATA:9; /*!< bit:  0.. 8  Data Value                         */
    uint16_t :7; /*!< bit:  9..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SERCOM_USART_DATA_Type;


#define SERCOM_USART_DATA_OFFSET 0x28
#define SERCOM_USART_DATA_RESETVALUE _U_(0x0000)

#define SERCOM_USART_DATA_DATA_Pos 0
#define SERCOM_USART_DATA_DATA_Msk (_U_(0x1FF) << SERCOM_USART_DATA_DATA_Pos)
#define SERCOM_USART_DATA_DATA(value) (SERCOM_USART_DATA_DATA_Msk & ((value) << SERCOM_USART_DATA_DATA_Pos))
#define SERCOM_USART_DATA_MASK _U_(0x01FF)

/* -------- SERCOM_I2CM_DBGCTRL : (SERCOM Offset: 0x30) (R/W  8) I2CM I2CM Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGSTOP:1; /*!< bit:      0  Debug Mode                         */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_I2CM_DBGCTRL_Type;


#define SERCOM_I2CM_DBGCTRL_OFFSET 0x30
#define SERCOM_I2CM_DBGCTRL_RESETVALUE _U_(0x00)

#define SERCOM_I2CM_DBGCTRL_DBGSTOP_Pos 0
#define SERCOM_I2CM_DBGCTRL_DBGSTOP (_U_(0x1) << SERCOM_I2CM_DBGCTRL_DBGSTOP_Pos)
#define SERCOM_I2CM_DBGCTRL_MASK _U_(0x01)

/* -------- SERCOM_SPI_DBGCTRL : (SERCOM Offset: 0x30) (R/W  8) SPI SPI Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGSTOP:1; /*!< bit:      0  Debug Mode                         */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_SPI_DBGCTRL_Type;


#define SERCOM_SPI_DBGCTRL_OFFSET 0x30
#define SERCOM_SPI_DBGCTRL_RESETVALUE _U_(0x00)

#define SERCOM_SPI_DBGCTRL_DBGSTOP_Pos 0
#define SERCOM_SPI_DBGCTRL_DBGSTOP (_U_(0x1) << SERCOM_SPI_DBGCTRL_DBGSTOP_Pos)
#define SERCOM_SPI_DBGCTRL_MASK _U_(0x01)

/* -------- SERCOM_USART_DBGCTRL : (SERCOM Offset: 0x30) (R/W  8) USART USART Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGSTOP:1; /*!< bit:      0  Debug Mode                         */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SERCOM_USART_DBGCTRL_Type;


#define SERCOM_USART_DBGCTRL_OFFSET 0x30
#define SERCOM_USART_DBGCTRL_RESETVALUE _U_(0x00)

#define SERCOM_USART_DBGCTRL_DBGSTOP_Pos 0
#define SERCOM_USART_DBGCTRL_DBGSTOP (_U_(0x1) << SERCOM_USART_DBGCTRL_DBGSTOP_Pos)
#define SERCOM_USART_DBGCTRL_MASK _U_(0x01)

/** \brief SERCOM_I2CM hardware registers */

typedef struct { /* I2C Master Mode */
  volatile SERCOM_I2CM_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 32) I2CM Control A */
  volatile SERCOM_I2CM_CTRLB_Type CTRLB; /**< \brief Offset: 0x04 (R/W 32) I2CM Control B */
       RoReg8 Reserved1[0x4];
  volatile SERCOM_I2CM_BAUD_Type BAUD; /**< \brief Offset: 0x0C (R/W 32) I2CM Baud Rate */
       RoReg8 Reserved2[0x4];
  volatile SERCOM_I2CM_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x14 (R/W  8) I2CM Interrupt Enable Clear */
       RoReg8 Reserved3[0x1];
  volatile SERCOM_I2CM_INTENSET_Type INTENSET; /**< \brief Offset: 0x16 (R/W  8) I2CM Interrupt Enable Set */
       RoReg8 Reserved4[0x1];
  volatile SERCOM_I2CM_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x18 (R/W  8) I2CM Interrupt Flag Status and Clear */
       RoReg8 Reserved5[0x1];
  volatile SERCOM_I2CM_STATUS_Type STATUS; /**< \brief Offset: 0x1A (R/W 16) I2CM Status */
  volatile const SERCOM_I2CM_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x1C (R/  32) I2CM Syncbusy */
       RoReg8 Reserved6[0x4];
  volatile SERCOM_I2CM_ADDR_Type ADDR; /**< \brief Offset: 0x24 (R/W 32) I2CM Address */
  volatile SERCOM_I2CM_DATA_Type DATA; /**< \brief Offset: 0x28 (R/W  8) I2CM Data */
       RoReg8 Reserved7[0x7];
  volatile SERCOM_I2CM_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x30 (R/W  8) I2CM Debug Control */
} SercomI2cm;


/** \brief SERCOM_I2CS hardware registers */

typedef struct { /* I2C Slave Mode */
  volatile SERCOM_I2CS_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 32) I2CS Control A */
  volatile SERCOM_I2CS_CTRLB_Type CTRLB; /**< \brief Offset: 0x04 (R/W 32) I2CS Control B */
       RoReg8 Reserved1[0xC];
  volatile SERCOM_I2CS_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x14 (R/W  8) I2CS Interrupt Enable Clear */
       RoReg8 Reserved2[0x1];
  volatile SERCOM_I2CS_INTENSET_Type INTENSET; /**< \brief Offset: 0x16 (R/W  8) I2CS Interrupt Enable Set */
       RoReg8 Reserved3[0x1];
  volatile SERCOM_I2CS_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x18 (R/W  8) I2CS Interrupt Flag Status and Clear */
       RoReg8 Reserved4[0x1];
  volatile SERCOM_I2CS_STATUS_Type STATUS; /**< \brief Offset: 0x1A (R/W 16) I2CS Status */
  volatile const SERCOM_I2CS_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x1C (R/  32) I2CS Syncbusy */
       RoReg8 Reserved5[0x4];
  volatile SERCOM_I2CS_ADDR_Type ADDR; /**< \brief Offset: 0x24 (R/W 32) I2CS Address */
  volatile SERCOM_I2CS_DATA_Type DATA; /**< \brief Offset: 0x28 (R/W  8) I2CS Data */
} SercomI2cs;


/** \brief SERCOM_SPI hardware registers */

typedef struct { /* SPI Mode */
  volatile SERCOM_SPI_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 32) SPI Control A */
  volatile SERCOM_SPI_CTRLB_Type CTRLB; /**< \brief Offset: 0x04 (R/W 32) SPI Control B */
       RoReg8 Reserved1[0x4];
  volatile SERCOM_SPI_BAUD_Type BAUD; /**< \brief Offset: 0x0C (R/W  8) SPI Baud Rate */
       RoReg8 Reserved2[0x7];
  volatile SERCOM_SPI_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x14 (R/W  8) SPI Interrupt Enable Clear */
       RoReg8 Reserved3[0x1];
  volatile SERCOM_SPI_INTENSET_Type INTENSET; /**< \brief Offset: 0x16 (R/W  8) SPI Interrupt Enable Set */
       RoReg8 Reserved4[0x1];
  volatile SERCOM_SPI_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x18 (R/W  8) SPI Interrupt Flag Status and Clear */
       RoReg8 Reserved5[0x1];
  volatile SERCOM_SPI_STATUS_Type STATUS; /**< \brief Offset: 0x1A (R/W 16) SPI Status */
  volatile const SERCOM_SPI_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x1C (R/  32) SPI Syncbusy */
       RoReg8 Reserved6[0x4];
  volatile SERCOM_SPI_ADDR_Type ADDR; /**< \brief Offset: 0x24 (R/W 32) SPI Address */
  volatile SERCOM_SPI_DATA_Type DATA; /**< \brief Offset: 0x28 (R/W 32) SPI Data */
       RoReg8 Reserved7[0x4];
  volatile SERCOM_SPI_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x30 (R/W  8) SPI Debug Control */
} SercomSpi;


/** \brief SERCOM_USART hardware registers */

typedef struct { /* USART Mode */
  volatile SERCOM_USART_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 32) USART Control A */
  volatile SERCOM_USART_CTRLB_Type CTRLB; /**< \brief Offset: 0x04 (R/W 32) USART Control B */
       RoReg8 Reserved1[0x4];
  volatile SERCOM_USART_BAUD_Type BAUD; /**< \brief Offset: 0x0C (R/W 16) USART Baud Rate */
  volatile SERCOM_USART_RXPL_Type RXPL; /**< \brief Offset: 0x0E (R/W  8) USART Receive Pulse Length */
       RoReg8 Reserved2[0x5];
  volatile SERCOM_USART_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x14 (R/W  8) USART Interrupt Enable Clear */
       RoReg8 Reserved3[0x1];
  volatile SERCOM_USART_INTENSET_Type INTENSET; /**< \brief Offset: 0x16 (R/W  8) USART Interrupt Enable Set */
       RoReg8 Reserved4[0x1];
  volatile SERCOM_USART_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x18 (R/W  8) USART Interrupt Flag Status and Clear */
       RoReg8 Reserved5[0x1];
  volatile SERCOM_USART_STATUS_Type STATUS; /**< \brief Offset: 0x1A (R/W 16) USART Status */
  volatile const SERCOM_USART_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x1C (R/  32) USART Syncbusy */
       RoReg8 Reserved6[0x8];
  volatile SERCOM_USART_DATA_Type DATA; /**< \brief Offset: 0x28 (R/W 16) USART Data */
       RoReg8 Reserved7[0x6];
  volatile SERCOM_USART_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x30 (R/W  8) USART Debug Control */
} SercomUsart;



typedef union {
       SercomI2cm I2CM; /**< \brief Offset: 0x00 I2C Master Mode */
       SercomI2cs I2CS; /**< \brief Offset: 0x00 I2C Slave Mode */
       SercomSpi SPI; /**< \brief Offset: 0x00 SPI Mode */
       SercomUsart USART; /**< \brief Offset: 0x00 USART Mode */
} Sercom;


/*@}*/
# 261 "asf4/samd21/include/samd21e18a.h" 2
#include "component/sysctrl.h"
# 261 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/sysctrl.h" 1
/**
 * \file
 *
 * \brief Component description for SYSCTRL
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SYSCTRL_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR SYSCTRL */
/* ========================================================================== */
/** \addtogroup SAMD21_SYSCTRL System Control */
/*@{*/

#define SYSCTRL_U2100 
#define REV_SYSCTRL 0x201

/* -------- SYSCTRL_INTENCLR : (SYSCTRL Offset: 0x00) (R/W 32) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint32_t XOSCRDY:1; /*!< bit:      0  XOSC Ready Interrupt Enable        */
    uint32_t XOSC32KRDY:1; /*!< bit:      1  XOSC32K Ready Interrupt Enable     */
    uint32_t OSC32KRDY:1; /*!< bit:      2  OSC32K Ready Interrupt Enable      */
    uint32_t OSC8MRDY:1; /*!< bit:      3  OSC8M Ready Interrupt Enable       */
    uint32_t DFLLRDY:1; /*!< bit:      4  DFLL Ready Interrupt Enable        */
    uint32_t DFLLOOB:1; /*!< bit:      5  DFLL Out Of Bounds Interrupt Enable */
    uint32_t DFLLLCKF:1; /*!< bit:      6  DFLL Lock Fine Interrupt Enable    */
    uint32_t DFLLLCKC:1; /*!< bit:      7  DFLL Lock Coarse Interrupt Enable  */
    uint32_t DFLLRCS:1; /*!< bit:      8  DFLL Reference Clock Stopped Interrupt Enable */
    uint32_t BOD33RDY:1; /*!< bit:      9  BOD33 Ready Interrupt Enable       */
    uint32_t BOD33DET:1; /*!< bit:     10  BOD33 Detection Interrupt Enable   */
    uint32_t B33SRDY:1; /*!< bit:     11  BOD33 Synchronization Ready Interrupt Enable */
    uint32_t :3; /*!< bit: 12..14  Reserved                           */
    uint32_t DPLLLCKR:1; /*!< bit:     15  DPLL Lock Rise Interrupt Enable    */
    uint32_t DPLLLCKF:1; /*!< bit:     16  DPLL Lock Fall Interrupt Enable    */
    uint32_t DPLLLTO:1; /*!< bit:     17  DPLL Lock Timeout Interrupt Enable */
    uint32_t :14; /*!< bit: 18..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_INTENCLR_Type;


#define SYSCTRL_INTENCLR_OFFSET 0x00
#define SYSCTRL_INTENCLR_RESETVALUE _U_(0x00000000)

#define SYSCTRL_INTENCLR_XOSCRDY_Pos 0
#define SYSCTRL_INTENCLR_XOSCRDY (_U_(0x1) << SYSCTRL_INTENCLR_XOSCRDY_Pos)
#define SYSCTRL_INTENCLR_XOSC32KRDY_Pos 1
#define SYSCTRL_INTENCLR_XOSC32KRDY (_U_(0x1) << SYSCTRL_INTENCLR_XOSC32KRDY_Pos)
#define SYSCTRL_INTENCLR_OSC32KRDY_Pos 2
#define SYSCTRL_INTENCLR_OSC32KRDY (_U_(0x1) << SYSCTRL_INTENCLR_OSC32KRDY_Pos)
#define SYSCTRL_INTENCLR_OSC8MRDY_Pos 3
#define SYSCTRL_INTENCLR_OSC8MRDY (_U_(0x1) << SYSCTRL_INTENCLR_OSC8MRDY_Pos)
#define SYSCTRL_INTENCLR_DFLLRDY_Pos 4
#define SYSCTRL_INTENCLR_DFLLRDY (_U_(0x1) << SYSCTRL_INTENCLR_DFLLRDY_Pos)
#define SYSCTRL_INTENCLR_DFLLOOB_Pos 5
#define SYSCTRL_INTENCLR_DFLLOOB (_U_(0x1) << SYSCTRL_INTENCLR_DFLLOOB_Pos)
#define SYSCTRL_INTENCLR_DFLLLCKF_Pos 6
#define SYSCTRL_INTENCLR_DFLLLCKF (_U_(0x1) << SYSCTRL_INTENCLR_DFLLLCKF_Pos)
#define SYSCTRL_INTENCLR_DFLLLCKC_Pos 7
#define SYSCTRL_INTENCLR_DFLLLCKC (_U_(0x1) << SYSCTRL_INTENCLR_DFLLLCKC_Pos)
#define SYSCTRL_INTENCLR_DFLLRCS_Pos 8
#define SYSCTRL_INTENCLR_DFLLRCS (_U_(0x1) << SYSCTRL_INTENCLR_DFLLRCS_Pos)
#define SYSCTRL_INTENCLR_BOD33RDY_Pos 9
#define SYSCTRL_INTENCLR_BOD33RDY (_U_(0x1) << SYSCTRL_INTENCLR_BOD33RDY_Pos)
#define SYSCTRL_INTENCLR_BOD33DET_Pos 10
#define SYSCTRL_INTENCLR_BOD33DET (_U_(0x1) << SYSCTRL_INTENCLR_BOD33DET_Pos)
#define SYSCTRL_INTENCLR_B33SRDY_Pos 11
#define SYSCTRL_INTENCLR_B33SRDY (_U_(0x1) << SYSCTRL_INTENCLR_B33SRDY_Pos)
#define SYSCTRL_INTENCLR_DPLLLCKR_Pos 15
#define SYSCTRL_INTENCLR_DPLLLCKR (_U_(0x1) << SYSCTRL_INTENCLR_DPLLLCKR_Pos)
#define SYSCTRL_INTENCLR_DPLLLCKF_Pos 16
#define SYSCTRL_INTENCLR_DPLLLCKF (_U_(0x1) << SYSCTRL_INTENCLR_DPLLLCKF_Pos)
#define SYSCTRL_INTENCLR_DPLLLTO_Pos 17
#define SYSCTRL_INTENCLR_DPLLLTO (_U_(0x1) << SYSCTRL_INTENCLR_DPLLLTO_Pos)
#define SYSCTRL_INTENCLR_MASK _U_(0x00038FFF)

/* -------- SYSCTRL_INTENSET : (SYSCTRL Offset: 0x04) (R/W 32) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint32_t XOSCRDY:1; /*!< bit:      0  XOSC Ready Interrupt Enable        */
    uint32_t XOSC32KRDY:1; /*!< bit:      1  XOSC32K Ready Interrupt Enable     */
    uint32_t OSC32KRDY:1; /*!< bit:      2  OSC32K Ready Interrupt Enable      */
    uint32_t OSC8MRDY:1; /*!< bit:      3  OSC8M Ready Interrupt Enable       */
    uint32_t DFLLRDY:1; /*!< bit:      4  DFLL Ready Interrupt Enable        */
    uint32_t DFLLOOB:1; /*!< bit:      5  DFLL Out Of Bounds Interrupt Enable */
    uint32_t DFLLLCKF:1; /*!< bit:      6  DFLL Lock Fine Interrupt Enable    */
    uint32_t DFLLLCKC:1; /*!< bit:      7  DFLL Lock Coarse Interrupt Enable  */
    uint32_t DFLLRCS:1; /*!< bit:      8  DFLL Reference Clock Stopped Interrupt Enable */
    uint32_t BOD33RDY:1; /*!< bit:      9  BOD33 Ready Interrupt Enable       */
    uint32_t BOD33DET:1; /*!< bit:     10  BOD33 Detection Interrupt Enable   */
    uint32_t B33SRDY:1; /*!< bit:     11  BOD33 Synchronization Ready Interrupt Enable */
    uint32_t :3; /*!< bit: 12..14  Reserved                           */
    uint32_t DPLLLCKR:1; /*!< bit:     15  DPLL Lock Rise Interrupt Enable    */
    uint32_t DPLLLCKF:1; /*!< bit:     16  DPLL Lock Fall Interrupt Enable    */
    uint32_t DPLLLTO:1; /*!< bit:     17  DPLL Lock Timeout Interrupt Enable */
    uint32_t :14; /*!< bit: 18..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_INTENSET_Type;


#define SYSCTRL_INTENSET_OFFSET 0x04
#define SYSCTRL_INTENSET_RESETVALUE _U_(0x00000000)

#define SYSCTRL_INTENSET_XOSCRDY_Pos 0
#define SYSCTRL_INTENSET_XOSCRDY (_U_(0x1) << SYSCTRL_INTENSET_XOSCRDY_Pos)
#define SYSCTRL_INTENSET_XOSC32KRDY_Pos 1
#define SYSCTRL_INTENSET_XOSC32KRDY (_U_(0x1) << SYSCTRL_INTENSET_XOSC32KRDY_Pos)
#define SYSCTRL_INTENSET_OSC32KRDY_Pos 2
#define SYSCTRL_INTENSET_OSC32KRDY (_U_(0x1) << SYSCTRL_INTENSET_OSC32KRDY_Pos)
#define SYSCTRL_INTENSET_OSC8MRDY_Pos 3
#define SYSCTRL_INTENSET_OSC8MRDY (_U_(0x1) << SYSCTRL_INTENSET_OSC8MRDY_Pos)
#define SYSCTRL_INTENSET_DFLLRDY_Pos 4
#define SYSCTRL_INTENSET_DFLLRDY (_U_(0x1) << SYSCTRL_INTENSET_DFLLRDY_Pos)
#define SYSCTRL_INTENSET_DFLLOOB_Pos 5
#define SYSCTRL_INTENSET_DFLLOOB (_U_(0x1) << SYSCTRL_INTENSET_DFLLOOB_Pos)
#define SYSCTRL_INTENSET_DFLLLCKF_Pos 6
#define SYSCTRL_INTENSET_DFLLLCKF (_U_(0x1) << SYSCTRL_INTENSET_DFLLLCKF_Pos)
#define SYSCTRL_INTENSET_DFLLLCKC_Pos 7
#define SYSCTRL_INTENSET_DFLLLCKC (_U_(0x1) << SYSCTRL_INTENSET_DFLLLCKC_Pos)
#define SYSCTRL_INTENSET_DFLLRCS_Pos 8
#define SYSCTRL_INTENSET_DFLLRCS (_U_(0x1) << SYSCTRL_INTENSET_DFLLRCS_Pos)
#define SYSCTRL_INTENSET_BOD33RDY_Pos 9
#define SYSCTRL_INTENSET_BOD33RDY (_U_(0x1) << SYSCTRL_INTENSET_BOD33RDY_Pos)
#define SYSCTRL_INTENSET_BOD33DET_Pos 10
#define SYSCTRL_INTENSET_BOD33DET (_U_(0x1) << SYSCTRL_INTENSET_BOD33DET_Pos)
#define SYSCTRL_INTENSET_B33SRDY_Pos 11
#define SYSCTRL_INTENSET_B33SRDY (_U_(0x1) << SYSCTRL_INTENSET_B33SRDY_Pos)
#define SYSCTRL_INTENSET_DPLLLCKR_Pos 15
#define SYSCTRL_INTENSET_DPLLLCKR (_U_(0x1) << SYSCTRL_INTENSET_DPLLLCKR_Pos)
#define SYSCTRL_INTENSET_DPLLLCKF_Pos 16
#define SYSCTRL_INTENSET_DPLLLCKF (_U_(0x1) << SYSCTRL_INTENSET_DPLLLCKF_Pos)
#define SYSCTRL_INTENSET_DPLLLTO_Pos 17
#define SYSCTRL_INTENSET_DPLLLTO (_U_(0x1) << SYSCTRL_INTENSET_DPLLLTO_Pos)
#define SYSCTRL_INTENSET_MASK _U_(0x00038FFF)

/* -------- SYSCTRL_INTFLAG : (SYSCTRL Offset: 0x08) (R/W 32) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint32_t XOSCRDY:1; /*!< bit:      0  XOSC Ready                         */
    volatile const uint32_t XOSC32KRDY:1; /*!< bit:      1  XOSC32K Ready                      */
    volatile const uint32_t OSC32KRDY:1; /*!< bit:      2  OSC32K Ready                       */
    volatile const uint32_t OSC8MRDY:1; /*!< bit:      3  OSC8M Ready                        */
    volatile const uint32_t DFLLRDY:1; /*!< bit:      4  DFLL Ready                         */
    volatile const uint32_t DFLLOOB:1; /*!< bit:      5  DFLL Out Of Bounds                 */
    volatile const uint32_t DFLLLCKF:1; /*!< bit:      6  DFLL Lock Fine                     */
    volatile const uint32_t DFLLLCKC:1; /*!< bit:      7  DFLL Lock Coarse                   */
    volatile const uint32_t DFLLRCS:1; /*!< bit:      8  DFLL Reference Clock Stopped       */
    volatile const uint32_t BOD33RDY:1; /*!< bit:      9  BOD33 Ready                        */
    volatile const uint32_t BOD33DET:1; /*!< bit:     10  BOD33 Detection                    */
    volatile const uint32_t B33SRDY:1; /*!< bit:     11  BOD33 Synchronization Ready        */
    volatile const uint32_t :3; /*!< bit: 12..14  Reserved                           */
    volatile const uint32_t DPLLLCKR:1; /*!< bit:     15  DPLL Lock Rise                     */
    volatile const uint32_t DPLLLCKF:1; /*!< bit:     16  DPLL Lock Fall                     */
    volatile const uint32_t DPLLLTO:1; /*!< bit:     17  DPLL Lock Timeout                  */
    volatile const uint32_t :14; /*!< bit: 18..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_INTFLAG_Type;


#define SYSCTRL_INTFLAG_OFFSET 0x08
#define SYSCTRL_INTFLAG_RESETVALUE _U_(0x00000000)

#define SYSCTRL_INTFLAG_XOSCRDY_Pos 0
#define SYSCTRL_INTFLAG_XOSCRDY (_U_(0x1) << SYSCTRL_INTFLAG_XOSCRDY_Pos)
#define SYSCTRL_INTFLAG_XOSC32KRDY_Pos 1
#define SYSCTRL_INTFLAG_XOSC32KRDY (_U_(0x1) << SYSCTRL_INTFLAG_XOSC32KRDY_Pos)
#define SYSCTRL_INTFLAG_OSC32KRDY_Pos 2
#define SYSCTRL_INTFLAG_OSC32KRDY (_U_(0x1) << SYSCTRL_INTFLAG_OSC32KRDY_Pos)
#define SYSCTRL_INTFLAG_OSC8MRDY_Pos 3
#define SYSCTRL_INTFLAG_OSC8MRDY (_U_(0x1) << SYSCTRL_INTFLAG_OSC8MRDY_Pos)
#define SYSCTRL_INTFLAG_DFLLRDY_Pos 4
#define SYSCTRL_INTFLAG_DFLLRDY (_U_(0x1) << SYSCTRL_INTFLAG_DFLLRDY_Pos)
#define SYSCTRL_INTFLAG_DFLLOOB_Pos 5
#define SYSCTRL_INTFLAG_DFLLOOB (_U_(0x1) << SYSCTRL_INTFLAG_DFLLOOB_Pos)
#define SYSCTRL_INTFLAG_DFLLLCKF_Pos 6
#define SYSCTRL_INTFLAG_DFLLLCKF (_U_(0x1) << SYSCTRL_INTFLAG_DFLLLCKF_Pos)
#define SYSCTRL_INTFLAG_DFLLLCKC_Pos 7
#define SYSCTRL_INTFLAG_DFLLLCKC (_U_(0x1) << SYSCTRL_INTFLAG_DFLLLCKC_Pos)
#define SYSCTRL_INTFLAG_DFLLRCS_Pos 8
#define SYSCTRL_INTFLAG_DFLLRCS (_U_(0x1) << SYSCTRL_INTFLAG_DFLLRCS_Pos)
#define SYSCTRL_INTFLAG_BOD33RDY_Pos 9
#define SYSCTRL_INTFLAG_BOD33RDY (_U_(0x1) << SYSCTRL_INTFLAG_BOD33RDY_Pos)
#define SYSCTRL_INTFLAG_BOD33DET_Pos 10
#define SYSCTRL_INTFLAG_BOD33DET (_U_(0x1) << SYSCTRL_INTFLAG_BOD33DET_Pos)
#define SYSCTRL_INTFLAG_B33SRDY_Pos 11
#define SYSCTRL_INTFLAG_B33SRDY (_U_(0x1) << SYSCTRL_INTFLAG_B33SRDY_Pos)
#define SYSCTRL_INTFLAG_DPLLLCKR_Pos 15
#define SYSCTRL_INTFLAG_DPLLLCKR (_U_(0x1) << SYSCTRL_INTFLAG_DPLLLCKR_Pos)
#define SYSCTRL_INTFLAG_DPLLLCKF_Pos 16
#define SYSCTRL_INTFLAG_DPLLLCKF (_U_(0x1) << SYSCTRL_INTFLAG_DPLLLCKF_Pos)
#define SYSCTRL_INTFLAG_DPLLLTO_Pos 17
#define SYSCTRL_INTFLAG_DPLLLTO (_U_(0x1) << SYSCTRL_INTFLAG_DPLLLTO_Pos)
#define SYSCTRL_INTFLAG_MASK _U_(0x00038FFF)

/* -------- SYSCTRL_PCLKSR : (SYSCTRL Offset: 0x0C) (R/  32) Power and Clocks Status -------- */

typedef union {
  struct {
    uint32_t XOSCRDY:1; /*!< bit:      0  XOSC Ready                         */
    uint32_t XOSC32KRDY:1; /*!< bit:      1  XOSC32K Ready                      */
    uint32_t OSC32KRDY:1; /*!< bit:      2  OSC32K Ready                       */
    uint32_t OSC8MRDY:1; /*!< bit:      3  OSC8M Ready                        */
    uint32_t DFLLRDY:1; /*!< bit:      4  DFLL Ready                         */
    uint32_t DFLLOOB:1; /*!< bit:      5  DFLL Out Of Bounds                 */
    uint32_t DFLLLCKF:1; /*!< bit:      6  DFLL Lock Fine                     */
    uint32_t DFLLLCKC:1; /*!< bit:      7  DFLL Lock Coarse                   */
    uint32_t DFLLRCS:1; /*!< bit:      8  DFLL Reference Clock Stopped       */
    uint32_t BOD33RDY:1; /*!< bit:      9  BOD33 Ready                        */
    uint32_t BOD33DET:1; /*!< bit:     10  BOD33 Detection                    */
    uint32_t B33SRDY:1; /*!< bit:     11  BOD33 Synchronization Ready        */
    uint32_t :3; /*!< bit: 12..14  Reserved                           */
    uint32_t DPLLLCKR:1; /*!< bit:     15  DPLL Lock Rise                     */
    uint32_t DPLLLCKF:1; /*!< bit:     16  DPLL Lock Fall                     */
    uint32_t DPLLLTO:1; /*!< bit:     17  DPLL Lock Timeout                  */
    uint32_t :14; /*!< bit: 18..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_PCLKSR_Type;


#define SYSCTRL_PCLKSR_OFFSET 0x0C
#define SYSCTRL_PCLKSR_RESETVALUE _U_(0x00000000)

#define SYSCTRL_PCLKSR_XOSCRDY_Pos 0
#define SYSCTRL_PCLKSR_XOSCRDY (_U_(0x1) << SYSCTRL_PCLKSR_XOSCRDY_Pos)
#define SYSCTRL_PCLKSR_XOSC32KRDY_Pos 1
#define SYSCTRL_PCLKSR_XOSC32KRDY (_U_(0x1) << SYSCTRL_PCLKSR_XOSC32KRDY_Pos)
#define SYSCTRL_PCLKSR_OSC32KRDY_Pos 2
#define SYSCTRL_PCLKSR_OSC32KRDY (_U_(0x1) << SYSCTRL_PCLKSR_OSC32KRDY_Pos)
#define SYSCTRL_PCLKSR_OSC8MRDY_Pos 3
#define SYSCTRL_PCLKSR_OSC8MRDY (_U_(0x1) << SYSCTRL_PCLKSR_OSC8MRDY_Pos)
#define SYSCTRL_PCLKSR_DFLLRDY_Pos 4
#define SYSCTRL_PCLKSR_DFLLRDY (_U_(0x1) << SYSCTRL_PCLKSR_DFLLRDY_Pos)
#define SYSCTRL_PCLKSR_DFLLOOB_Pos 5
#define SYSCTRL_PCLKSR_DFLLOOB (_U_(0x1) << SYSCTRL_PCLKSR_DFLLOOB_Pos)
#define SYSCTRL_PCLKSR_DFLLLCKF_Pos 6
#define SYSCTRL_PCLKSR_DFLLLCKF (_U_(0x1) << SYSCTRL_PCLKSR_DFLLLCKF_Pos)
#define SYSCTRL_PCLKSR_DFLLLCKC_Pos 7
#define SYSCTRL_PCLKSR_DFLLLCKC (_U_(0x1) << SYSCTRL_PCLKSR_DFLLLCKC_Pos)
#define SYSCTRL_PCLKSR_DFLLRCS_Pos 8
#define SYSCTRL_PCLKSR_DFLLRCS (_U_(0x1) << SYSCTRL_PCLKSR_DFLLRCS_Pos)
#define SYSCTRL_PCLKSR_BOD33RDY_Pos 9
#define SYSCTRL_PCLKSR_BOD33RDY (_U_(0x1) << SYSCTRL_PCLKSR_BOD33RDY_Pos)
#define SYSCTRL_PCLKSR_BOD33DET_Pos 10
#define SYSCTRL_PCLKSR_BOD33DET (_U_(0x1) << SYSCTRL_PCLKSR_BOD33DET_Pos)
#define SYSCTRL_PCLKSR_B33SRDY_Pos 11
#define SYSCTRL_PCLKSR_B33SRDY (_U_(0x1) << SYSCTRL_PCLKSR_B33SRDY_Pos)
#define SYSCTRL_PCLKSR_DPLLLCKR_Pos 15
#define SYSCTRL_PCLKSR_DPLLLCKR (_U_(0x1) << SYSCTRL_PCLKSR_DPLLLCKR_Pos)
#define SYSCTRL_PCLKSR_DPLLLCKF_Pos 16
#define SYSCTRL_PCLKSR_DPLLLCKF (_U_(0x1) << SYSCTRL_PCLKSR_DPLLLCKF_Pos)
#define SYSCTRL_PCLKSR_DPLLLTO_Pos 17
#define SYSCTRL_PCLKSR_DPLLLTO (_U_(0x1) << SYSCTRL_PCLKSR_DPLLLTO_Pos)
#define SYSCTRL_PCLKSR_MASK _U_(0x00038FFF)

/* -------- SYSCTRL_XOSC : (SYSCTRL Offset: 0x10) (R/W 16) External Multipurpose Crystal Oscillator (XOSC) Control -------- */

typedef union {
  struct {
    uint16_t :1; /*!< bit:      0  Reserved                           */
    uint16_t ENABLE:1; /*!< bit:      1  Oscillator Enable                  */
    uint16_t XTALEN:1; /*!< bit:      2  Crystal Oscillator Enable          */
    uint16_t :3; /*!< bit:  3.. 5  Reserved                           */
    uint16_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint16_t ONDEMAND:1; /*!< bit:      7  On Demand Control                  */
    uint16_t GAIN:3; /*!< bit:  8..10  Oscillator Gain                    */
    uint16_t AMPGC:1; /*!< bit:     11  Automatic Amplitude Gain Control   */
    uint16_t STARTUP:4; /*!< bit: 12..15  Start-Up Time                      */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SYSCTRL_XOSC_Type;


#define SYSCTRL_XOSC_OFFSET 0x10
#define SYSCTRL_XOSC_RESETVALUE _U_(0x0080)

#define SYSCTRL_XOSC_ENABLE_Pos 1
#define SYSCTRL_XOSC_ENABLE (_U_(0x1) << SYSCTRL_XOSC_ENABLE_Pos)
#define SYSCTRL_XOSC_XTALEN_Pos 2
#define SYSCTRL_XOSC_XTALEN (_U_(0x1) << SYSCTRL_XOSC_XTALEN_Pos)
#define SYSCTRL_XOSC_RUNSTDBY_Pos 6
#define SYSCTRL_XOSC_RUNSTDBY (_U_(0x1) << SYSCTRL_XOSC_RUNSTDBY_Pos)
#define SYSCTRL_XOSC_ONDEMAND_Pos 7
#define SYSCTRL_XOSC_ONDEMAND (_U_(0x1) << SYSCTRL_XOSC_ONDEMAND_Pos)
#define SYSCTRL_XOSC_GAIN_Pos 8
#define SYSCTRL_XOSC_GAIN_Msk (_U_(0x7) << SYSCTRL_XOSC_GAIN_Pos)
#define SYSCTRL_XOSC_GAIN(value) (SYSCTRL_XOSC_GAIN_Msk & ((value) << SYSCTRL_XOSC_GAIN_Pos))
#define SYSCTRL_XOSC_GAIN_0_Val _U_(0x0)
#define SYSCTRL_XOSC_GAIN_1_Val _U_(0x1)
#define SYSCTRL_XOSC_GAIN_2_Val _U_(0x2)
#define SYSCTRL_XOSC_GAIN_3_Val _U_(0x3)
#define SYSCTRL_XOSC_GAIN_4_Val _U_(0x4)
#define SYSCTRL_XOSC_GAIN_0 (SYSCTRL_XOSC_GAIN_0_Val << SYSCTRL_XOSC_GAIN_Pos)
#define SYSCTRL_XOSC_GAIN_1 (SYSCTRL_XOSC_GAIN_1_Val << SYSCTRL_XOSC_GAIN_Pos)
#define SYSCTRL_XOSC_GAIN_2 (SYSCTRL_XOSC_GAIN_2_Val << SYSCTRL_XOSC_GAIN_Pos)
#define SYSCTRL_XOSC_GAIN_3 (SYSCTRL_XOSC_GAIN_3_Val << SYSCTRL_XOSC_GAIN_Pos)
#define SYSCTRL_XOSC_GAIN_4 (SYSCTRL_XOSC_GAIN_4_Val << SYSCTRL_XOSC_GAIN_Pos)
#define SYSCTRL_XOSC_AMPGC_Pos 11
#define SYSCTRL_XOSC_AMPGC (_U_(0x1) << SYSCTRL_XOSC_AMPGC_Pos)
#define SYSCTRL_XOSC_STARTUP_Pos 12
#define SYSCTRL_XOSC_STARTUP_Msk (_U_(0xF) << SYSCTRL_XOSC_STARTUP_Pos)
#define SYSCTRL_XOSC_STARTUP(value) (SYSCTRL_XOSC_STARTUP_Msk & ((value) << SYSCTRL_XOSC_STARTUP_Pos))
#define SYSCTRL_XOSC_MASK _U_(0xFFC6)

/* -------- SYSCTRL_XOSC32K : (SYSCTRL Offset: 0x14) (R/W 16) 32kHz External Crystal Oscillator (XOSC32K) Control -------- */

typedef union {
  struct {
    uint16_t :1; /*!< bit:      0  Reserved                           */
    uint16_t ENABLE:1; /*!< bit:      1  Oscillator Enable                  */
    uint16_t XTALEN:1; /*!< bit:      2  Crystal Oscillator Enable          */
    uint16_t EN32K:1; /*!< bit:      3  32kHz Output Enable                */
    uint16_t EN1K:1; /*!< bit:      4  1kHz Output Enable                 */
    uint16_t AAMPEN:1; /*!< bit:      5  Automatic Amplitude Control Enable */
    uint16_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint16_t ONDEMAND:1; /*!< bit:      7  On Demand Control                  */
    uint16_t STARTUP:3; /*!< bit:  8..10  Oscillator Start-Up Time           */
    uint16_t :1; /*!< bit:     11  Reserved                           */
    uint16_t WRTLOCK:1; /*!< bit:     12  Write Lock                         */
    uint16_t :3; /*!< bit: 13..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SYSCTRL_XOSC32K_Type;


#define SYSCTRL_XOSC32K_OFFSET 0x14
#define SYSCTRL_XOSC32K_RESETVALUE _U_(0x0080)

#define SYSCTRL_XOSC32K_ENABLE_Pos 1
#define SYSCTRL_XOSC32K_ENABLE (_U_(0x1) << SYSCTRL_XOSC32K_ENABLE_Pos)
#define SYSCTRL_XOSC32K_XTALEN_Pos 2
#define SYSCTRL_XOSC32K_XTALEN (_U_(0x1) << SYSCTRL_XOSC32K_XTALEN_Pos)
#define SYSCTRL_XOSC32K_EN32K_Pos 3
#define SYSCTRL_XOSC32K_EN32K (_U_(0x1) << SYSCTRL_XOSC32K_EN32K_Pos)
#define SYSCTRL_XOSC32K_EN1K_Pos 4
#define SYSCTRL_XOSC32K_EN1K (_U_(0x1) << SYSCTRL_XOSC32K_EN1K_Pos)
#define SYSCTRL_XOSC32K_AAMPEN_Pos 5
#define SYSCTRL_XOSC32K_AAMPEN (_U_(0x1) << SYSCTRL_XOSC32K_AAMPEN_Pos)
#define SYSCTRL_XOSC32K_RUNSTDBY_Pos 6
#define SYSCTRL_XOSC32K_RUNSTDBY (_U_(0x1) << SYSCTRL_XOSC32K_RUNSTDBY_Pos)
#define SYSCTRL_XOSC32K_ONDEMAND_Pos 7
#define SYSCTRL_XOSC32K_ONDEMAND (_U_(0x1) << SYSCTRL_XOSC32K_ONDEMAND_Pos)
#define SYSCTRL_XOSC32K_STARTUP_Pos 8
#define SYSCTRL_XOSC32K_STARTUP_Msk (_U_(0x7) << SYSCTRL_XOSC32K_STARTUP_Pos)
#define SYSCTRL_XOSC32K_STARTUP(value) (SYSCTRL_XOSC32K_STARTUP_Msk & ((value) << SYSCTRL_XOSC32K_STARTUP_Pos))
#define SYSCTRL_XOSC32K_WRTLOCK_Pos 12
#define SYSCTRL_XOSC32K_WRTLOCK (_U_(0x1) << SYSCTRL_XOSC32K_WRTLOCK_Pos)
#define SYSCTRL_XOSC32K_MASK _U_(0x17FE)

/* -------- SYSCTRL_OSC32K : (SYSCTRL Offset: 0x18) (R/W 32) 32kHz Internal Oscillator (OSC32K) Control -------- */

typedef union {
  struct {
    uint32_t :1; /*!< bit:      0  Reserved                           */
    uint32_t ENABLE:1; /*!< bit:      1  Oscillator Enable                  */
    uint32_t EN32K:1; /*!< bit:      2  32kHz Output Enable                */
    uint32_t EN1K:1; /*!< bit:      3  1kHz Output Enable                 */
    uint32_t :2; /*!< bit:  4.. 5  Reserved                           */
    uint32_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint32_t ONDEMAND:1; /*!< bit:      7  On Demand Control                  */
    uint32_t STARTUP:3; /*!< bit:  8..10  Oscillator Start-Up Time           */
    uint32_t :1; /*!< bit:     11  Reserved                           */
    uint32_t WRTLOCK:1; /*!< bit:     12  Write Lock                         */
    uint32_t :3; /*!< bit: 13..15  Reserved                           */
    uint32_t CALIB:7; /*!< bit: 16..22  Oscillator Calibration             */
    uint32_t :9; /*!< bit: 23..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_OSC32K_Type;


#define SYSCTRL_OSC32K_OFFSET 0x18
#define SYSCTRL_OSC32K_RESETVALUE _U_(0x003F0080)

#define SYSCTRL_OSC32K_ENABLE_Pos 1
#define SYSCTRL_OSC32K_ENABLE (_U_(0x1) << SYSCTRL_OSC32K_ENABLE_Pos)
#define SYSCTRL_OSC32K_EN32K_Pos 2
#define SYSCTRL_OSC32K_EN32K (_U_(0x1) << SYSCTRL_OSC32K_EN32K_Pos)
#define SYSCTRL_OSC32K_EN1K_Pos 3
#define SYSCTRL_OSC32K_EN1K (_U_(0x1) << SYSCTRL_OSC32K_EN1K_Pos)
#define SYSCTRL_OSC32K_RUNSTDBY_Pos 6
#define SYSCTRL_OSC32K_RUNSTDBY (_U_(0x1) << SYSCTRL_OSC32K_RUNSTDBY_Pos)
#define SYSCTRL_OSC32K_ONDEMAND_Pos 7
#define SYSCTRL_OSC32K_ONDEMAND (_U_(0x1) << SYSCTRL_OSC32K_ONDEMAND_Pos)
#define SYSCTRL_OSC32K_STARTUP_Pos 8
#define SYSCTRL_OSC32K_STARTUP_Msk (_U_(0x7) << SYSCTRL_OSC32K_STARTUP_Pos)
#define SYSCTRL_OSC32K_STARTUP(value) (SYSCTRL_OSC32K_STARTUP_Msk & ((value) << SYSCTRL_OSC32K_STARTUP_Pos))
#define SYSCTRL_OSC32K_WRTLOCK_Pos 12
#define SYSCTRL_OSC32K_WRTLOCK (_U_(0x1) << SYSCTRL_OSC32K_WRTLOCK_Pos)
#define SYSCTRL_OSC32K_CALIB_Pos 16
#define SYSCTRL_OSC32K_CALIB_Msk (_U_(0x7F) << SYSCTRL_OSC32K_CALIB_Pos)
#define SYSCTRL_OSC32K_CALIB(value) (SYSCTRL_OSC32K_CALIB_Msk & ((value) << SYSCTRL_OSC32K_CALIB_Pos))
#define SYSCTRL_OSC32K_MASK _U_(0x007F17CE)

/* -------- SYSCTRL_OSCULP32K : (SYSCTRL Offset: 0x1C) (R/W  8) 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control -------- */

typedef union {
  struct {
    uint8_t CALIB:5; /*!< bit:  0.. 4  Oscillator Calibration             */
    uint8_t :2; /*!< bit:  5.. 6  Reserved                           */
    uint8_t WRTLOCK:1; /*!< bit:      7  Write Lock                         */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SYSCTRL_OSCULP32K_Type;


#define SYSCTRL_OSCULP32K_OFFSET 0x1C
#define SYSCTRL_OSCULP32K_RESETVALUE _U_(0x1F)

#define SYSCTRL_OSCULP32K_CALIB_Pos 0
#define SYSCTRL_OSCULP32K_CALIB_Msk (_U_(0x1F) << SYSCTRL_OSCULP32K_CALIB_Pos)
#define SYSCTRL_OSCULP32K_CALIB(value) (SYSCTRL_OSCULP32K_CALIB_Msk & ((value) << SYSCTRL_OSCULP32K_CALIB_Pos))
#define SYSCTRL_OSCULP32K_WRTLOCK_Pos 7
#define SYSCTRL_OSCULP32K_WRTLOCK (_U_(0x1) << SYSCTRL_OSCULP32K_WRTLOCK_Pos)
#define SYSCTRL_OSCULP32K_MASK _U_(0x9F)

/* -------- SYSCTRL_OSC8M : (SYSCTRL Offset: 0x20) (R/W 32) 8MHz Internal Oscillator (OSC8M) Control -------- */

typedef union {
  struct {
    uint32_t :1; /*!< bit:      0  Reserved                           */
    uint32_t ENABLE:1; /*!< bit:      1  Oscillator Enable                  */
    uint32_t :4; /*!< bit:  2.. 5  Reserved                           */
    uint32_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint32_t ONDEMAND:1; /*!< bit:      7  On Demand Control                  */
    uint32_t PRESC:2; /*!< bit:  8.. 9  Oscillator Prescaler               */
    uint32_t :6; /*!< bit: 10..15  Reserved                           */
    uint32_t CALIB:12; /*!< bit: 16..27  Oscillator Calibration             */
    uint32_t :2; /*!< bit: 28..29  Reserved                           */
    uint32_t FRANGE:2; /*!< bit: 30..31  Oscillator Frequency Range         */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_OSC8M_Type;


#define SYSCTRL_OSC8M_OFFSET 0x20
#define SYSCTRL_OSC8M_RESETVALUE _U_(0x87070382)

#define SYSCTRL_OSC8M_ENABLE_Pos 1
#define SYSCTRL_OSC8M_ENABLE (_U_(0x1) << SYSCTRL_OSC8M_ENABLE_Pos)
#define SYSCTRL_OSC8M_RUNSTDBY_Pos 6
#define SYSCTRL_OSC8M_RUNSTDBY (_U_(0x1) << SYSCTRL_OSC8M_RUNSTDBY_Pos)
#define SYSCTRL_OSC8M_ONDEMAND_Pos 7
#define SYSCTRL_OSC8M_ONDEMAND (_U_(0x1) << SYSCTRL_OSC8M_ONDEMAND_Pos)
#define SYSCTRL_OSC8M_PRESC_Pos 8
#define SYSCTRL_OSC8M_PRESC_Msk (_U_(0x3) << SYSCTRL_OSC8M_PRESC_Pos)
#define SYSCTRL_OSC8M_PRESC(value) (SYSCTRL_OSC8M_PRESC_Msk & ((value) << SYSCTRL_OSC8M_PRESC_Pos))
#define SYSCTRL_OSC8M_PRESC_0_Val _U_(0x0)
#define SYSCTRL_OSC8M_PRESC_1_Val _U_(0x1)
#define SYSCTRL_OSC8M_PRESC_2_Val _U_(0x2)
#define SYSCTRL_OSC8M_PRESC_3_Val _U_(0x3)
#define SYSCTRL_OSC8M_PRESC_0 (SYSCTRL_OSC8M_PRESC_0_Val << SYSCTRL_OSC8M_PRESC_Pos)
#define SYSCTRL_OSC8M_PRESC_1 (SYSCTRL_OSC8M_PRESC_1_Val << SYSCTRL_OSC8M_PRESC_Pos)
#define SYSCTRL_OSC8M_PRESC_2 (SYSCTRL_OSC8M_PRESC_2_Val << SYSCTRL_OSC8M_PRESC_Pos)
#define SYSCTRL_OSC8M_PRESC_3 (SYSCTRL_OSC8M_PRESC_3_Val << SYSCTRL_OSC8M_PRESC_Pos)
#define SYSCTRL_OSC8M_CALIB_Pos 16
#define SYSCTRL_OSC8M_CALIB_Msk (_U_(0xFFF) << SYSCTRL_OSC8M_CALIB_Pos)
#define SYSCTRL_OSC8M_CALIB(value) (SYSCTRL_OSC8M_CALIB_Msk & ((value) << SYSCTRL_OSC8M_CALIB_Pos))
#define SYSCTRL_OSC8M_FRANGE_Pos 30
#define SYSCTRL_OSC8M_FRANGE_Msk (_U_(0x3) << SYSCTRL_OSC8M_FRANGE_Pos)
#define SYSCTRL_OSC8M_FRANGE(value) (SYSCTRL_OSC8M_FRANGE_Msk & ((value) << SYSCTRL_OSC8M_FRANGE_Pos))
#define SYSCTRL_OSC8M_FRANGE_0_Val _U_(0x0)
#define SYSCTRL_OSC8M_FRANGE_1_Val _U_(0x1)
#define SYSCTRL_OSC8M_FRANGE_2_Val _U_(0x2)
#define SYSCTRL_OSC8M_FRANGE_3_Val _U_(0x3)
#define SYSCTRL_OSC8M_FRANGE_0 (SYSCTRL_OSC8M_FRANGE_0_Val << SYSCTRL_OSC8M_FRANGE_Pos)
#define SYSCTRL_OSC8M_FRANGE_1 (SYSCTRL_OSC8M_FRANGE_1_Val << SYSCTRL_OSC8M_FRANGE_Pos)
#define SYSCTRL_OSC8M_FRANGE_2 (SYSCTRL_OSC8M_FRANGE_2_Val << SYSCTRL_OSC8M_FRANGE_Pos)
#define SYSCTRL_OSC8M_FRANGE_3 (SYSCTRL_OSC8M_FRANGE_3_Val << SYSCTRL_OSC8M_FRANGE_Pos)
#define SYSCTRL_OSC8M_MASK _U_(0xCFFF03C2)

/* -------- SYSCTRL_DFLLCTRL : (SYSCTRL Offset: 0x24) (R/W 16) DFLL48M Control -------- */

typedef union {
  struct {
    uint16_t :1; /*!< bit:      0  Reserved                           */
    uint16_t ENABLE:1; /*!< bit:      1  DFLL Enable                        */
    uint16_t MODE:1; /*!< bit:      2  Operating Mode Selection           */
    uint16_t STABLE:1; /*!< bit:      3  Stable DFLL Frequency              */
    uint16_t LLAW:1; /*!< bit:      4  Lose Lock After Wake               */
    uint16_t USBCRM:1; /*!< bit:      5  USB Clock Recovery Mode            */
    uint16_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint16_t ONDEMAND:1; /*!< bit:      7  On Demand Control                  */
    uint16_t CCDIS:1; /*!< bit:      8  Chill Cycle Disable                */
    uint16_t QLDIS:1; /*!< bit:      9  Quick Lock Disable                 */
    uint16_t BPLCKC:1; /*!< bit:     10  Bypass Coarse Lock                 */
    uint16_t WAITLOCK:1; /*!< bit:     11  Wait Lock                          */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SYSCTRL_DFLLCTRL_Type;


#define SYSCTRL_DFLLCTRL_OFFSET 0x24
#define SYSCTRL_DFLLCTRL_RESETVALUE _U_(0x0080)

#define SYSCTRL_DFLLCTRL_ENABLE_Pos 1
#define SYSCTRL_DFLLCTRL_ENABLE (_U_(0x1) << SYSCTRL_DFLLCTRL_ENABLE_Pos)
#define SYSCTRL_DFLLCTRL_MODE_Pos 2
#define SYSCTRL_DFLLCTRL_MODE (_U_(0x1) << SYSCTRL_DFLLCTRL_MODE_Pos)
#define SYSCTRL_DFLLCTRL_STABLE_Pos 3
#define SYSCTRL_DFLLCTRL_STABLE (_U_(0x1) << SYSCTRL_DFLLCTRL_STABLE_Pos)
#define SYSCTRL_DFLLCTRL_LLAW_Pos 4
#define SYSCTRL_DFLLCTRL_LLAW (_U_(0x1) << SYSCTRL_DFLLCTRL_LLAW_Pos)
#define SYSCTRL_DFLLCTRL_USBCRM_Pos 5
#define SYSCTRL_DFLLCTRL_USBCRM (_U_(0x1) << SYSCTRL_DFLLCTRL_USBCRM_Pos)
#define SYSCTRL_DFLLCTRL_RUNSTDBY_Pos 6
#define SYSCTRL_DFLLCTRL_RUNSTDBY (_U_(0x1) << SYSCTRL_DFLLCTRL_RUNSTDBY_Pos)
#define SYSCTRL_DFLLCTRL_ONDEMAND_Pos 7
#define SYSCTRL_DFLLCTRL_ONDEMAND (_U_(0x1) << SYSCTRL_DFLLCTRL_ONDEMAND_Pos)
#define SYSCTRL_DFLLCTRL_CCDIS_Pos 8
#define SYSCTRL_DFLLCTRL_CCDIS (_U_(0x1) << SYSCTRL_DFLLCTRL_CCDIS_Pos)
#define SYSCTRL_DFLLCTRL_QLDIS_Pos 9
#define SYSCTRL_DFLLCTRL_QLDIS (_U_(0x1) << SYSCTRL_DFLLCTRL_QLDIS_Pos)
#define SYSCTRL_DFLLCTRL_BPLCKC_Pos 10
#define SYSCTRL_DFLLCTRL_BPLCKC (_U_(0x1) << SYSCTRL_DFLLCTRL_BPLCKC_Pos)
#define SYSCTRL_DFLLCTRL_WAITLOCK_Pos 11
#define SYSCTRL_DFLLCTRL_WAITLOCK (_U_(0x1) << SYSCTRL_DFLLCTRL_WAITLOCK_Pos)
#define SYSCTRL_DFLLCTRL_MASK _U_(0x0FFE)

/* -------- SYSCTRL_DFLLVAL : (SYSCTRL Offset: 0x28) (R/W 32) DFLL48M Value -------- */

typedef union {
  struct {
    uint32_t FINE:10; /*!< bit:  0.. 9  Fine Value                         */
    uint32_t COARSE:6; /*!< bit: 10..15  Coarse Value                       */
    uint32_t DIFF:16; /*!< bit: 16..31  Multiplication Ratio Difference    */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_DFLLVAL_Type;


#define SYSCTRL_DFLLVAL_OFFSET 0x28
#define SYSCTRL_DFLLVAL_RESETVALUE _U_(0x00000000)

#define SYSCTRL_DFLLVAL_FINE_Pos 0
#define SYSCTRL_DFLLVAL_FINE_Msk (_U_(0x3FF) << SYSCTRL_DFLLVAL_FINE_Pos)
#define SYSCTRL_DFLLVAL_FINE(value) (SYSCTRL_DFLLVAL_FINE_Msk & ((value) << SYSCTRL_DFLLVAL_FINE_Pos))
#define SYSCTRL_DFLLVAL_COARSE_Pos 10
#define SYSCTRL_DFLLVAL_COARSE_Msk (_U_(0x3F) << SYSCTRL_DFLLVAL_COARSE_Pos)
#define SYSCTRL_DFLLVAL_COARSE(value) (SYSCTRL_DFLLVAL_COARSE_Msk & ((value) << SYSCTRL_DFLLVAL_COARSE_Pos))
#define SYSCTRL_DFLLVAL_DIFF_Pos 16
#define SYSCTRL_DFLLVAL_DIFF_Msk (_U_(0xFFFF) << SYSCTRL_DFLLVAL_DIFF_Pos)
#define SYSCTRL_DFLLVAL_DIFF(value) (SYSCTRL_DFLLVAL_DIFF_Msk & ((value) << SYSCTRL_DFLLVAL_DIFF_Pos))
#define SYSCTRL_DFLLVAL_MASK _U_(0xFFFFFFFF)

/* -------- SYSCTRL_DFLLMUL : (SYSCTRL Offset: 0x2C) (R/W 32) DFLL48M Multiplier -------- */

typedef union {
  struct {
    uint32_t MUL:16; /*!< bit:  0..15  DFLL Multiply Factor               */
    uint32_t FSTEP:10; /*!< bit: 16..25  Fine Maximum Step                  */
    uint32_t CSTEP:6; /*!< bit: 26..31  Coarse Maximum Step                */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_DFLLMUL_Type;


#define SYSCTRL_DFLLMUL_OFFSET 0x2C
#define SYSCTRL_DFLLMUL_RESETVALUE _U_(0x00000000)

#define SYSCTRL_DFLLMUL_MUL_Pos 0
#define SYSCTRL_DFLLMUL_MUL_Msk (_U_(0xFFFF) << SYSCTRL_DFLLMUL_MUL_Pos)
#define SYSCTRL_DFLLMUL_MUL(value) (SYSCTRL_DFLLMUL_MUL_Msk & ((value) << SYSCTRL_DFLLMUL_MUL_Pos))
#define SYSCTRL_DFLLMUL_FSTEP_Pos 16
#define SYSCTRL_DFLLMUL_FSTEP_Msk (_U_(0x3FF) << SYSCTRL_DFLLMUL_FSTEP_Pos)
#define SYSCTRL_DFLLMUL_FSTEP(value) (SYSCTRL_DFLLMUL_FSTEP_Msk & ((value) << SYSCTRL_DFLLMUL_FSTEP_Pos))
#define SYSCTRL_DFLLMUL_CSTEP_Pos 26
#define SYSCTRL_DFLLMUL_CSTEP_Msk (_U_(0x3F) << SYSCTRL_DFLLMUL_CSTEP_Pos)
#define SYSCTRL_DFLLMUL_CSTEP(value) (SYSCTRL_DFLLMUL_CSTEP_Msk & ((value) << SYSCTRL_DFLLMUL_CSTEP_Pos))
#define SYSCTRL_DFLLMUL_MASK _U_(0xFFFFFFFF)

/* -------- SYSCTRL_DFLLSYNC : (SYSCTRL Offset: 0x30) (R/W  8) DFLL48M Synchronization -------- */

typedef union {
  struct {
    uint8_t :7; /*!< bit:  0.. 6  Reserved                           */
    uint8_t READREQ:1; /*!< bit:      7  Read Request                       */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SYSCTRL_DFLLSYNC_Type;


#define SYSCTRL_DFLLSYNC_OFFSET 0x30
#define SYSCTRL_DFLLSYNC_RESETVALUE _U_(0x00)

#define SYSCTRL_DFLLSYNC_READREQ_Pos 7
#define SYSCTRL_DFLLSYNC_READREQ (_U_(0x1) << SYSCTRL_DFLLSYNC_READREQ_Pos)
#define SYSCTRL_DFLLSYNC_MASK _U_(0x80)

/* -------- SYSCTRL_BOD33 : (SYSCTRL Offset: 0x34) (R/W 32) 3.3V Brown-Out Detector (BOD33) Control -------- */

typedef union {
  struct {
    uint32_t :1; /*!< bit:      0  Reserved                           */
    uint32_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint32_t HYST:1; /*!< bit:      2  Hysteresis                         */
    uint32_t ACTION:2; /*!< bit:  3.. 4  BOD33 Action                       */
    uint32_t :1; /*!< bit:      5  Reserved                           */
    uint32_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint32_t :1; /*!< bit:      7  Reserved                           */
    uint32_t MODE:1; /*!< bit:      8  Operation Mode                     */
    uint32_t CEN:1; /*!< bit:      9  Clock Enable                       */
    uint32_t :2; /*!< bit: 10..11  Reserved                           */
    uint32_t PSEL:4; /*!< bit: 12..15  Prescaler Select                   */
    uint32_t LEVEL:6; /*!< bit: 16..21  BOD33 Threshold Level              */
    uint32_t :10; /*!< bit: 22..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_BOD33_Type;


#define SYSCTRL_BOD33_OFFSET 0x34
#define SYSCTRL_BOD33_RESETVALUE _U_(0x00000000)

#define SYSCTRL_BOD33_ENABLE_Pos 1
#define SYSCTRL_BOD33_ENABLE (_U_(0x1) << SYSCTRL_BOD33_ENABLE_Pos)
#define SYSCTRL_BOD33_HYST_Pos 2
#define SYSCTRL_BOD33_HYST (_U_(0x1) << SYSCTRL_BOD33_HYST_Pos)
#define SYSCTRL_BOD33_ACTION_Pos 3
#define SYSCTRL_BOD33_ACTION_Msk (_U_(0x3) << SYSCTRL_BOD33_ACTION_Pos)
#define SYSCTRL_BOD33_ACTION(value) (SYSCTRL_BOD33_ACTION_Msk & ((value) << SYSCTRL_BOD33_ACTION_Pos))
#define SYSCTRL_BOD33_ACTION_NONE_Val _U_(0x0)
#define SYSCTRL_BOD33_ACTION_RESET_Val _U_(0x1)
#define SYSCTRL_BOD33_ACTION_INTERRUPT_Val _U_(0x2)
#define SYSCTRL_BOD33_ACTION_NONE (SYSCTRL_BOD33_ACTION_NONE_Val << SYSCTRL_BOD33_ACTION_Pos)
#define SYSCTRL_BOD33_ACTION_RESET (SYSCTRL_BOD33_ACTION_RESET_Val << SYSCTRL_BOD33_ACTION_Pos)
#define SYSCTRL_BOD33_ACTION_INTERRUPT (SYSCTRL_BOD33_ACTION_INTERRUPT_Val << SYSCTRL_BOD33_ACTION_Pos)
#define SYSCTRL_BOD33_RUNSTDBY_Pos 6
#define SYSCTRL_BOD33_RUNSTDBY (_U_(0x1) << SYSCTRL_BOD33_RUNSTDBY_Pos)
#define SYSCTRL_BOD33_MODE_Pos 8
#define SYSCTRL_BOD33_MODE (_U_(0x1) << SYSCTRL_BOD33_MODE_Pos)
#define SYSCTRL_BOD33_CEN_Pos 9
#define SYSCTRL_BOD33_CEN (_U_(0x1) << SYSCTRL_BOD33_CEN_Pos)
#define SYSCTRL_BOD33_PSEL_Pos 12
#define SYSCTRL_BOD33_PSEL_Msk (_U_(0xF) << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL(value) (SYSCTRL_BOD33_PSEL_Msk & ((value) << SYSCTRL_BOD33_PSEL_Pos))
#define SYSCTRL_BOD33_PSEL_DIV2_Val _U_(0x0)
#define SYSCTRL_BOD33_PSEL_DIV4_Val _U_(0x1)
#define SYSCTRL_BOD33_PSEL_DIV8_Val _U_(0x2)
#define SYSCTRL_BOD33_PSEL_DIV16_Val _U_(0x3)
#define SYSCTRL_BOD33_PSEL_DIV32_Val _U_(0x4)
#define SYSCTRL_BOD33_PSEL_DIV64_Val _U_(0x5)
#define SYSCTRL_BOD33_PSEL_DIV128_Val _U_(0x6)
#define SYSCTRL_BOD33_PSEL_DIV256_Val _U_(0x7)
#define SYSCTRL_BOD33_PSEL_DIV512_Val _U_(0x8)
#define SYSCTRL_BOD33_PSEL_DIV1K_Val _U_(0x9)
#define SYSCTRL_BOD33_PSEL_DIV2K_Val _U_(0xA)
#define SYSCTRL_BOD33_PSEL_DIV4K_Val _U_(0xB)
#define SYSCTRL_BOD33_PSEL_DIV8K_Val _U_(0xC)
#define SYSCTRL_BOD33_PSEL_DIV16K_Val _U_(0xD)
#define SYSCTRL_BOD33_PSEL_DIV32K_Val _U_(0xE)
#define SYSCTRL_BOD33_PSEL_DIV64K_Val _U_(0xF)
#define SYSCTRL_BOD33_PSEL_DIV2 (SYSCTRL_BOD33_PSEL_DIV2_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV4 (SYSCTRL_BOD33_PSEL_DIV4_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV8 (SYSCTRL_BOD33_PSEL_DIV8_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV16 (SYSCTRL_BOD33_PSEL_DIV16_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV32 (SYSCTRL_BOD33_PSEL_DIV32_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV64 (SYSCTRL_BOD33_PSEL_DIV64_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV128 (SYSCTRL_BOD33_PSEL_DIV128_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV256 (SYSCTRL_BOD33_PSEL_DIV256_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV512 (SYSCTRL_BOD33_PSEL_DIV512_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV1K (SYSCTRL_BOD33_PSEL_DIV1K_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV2K (SYSCTRL_BOD33_PSEL_DIV2K_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV4K (SYSCTRL_BOD33_PSEL_DIV4K_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV8K (SYSCTRL_BOD33_PSEL_DIV8K_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV16K (SYSCTRL_BOD33_PSEL_DIV16K_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV32K (SYSCTRL_BOD33_PSEL_DIV32K_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_PSEL_DIV64K (SYSCTRL_BOD33_PSEL_DIV64K_Val << SYSCTRL_BOD33_PSEL_Pos)
#define SYSCTRL_BOD33_LEVEL_Pos 16
#define SYSCTRL_BOD33_LEVEL_Msk (_U_(0x3F) << SYSCTRL_BOD33_LEVEL_Pos)
#define SYSCTRL_BOD33_LEVEL(value) (SYSCTRL_BOD33_LEVEL_Msk & ((value) << SYSCTRL_BOD33_LEVEL_Pos))
#define SYSCTRL_BOD33_MASK _U_(0x003FF35E)

/* -------- SYSCTRL_VREG : (SYSCTRL Offset: 0x3C) (R/W 16) Voltage Regulator System (VREG) Control -------- */

typedef union {
  struct {
    uint16_t :6; /*!< bit:  0.. 5  Reserved                           */
    uint16_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint16_t :6; /*!< bit:  7..12  Reserved                           */
    uint16_t FORCELDO:1; /*!< bit:     13  Force LDO Voltage Regulator        */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} SYSCTRL_VREG_Type;


#define SYSCTRL_VREG_OFFSET 0x3C
#define SYSCTRL_VREG_RESETVALUE _U_(0x0000)

#define SYSCTRL_VREG_RUNSTDBY_Pos 6
#define SYSCTRL_VREG_RUNSTDBY (_U_(0x1) << SYSCTRL_VREG_RUNSTDBY_Pos)
#define SYSCTRL_VREG_FORCELDO_Pos 13
#define SYSCTRL_VREG_FORCELDO (_U_(0x1) << SYSCTRL_VREG_FORCELDO_Pos)
#define SYSCTRL_VREG_MASK _U_(0x2040)

/* -------- SYSCTRL_VREF : (SYSCTRL Offset: 0x40) (R/W 32) Voltage References System (VREF) Control -------- */

typedef union {
  struct {
    uint32_t :1; /*!< bit:      0  Reserved                           */
    uint32_t TSEN:1; /*!< bit:      1  Temperature Sensor Enable          */
    uint32_t BGOUTEN:1; /*!< bit:      2  Bandgap Output Enable              */
    uint32_t :13; /*!< bit:  3..15  Reserved                           */
    uint32_t CALIB:11; /*!< bit: 16..26  Bandgap Voltage Generator Calibration */
    uint32_t :5; /*!< bit: 27..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_VREF_Type;


#define SYSCTRL_VREF_OFFSET 0x40
#define SYSCTRL_VREF_RESETVALUE _U_(0x00000000)

#define SYSCTRL_VREF_TSEN_Pos 1
#define SYSCTRL_VREF_TSEN (_U_(0x1) << SYSCTRL_VREF_TSEN_Pos)
#define SYSCTRL_VREF_BGOUTEN_Pos 2
#define SYSCTRL_VREF_BGOUTEN (_U_(0x1) << SYSCTRL_VREF_BGOUTEN_Pos)
#define SYSCTRL_VREF_CALIB_Pos 16
#define SYSCTRL_VREF_CALIB_Msk (_U_(0x7FF) << SYSCTRL_VREF_CALIB_Pos)
#define SYSCTRL_VREF_CALIB(value) (SYSCTRL_VREF_CALIB_Msk & ((value) << SYSCTRL_VREF_CALIB_Pos))
#define SYSCTRL_VREF_MASK _U_(0x07FF0006)

/* -------- SYSCTRL_DPLLCTRLA : (SYSCTRL Offset: 0x44) (R/W  8) DPLL Control A -------- */

typedef union {
  struct {
    uint8_t :1; /*!< bit:      0  Reserved                           */
    uint8_t ENABLE:1; /*!< bit:      1  DPLL Enable                        */
    uint8_t :4; /*!< bit:  2.. 5  Reserved                           */
    uint8_t RUNSTDBY:1; /*!< bit:      6  Run in Standby                     */
    uint8_t ONDEMAND:1; /*!< bit:      7  On Demand Clock Activation         */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SYSCTRL_DPLLCTRLA_Type;


#define SYSCTRL_DPLLCTRLA_OFFSET 0x44
#define SYSCTRL_DPLLCTRLA_RESETVALUE _U_(0x80)

#define SYSCTRL_DPLLCTRLA_ENABLE_Pos 1
#define SYSCTRL_DPLLCTRLA_ENABLE (_U_(0x1) << SYSCTRL_DPLLCTRLA_ENABLE_Pos)
#define SYSCTRL_DPLLCTRLA_RUNSTDBY_Pos 6
#define SYSCTRL_DPLLCTRLA_RUNSTDBY (_U_(0x1) << SYSCTRL_DPLLCTRLA_RUNSTDBY_Pos)
#define SYSCTRL_DPLLCTRLA_ONDEMAND_Pos 7
#define SYSCTRL_DPLLCTRLA_ONDEMAND (_U_(0x1) << SYSCTRL_DPLLCTRLA_ONDEMAND_Pos)
#define SYSCTRL_DPLLCTRLA_MASK _U_(0xC2)

/* -------- SYSCTRL_DPLLRATIO : (SYSCTRL Offset: 0x48) (R/W 32) DPLL Ratio Control -------- */

typedef union {
  struct {
    uint32_t LDR:12; /*!< bit:  0..11  Loop Divider Ratio                 */
    uint32_t :4; /*!< bit: 12..15  Reserved                           */
    uint32_t LDRFRAC:4; /*!< bit: 16..19  Loop Divider Ratio Fractional Part */
    uint32_t :12; /*!< bit: 20..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_DPLLRATIO_Type;


#define SYSCTRL_DPLLRATIO_OFFSET 0x48
#define SYSCTRL_DPLLRATIO_RESETVALUE _U_(0x00000000)

#define SYSCTRL_DPLLRATIO_LDR_Pos 0
#define SYSCTRL_DPLLRATIO_LDR_Msk (_U_(0xFFF) << SYSCTRL_DPLLRATIO_LDR_Pos)
#define SYSCTRL_DPLLRATIO_LDR(value) (SYSCTRL_DPLLRATIO_LDR_Msk & ((value) << SYSCTRL_DPLLRATIO_LDR_Pos))
#define SYSCTRL_DPLLRATIO_LDRFRAC_Pos 16
#define SYSCTRL_DPLLRATIO_LDRFRAC_Msk (_U_(0xF) << SYSCTRL_DPLLRATIO_LDRFRAC_Pos)
#define SYSCTRL_DPLLRATIO_LDRFRAC(value) (SYSCTRL_DPLLRATIO_LDRFRAC_Msk & ((value) << SYSCTRL_DPLLRATIO_LDRFRAC_Pos))
#define SYSCTRL_DPLLRATIO_MASK _U_(0x000F0FFF)

/* -------- SYSCTRL_DPLLCTRLB : (SYSCTRL Offset: 0x4C) (R/W 32) DPLL Control B -------- */

typedef union {
  struct {
    uint32_t FILTER:2; /*!< bit:  0.. 1  Proportional Integral Filter Selection */
    uint32_t LPEN:1; /*!< bit:      2  Low-Power Enable                   */
    uint32_t WUF:1; /*!< bit:      3  Wake Up Fast                       */
    uint32_t REFCLK:2; /*!< bit:  4.. 5  Reference Clock Selection          */
    uint32_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint32_t LTIME:3; /*!< bit:  8..10  Lock Time                          */
    uint32_t :1; /*!< bit:     11  Reserved                           */
    uint32_t LBYPASS:1; /*!< bit:     12  Lock Bypass                        */
    uint32_t :3; /*!< bit: 13..15  Reserved                           */
    uint32_t DIV:11; /*!< bit: 16..26  Clock Divider                      */
    uint32_t :5; /*!< bit: 27..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} SYSCTRL_DPLLCTRLB_Type;


#define SYSCTRL_DPLLCTRLB_OFFSET 0x4C
#define SYSCTRL_DPLLCTRLB_RESETVALUE _U_(0x00000000)

#define SYSCTRL_DPLLCTRLB_FILTER_Pos 0
#define SYSCTRL_DPLLCTRLB_FILTER_Msk (_U_(0x3) << SYSCTRL_DPLLCTRLB_FILTER_Pos)
#define SYSCTRL_DPLLCTRLB_FILTER(value) (SYSCTRL_DPLLCTRLB_FILTER_Msk & ((value) << SYSCTRL_DPLLCTRLB_FILTER_Pos))
#define SYSCTRL_DPLLCTRLB_FILTER_DEFAULT_Val _U_(0x0)
#define SYSCTRL_DPLLCTRLB_FILTER_LBFILT_Val _U_(0x1)
#define SYSCTRL_DPLLCTRLB_FILTER_HBFILT_Val _U_(0x2)
#define SYSCTRL_DPLLCTRLB_FILTER_HDFILT_Val _U_(0x3)
#define SYSCTRL_DPLLCTRLB_FILTER_DEFAULT (SYSCTRL_DPLLCTRLB_FILTER_DEFAULT_Val << SYSCTRL_DPLLCTRLB_FILTER_Pos)
#define SYSCTRL_DPLLCTRLB_FILTER_LBFILT (SYSCTRL_DPLLCTRLB_FILTER_LBFILT_Val << SYSCTRL_DPLLCTRLB_FILTER_Pos)
#define SYSCTRL_DPLLCTRLB_FILTER_HBFILT (SYSCTRL_DPLLCTRLB_FILTER_HBFILT_Val << SYSCTRL_DPLLCTRLB_FILTER_Pos)
#define SYSCTRL_DPLLCTRLB_FILTER_HDFILT (SYSCTRL_DPLLCTRLB_FILTER_HDFILT_Val << SYSCTRL_DPLLCTRLB_FILTER_Pos)
#define SYSCTRL_DPLLCTRLB_LPEN_Pos 2
#define SYSCTRL_DPLLCTRLB_LPEN (_U_(0x1) << SYSCTRL_DPLLCTRLB_LPEN_Pos)
#define SYSCTRL_DPLLCTRLB_WUF_Pos 3
#define SYSCTRL_DPLLCTRLB_WUF (_U_(0x1) << SYSCTRL_DPLLCTRLB_WUF_Pos)
#define SYSCTRL_DPLLCTRLB_REFCLK_Pos 4
#define SYSCTRL_DPLLCTRLB_REFCLK_Msk (_U_(0x3) << SYSCTRL_DPLLCTRLB_REFCLK_Pos)
#define SYSCTRL_DPLLCTRLB_REFCLK(value) (SYSCTRL_DPLLCTRLB_REFCLK_Msk & ((value) << SYSCTRL_DPLLCTRLB_REFCLK_Pos))
#define SYSCTRL_DPLLCTRLB_REFCLK_REF0_Val _U_(0x0)
#define SYSCTRL_DPLLCTRLB_REFCLK_REF1_Val _U_(0x1)
#define SYSCTRL_DPLLCTRLB_REFCLK_GCLK_Val _U_(0x2)
#define SYSCTRL_DPLLCTRLB_REFCLK_REF0 (SYSCTRL_DPLLCTRLB_REFCLK_REF0_Val << SYSCTRL_DPLLCTRLB_REFCLK_Pos)
#define SYSCTRL_DPLLCTRLB_REFCLK_REF1 (SYSCTRL_DPLLCTRLB_REFCLK_REF1_Val << SYSCTRL_DPLLCTRLB_REFCLK_Pos)
#define SYSCTRL_DPLLCTRLB_REFCLK_GCLK (SYSCTRL_DPLLCTRLB_REFCLK_GCLK_Val << SYSCTRL_DPLLCTRLB_REFCLK_Pos)
#define SYSCTRL_DPLLCTRLB_LTIME_Pos 8
#define SYSCTRL_DPLLCTRLB_LTIME_Msk (_U_(0x7) << SYSCTRL_DPLLCTRLB_LTIME_Pos)
#define SYSCTRL_DPLLCTRLB_LTIME(value) (SYSCTRL_DPLLCTRLB_LTIME_Msk & ((value) << SYSCTRL_DPLLCTRLB_LTIME_Pos))
#define SYSCTRL_DPLLCTRLB_LTIME_DEFAULT_Val _U_(0x0)
#define SYSCTRL_DPLLCTRLB_LTIME_8MS_Val _U_(0x4)
#define SYSCTRL_DPLLCTRLB_LTIME_9MS_Val _U_(0x5)
#define SYSCTRL_DPLLCTRLB_LTIME_10MS_Val _U_(0x6)
#define SYSCTRL_DPLLCTRLB_LTIME_11MS_Val _U_(0x7)
#define SYSCTRL_DPLLCTRLB_LTIME_DEFAULT (SYSCTRL_DPLLCTRLB_LTIME_DEFAULT_Val << SYSCTRL_DPLLCTRLB_LTIME_Pos)
#define SYSCTRL_DPLLCTRLB_LTIME_8MS (SYSCTRL_DPLLCTRLB_LTIME_8MS_Val << SYSCTRL_DPLLCTRLB_LTIME_Pos)
#define SYSCTRL_DPLLCTRLB_LTIME_9MS (SYSCTRL_DPLLCTRLB_LTIME_9MS_Val << SYSCTRL_DPLLCTRLB_LTIME_Pos)
#define SYSCTRL_DPLLCTRLB_LTIME_10MS (SYSCTRL_DPLLCTRLB_LTIME_10MS_Val << SYSCTRL_DPLLCTRLB_LTIME_Pos)
#define SYSCTRL_DPLLCTRLB_LTIME_11MS (SYSCTRL_DPLLCTRLB_LTIME_11MS_Val << SYSCTRL_DPLLCTRLB_LTIME_Pos)
#define SYSCTRL_DPLLCTRLB_LBYPASS_Pos 12
#define SYSCTRL_DPLLCTRLB_LBYPASS (_U_(0x1) << SYSCTRL_DPLLCTRLB_LBYPASS_Pos)
#define SYSCTRL_DPLLCTRLB_DIV_Pos 16
#define SYSCTRL_DPLLCTRLB_DIV_Msk (_U_(0x7FF) << SYSCTRL_DPLLCTRLB_DIV_Pos)
#define SYSCTRL_DPLLCTRLB_DIV(value) (SYSCTRL_DPLLCTRLB_DIV_Msk & ((value) << SYSCTRL_DPLLCTRLB_DIV_Pos))
#define SYSCTRL_DPLLCTRLB_MASK _U_(0x07FF173F)

/* -------- SYSCTRL_DPLLSTATUS : (SYSCTRL Offset: 0x50) (R/   8) DPLL Status -------- */

typedef union {
  struct {
    uint8_t LOCK:1; /*!< bit:      0  DPLL Lock Status                   */
    uint8_t CLKRDY:1; /*!< bit:      1  Output Clock Ready                 */
    uint8_t ENABLE:1; /*!< bit:      2  DPLL Enable                        */
    uint8_t DIV:1; /*!< bit:      3  Divider Enable                     */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} SYSCTRL_DPLLSTATUS_Type;


#define SYSCTRL_DPLLSTATUS_OFFSET 0x50
#define SYSCTRL_DPLLSTATUS_RESETVALUE _U_(0x00)

#define SYSCTRL_DPLLSTATUS_LOCK_Pos 0
#define SYSCTRL_DPLLSTATUS_LOCK (_U_(0x1) << SYSCTRL_DPLLSTATUS_LOCK_Pos)
#define SYSCTRL_DPLLSTATUS_CLKRDY_Pos 1
#define SYSCTRL_DPLLSTATUS_CLKRDY (_U_(0x1) << SYSCTRL_DPLLSTATUS_CLKRDY_Pos)
#define SYSCTRL_DPLLSTATUS_ENABLE_Pos 2
#define SYSCTRL_DPLLSTATUS_ENABLE (_U_(0x1) << SYSCTRL_DPLLSTATUS_ENABLE_Pos)
#define SYSCTRL_DPLLSTATUS_DIV_Pos 3
#define SYSCTRL_DPLLSTATUS_DIV (_U_(0x1) << SYSCTRL_DPLLSTATUS_DIV_Pos)
#define SYSCTRL_DPLLSTATUS_MASK _U_(0x0F)

/** \brief SYSCTRL hardware registers */

typedef struct {
  volatile SYSCTRL_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x00 (R/W 32) Interrupt Enable Clear */
  volatile SYSCTRL_INTENSET_Type INTENSET; /**< \brief Offset: 0x04 (R/W 32) Interrupt Enable Set */
  volatile SYSCTRL_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x08 (R/W 32) Interrupt Flag Status and Clear */
  volatile const SYSCTRL_PCLKSR_Type PCLKSR; /**< \brief Offset: 0x0C (R/  32) Power and Clocks Status */
  volatile SYSCTRL_XOSC_Type XOSC; /**< \brief Offset: 0x10 (R/W 16) External Multipurpose Crystal Oscillator (XOSC) Control */
       RoReg8 Reserved1[0x2];
  volatile SYSCTRL_XOSC32K_Type XOSC32K; /**< \brief Offset: 0x14 (R/W 16) 32kHz External Crystal Oscillator (XOSC32K) Control */
       RoReg8 Reserved2[0x2];
  volatile SYSCTRL_OSC32K_Type OSC32K; /**< \brief Offset: 0x18 (R/W 32) 32kHz Internal Oscillator (OSC32K) Control */
  volatile SYSCTRL_OSCULP32K_Type OSCULP32K; /**< \brief Offset: 0x1C (R/W  8) 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control */
       RoReg8 Reserved3[0x3];
  volatile SYSCTRL_OSC8M_Type OSC8M; /**< \brief Offset: 0x20 (R/W 32) 8MHz Internal Oscillator (OSC8M) Control */
  volatile SYSCTRL_DFLLCTRL_Type DFLLCTRL; /**< \brief Offset: 0x24 (R/W 16) DFLL48M Control */
       RoReg8 Reserved4[0x2];
  volatile SYSCTRL_DFLLVAL_Type DFLLVAL; /**< \brief Offset: 0x28 (R/W 32) DFLL48M Value */
  volatile SYSCTRL_DFLLMUL_Type DFLLMUL; /**< \brief Offset: 0x2C (R/W 32) DFLL48M Multiplier */
  volatile SYSCTRL_DFLLSYNC_Type DFLLSYNC; /**< \brief Offset: 0x30 (R/W  8) DFLL48M Synchronization */
       RoReg8 Reserved5[0x3];
  volatile SYSCTRL_BOD33_Type BOD33; /**< \brief Offset: 0x34 (R/W 32) 3.3V Brown-Out Detector (BOD33) Control */
       RoReg8 Reserved6[0x4];
  volatile SYSCTRL_VREG_Type VREG; /**< \brief Offset: 0x3C (R/W 16) Voltage Regulator System (VREG) Control */
       RoReg8 Reserved7[0x2];
  volatile SYSCTRL_VREF_Type VREF; /**< \brief Offset: 0x40 (R/W 32) Voltage References System (VREF) Control */
  volatile SYSCTRL_DPLLCTRLA_Type DPLLCTRLA; /**< \brief Offset: 0x44 (R/W  8) DPLL Control A */
       RoReg8 Reserved8[0x3];
  volatile SYSCTRL_DPLLRATIO_Type DPLLRATIO; /**< \brief Offset: 0x48 (R/W 32) DPLL Ratio Control */
  volatile SYSCTRL_DPLLCTRLB_Type DPLLCTRLB; /**< \brief Offset: 0x4C (R/W 32) DPLL Control B */
  volatile const SYSCTRL_DPLLSTATUS_Type DPLLSTATUS; /**< \brief Offset: 0x50 (R/   8) DPLL Status */
} Sysctrl;


/*@}*/
# 262 "asf4/samd21/include/samd21e18a.h" 2
#include "component/tc.h"
# 262 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/tc.h" 1
/**
 * \file
 *
 * \brief Component description for TC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR TC */
/* ========================================================================== */
/** \addtogroup SAMD21_TC Basic Timer Counter */
/*@{*/

#define TC_U2212 
#define REV_TC 0x121

/* -------- TC_CTRLA : (TC Offset: 0x00) (R/W 16) Control A -------- */

typedef union {
  struct {
    uint16_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint16_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint16_t MODE:2; /*!< bit:  2.. 3  TC Mode                            */
    uint16_t :1; /*!< bit:      4  Reserved                           */
    uint16_t WAVEGEN:2; /*!< bit:  5.. 6  Waveform Generation Operation      */
    uint16_t :1; /*!< bit:      7  Reserved                           */
    uint16_t PRESCALER:3; /*!< bit:  8..10  Prescaler                          */
    uint16_t RUNSTDBY:1; /*!< bit:     11  Run in Standby                     */
    uint16_t PRESCSYNC:2; /*!< bit: 12..13  Prescaler and Counter Synchronization */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} TC_CTRLA_Type;


#define TC_CTRLA_OFFSET 0x00
#define TC_CTRLA_RESETVALUE _U_(0x0000)

#define TC_CTRLA_SWRST_Pos 0
#define TC_CTRLA_SWRST (_U_(0x1) << TC_CTRLA_SWRST_Pos)
#define TC_CTRLA_ENABLE_Pos 1
#define TC_CTRLA_ENABLE (_U_(0x1) << TC_CTRLA_ENABLE_Pos)
#define TC_CTRLA_MODE_Pos 2
#define TC_CTRLA_MODE_Msk (_U_(0x3) << TC_CTRLA_MODE_Pos)
#define TC_CTRLA_MODE(value) (TC_CTRLA_MODE_Msk & ((value) << TC_CTRLA_MODE_Pos))
#define TC_CTRLA_MODE_COUNT16_Val _U_(0x0)
#define TC_CTRLA_MODE_COUNT8_Val _U_(0x1)
#define TC_CTRLA_MODE_COUNT32_Val _U_(0x2)
#define TC_CTRLA_MODE_COUNT16 (TC_CTRLA_MODE_COUNT16_Val << TC_CTRLA_MODE_Pos)
#define TC_CTRLA_MODE_COUNT8 (TC_CTRLA_MODE_COUNT8_Val << TC_CTRLA_MODE_Pos)
#define TC_CTRLA_MODE_COUNT32 (TC_CTRLA_MODE_COUNT32_Val << TC_CTRLA_MODE_Pos)
#define TC_CTRLA_WAVEGEN_Pos 5
#define TC_CTRLA_WAVEGEN_Msk (_U_(0x3) << TC_CTRLA_WAVEGEN_Pos)
#define TC_CTRLA_WAVEGEN(value) (TC_CTRLA_WAVEGEN_Msk & ((value) << TC_CTRLA_WAVEGEN_Pos))
#define TC_CTRLA_WAVEGEN_NFRQ_Val _U_(0x0)
#define TC_CTRLA_WAVEGEN_MFRQ_Val _U_(0x1)
#define TC_CTRLA_WAVEGEN_NPWM_Val _U_(0x2)
#define TC_CTRLA_WAVEGEN_MPWM_Val _U_(0x3)
#define TC_CTRLA_WAVEGEN_NFRQ (TC_CTRLA_WAVEGEN_NFRQ_Val << TC_CTRLA_WAVEGEN_Pos)
#define TC_CTRLA_WAVEGEN_MFRQ (TC_CTRLA_WAVEGEN_MFRQ_Val << TC_CTRLA_WAVEGEN_Pos)
#define TC_CTRLA_WAVEGEN_NPWM (TC_CTRLA_WAVEGEN_NPWM_Val << TC_CTRLA_WAVEGEN_Pos)
#define TC_CTRLA_WAVEGEN_MPWM (TC_CTRLA_WAVEGEN_MPWM_Val << TC_CTRLA_WAVEGEN_Pos)
#define TC_CTRLA_PRESCALER_Pos 8
#define TC_CTRLA_PRESCALER_Msk (_U_(0x7) << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER(value) (TC_CTRLA_PRESCALER_Msk & ((value) << TC_CTRLA_PRESCALER_Pos))
#define TC_CTRLA_PRESCALER_DIV1_Val _U_(0x0)
#define TC_CTRLA_PRESCALER_DIV2_Val _U_(0x1)
#define TC_CTRLA_PRESCALER_DIV4_Val _U_(0x2)
#define TC_CTRLA_PRESCALER_DIV8_Val _U_(0x3)
#define TC_CTRLA_PRESCALER_DIV16_Val _U_(0x4)
#define TC_CTRLA_PRESCALER_DIV64_Val _U_(0x5)
#define TC_CTRLA_PRESCALER_DIV256_Val _U_(0x6)
#define TC_CTRLA_PRESCALER_DIV1024_Val _U_(0x7)
#define TC_CTRLA_PRESCALER_DIV1 (TC_CTRLA_PRESCALER_DIV1_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER_DIV2 (TC_CTRLA_PRESCALER_DIV2_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER_DIV4 (TC_CTRLA_PRESCALER_DIV4_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER_DIV8 (TC_CTRLA_PRESCALER_DIV8_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER_DIV16 (TC_CTRLA_PRESCALER_DIV16_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER_DIV64 (TC_CTRLA_PRESCALER_DIV64_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER_DIV256 (TC_CTRLA_PRESCALER_DIV256_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_PRESCALER_DIV1024 (TC_CTRLA_PRESCALER_DIV1024_Val << TC_CTRLA_PRESCALER_Pos)
#define TC_CTRLA_RUNSTDBY_Pos 11
#define TC_CTRLA_RUNSTDBY (_U_(0x1) << TC_CTRLA_RUNSTDBY_Pos)
#define TC_CTRLA_PRESCSYNC_Pos 12
#define TC_CTRLA_PRESCSYNC_Msk (_U_(0x3) << TC_CTRLA_PRESCSYNC_Pos)
#define TC_CTRLA_PRESCSYNC(value) (TC_CTRLA_PRESCSYNC_Msk & ((value) << TC_CTRLA_PRESCSYNC_Pos))
#define TC_CTRLA_PRESCSYNC_GCLK_Val _U_(0x0)
#define TC_CTRLA_PRESCSYNC_PRESC_Val _U_(0x1)
#define TC_CTRLA_PRESCSYNC_RESYNC_Val _U_(0x2)
#define TC_CTRLA_PRESCSYNC_GCLK (TC_CTRLA_PRESCSYNC_GCLK_Val << TC_CTRLA_PRESCSYNC_Pos)
#define TC_CTRLA_PRESCSYNC_PRESC (TC_CTRLA_PRESCSYNC_PRESC_Val << TC_CTRLA_PRESCSYNC_Pos)
#define TC_CTRLA_PRESCSYNC_RESYNC (TC_CTRLA_PRESCSYNC_RESYNC_Val << TC_CTRLA_PRESCSYNC_Pos)
#define TC_CTRLA_MASK _U_(0x3F6F)

/* -------- TC_READREQ : (TC Offset: 0x02) (R/W 16) Read Request -------- */

typedef union {
  struct {
    uint16_t ADDR:5; /*!< bit:  0.. 4  Address                            */
    uint16_t :9; /*!< bit:  5..13  Reserved                           */
    uint16_t RCONT:1; /*!< bit:     14  Read Continuously                  */
    uint16_t RREQ:1; /*!< bit:     15  Read Request                       */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} TC_READREQ_Type;


#define TC_READREQ_OFFSET 0x02
#define TC_READREQ_RESETVALUE _U_(0x0000)

#define TC_READREQ_ADDR_Pos 0
#define TC_READREQ_ADDR_Msk (_U_(0x1F) << TC_READREQ_ADDR_Pos)
#define TC_READREQ_ADDR(value) (TC_READREQ_ADDR_Msk & ((value) << TC_READREQ_ADDR_Pos))
#define TC_READREQ_RCONT_Pos 14
#define TC_READREQ_RCONT (_U_(0x1) << TC_READREQ_RCONT_Pos)
#define TC_READREQ_RREQ_Pos 15
#define TC_READREQ_RREQ (_U_(0x1) << TC_READREQ_RREQ_Pos)
#define TC_READREQ_MASK _U_(0xC01F)

/* -------- TC_CTRLBCLR : (TC Offset: 0x04) (R/W  8) Control B Clear -------- */

typedef union {
  struct {
    uint8_t DIR:1; /*!< bit:      0  Counter Direction                  */
    uint8_t :1; /*!< bit:      1  Reserved                           */
    uint8_t ONESHOT:1; /*!< bit:      2  One-Shot                           */
    uint8_t :3; /*!< bit:  3.. 5  Reserved                           */
    uint8_t CMD:2; /*!< bit:  6.. 7  Command                            */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_CTRLBCLR_Type;


#define TC_CTRLBCLR_OFFSET 0x04
#define TC_CTRLBCLR_RESETVALUE _U_(0x02)

#define TC_CTRLBCLR_DIR_Pos 0
#define TC_CTRLBCLR_DIR (_U_(0x1) << TC_CTRLBCLR_DIR_Pos)
#define TC_CTRLBCLR_ONESHOT_Pos 2
#define TC_CTRLBCLR_ONESHOT (_U_(0x1) << TC_CTRLBCLR_ONESHOT_Pos)
#define TC_CTRLBCLR_CMD_Pos 6
#define TC_CTRLBCLR_CMD_Msk (_U_(0x3) << TC_CTRLBCLR_CMD_Pos)
#define TC_CTRLBCLR_CMD(value) (TC_CTRLBCLR_CMD_Msk & ((value) << TC_CTRLBCLR_CMD_Pos))
#define TC_CTRLBCLR_CMD_NONE_Val _U_(0x0)
#define TC_CTRLBCLR_CMD_RETRIGGER_Val _U_(0x1)
#define TC_CTRLBCLR_CMD_STOP_Val _U_(0x2)
#define TC_CTRLBCLR_CMD_NONE (TC_CTRLBCLR_CMD_NONE_Val << TC_CTRLBCLR_CMD_Pos)
#define TC_CTRLBCLR_CMD_RETRIGGER (TC_CTRLBCLR_CMD_RETRIGGER_Val << TC_CTRLBCLR_CMD_Pos)
#define TC_CTRLBCLR_CMD_STOP (TC_CTRLBCLR_CMD_STOP_Val << TC_CTRLBCLR_CMD_Pos)
#define TC_CTRLBCLR_MASK _U_(0xC5)

/* -------- TC_CTRLBSET : (TC Offset: 0x05) (R/W  8) Control B Set -------- */

typedef union {
  struct {
    uint8_t DIR:1; /*!< bit:      0  Counter Direction                  */
    uint8_t :1; /*!< bit:      1  Reserved                           */
    uint8_t ONESHOT:1; /*!< bit:      2  One-Shot                           */
    uint8_t :3; /*!< bit:  3.. 5  Reserved                           */
    uint8_t CMD:2; /*!< bit:  6.. 7  Command                            */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_CTRLBSET_Type;


#define TC_CTRLBSET_OFFSET 0x05
#define TC_CTRLBSET_RESETVALUE _U_(0x00)

#define TC_CTRLBSET_DIR_Pos 0
#define TC_CTRLBSET_DIR (_U_(0x1) << TC_CTRLBSET_DIR_Pos)
#define TC_CTRLBSET_ONESHOT_Pos 2
#define TC_CTRLBSET_ONESHOT (_U_(0x1) << TC_CTRLBSET_ONESHOT_Pos)
#define TC_CTRLBSET_CMD_Pos 6
#define TC_CTRLBSET_CMD_Msk (_U_(0x3) << TC_CTRLBSET_CMD_Pos)
#define TC_CTRLBSET_CMD(value) (TC_CTRLBSET_CMD_Msk & ((value) << TC_CTRLBSET_CMD_Pos))
#define TC_CTRLBSET_CMD_NONE_Val _U_(0x0)
#define TC_CTRLBSET_CMD_RETRIGGER_Val _U_(0x1)
#define TC_CTRLBSET_CMD_STOP_Val _U_(0x2)
#define TC_CTRLBSET_CMD_NONE (TC_CTRLBSET_CMD_NONE_Val << TC_CTRLBSET_CMD_Pos)
#define TC_CTRLBSET_CMD_RETRIGGER (TC_CTRLBSET_CMD_RETRIGGER_Val << TC_CTRLBSET_CMD_Pos)
#define TC_CTRLBSET_CMD_STOP (TC_CTRLBSET_CMD_STOP_Val << TC_CTRLBSET_CMD_Pos)
#define TC_CTRLBSET_MASK _U_(0xC5)

/* -------- TC_CTRLC : (TC Offset: 0x06) (R/W  8) Control C -------- */

typedef union {
  struct {
    uint8_t INVEN0:1; /*!< bit:      0  Output Waveform 0 Invert Enable    */
    uint8_t INVEN1:1; /*!< bit:      1  Output Waveform 1 Invert Enable    */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t CPTEN0:1; /*!< bit:      4  Capture Channel 0 Enable           */
    uint8_t CPTEN1:1; /*!< bit:      5  Capture Channel 1 Enable           */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t INVEN:2; /*!< bit:  0.. 1  Output Waveform x Invert Enable    */
    uint8_t :2; /*!< bit:  2.. 3  Reserved                           */
    uint8_t CPTEN:2; /*!< bit:  4.. 5  Capture Channel x Enable           */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_CTRLC_Type;


#define TC_CTRLC_OFFSET 0x06
#define TC_CTRLC_RESETVALUE _U_(0x00)

#define TC_CTRLC_INVEN0_Pos 0
#define TC_CTRLC_INVEN0 (_U_(1) << TC_CTRLC_INVEN0_Pos)
#define TC_CTRLC_INVEN1_Pos 1
#define TC_CTRLC_INVEN1 (_U_(1) << TC_CTRLC_INVEN1_Pos)
#define TC_CTRLC_INVEN_Pos 0
#define TC_CTRLC_INVEN_Msk (_U_(0x3) << TC_CTRLC_INVEN_Pos)
#define TC_CTRLC_INVEN(value) (TC_CTRLC_INVEN_Msk & ((value) << TC_CTRLC_INVEN_Pos))
#define TC_CTRLC_CPTEN0_Pos 4
#define TC_CTRLC_CPTEN0 (_U_(1) << TC_CTRLC_CPTEN0_Pos)
#define TC_CTRLC_CPTEN1_Pos 5
#define TC_CTRLC_CPTEN1 (_U_(1) << TC_CTRLC_CPTEN1_Pos)
#define TC_CTRLC_CPTEN_Pos 4
#define TC_CTRLC_CPTEN_Msk (_U_(0x3) << TC_CTRLC_CPTEN_Pos)
#define TC_CTRLC_CPTEN(value) (TC_CTRLC_CPTEN_Msk & ((value) << TC_CTRLC_CPTEN_Pos))
#define TC_CTRLC_MASK _U_(0x33)

/* -------- TC_DBGCTRL : (TC Offset: 0x08) (R/W  8) Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGRUN:1; /*!< bit:      0  Debug Run Mode                     */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_DBGCTRL_Type;


#define TC_DBGCTRL_OFFSET 0x08
#define TC_DBGCTRL_RESETVALUE _U_(0x00)

#define TC_DBGCTRL_DBGRUN_Pos 0
#define TC_DBGCTRL_DBGRUN (_U_(0x1) << TC_DBGCTRL_DBGRUN_Pos)
#define TC_DBGCTRL_MASK _U_(0x01)

/* -------- TC_EVCTRL : (TC Offset: 0x0A) (R/W 16) Event Control -------- */

typedef union {
  struct {
    uint16_t EVACT:3; /*!< bit:  0.. 2  Event Action                       */
    uint16_t :1; /*!< bit:      3  Reserved                           */
    uint16_t TCINV:1; /*!< bit:      4  TC Inverted Event Input            */
    uint16_t TCEI:1; /*!< bit:      5  TC Event Input                     */
    uint16_t :2; /*!< bit:  6.. 7  Reserved                           */
    uint16_t OVFEO:1; /*!< bit:      8  Overflow/Underflow Event Output Enable */
    uint16_t :3; /*!< bit:  9..11  Reserved                           */
    uint16_t MCEO0:1; /*!< bit:     12  Match or Capture Channel 0 Event Output Enable */
    uint16_t MCEO1:1; /*!< bit:     13  Match or Capture Channel 1 Event Output Enable */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t :12; /*!< bit:  0..11  Reserved                           */
    uint16_t MCEO:2; /*!< bit: 12..13  Match or Capture Channel x Event Output Enable */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} TC_EVCTRL_Type;


#define TC_EVCTRL_OFFSET 0x0A
#define TC_EVCTRL_RESETVALUE _U_(0x0000)

#define TC_EVCTRL_EVACT_Pos 0
#define TC_EVCTRL_EVACT_Msk (_U_(0x7) << TC_EVCTRL_EVACT_Pos)
#define TC_EVCTRL_EVACT(value) (TC_EVCTRL_EVACT_Msk & ((value) << TC_EVCTRL_EVACT_Pos))
#define TC_EVCTRL_EVACT_OFF_Val _U_(0x0)
#define TC_EVCTRL_EVACT_RETRIGGER_Val _U_(0x1)
#define TC_EVCTRL_EVACT_COUNT_Val _U_(0x2)
#define TC_EVCTRL_EVACT_START_Val _U_(0x3)
#define TC_EVCTRL_EVACT_PPW_Val _U_(0x5)
#define TC_EVCTRL_EVACT_PWP_Val _U_(0x6)
#define TC_EVCTRL_EVACT_OFF (TC_EVCTRL_EVACT_OFF_Val << TC_EVCTRL_EVACT_Pos)
#define TC_EVCTRL_EVACT_RETRIGGER (TC_EVCTRL_EVACT_RETRIGGER_Val << TC_EVCTRL_EVACT_Pos)
#define TC_EVCTRL_EVACT_COUNT (TC_EVCTRL_EVACT_COUNT_Val << TC_EVCTRL_EVACT_Pos)
#define TC_EVCTRL_EVACT_START (TC_EVCTRL_EVACT_START_Val << TC_EVCTRL_EVACT_Pos)
#define TC_EVCTRL_EVACT_PPW (TC_EVCTRL_EVACT_PPW_Val << TC_EVCTRL_EVACT_Pos)
#define TC_EVCTRL_EVACT_PWP (TC_EVCTRL_EVACT_PWP_Val << TC_EVCTRL_EVACT_Pos)
#define TC_EVCTRL_TCINV_Pos 4
#define TC_EVCTRL_TCINV (_U_(0x1) << TC_EVCTRL_TCINV_Pos)
#define TC_EVCTRL_TCEI_Pos 5
#define TC_EVCTRL_TCEI (_U_(0x1) << TC_EVCTRL_TCEI_Pos)
#define TC_EVCTRL_OVFEO_Pos 8
#define TC_EVCTRL_OVFEO (_U_(0x1) << TC_EVCTRL_OVFEO_Pos)
#define TC_EVCTRL_MCEO0_Pos 12
#define TC_EVCTRL_MCEO0 (_U_(1) << TC_EVCTRL_MCEO0_Pos)
#define TC_EVCTRL_MCEO1_Pos 13
#define TC_EVCTRL_MCEO1 (_U_(1) << TC_EVCTRL_MCEO1_Pos)
#define TC_EVCTRL_MCEO_Pos 12
#define TC_EVCTRL_MCEO_Msk (_U_(0x3) << TC_EVCTRL_MCEO_Pos)
#define TC_EVCTRL_MCEO(value) (TC_EVCTRL_MCEO_Msk & ((value) << TC_EVCTRL_MCEO_Pos))
#define TC_EVCTRL_MASK _U_(0x3137)

/* -------- TC_INTENCLR : (TC Offset: 0x0C) (R/W  8) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t OVF:1; /*!< bit:      0  Overflow Interrupt Enable          */
    uint8_t ERR:1; /*!< bit:      1  Error Interrupt Enable             */
    uint8_t :1; /*!< bit:      2  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      3  Synchronization Ready Interrupt Enable */
    uint8_t MC0:1; /*!< bit:      4  Match or Capture Channel 0 Interrupt Enable */
    uint8_t MC1:1; /*!< bit:      5  Match or Capture Channel 1 Interrupt Enable */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t :4; /*!< bit:  0.. 3  Reserved                           */
    uint8_t MC:2; /*!< bit:  4.. 5  Match or Capture Channel x Interrupt Enable */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_INTENCLR_Type;


#define TC_INTENCLR_OFFSET 0x0C
#define TC_INTENCLR_RESETVALUE _U_(0x00)

#define TC_INTENCLR_OVF_Pos 0
#define TC_INTENCLR_OVF (_U_(0x1) << TC_INTENCLR_OVF_Pos)
#define TC_INTENCLR_ERR_Pos 1
#define TC_INTENCLR_ERR (_U_(0x1) << TC_INTENCLR_ERR_Pos)
#define TC_INTENCLR_SYNCRDY_Pos 3
#define TC_INTENCLR_SYNCRDY (_U_(0x1) << TC_INTENCLR_SYNCRDY_Pos)
#define TC_INTENCLR_MC0_Pos 4
#define TC_INTENCLR_MC0 (_U_(1) << TC_INTENCLR_MC0_Pos)
#define TC_INTENCLR_MC1_Pos 5
#define TC_INTENCLR_MC1 (_U_(1) << TC_INTENCLR_MC1_Pos)
#define TC_INTENCLR_MC_Pos 4
#define TC_INTENCLR_MC_Msk (_U_(0x3) << TC_INTENCLR_MC_Pos)
#define TC_INTENCLR_MC(value) (TC_INTENCLR_MC_Msk & ((value) << TC_INTENCLR_MC_Pos))
#define TC_INTENCLR_MASK _U_(0x3B)

/* -------- TC_INTENSET : (TC Offset: 0x0D) (R/W  8) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t OVF:1; /*!< bit:      0  Overflow Interrupt Enable          */
    uint8_t ERR:1; /*!< bit:      1  Error Interrupt Enable             */
    uint8_t :1; /*!< bit:      2  Reserved                           */
    uint8_t SYNCRDY:1; /*!< bit:      3  Synchronization Ready Interrupt Enable */
    uint8_t MC0:1; /*!< bit:      4  Match or Capture Channel 0 Interrupt Enable */
    uint8_t MC1:1; /*!< bit:      5  Match or Capture Channel 1 Interrupt Enable */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t :4; /*!< bit:  0.. 3  Reserved                           */
    uint8_t MC:2; /*!< bit:  4.. 5  Match or Capture Channel x Interrupt Enable */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_INTENSET_Type;


#define TC_INTENSET_OFFSET 0x0D
#define TC_INTENSET_RESETVALUE _U_(0x00)

#define TC_INTENSET_OVF_Pos 0
#define TC_INTENSET_OVF (_U_(0x1) << TC_INTENSET_OVF_Pos)
#define TC_INTENSET_ERR_Pos 1
#define TC_INTENSET_ERR (_U_(0x1) << TC_INTENSET_ERR_Pos)
#define TC_INTENSET_SYNCRDY_Pos 3
#define TC_INTENSET_SYNCRDY (_U_(0x1) << TC_INTENSET_SYNCRDY_Pos)
#define TC_INTENSET_MC0_Pos 4
#define TC_INTENSET_MC0 (_U_(1) << TC_INTENSET_MC0_Pos)
#define TC_INTENSET_MC1_Pos 5
#define TC_INTENSET_MC1 (_U_(1) << TC_INTENSET_MC1_Pos)
#define TC_INTENSET_MC_Pos 4
#define TC_INTENSET_MC_Msk (_U_(0x3) << TC_INTENSET_MC_Pos)
#define TC_INTENSET_MC(value) (TC_INTENSET_MC_Msk & ((value) << TC_INTENSET_MC_Pos))
#define TC_INTENSET_MASK _U_(0x3B)

/* -------- TC_INTFLAG : (TC Offset: 0x0E) (R/W  8) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t OVF:1; /*!< bit:      0  Overflow                           */
    volatile const uint8_t ERR:1; /*!< bit:      1  Error                              */
    volatile const uint8_t :1; /*!< bit:      2  Reserved                           */
    volatile const uint8_t SYNCRDY:1; /*!< bit:      3  Synchronization Ready              */
    volatile const uint8_t MC0:1; /*!< bit:      4  Match or Capture Channel 0         */
    volatile const uint8_t MC1:1; /*!< bit:      5  Match or Capture Channel 1         */
    volatile const uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint8_t :4; /*!< bit:  0.. 3  Reserved                           */
    volatile const uint8_t MC:2; /*!< bit:  4.. 5  Match or Capture Channel x         */
    volatile const uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_INTFLAG_Type;


#define TC_INTFLAG_OFFSET 0x0E
#define TC_INTFLAG_RESETVALUE _U_(0x00)

#define TC_INTFLAG_OVF_Pos 0
#define TC_INTFLAG_OVF (_U_(0x1) << TC_INTFLAG_OVF_Pos)
#define TC_INTFLAG_ERR_Pos 1
#define TC_INTFLAG_ERR (_U_(0x1) << TC_INTFLAG_ERR_Pos)
#define TC_INTFLAG_SYNCRDY_Pos 3
#define TC_INTFLAG_SYNCRDY (_U_(0x1) << TC_INTFLAG_SYNCRDY_Pos)
#define TC_INTFLAG_MC0_Pos 4
#define TC_INTFLAG_MC0 (_U_(1) << TC_INTFLAG_MC0_Pos)
#define TC_INTFLAG_MC1_Pos 5
#define TC_INTFLAG_MC1 (_U_(1) << TC_INTFLAG_MC1_Pos)
#define TC_INTFLAG_MC_Pos 4
#define TC_INTFLAG_MC_Msk (_U_(0x3) << TC_INTFLAG_MC_Pos)
#define TC_INTFLAG_MC(value) (TC_INTFLAG_MC_Msk & ((value) << TC_INTFLAG_MC_Pos))
#define TC_INTFLAG_MASK _U_(0x3B)

/* -------- TC_STATUS : (TC Offset: 0x0F) (R/   8) Status -------- */

typedef union {
  struct {
    uint8_t :3; /*!< bit:  0.. 2  Reserved                           */
    uint8_t STOP:1; /*!< bit:      3  Stop                               */
    uint8_t SLAVE:1; /*!< bit:      4  Slave                              */
    uint8_t :2; /*!< bit:  5.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy               */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_STATUS_Type;


#define TC_STATUS_OFFSET 0x0F
#define TC_STATUS_RESETVALUE _U_(0x08)

#define TC_STATUS_STOP_Pos 3
#define TC_STATUS_STOP (_U_(0x1) << TC_STATUS_STOP_Pos)
#define TC_STATUS_SLAVE_Pos 4
#define TC_STATUS_SLAVE (_U_(0x1) << TC_STATUS_SLAVE_Pos)
#define TC_STATUS_SYNCBUSY_Pos 7
#define TC_STATUS_SYNCBUSY (_U_(0x1) << TC_STATUS_SYNCBUSY_Pos)
#define TC_STATUS_MASK _U_(0x98)

/* -------- TC_COUNT16_COUNT : (TC Offset: 0x10) (R/W 16) COUNT16 COUNT16 Counter Value -------- */

typedef union {
  struct {
    uint16_t COUNT:16; /*!< bit:  0..15  Count Value                        */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} TC_COUNT16_COUNT_Type;


#define TC_COUNT16_COUNT_OFFSET 0x10
#define TC_COUNT16_COUNT_RESETVALUE _U_(0x0000)

#define TC_COUNT16_COUNT_COUNT_Pos 0
#define TC_COUNT16_COUNT_COUNT_Msk (_U_(0xFFFF) << TC_COUNT16_COUNT_COUNT_Pos)
#define TC_COUNT16_COUNT_COUNT(value) (TC_COUNT16_COUNT_COUNT_Msk & ((value) << TC_COUNT16_COUNT_COUNT_Pos))
#define TC_COUNT16_COUNT_MASK _U_(0xFFFF)

/* -------- TC_COUNT32_COUNT : (TC Offset: 0x10) (R/W 32) COUNT32 COUNT32 Counter Value -------- */

typedef union {
  struct {
    uint32_t COUNT:32; /*!< bit:  0..31  Count Value                        */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TC_COUNT32_COUNT_Type;


#define TC_COUNT32_COUNT_OFFSET 0x10
#define TC_COUNT32_COUNT_RESETVALUE _U_(0x00000000)

#define TC_COUNT32_COUNT_COUNT_Pos 0
#define TC_COUNT32_COUNT_COUNT_Msk (_U_(0xFFFFFFFF) << TC_COUNT32_COUNT_COUNT_Pos)
#define TC_COUNT32_COUNT_COUNT(value) (TC_COUNT32_COUNT_COUNT_Msk & ((value) << TC_COUNT32_COUNT_COUNT_Pos))
#define TC_COUNT32_COUNT_MASK _U_(0xFFFFFFFF)

/* -------- TC_COUNT8_COUNT : (TC Offset: 0x10) (R/W  8) COUNT8 COUNT8 Counter Value -------- */

typedef union {
  struct {
    uint8_t COUNT:8; /*!< bit:  0.. 7  Counter Value                      */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_COUNT8_COUNT_Type;


#define TC_COUNT8_COUNT_OFFSET 0x10
#define TC_COUNT8_COUNT_RESETVALUE _U_(0x00)

#define TC_COUNT8_COUNT_COUNT_Pos 0
#define TC_COUNT8_COUNT_COUNT_Msk (_U_(0xFF) << TC_COUNT8_COUNT_COUNT_Pos)
#define TC_COUNT8_COUNT_COUNT(value) (TC_COUNT8_COUNT_COUNT_Msk & ((value) << TC_COUNT8_COUNT_COUNT_Pos))
#define TC_COUNT8_COUNT_MASK _U_(0xFF)

/* -------- TC_COUNT8_PER : (TC Offset: 0x14) (R/W  8) COUNT8 COUNT8 Period Value -------- */

typedef union {
  struct {
    uint8_t PER:8; /*!< bit:  0.. 7  Period Value                       */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_COUNT8_PER_Type;


#define TC_COUNT8_PER_OFFSET 0x14
#define TC_COUNT8_PER_RESETVALUE _U_(0xFF)

#define TC_COUNT8_PER_PER_Pos 0
#define TC_COUNT8_PER_PER_Msk (_U_(0xFF) << TC_COUNT8_PER_PER_Pos)
#define TC_COUNT8_PER_PER(value) (TC_COUNT8_PER_PER_Msk & ((value) << TC_COUNT8_PER_PER_Pos))
#define TC_COUNT8_PER_MASK _U_(0xFF)

/* -------- TC_COUNT16_CC : (TC Offset: 0x18) (R/W 16) COUNT16 COUNT16 Compare/Capture -------- */

typedef union {
  struct {
    uint16_t CC:16; /*!< bit:  0..15  Compare/Capture Value              */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} TC_COUNT16_CC_Type;


#define TC_COUNT16_CC_OFFSET 0x18
#define TC_COUNT16_CC_RESETVALUE _U_(0x0000)

#define TC_COUNT16_CC_CC_Pos 0
#define TC_COUNT16_CC_CC_Msk (_U_(0xFFFF) << TC_COUNT16_CC_CC_Pos)
#define TC_COUNT16_CC_CC(value) (TC_COUNT16_CC_CC_Msk & ((value) << TC_COUNT16_CC_CC_Pos))
#define TC_COUNT16_CC_MASK _U_(0xFFFF)

/* -------- TC_COUNT32_CC : (TC Offset: 0x18) (R/W 32) COUNT32 COUNT32 Compare/Capture -------- */

typedef union {
  struct {
    uint32_t CC:32; /*!< bit:  0..31  Compare/Capture Value              */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TC_COUNT32_CC_Type;


#define TC_COUNT32_CC_OFFSET 0x18
#define TC_COUNT32_CC_RESETVALUE _U_(0x00000000)

#define TC_COUNT32_CC_CC_Pos 0
#define TC_COUNT32_CC_CC_Msk (_U_(0xFFFFFFFF) << TC_COUNT32_CC_CC_Pos)
#define TC_COUNT32_CC_CC(value) (TC_COUNT32_CC_CC_Msk & ((value) << TC_COUNT32_CC_CC_Pos))
#define TC_COUNT32_CC_MASK _U_(0xFFFFFFFF)

/* -------- TC_COUNT8_CC : (TC Offset: 0x18) (R/W  8) COUNT8 COUNT8 Compare/Capture -------- */

typedef union {
  struct {
    uint8_t CC:8; /*!< bit:  0.. 7  Compare/Capture Value              */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TC_COUNT8_CC_Type;


#define TC_COUNT8_CC_OFFSET 0x18
#define TC_COUNT8_CC_RESETVALUE _U_(0x00)

#define TC_COUNT8_CC_CC_Pos 0
#define TC_COUNT8_CC_CC_Msk (_U_(0xFF) << TC_COUNT8_CC_CC_Pos)
#define TC_COUNT8_CC_CC(value) (TC_COUNT8_CC_CC_Msk & ((value) << TC_COUNT8_CC_CC_Pos))
#define TC_COUNT8_CC_MASK _U_(0xFF)

/** \brief TC_COUNT8 hardware registers */

typedef struct { /* 8-bit Counter Mode */
  volatile TC_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 16) Control A */
  volatile TC_READREQ_Type READREQ; /**< \brief Offset: 0x02 (R/W 16) Read Request */
  volatile TC_CTRLBCLR_Type CTRLBCLR; /**< \brief Offset: 0x04 (R/W  8) Control B Clear */
  volatile TC_CTRLBSET_Type CTRLBSET; /**< \brief Offset: 0x05 (R/W  8) Control B Set */
  volatile TC_CTRLC_Type CTRLC; /**< \brief Offset: 0x06 (R/W  8) Control C */
       RoReg8 Reserved1[0x1];
  volatile TC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x08 (R/W  8) Debug Control */
       RoReg8 Reserved2[0x1];
  volatile TC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x0A (R/W 16) Event Control */
  volatile TC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x0C (R/W  8) Interrupt Enable Clear */
  volatile TC_INTENSET_Type INTENSET; /**< \brief Offset: 0x0D (R/W  8) Interrupt Enable Set */
  volatile TC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x0E (R/W  8) Interrupt Flag Status and Clear */
  volatile const TC_STATUS_Type STATUS; /**< \brief Offset: 0x0F (R/   8) Status */
  volatile TC_COUNT8_COUNT_Type COUNT; /**< \brief Offset: 0x10 (R/W  8) COUNT8 Counter Value */
       RoReg8 Reserved3[0x3];
  volatile TC_COUNT8_PER_Type PER; /**< \brief Offset: 0x14 (R/W  8) COUNT8 Period Value */
       RoReg8 Reserved4[0x3];
  volatile TC_COUNT8_CC_Type CC[2]; /**< \brief Offset: 0x18 (R/W  8) COUNT8 Compare/Capture */
} TcCount8;


/** \brief TC_COUNT16 hardware registers */

typedef struct { /* 16-bit Counter Mode */
  volatile TC_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 16) Control A */
  volatile TC_READREQ_Type READREQ; /**< \brief Offset: 0x02 (R/W 16) Read Request */
  volatile TC_CTRLBCLR_Type CTRLBCLR; /**< \brief Offset: 0x04 (R/W  8) Control B Clear */
  volatile TC_CTRLBSET_Type CTRLBSET; /**< \brief Offset: 0x05 (R/W  8) Control B Set */
  volatile TC_CTRLC_Type CTRLC; /**< \brief Offset: 0x06 (R/W  8) Control C */
       RoReg8 Reserved1[0x1];
  volatile TC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x08 (R/W  8) Debug Control */
       RoReg8 Reserved2[0x1];
  volatile TC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x0A (R/W 16) Event Control */
  volatile TC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x0C (R/W  8) Interrupt Enable Clear */
  volatile TC_INTENSET_Type INTENSET; /**< \brief Offset: 0x0D (R/W  8) Interrupt Enable Set */
  volatile TC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x0E (R/W  8) Interrupt Flag Status and Clear */
  volatile const TC_STATUS_Type STATUS; /**< \brief Offset: 0x0F (R/   8) Status */
  volatile TC_COUNT16_COUNT_Type COUNT; /**< \brief Offset: 0x10 (R/W 16) COUNT16 Counter Value */
       RoReg8 Reserved3[0x6];
  volatile TC_COUNT16_CC_Type CC[2]; /**< \brief Offset: 0x18 (R/W 16) COUNT16 Compare/Capture */
} TcCount16;


/** \brief TC_COUNT32 hardware registers */

typedef struct { /* 32-bit Counter Mode */
  volatile TC_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 16) Control A */
  volatile TC_READREQ_Type READREQ; /**< \brief Offset: 0x02 (R/W 16) Read Request */
  volatile TC_CTRLBCLR_Type CTRLBCLR; /**< \brief Offset: 0x04 (R/W  8) Control B Clear */
  volatile TC_CTRLBSET_Type CTRLBSET; /**< \brief Offset: 0x05 (R/W  8) Control B Set */
  volatile TC_CTRLC_Type CTRLC; /**< \brief Offset: 0x06 (R/W  8) Control C */
       RoReg8 Reserved1[0x1];
  volatile TC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x08 (R/W  8) Debug Control */
       RoReg8 Reserved2[0x1];
  volatile TC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x0A (R/W 16) Event Control */
  volatile TC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x0C (R/W  8) Interrupt Enable Clear */
  volatile TC_INTENSET_Type INTENSET; /**< \brief Offset: 0x0D (R/W  8) Interrupt Enable Set */
  volatile TC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x0E (R/W  8) Interrupt Flag Status and Clear */
  volatile const TC_STATUS_Type STATUS; /**< \brief Offset: 0x0F (R/   8) Status */
  volatile TC_COUNT32_COUNT_Type COUNT; /**< \brief Offset: 0x10 (R/W 32) COUNT32 Counter Value */
       RoReg8 Reserved3[0x4];
  volatile TC_COUNT32_CC_Type CC[2]; /**< \brief Offset: 0x18 (R/W 32) COUNT32 Compare/Capture */
} TcCount32;



typedef union {
       TcCount8 COUNT8; /**< \brief Offset: 0x00 8-bit Counter Mode */
       TcCount16 COUNT16; /**< \brief Offset: 0x00 16-bit Counter Mode */
       TcCount32 COUNT32; /**< \brief Offset: 0x00 32-bit Counter Mode */
} Tc;


/*@}*/
# 263 "asf4/samd21/include/samd21e18a.h" 2
#include "component/tcc.h"
# 263 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/tcc.h" 1
/**
 * \file
 *
 * \brief Component description for TCC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TCC_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR TCC */
/* ========================================================================== */
/** \addtogroup SAMD21_TCC Timer Counter Control */
/*@{*/

#define TCC_U2213 
#define REV_TCC 0x101

/* -------- TCC_CTRLA : (TCC Offset: 0x00) (R/W 32) Control A -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint32_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint32_t :3; /*!< bit:  2.. 4  Reserved                           */
    uint32_t RESOLUTION:2; /*!< bit:  5.. 6  Enhanced Resolution                */
    uint32_t :1; /*!< bit:      7  Reserved                           */
    uint32_t PRESCALER:3; /*!< bit:  8..10  Prescaler                          */
    uint32_t RUNSTDBY:1; /*!< bit:     11  Run in Standby                     */
    uint32_t PRESCSYNC:2; /*!< bit: 12..13  Prescaler and Counter Synchronization Selection */
    uint32_t ALOCK:1; /*!< bit:     14  Auto Lock                          */
    uint32_t :9; /*!< bit: 15..23  Reserved                           */
    uint32_t CPTEN0:1; /*!< bit:     24  Capture Channel 0 Enable           */
    uint32_t CPTEN1:1; /*!< bit:     25  Capture Channel 1 Enable           */
    uint32_t CPTEN2:1; /*!< bit:     26  Capture Channel 2 Enable           */
    uint32_t CPTEN3:1; /*!< bit:     27  Capture Channel 3 Enable           */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :24; /*!< bit:  0..23  Reserved                           */
    uint32_t CPTEN:4; /*!< bit: 24..27  Capture Channel x Enable           */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_CTRLA_Type;


#define TCC_CTRLA_OFFSET 0x00
#define TCC_CTRLA_RESETVALUE _U_(0x00000000)

#define TCC_CTRLA_SWRST_Pos 0
#define TCC_CTRLA_SWRST (_U_(0x1) << TCC_CTRLA_SWRST_Pos)
#define TCC_CTRLA_ENABLE_Pos 1
#define TCC_CTRLA_ENABLE (_U_(0x1) << TCC_CTRLA_ENABLE_Pos)
#define TCC_CTRLA_RESOLUTION_Pos 5
#define TCC_CTRLA_RESOLUTION_Msk (_U_(0x3) << TCC_CTRLA_RESOLUTION_Pos)
#define TCC_CTRLA_RESOLUTION(value) (TCC_CTRLA_RESOLUTION_Msk & ((value) << TCC_CTRLA_RESOLUTION_Pos))
#define TCC_CTRLA_RESOLUTION_NONE_Val _U_(0x0)
#define TCC_CTRLA_RESOLUTION_DITH4_Val _U_(0x1)
#define TCC_CTRLA_RESOLUTION_DITH5_Val _U_(0x2)
#define TCC_CTRLA_RESOLUTION_DITH6_Val _U_(0x3)
#define TCC_CTRLA_RESOLUTION_NONE (TCC_CTRLA_RESOLUTION_NONE_Val << TCC_CTRLA_RESOLUTION_Pos)
#define TCC_CTRLA_RESOLUTION_DITH4 (TCC_CTRLA_RESOLUTION_DITH4_Val << TCC_CTRLA_RESOLUTION_Pos)
#define TCC_CTRLA_RESOLUTION_DITH5 (TCC_CTRLA_RESOLUTION_DITH5_Val << TCC_CTRLA_RESOLUTION_Pos)
#define TCC_CTRLA_RESOLUTION_DITH6 (TCC_CTRLA_RESOLUTION_DITH6_Val << TCC_CTRLA_RESOLUTION_Pos)
#define TCC_CTRLA_PRESCALER_Pos 8
#define TCC_CTRLA_PRESCALER_Msk (_U_(0x7) << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER(value) (TCC_CTRLA_PRESCALER_Msk & ((value) << TCC_CTRLA_PRESCALER_Pos))
#define TCC_CTRLA_PRESCALER_DIV1_Val _U_(0x0)
#define TCC_CTRLA_PRESCALER_DIV2_Val _U_(0x1)
#define TCC_CTRLA_PRESCALER_DIV4_Val _U_(0x2)
#define TCC_CTRLA_PRESCALER_DIV8_Val _U_(0x3)
#define TCC_CTRLA_PRESCALER_DIV16_Val _U_(0x4)
#define TCC_CTRLA_PRESCALER_DIV64_Val _U_(0x5)
#define TCC_CTRLA_PRESCALER_DIV256_Val _U_(0x6)
#define TCC_CTRLA_PRESCALER_DIV1024_Val _U_(0x7)
#define TCC_CTRLA_PRESCALER_DIV1 (TCC_CTRLA_PRESCALER_DIV1_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER_DIV2 (TCC_CTRLA_PRESCALER_DIV2_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER_DIV4 (TCC_CTRLA_PRESCALER_DIV4_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER_DIV8 (TCC_CTRLA_PRESCALER_DIV8_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER_DIV16 (TCC_CTRLA_PRESCALER_DIV16_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER_DIV64 (TCC_CTRLA_PRESCALER_DIV64_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER_DIV256 (TCC_CTRLA_PRESCALER_DIV256_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_PRESCALER_DIV1024 (TCC_CTRLA_PRESCALER_DIV1024_Val << TCC_CTRLA_PRESCALER_Pos)
#define TCC_CTRLA_RUNSTDBY_Pos 11
#define TCC_CTRLA_RUNSTDBY (_U_(0x1) << TCC_CTRLA_RUNSTDBY_Pos)
#define TCC_CTRLA_PRESCSYNC_Pos 12
#define TCC_CTRLA_PRESCSYNC_Msk (_U_(0x3) << TCC_CTRLA_PRESCSYNC_Pos)
#define TCC_CTRLA_PRESCSYNC(value) (TCC_CTRLA_PRESCSYNC_Msk & ((value) << TCC_CTRLA_PRESCSYNC_Pos))
#define TCC_CTRLA_PRESCSYNC_GCLK_Val _U_(0x0)
#define TCC_CTRLA_PRESCSYNC_PRESC_Val _U_(0x1)
#define TCC_CTRLA_PRESCSYNC_RESYNC_Val _U_(0x2)
#define TCC_CTRLA_PRESCSYNC_GCLK (TCC_CTRLA_PRESCSYNC_GCLK_Val << TCC_CTRLA_PRESCSYNC_Pos)
#define TCC_CTRLA_PRESCSYNC_PRESC (TCC_CTRLA_PRESCSYNC_PRESC_Val << TCC_CTRLA_PRESCSYNC_Pos)
#define TCC_CTRLA_PRESCSYNC_RESYNC (TCC_CTRLA_PRESCSYNC_RESYNC_Val << TCC_CTRLA_PRESCSYNC_Pos)
#define TCC_CTRLA_ALOCK_Pos 14
#define TCC_CTRLA_ALOCK (_U_(0x1) << TCC_CTRLA_ALOCK_Pos)
#define TCC_CTRLA_CPTEN0_Pos 24
#define TCC_CTRLA_CPTEN0 (_U_(1) << TCC_CTRLA_CPTEN0_Pos)
#define TCC_CTRLA_CPTEN1_Pos 25
#define TCC_CTRLA_CPTEN1 (_U_(1) << TCC_CTRLA_CPTEN1_Pos)
#define TCC_CTRLA_CPTEN2_Pos 26
#define TCC_CTRLA_CPTEN2 (_U_(1) << TCC_CTRLA_CPTEN2_Pos)
#define TCC_CTRLA_CPTEN3_Pos 27
#define TCC_CTRLA_CPTEN3 (_U_(1) << TCC_CTRLA_CPTEN3_Pos)
#define TCC_CTRLA_CPTEN_Pos 24
#define TCC_CTRLA_CPTEN_Msk (_U_(0xF) << TCC_CTRLA_CPTEN_Pos)
#define TCC_CTRLA_CPTEN(value) (TCC_CTRLA_CPTEN_Msk & ((value) << TCC_CTRLA_CPTEN_Pos))
#define TCC_CTRLA_MASK _U_(0x0F007F63)

/* -------- TCC_CTRLBCLR : (TCC Offset: 0x04) (R/W  8) Control B Clear -------- */

typedef union {
  struct {
    uint8_t DIR:1; /*!< bit:      0  Counter Direction                  */
    uint8_t LUPD:1; /*!< bit:      1  Lock Update                        */
    uint8_t ONESHOT:1; /*!< bit:      2  One-Shot                           */
    uint8_t IDXCMD:2; /*!< bit:  3.. 4  Ramp Index Command                 */
    uint8_t CMD:3; /*!< bit:  5.. 7  TCC Command                        */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TCC_CTRLBCLR_Type;


#define TCC_CTRLBCLR_OFFSET 0x04
#define TCC_CTRLBCLR_RESETVALUE _U_(0x00)

#define TCC_CTRLBCLR_DIR_Pos 0
#define TCC_CTRLBCLR_DIR (_U_(0x1) << TCC_CTRLBCLR_DIR_Pos)
#define TCC_CTRLBCLR_LUPD_Pos 1
#define TCC_CTRLBCLR_LUPD (_U_(0x1) << TCC_CTRLBCLR_LUPD_Pos)
#define TCC_CTRLBCLR_ONESHOT_Pos 2
#define TCC_CTRLBCLR_ONESHOT (_U_(0x1) << TCC_CTRLBCLR_ONESHOT_Pos)
#define TCC_CTRLBCLR_IDXCMD_Pos 3
#define TCC_CTRLBCLR_IDXCMD_Msk (_U_(0x3) << TCC_CTRLBCLR_IDXCMD_Pos)
#define TCC_CTRLBCLR_IDXCMD(value) (TCC_CTRLBCLR_IDXCMD_Msk & ((value) << TCC_CTRLBCLR_IDXCMD_Pos))
#define TCC_CTRLBCLR_IDXCMD_DISABLE_Val _U_(0x0)
#define TCC_CTRLBCLR_IDXCMD_SET_Val _U_(0x1)
#define TCC_CTRLBCLR_IDXCMD_CLEAR_Val _U_(0x2)
#define TCC_CTRLBCLR_IDXCMD_HOLD_Val _U_(0x3)
#define TCC_CTRLBCLR_IDXCMD_DISABLE (TCC_CTRLBCLR_IDXCMD_DISABLE_Val << TCC_CTRLBCLR_IDXCMD_Pos)
#define TCC_CTRLBCLR_IDXCMD_SET (TCC_CTRLBCLR_IDXCMD_SET_Val << TCC_CTRLBCLR_IDXCMD_Pos)
#define TCC_CTRLBCLR_IDXCMD_CLEAR (TCC_CTRLBCLR_IDXCMD_CLEAR_Val << TCC_CTRLBCLR_IDXCMD_Pos)
#define TCC_CTRLBCLR_IDXCMD_HOLD (TCC_CTRLBCLR_IDXCMD_HOLD_Val << TCC_CTRLBCLR_IDXCMD_Pos)
#define TCC_CTRLBCLR_CMD_Pos 5
#define TCC_CTRLBCLR_CMD_Msk (_U_(0x7) << TCC_CTRLBCLR_CMD_Pos)
#define TCC_CTRLBCLR_CMD(value) (TCC_CTRLBCLR_CMD_Msk & ((value) << TCC_CTRLBCLR_CMD_Pos))
#define TCC_CTRLBCLR_CMD_NONE_Val _U_(0x0)
#define TCC_CTRLBCLR_CMD_RETRIGGER_Val _U_(0x1)
#define TCC_CTRLBCLR_CMD_STOP_Val _U_(0x2)
#define TCC_CTRLBCLR_CMD_UPDATE_Val _U_(0x3)
#define TCC_CTRLBCLR_CMD_READSYNC_Val _U_(0x4)
#define TCC_CTRLBCLR_CMD_NONE (TCC_CTRLBCLR_CMD_NONE_Val << TCC_CTRLBCLR_CMD_Pos)
#define TCC_CTRLBCLR_CMD_RETRIGGER (TCC_CTRLBCLR_CMD_RETRIGGER_Val << TCC_CTRLBCLR_CMD_Pos)
#define TCC_CTRLBCLR_CMD_STOP (TCC_CTRLBCLR_CMD_STOP_Val << TCC_CTRLBCLR_CMD_Pos)
#define TCC_CTRLBCLR_CMD_UPDATE (TCC_CTRLBCLR_CMD_UPDATE_Val << TCC_CTRLBCLR_CMD_Pos)
#define TCC_CTRLBCLR_CMD_READSYNC (TCC_CTRLBCLR_CMD_READSYNC_Val << TCC_CTRLBCLR_CMD_Pos)
#define TCC_CTRLBCLR_MASK _U_(0xFF)

/* -------- TCC_CTRLBSET : (TCC Offset: 0x05) (R/W  8) Control B Set -------- */

typedef union {
  struct {
    uint8_t DIR:1; /*!< bit:      0  Counter Direction                  */
    uint8_t LUPD:1; /*!< bit:      1  Lock Update                        */
    uint8_t ONESHOT:1; /*!< bit:      2  One-Shot                           */
    uint8_t IDXCMD:2; /*!< bit:  3.. 4  Ramp Index Command                 */
    uint8_t CMD:3; /*!< bit:  5.. 7  TCC Command                        */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TCC_CTRLBSET_Type;


#define TCC_CTRLBSET_OFFSET 0x05
#define TCC_CTRLBSET_RESETVALUE _U_(0x00)

#define TCC_CTRLBSET_DIR_Pos 0
#define TCC_CTRLBSET_DIR (_U_(0x1) << TCC_CTRLBSET_DIR_Pos)
#define TCC_CTRLBSET_LUPD_Pos 1
#define TCC_CTRLBSET_LUPD (_U_(0x1) << TCC_CTRLBSET_LUPD_Pos)
#define TCC_CTRLBSET_ONESHOT_Pos 2
#define TCC_CTRLBSET_ONESHOT (_U_(0x1) << TCC_CTRLBSET_ONESHOT_Pos)
#define TCC_CTRLBSET_IDXCMD_Pos 3
#define TCC_CTRLBSET_IDXCMD_Msk (_U_(0x3) << TCC_CTRLBSET_IDXCMD_Pos)
#define TCC_CTRLBSET_IDXCMD(value) (TCC_CTRLBSET_IDXCMD_Msk & ((value) << TCC_CTRLBSET_IDXCMD_Pos))
#define TCC_CTRLBSET_IDXCMD_DISABLE_Val _U_(0x0)
#define TCC_CTRLBSET_IDXCMD_SET_Val _U_(0x1)
#define TCC_CTRLBSET_IDXCMD_CLEAR_Val _U_(0x2)
#define TCC_CTRLBSET_IDXCMD_HOLD_Val _U_(0x3)
#define TCC_CTRLBSET_IDXCMD_DISABLE (TCC_CTRLBSET_IDXCMD_DISABLE_Val << TCC_CTRLBSET_IDXCMD_Pos)
#define TCC_CTRLBSET_IDXCMD_SET (TCC_CTRLBSET_IDXCMD_SET_Val << TCC_CTRLBSET_IDXCMD_Pos)
#define TCC_CTRLBSET_IDXCMD_CLEAR (TCC_CTRLBSET_IDXCMD_CLEAR_Val << TCC_CTRLBSET_IDXCMD_Pos)
#define TCC_CTRLBSET_IDXCMD_HOLD (TCC_CTRLBSET_IDXCMD_HOLD_Val << TCC_CTRLBSET_IDXCMD_Pos)
#define TCC_CTRLBSET_CMD_Pos 5
#define TCC_CTRLBSET_CMD_Msk (_U_(0x7) << TCC_CTRLBSET_CMD_Pos)
#define TCC_CTRLBSET_CMD(value) (TCC_CTRLBSET_CMD_Msk & ((value) << TCC_CTRLBSET_CMD_Pos))
#define TCC_CTRLBSET_CMD_NONE_Val _U_(0x0)
#define TCC_CTRLBSET_CMD_RETRIGGER_Val _U_(0x1)
#define TCC_CTRLBSET_CMD_STOP_Val _U_(0x2)
#define TCC_CTRLBSET_CMD_UPDATE_Val _U_(0x3)
#define TCC_CTRLBSET_CMD_READSYNC_Val _U_(0x4)
#define TCC_CTRLBSET_CMD_NONE (TCC_CTRLBSET_CMD_NONE_Val << TCC_CTRLBSET_CMD_Pos)
#define TCC_CTRLBSET_CMD_RETRIGGER (TCC_CTRLBSET_CMD_RETRIGGER_Val << TCC_CTRLBSET_CMD_Pos)
#define TCC_CTRLBSET_CMD_STOP (TCC_CTRLBSET_CMD_STOP_Val << TCC_CTRLBSET_CMD_Pos)
#define TCC_CTRLBSET_CMD_UPDATE (TCC_CTRLBSET_CMD_UPDATE_Val << TCC_CTRLBSET_CMD_Pos)
#define TCC_CTRLBSET_CMD_READSYNC (TCC_CTRLBSET_CMD_READSYNC_Val << TCC_CTRLBSET_CMD_Pos)
#define TCC_CTRLBSET_MASK _U_(0xFF)

/* -------- TCC_SYNCBUSY : (TCC Offset: 0x08) (R/  32) Synchronization Busy -------- */

typedef union {
  struct {
    uint32_t SWRST:1; /*!< bit:      0  Swrst Busy                         */
    uint32_t ENABLE:1; /*!< bit:      1  Enable Busy                        */
    uint32_t CTRLB:1; /*!< bit:      2  Ctrlb Busy                         */
    uint32_t STATUS:1; /*!< bit:      3  Status Busy                        */
    uint32_t COUNT:1; /*!< bit:      4  Count Busy                         */
    uint32_t PATT:1; /*!< bit:      5  Pattern Busy                       */
    uint32_t WAVE:1; /*!< bit:      6  Wave Busy                          */
    uint32_t PER:1; /*!< bit:      7  Period busy                        */
    uint32_t CC0:1; /*!< bit:      8  Compare Channel 0 Busy             */
    uint32_t CC1:1; /*!< bit:      9  Compare Channel 1 Busy             */
    uint32_t CC2:1; /*!< bit:     10  Compare Channel 2 Busy             */
    uint32_t CC3:1; /*!< bit:     11  Compare Channel 3 Busy             */
    uint32_t :4; /*!< bit: 12..15  Reserved                           */
    uint32_t PATTB:1; /*!< bit:     16  Pattern Buffer Busy                */
    uint32_t WAVEB:1; /*!< bit:     17  Wave Buffer Busy                   */
    uint32_t PERB:1; /*!< bit:     18  Period Buffer Busy                 */
    uint32_t CCB0:1; /*!< bit:     19  Compare Channel Buffer 0 Busy      */
    uint32_t CCB1:1; /*!< bit:     20  Compare Channel Buffer 1 Busy      */
    uint32_t CCB2:1; /*!< bit:     21  Compare Channel Buffer 2 Busy      */
    uint32_t CCB3:1; /*!< bit:     22  Compare Channel Buffer 3 Busy      */
    uint32_t :9; /*!< bit: 23..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :8; /*!< bit:  0.. 7  Reserved                           */
    uint32_t CC:4; /*!< bit:  8..11  Compare Channel x Busy             */
    uint32_t :7; /*!< bit: 12..18  Reserved                           */
    uint32_t CCB:4; /*!< bit: 19..22  Compare Channel Buffer x Busy      */
    uint32_t :9; /*!< bit: 23..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_SYNCBUSY_Type;


#define TCC_SYNCBUSY_OFFSET 0x08
#define TCC_SYNCBUSY_RESETVALUE _U_(0x00000000)

#define TCC_SYNCBUSY_SWRST_Pos 0
#define TCC_SYNCBUSY_SWRST (_U_(0x1) << TCC_SYNCBUSY_SWRST_Pos)
#define TCC_SYNCBUSY_ENABLE_Pos 1
#define TCC_SYNCBUSY_ENABLE (_U_(0x1) << TCC_SYNCBUSY_ENABLE_Pos)
#define TCC_SYNCBUSY_CTRLB_Pos 2
#define TCC_SYNCBUSY_CTRLB (_U_(0x1) << TCC_SYNCBUSY_CTRLB_Pos)
#define TCC_SYNCBUSY_STATUS_Pos 3
#define TCC_SYNCBUSY_STATUS (_U_(0x1) << TCC_SYNCBUSY_STATUS_Pos)
#define TCC_SYNCBUSY_COUNT_Pos 4
#define TCC_SYNCBUSY_COUNT (_U_(0x1) << TCC_SYNCBUSY_COUNT_Pos)
#define TCC_SYNCBUSY_PATT_Pos 5
#define TCC_SYNCBUSY_PATT (_U_(0x1) << TCC_SYNCBUSY_PATT_Pos)
#define TCC_SYNCBUSY_WAVE_Pos 6
#define TCC_SYNCBUSY_WAVE (_U_(0x1) << TCC_SYNCBUSY_WAVE_Pos)
#define TCC_SYNCBUSY_PER_Pos 7
#define TCC_SYNCBUSY_PER (_U_(0x1) << TCC_SYNCBUSY_PER_Pos)
#define TCC_SYNCBUSY_CC0_Pos 8
#define TCC_SYNCBUSY_CC0 (_U_(1) << TCC_SYNCBUSY_CC0_Pos)
#define TCC_SYNCBUSY_CC1_Pos 9
#define TCC_SYNCBUSY_CC1 (_U_(1) << TCC_SYNCBUSY_CC1_Pos)
#define TCC_SYNCBUSY_CC2_Pos 10
#define TCC_SYNCBUSY_CC2 (_U_(1) << TCC_SYNCBUSY_CC2_Pos)
#define TCC_SYNCBUSY_CC3_Pos 11
#define TCC_SYNCBUSY_CC3 (_U_(1) << TCC_SYNCBUSY_CC3_Pos)
#define TCC_SYNCBUSY_CC_Pos 8
#define TCC_SYNCBUSY_CC_Msk (_U_(0xF) << TCC_SYNCBUSY_CC_Pos)
#define TCC_SYNCBUSY_CC(value) (TCC_SYNCBUSY_CC_Msk & ((value) << TCC_SYNCBUSY_CC_Pos))
#define TCC_SYNCBUSY_PATTB_Pos 16
#define TCC_SYNCBUSY_PATTB (_U_(0x1) << TCC_SYNCBUSY_PATTB_Pos)
#define TCC_SYNCBUSY_WAVEB_Pos 17
#define TCC_SYNCBUSY_WAVEB (_U_(0x1) << TCC_SYNCBUSY_WAVEB_Pos)
#define TCC_SYNCBUSY_PERB_Pos 18
#define TCC_SYNCBUSY_PERB (_U_(0x1) << TCC_SYNCBUSY_PERB_Pos)
#define TCC_SYNCBUSY_CCB0_Pos 19
#define TCC_SYNCBUSY_CCB0 (_U_(1) << TCC_SYNCBUSY_CCB0_Pos)
#define TCC_SYNCBUSY_CCB1_Pos 20
#define TCC_SYNCBUSY_CCB1 (_U_(1) << TCC_SYNCBUSY_CCB1_Pos)
#define TCC_SYNCBUSY_CCB2_Pos 21
#define TCC_SYNCBUSY_CCB2 (_U_(1) << TCC_SYNCBUSY_CCB2_Pos)
#define TCC_SYNCBUSY_CCB3_Pos 22
#define TCC_SYNCBUSY_CCB3 (_U_(1) << TCC_SYNCBUSY_CCB3_Pos)
#define TCC_SYNCBUSY_CCB_Pos 19
#define TCC_SYNCBUSY_CCB_Msk (_U_(0xF) << TCC_SYNCBUSY_CCB_Pos)
#define TCC_SYNCBUSY_CCB(value) (TCC_SYNCBUSY_CCB_Msk & ((value) << TCC_SYNCBUSY_CCB_Pos))
#define TCC_SYNCBUSY_MASK _U_(0x007F0FFF)

/* -------- TCC_FCTRLA : (TCC Offset: 0x0C) (R/W 32) Recoverable Fault A Configuration -------- */

typedef union {
  struct {
    uint32_t SRC:2; /*!< bit:  0.. 1  Fault A Source                     */
    uint32_t :1; /*!< bit:      2  Reserved                           */
    uint32_t KEEP:1; /*!< bit:      3  Fault A Keeper                     */
    uint32_t QUAL:1; /*!< bit:      4  Fault A Qualification              */
    uint32_t BLANK:2; /*!< bit:  5.. 6  Fault A Blanking Mode              */
    uint32_t RESTART:1; /*!< bit:      7  Fault A Restart                    */
    uint32_t HALT:2; /*!< bit:  8.. 9  Fault A Halt Mode                  */
    uint32_t CHSEL:2; /*!< bit: 10..11  Fault A Capture Channel            */
    uint32_t CAPTURE:3; /*!< bit: 12..14  Fault A Capture Action             */
    uint32_t :1; /*!< bit:     15  Reserved                           */
    uint32_t BLANKVAL:8; /*!< bit: 16..23  Fault A Blanking Time              */
    uint32_t FILTERVAL:4; /*!< bit: 24..27  Fault A Filter Value               */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_FCTRLA_Type;


#define TCC_FCTRLA_OFFSET 0x0C
#define TCC_FCTRLA_RESETVALUE _U_(0x00000000)

#define TCC_FCTRLA_SRC_Pos 0
#define TCC_FCTRLA_SRC_Msk (_U_(0x3) << TCC_FCTRLA_SRC_Pos)
#define TCC_FCTRLA_SRC(value) (TCC_FCTRLA_SRC_Msk & ((value) << TCC_FCTRLA_SRC_Pos))
#define TCC_FCTRLA_SRC_DISABLE_Val _U_(0x0)
#define TCC_FCTRLA_SRC_ENABLE_Val _U_(0x1)
#define TCC_FCTRLA_SRC_INVERT_Val _U_(0x2)
#define TCC_FCTRLA_SRC_ALTFAULT_Val _U_(0x3)
#define TCC_FCTRLA_SRC_DISABLE (TCC_FCTRLA_SRC_DISABLE_Val << TCC_FCTRLA_SRC_Pos)
#define TCC_FCTRLA_SRC_ENABLE (TCC_FCTRLA_SRC_ENABLE_Val << TCC_FCTRLA_SRC_Pos)
#define TCC_FCTRLA_SRC_INVERT (TCC_FCTRLA_SRC_INVERT_Val << TCC_FCTRLA_SRC_Pos)
#define TCC_FCTRLA_SRC_ALTFAULT (TCC_FCTRLA_SRC_ALTFAULT_Val << TCC_FCTRLA_SRC_Pos)
#define TCC_FCTRLA_KEEP_Pos 3
#define TCC_FCTRLA_KEEP (_U_(0x1) << TCC_FCTRLA_KEEP_Pos)
#define TCC_FCTRLA_QUAL_Pos 4
#define TCC_FCTRLA_QUAL (_U_(0x1) << TCC_FCTRLA_QUAL_Pos)
#define TCC_FCTRLA_BLANK_Pos 5
#define TCC_FCTRLA_BLANK_Msk (_U_(0x3) << TCC_FCTRLA_BLANK_Pos)
#define TCC_FCTRLA_BLANK(value) (TCC_FCTRLA_BLANK_Msk & ((value) << TCC_FCTRLA_BLANK_Pos))
#define TCC_FCTRLA_BLANK_NONE_Val _U_(0x0)
#define TCC_FCTRLA_BLANK_RISE_Val _U_(0x1)
#define TCC_FCTRLA_BLANK_FALL_Val _U_(0x2)
#define TCC_FCTRLA_BLANK_BOTH_Val _U_(0x3)
#define TCC_FCTRLA_BLANK_NONE (TCC_FCTRLA_BLANK_NONE_Val << TCC_FCTRLA_BLANK_Pos)
#define TCC_FCTRLA_BLANK_RISE (TCC_FCTRLA_BLANK_RISE_Val << TCC_FCTRLA_BLANK_Pos)
#define TCC_FCTRLA_BLANK_FALL (TCC_FCTRLA_BLANK_FALL_Val << TCC_FCTRLA_BLANK_Pos)
#define TCC_FCTRLA_BLANK_BOTH (TCC_FCTRLA_BLANK_BOTH_Val << TCC_FCTRLA_BLANK_Pos)
#define TCC_FCTRLA_RESTART_Pos 7
#define TCC_FCTRLA_RESTART (_U_(0x1) << TCC_FCTRLA_RESTART_Pos)
#define TCC_FCTRLA_HALT_Pos 8
#define TCC_FCTRLA_HALT_Msk (_U_(0x3) << TCC_FCTRLA_HALT_Pos)
#define TCC_FCTRLA_HALT(value) (TCC_FCTRLA_HALT_Msk & ((value) << TCC_FCTRLA_HALT_Pos))
#define TCC_FCTRLA_HALT_DISABLE_Val _U_(0x0)
#define TCC_FCTRLA_HALT_HW_Val _U_(0x1)
#define TCC_FCTRLA_HALT_SW_Val _U_(0x2)
#define TCC_FCTRLA_HALT_NR_Val _U_(0x3)
#define TCC_FCTRLA_HALT_DISABLE (TCC_FCTRLA_HALT_DISABLE_Val << TCC_FCTRLA_HALT_Pos)
#define TCC_FCTRLA_HALT_HW (TCC_FCTRLA_HALT_HW_Val << TCC_FCTRLA_HALT_Pos)
#define TCC_FCTRLA_HALT_SW (TCC_FCTRLA_HALT_SW_Val << TCC_FCTRLA_HALT_Pos)
#define TCC_FCTRLA_HALT_NR (TCC_FCTRLA_HALT_NR_Val << TCC_FCTRLA_HALT_Pos)
#define TCC_FCTRLA_CHSEL_Pos 10
#define TCC_FCTRLA_CHSEL_Msk (_U_(0x3) << TCC_FCTRLA_CHSEL_Pos)
#define TCC_FCTRLA_CHSEL(value) (TCC_FCTRLA_CHSEL_Msk & ((value) << TCC_FCTRLA_CHSEL_Pos))
#define TCC_FCTRLA_CHSEL_CC0_Val _U_(0x0)
#define TCC_FCTRLA_CHSEL_CC1_Val _U_(0x1)
#define TCC_FCTRLA_CHSEL_CC2_Val _U_(0x2)
#define TCC_FCTRLA_CHSEL_CC3_Val _U_(0x3)
#define TCC_FCTRLA_CHSEL_CC0 (TCC_FCTRLA_CHSEL_CC0_Val << TCC_FCTRLA_CHSEL_Pos)
#define TCC_FCTRLA_CHSEL_CC1 (TCC_FCTRLA_CHSEL_CC1_Val << TCC_FCTRLA_CHSEL_Pos)
#define TCC_FCTRLA_CHSEL_CC2 (TCC_FCTRLA_CHSEL_CC2_Val << TCC_FCTRLA_CHSEL_Pos)
#define TCC_FCTRLA_CHSEL_CC3 (TCC_FCTRLA_CHSEL_CC3_Val << TCC_FCTRLA_CHSEL_Pos)
#define TCC_FCTRLA_CAPTURE_Pos 12
#define TCC_FCTRLA_CAPTURE_Msk (_U_(0x7) << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_CAPTURE(value) (TCC_FCTRLA_CAPTURE_Msk & ((value) << TCC_FCTRLA_CAPTURE_Pos))
#define TCC_FCTRLA_CAPTURE_DISABLE_Val _U_(0x0)
#define TCC_FCTRLA_CAPTURE_CAPT_Val _U_(0x1)
#define TCC_FCTRLA_CAPTURE_CAPTMIN_Val _U_(0x2)
#define TCC_FCTRLA_CAPTURE_CAPTMAX_Val _U_(0x3)
#define TCC_FCTRLA_CAPTURE_LOCMIN_Val _U_(0x4)
#define TCC_FCTRLA_CAPTURE_LOCMAX_Val _U_(0x5)
#define TCC_FCTRLA_CAPTURE_DERIV0_Val _U_(0x6)
#define TCC_FCTRLA_CAPTURE_DISABLE (TCC_FCTRLA_CAPTURE_DISABLE_Val << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_CAPTURE_CAPT (TCC_FCTRLA_CAPTURE_CAPT_Val << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_CAPTURE_CAPTMIN (TCC_FCTRLA_CAPTURE_CAPTMIN_Val << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_CAPTURE_CAPTMAX (TCC_FCTRLA_CAPTURE_CAPTMAX_Val << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_CAPTURE_LOCMIN (TCC_FCTRLA_CAPTURE_LOCMIN_Val << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_CAPTURE_LOCMAX (TCC_FCTRLA_CAPTURE_LOCMAX_Val << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_CAPTURE_DERIV0 (TCC_FCTRLA_CAPTURE_DERIV0_Val << TCC_FCTRLA_CAPTURE_Pos)
#define TCC_FCTRLA_BLANKVAL_Pos 16
#define TCC_FCTRLA_BLANKVAL_Msk (_U_(0xFF) << TCC_FCTRLA_BLANKVAL_Pos)
#define TCC_FCTRLA_BLANKVAL(value) (TCC_FCTRLA_BLANKVAL_Msk & ((value) << TCC_FCTRLA_BLANKVAL_Pos))
#define TCC_FCTRLA_FILTERVAL_Pos 24
#define TCC_FCTRLA_FILTERVAL_Msk (_U_(0xF) << TCC_FCTRLA_FILTERVAL_Pos)
#define TCC_FCTRLA_FILTERVAL(value) (TCC_FCTRLA_FILTERVAL_Msk & ((value) << TCC_FCTRLA_FILTERVAL_Pos))
#define TCC_FCTRLA_MASK _U_(0x0FFF7FFB)

/* -------- TCC_FCTRLB : (TCC Offset: 0x10) (R/W 32) Recoverable Fault B Configuration -------- */

typedef union {
  struct {
    uint32_t SRC:2; /*!< bit:  0.. 1  Fault B Source                     */
    uint32_t :1; /*!< bit:      2  Reserved                           */
    uint32_t KEEP:1; /*!< bit:      3  Fault B Keeper                     */
    uint32_t QUAL:1; /*!< bit:      4  Fault B Qualification              */
    uint32_t BLANK:2; /*!< bit:  5.. 6  Fault B Blanking Mode              */
    uint32_t RESTART:1; /*!< bit:      7  Fault B Restart                    */
    uint32_t HALT:2; /*!< bit:  8.. 9  Fault B Halt Mode                  */
    uint32_t CHSEL:2; /*!< bit: 10..11  Fault B Capture Channel            */
    uint32_t CAPTURE:3; /*!< bit: 12..14  Fault B Capture Action             */
    uint32_t :1; /*!< bit:     15  Reserved                           */
    uint32_t BLANKVAL:8; /*!< bit: 16..23  Fault B Blanking Time              */
    uint32_t FILTERVAL:4; /*!< bit: 24..27  Fault B Filter Value               */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_FCTRLB_Type;


#define TCC_FCTRLB_OFFSET 0x10
#define TCC_FCTRLB_RESETVALUE _U_(0x00000000)

#define TCC_FCTRLB_SRC_Pos 0
#define TCC_FCTRLB_SRC_Msk (_U_(0x3) << TCC_FCTRLB_SRC_Pos)
#define TCC_FCTRLB_SRC(value) (TCC_FCTRLB_SRC_Msk & ((value) << TCC_FCTRLB_SRC_Pos))
#define TCC_FCTRLB_SRC_DISABLE_Val _U_(0x0)
#define TCC_FCTRLB_SRC_ENABLE_Val _U_(0x1)
#define TCC_FCTRLB_SRC_INVERT_Val _U_(0x2)
#define TCC_FCTRLB_SRC_ALTFAULT_Val _U_(0x3)
#define TCC_FCTRLB_SRC_DISABLE (TCC_FCTRLB_SRC_DISABLE_Val << TCC_FCTRLB_SRC_Pos)
#define TCC_FCTRLB_SRC_ENABLE (TCC_FCTRLB_SRC_ENABLE_Val << TCC_FCTRLB_SRC_Pos)
#define TCC_FCTRLB_SRC_INVERT (TCC_FCTRLB_SRC_INVERT_Val << TCC_FCTRLB_SRC_Pos)
#define TCC_FCTRLB_SRC_ALTFAULT (TCC_FCTRLB_SRC_ALTFAULT_Val << TCC_FCTRLB_SRC_Pos)
#define TCC_FCTRLB_KEEP_Pos 3
#define TCC_FCTRLB_KEEP (_U_(0x1) << TCC_FCTRLB_KEEP_Pos)
#define TCC_FCTRLB_QUAL_Pos 4
#define TCC_FCTRLB_QUAL (_U_(0x1) << TCC_FCTRLB_QUAL_Pos)
#define TCC_FCTRLB_BLANK_Pos 5
#define TCC_FCTRLB_BLANK_Msk (_U_(0x3) << TCC_FCTRLB_BLANK_Pos)
#define TCC_FCTRLB_BLANK(value) (TCC_FCTRLB_BLANK_Msk & ((value) << TCC_FCTRLB_BLANK_Pos))
#define TCC_FCTRLB_BLANK_NONE_Val _U_(0x0)
#define TCC_FCTRLB_BLANK_RISE_Val _U_(0x1)
#define TCC_FCTRLB_BLANK_FALL_Val _U_(0x2)
#define TCC_FCTRLB_BLANK_BOTH_Val _U_(0x3)
#define TCC_FCTRLB_BLANK_NONE (TCC_FCTRLB_BLANK_NONE_Val << TCC_FCTRLB_BLANK_Pos)
#define TCC_FCTRLB_BLANK_RISE (TCC_FCTRLB_BLANK_RISE_Val << TCC_FCTRLB_BLANK_Pos)
#define TCC_FCTRLB_BLANK_FALL (TCC_FCTRLB_BLANK_FALL_Val << TCC_FCTRLB_BLANK_Pos)
#define TCC_FCTRLB_BLANK_BOTH (TCC_FCTRLB_BLANK_BOTH_Val << TCC_FCTRLB_BLANK_Pos)
#define TCC_FCTRLB_RESTART_Pos 7
#define TCC_FCTRLB_RESTART (_U_(0x1) << TCC_FCTRLB_RESTART_Pos)
#define TCC_FCTRLB_HALT_Pos 8
#define TCC_FCTRLB_HALT_Msk (_U_(0x3) << TCC_FCTRLB_HALT_Pos)
#define TCC_FCTRLB_HALT(value) (TCC_FCTRLB_HALT_Msk & ((value) << TCC_FCTRLB_HALT_Pos))
#define TCC_FCTRLB_HALT_DISABLE_Val _U_(0x0)
#define TCC_FCTRLB_HALT_HW_Val _U_(0x1)
#define TCC_FCTRLB_HALT_SW_Val _U_(0x2)
#define TCC_FCTRLB_HALT_NR_Val _U_(0x3)
#define TCC_FCTRLB_HALT_DISABLE (TCC_FCTRLB_HALT_DISABLE_Val << TCC_FCTRLB_HALT_Pos)
#define TCC_FCTRLB_HALT_HW (TCC_FCTRLB_HALT_HW_Val << TCC_FCTRLB_HALT_Pos)
#define TCC_FCTRLB_HALT_SW (TCC_FCTRLB_HALT_SW_Val << TCC_FCTRLB_HALT_Pos)
#define TCC_FCTRLB_HALT_NR (TCC_FCTRLB_HALT_NR_Val << TCC_FCTRLB_HALT_Pos)
#define TCC_FCTRLB_CHSEL_Pos 10
#define TCC_FCTRLB_CHSEL_Msk (_U_(0x3) << TCC_FCTRLB_CHSEL_Pos)
#define TCC_FCTRLB_CHSEL(value) (TCC_FCTRLB_CHSEL_Msk & ((value) << TCC_FCTRLB_CHSEL_Pos))
#define TCC_FCTRLB_CHSEL_CC0_Val _U_(0x0)
#define TCC_FCTRLB_CHSEL_CC1_Val _U_(0x1)
#define TCC_FCTRLB_CHSEL_CC2_Val _U_(0x2)
#define TCC_FCTRLB_CHSEL_CC3_Val _U_(0x3)
#define TCC_FCTRLB_CHSEL_CC0 (TCC_FCTRLB_CHSEL_CC0_Val << TCC_FCTRLB_CHSEL_Pos)
#define TCC_FCTRLB_CHSEL_CC1 (TCC_FCTRLB_CHSEL_CC1_Val << TCC_FCTRLB_CHSEL_Pos)
#define TCC_FCTRLB_CHSEL_CC2 (TCC_FCTRLB_CHSEL_CC2_Val << TCC_FCTRLB_CHSEL_Pos)
#define TCC_FCTRLB_CHSEL_CC3 (TCC_FCTRLB_CHSEL_CC3_Val << TCC_FCTRLB_CHSEL_Pos)
#define TCC_FCTRLB_CAPTURE_Pos 12
#define TCC_FCTRLB_CAPTURE_Msk (_U_(0x7) << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_CAPTURE(value) (TCC_FCTRLB_CAPTURE_Msk & ((value) << TCC_FCTRLB_CAPTURE_Pos))
#define TCC_FCTRLB_CAPTURE_DISABLE_Val _U_(0x0)
#define TCC_FCTRLB_CAPTURE_CAPT_Val _U_(0x1)
#define TCC_FCTRLB_CAPTURE_CAPTMIN_Val _U_(0x2)
#define TCC_FCTRLB_CAPTURE_CAPTMAX_Val _U_(0x3)
#define TCC_FCTRLB_CAPTURE_LOCMIN_Val _U_(0x4)
#define TCC_FCTRLB_CAPTURE_LOCMAX_Val _U_(0x5)
#define TCC_FCTRLB_CAPTURE_DERIV0_Val _U_(0x6)
#define TCC_FCTRLB_CAPTURE_DISABLE (TCC_FCTRLB_CAPTURE_DISABLE_Val << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_CAPTURE_CAPT (TCC_FCTRLB_CAPTURE_CAPT_Val << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_CAPTURE_CAPTMIN (TCC_FCTRLB_CAPTURE_CAPTMIN_Val << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_CAPTURE_CAPTMAX (TCC_FCTRLB_CAPTURE_CAPTMAX_Val << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_CAPTURE_LOCMIN (TCC_FCTRLB_CAPTURE_LOCMIN_Val << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_CAPTURE_LOCMAX (TCC_FCTRLB_CAPTURE_LOCMAX_Val << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_CAPTURE_DERIV0 (TCC_FCTRLB_CAPTURE_DERIV0_Val << TCC_FCTRLB_CAPTURE_Pos)
#define TCC_FCTRLB_BLANKVAL_Pos 16
#define TCC_FCTRLB_BLANKVAL_Msk (_U_(0xFF) << TCC_FCTRLB_BLANKVAL_Pos)
#define TCC_FCTRLB_BLANKVAL(value) (TCC_FCTRLB_BLANKVAL_Msk & ((value) << TCC_FCTRLB_BLANKVAL_Pos))
#define TCC_FCTRLB_FILTERVAL_Pos 24
#define TCC_FCTRLB_FILTERVAL_Msk (_U_(0xF) << TCC_FCTRLB_FILTERVAL_Pos)
#define TCC_FCTRLB_FILTERVAL(value) (TCC_FCTRLB_FILTERVAL_Msk & ((value) << TCC_FCTRLB_FILTERVAL_Pos))
#define TCC_FCTRLB_MASK _U_(0x0FFF7FFB)

/* -------- TCC_WEXCTRL : (TCC Offset: 0x14) (R/W 32) Waveform Extension Configuration -------- */

typedef union {
  struct {
    uint32_t OTMX:2; /*!< bit:  0.. 1  Output Matrix                      */
    uint32_t :6; /*!< bit:  2.. 7  Reserved                           */
    uint32_t DTIEN0:1; /*!< bit:      8  Dead-time Insertion Generator 0 Enable */
    uint32_t DTIEN1:1; /*!< bit:      9  Dead-time Insertion Generator 1 Enable */
    uint32_t DTIEN2:1; /*!< bit:     10  Dead-time Insertion Generator 2 Enable */
    uint32_t DTIEN3:1; /*!< bit:     11  Dead-time Insertion Generator 3 Enable */
    uint32_t :4; /*!< bit: 12..15  Reserved                           */
    uint32_t DTLS:8; /*!< bit: 16..23  Dead-time Low Side Outputs Value   */
    uint32_t DTHS:8; /*!< bit: 24..31  Dead-time High Side Outputs Value  */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :8; /*!< bit:  0.. 7  Reserved                           */
    uint32_t DTIEN:4; /*!< bit:  8..11  Dead-time Insertion Generator x Enable */
    uint32_t :20; /*!< bit: 12..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_WEXCTRL_Type;


#define TCC_WEXCTRL_OFFSET 0x14
#define TCC_WEXCTRL_RESETVALUE _U_(0x00000000)

#define TCC_WEXCTRL_OTMX_Pos 0
#define TCC_WEXCTRL_OTMX_Msk (_U_(0x3) << TCC_WEXCTRL_OTMX_Pos)
#define TCC_WEXCTRL_OTMX(value) (TCC_WEXCTRL_OTMX_Msk & ((value) << TCC_WEXCTRL_OTMX_Pos))
#define TCC_WEXCTRL_DTIEN0_Pos 8
#define TCC_WEXCTRL_DTIEN0 (_U_(1) << TCC_WEXCTRL_DTIEN0_Pos)
#define TCC_WEXCTRL_DTIEN1_Pos 9
#define TCC_WEXCTRL_DTIEN1 (_U_(1) << TCC_WEXCTRL_DTIEN1_Pos)
#define TCC_WEXCTRL_DTIEN2_Pos 10
#define TCC_WEXCTRL_DTIEN2 (_U_(1) << TCC_WEXCTRL_DTIEN2_Pos)
#define TCC_WEXCTRL_DTIEN3_Pos 11
#define TCC_WEXCTRL_DTIEN3 (_U_(1) << TCC_WEXCTRL_DTIEN3_Pos)
#define TCC_WEXCTRL_DTIEN_Pos 8
#define TCC_WEXCTRL_DTIEN_Msk (_U_(0xF) << TCC_WEXCTRL_DTIEN_Pos)
#define TCC_WEXCTRL_DTIEN(value) (TCC_WEXCTRL_DTIEN_Msk & ((value) << TCC_WEXCTRL_DTIEN_Pos))
#define TCC_WEXCTRL_DTLS_Pos 16
#define TCC_WEXCTRL_DTLS_Msk (_U_(0xFF) << TCC_WEXCTRL_DTLS_Pos)
#define TCC_WEXCTRL_DTLS(value) (TCC_WEXCTRL_DTLS_Msk & ((value) << TCC_WEXCTRL_DTLS_Pos))
#define TCC_WEXCTRL_DTHS_Pos 24
#define TCC_WEXCTRL_DTHS_Msk (_U_(0xFF) << TCC_WEXCTRL_DTHS_Pos)
#define TCC_WEXCTRL_DTHS(value) (TCC_WEXCTRL_DTHS_Msk & ((value) << TCC_WEXCTRL_DTHS_Pos))
#define TCC_WEXCTRL_MASK _U_(0xFFFF0F03)

/* -------- TCC_DRVCTRL : (TCC Offset: 0x18) (R/W 32) Driver Control -------- */

typedef union {
  struct {
    uint32_t NRE0:1; /*!< bit:      0  Non-Recoverable State 0 Output Enable */
    uint32_t NRE1:1; /*!< bit:      1  Non-Recoverable State 1 Output Enable */
    uint32_t NRE2:1; /*!< bit:      2  Non-Recoverable State 2 Output Enable */
    uint32_t NRE3:1; /*!< bit:      3  Non-Recoverable State 3 Output Enable */
    uint32_t NRE4:1; /*!< bit:      4  Non-Recoverable State 4 Output Enable */
    uint32_t NRE5:1; /*!< bit:      5  Non-Recoverable State 5 Output Enable */
    uint32_t NRE6:1; /*!< bit:      6  Non-Recoverable State 6 Output Enable */
    uint32_t NRE7:1; /*!< bit:      7  Non-Recoverable State 7 Output Enable */
    uint32_t NRV0:1; /*!< bit:      8  Non-Recoverable State 0 Output Value */
    uint32_t NRV1:1; /*!< bit:      9  Non-Recoverable State 1 Output Value */
    uint32_t NRV2:1; /*!< bit:     10  Non-Recoverable State 2 Output Value */
    uint32_t NRV3:1; /*!< bit:     11  Non-Recoverable State 3 Output Value */
    uint32_t NRV4:1; /*!< bit:     12  Non-Recoverable State 4 Output Value */
    uint32_t NRV5:1; /*!< bit:     13  Non-Recoverable State 5 Output Value */
    uint32_t NRV6:1; /*!< bit:     14  Non-Recoverable State 6 Output Value */
    uint32_t NRV7:1; /*!< bit:     15  Non-Recoverable State 7 Output Value */
    uint32_t INVEN0:1; /*!< bit:     16  Output Waveform 0 Inversion        */
    uint32_t INVEN1:1; /*!< bit:     17  Output Waveform 1 Inversion        */
    uint32_t INVEN2:1; /*!< bit:     18  Output Waveform 2 Inversion        */
    uint32_t INVEN3:1; /*!< bit:     19  Output Waveform 3 Inversion        */
    uint32_t INVEN4:1; /*!< bit:     20  Output Waveform 4 Inversion        */
    uint32_t INVEN5:1; /*!< bit:     21  Output Waveform 5 Inversion        */
    uint32_t INVEN6:1; /*!< bit:     22  Output Waveform 6 Inversion        */
    uint32_t INVEN7:1; /*!< bit:     23  Output Waveform 7 Inversion        */
    uint32_t FILTERVAL0:4; /*!< bit: 24..27  Non-Recoverable Fault Input 0 Filter Value */
    uint32_t FILTERVAL1:4; /*!< bit: 28..31  Non-Recoverable Fault Input 1 Filter Value */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t NRE:8; /*!< bit:  0.. 7  Non-Recoverable State x Output Enable */
    uint32_t NRV:8; /*!< bit:  8..15  Non-Recoverable State x Output Value */
    uint32_t INVEN:8; /*!< bit: 16..23  Output Waveform x Inversion        */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_DRVCTRL_Type;


#define TCC_DRVCTRL_OFFSET 0x18
#define TCC_DRVCTRL_RESETVALUE _U_(0x00000000)

#define TCC_DRVCTRL_NRE0_Pos 0
#define TCC_DRVCTRL_NRE0 (_U_(1) << TCC_DRVCTRL_NRE0_Pos)
#define TCC_DRVCTRL_NRE1_Pos 1
#define TCC_DRVCTRL_NRE1 (_U_(1) << TCC_DRVCTRL_NRE1_Pos)
#define TCC_DRVCTRL_NRE2_Pos 2
#define TCC_DRVCTRL_NRE2 (_U_(1) << TCC_DRVCTRL_NRE2_Pos)
#define TCC_DRVCTRL_NRE3_Pos 3
#define TCC_DRVCTRL_NRE3 (_U_(1) << TCC_DRVCTRL_NRE3_Pos)
#define TCC_DRVCTRL_NRE4_Pos 4
#define TCC_DRVCTRL_NRE4 (_U_(1) << TCC_DRVCTRL_NRE4_Pos)
#define TCC_DRVCTRL_NRE5_Pos 5
#define TCC_DRVCTRL_NRE5 (_U_(1) << TCC_DRVCTRL_NRE5_Pos)
#define TCC_DRVCTRL_NRE6_Pos 6
#define TCC_DRVCTRL_NRE6 (_U_(1) << TCC_DRVCTRL_NRE6_Pos)
#define TCC_DRVCTRL_NRE7_Pos 7
#define TCC_DRVCTRL_NRE7 (_U_(1) << TCC_DRVCTRL_NRE7_Pos)
#define TCC_DRVCTRL_NRE_Pos 0
#define TCC_DRVCTRL_NRE_Msk (_U_(0xFF) << TCC_DRVCTRL_NRE_Pos)
#define TCC_DRVCTRL_NRE(value) (TCC_DRVCTRL_NRE_Msk & ((value) << TCC_DRVCTRL_NRE_Pos))
#define TCC_DRVCTRL_NRV0_Pos 8
#define TCC_DRVCTRL_NRV0 (_U_(1) << TCC_DRVCTRL_NRV0_Pos)
#define TCC_DRVCTRL_NRV1_Pos 9
#define TCC_DRVCTRL_NRV1 (_U_(1) << TCC_DRVCTRL_NRV1_Pos)
#define TCC_DRVCTRL_NRV2_Pos 10
#define TCC_DRVCTRL_NRV2 (_U_(1) << TCC_DRVCTRL_NRV2_Pos)
#define TCC_DRVCTRL_NRV3_Pos 11
#define TCC_DRVCTRL_NRV3 (_U_(1) << TCC_DRVCTRL_NRV3_Pos)
#define TCC_DRVCTRL_NRV4_Pos 12
#define TCC_DRVCTRL_NRV4 (_U_(1) << TCC_DRVCTRL_NRV4_Pos)
#define TCC_DRVCTRL_NRV5_Pos 13
#define TCC_DRVCTRL_NRV5 (_U_(1) << TCC_DRVCTRL_NRV5_Pos)
#define TCC_DRVCTRL_NRV6_Pos 14
#define TCC_DRVCTRL_NRV6 (_U_(1) << TCC_DRVCTRL_NRV6_Pos)
#define TCC_DRVCTRL_NRV7_Pos 15
#define TCC_DRVCTRL_NRV7 (_U_(1) << TCC_DRVCTRL_NRV7_Pos)
#define TCC_DRVCTRL_NRV_Pos 8
#define TCC_DRVCTRL_NRV_Msk (_U_(0xFF) << TCC_DRVCTRL_NRV_Pos)
#define TCC_DRVCTRL_NRV(value) (TCC_DRVCTRL_NRV_Msk & ((value) << TCC_DRVCTRL_NRV_Pos))
#define TCC_DRVCTRL_INVEN0_Pos 16
#define TCC_DRVCTRL_INVEN0 (_U_(1) << TCC_DRVCTRL_INVEN0_Pos)
#define TCC_DRVCTRL_INVEN1_Pos 17
#define TCC_DRVCTRL_INVEN1 (_U_(1) << TCC_DRVCTRL_INVEN1_Pos)
#define TCC_DRVCTRL_INVEN2_Pos 18
#define TCC_DRVCTRL_INVEN2 (_U_(1) << TCC_DRVCTRL_INVEN2_Pos)
#define TCC_DRVCTRL_INVEN3_Pos 19
#define TCC_DRVCTRL_INVEN3 (_U_(1) << TCC_DRVCTRL_INVEN3_Pos)
#define TCC_DRVCTRL_INVEN4_Pos 20
#define TCC_DRVCTRL_INVEN4 (_U_(1) << TCC_DRVCTRL_INVEN4_Pos)
#define TCC_DRVCTRL_INVEN5_Pos 21
#define TCC_DRVCTRL_INVEN5 (_U_(1) << TCC_DRVCTRL_INVEN5_Pos)
#define TCC_DRVCTRL_INVEN6_Pos 22
#define TCC_DRVCTRL_INVEN6 (_U_(1) << TCC_DRVCTRL_INVEN6_Pos)
#define TCC_DRVCTRL_INVEN7_Pos 23
#define TCC_DRVCTRL_INVEN7 (_U_(1) << TCC_DRVCTRL_INVEN7_Pos)
#define TCC_DRVCTRL_INVEN_Pos 16
#define TCC_DRVCTRL_INVEN_Msk (_U_(0xFF) << TCC_DRVCTRL_INVEN_Pos)
#define TCC_DRVCTRL_INVEN(value) (TCC_DRVCTRL_INVEN_Msk & ((value) << TCC_DRVCTRL_INVEN_Pos))
#define TCC_DRVCTRL_FILTERVAL0_Pos 24
#define TCC_DRVCTRL_FILTERVAL0_Msk (_U_(0xF) << TCC_DRVCTRL_FILTERVAL0_Pos)
#define TCC_DRVCTRL_FILTERVAL0(value) (TCC_DRVCTRL_FILTERVAL0_Msk & ((value) << TCC_DRVCTRL_FILTERVAL0_Pos))
#define TCC_DRVCTRL_FILTERVAL1_Pos 28
#define TCC_DRVCTRL_FILTERVAL1_Msk (_U_(0xF) << TCC_DRVCTRL_FILTERVAL1_Pos)
#define TCC_DRVCTRL_FILTERVAL1(value) (TCC_DRVCTRL_FILTERVAL1_Msk & ((value) << TCC_DRVCTRL_FILTERVAL1_Pos))
#define TCC_DRVCTRL_MASK _U_(0xFFFFFFFF)

/* -------- TCC_DBGCTRL : (TCC Offset: 0x1E) (R/W  8) Debug Control -------- */

typedef union {
  struct {
    uint8_t DBGRUN:1; /*!< bit:      0  Debug Running Mode                 */
    uint8_t :1; /*!< bit:      1  Reserved                           */
    uint8_t FDDBD:1; /*!< bit:      2  Fault Detection on Debug Break Detection */
    uint8_t :5; /*!< bit:  3.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} TCC_DBGCTRL_Type;


#define TCC_DBGCTRL_OFFSET 0x1E
#define TCC_DBGCTRL_RESETVALUE _U_(0x00)

#define TCC_DBGCTRL_DBGRUN_Pos 0
#define TCC_DBGCTRL_DBGRUN (_U_(0x1) << TCC_DBGCTRL_DBGRUN_Pos)
#define TCC_DBGCTRL_FDDBD_Pos 2
#define TCC_DBGCTRL_FDDBD (_U_(0x1) << TCC_DBGCTRL_FDDBD_Pos)
#define TCC_DBGCTRL_MASK _U_(0x05)

/* -------- TCC_EVCTRL : (TCC Offset: 0x20) (R/W 32) Event Control -------- */

typedef union {
  struct {
    uint32_t EVACT0:3; /*!< bit:  0.. 2  Timer/counter Input Event0 Action  */
    uint32_t EVACT1:3; /*!< bit:  3.. 5  Timer/counter Input Event1 Action  */
    uint32_t CNTSEL:2; /*!< bit:  6.. 7  Timer/counter Output Event Mode    */
    uint32_t OVFEO:1; /*!< bit:      8  Overflow/Underflow Output Event Enable */
    uint32_t TRGEO:1; /*!< bit:      9  Retrigger Output Event Enable      */
    uint32_t CNTEO:1; /*!< bit:     10  Timer/counter Output Event Enable  */
    uint32_t :1; /*!< bit:     11  Reserved                           */
    uint32_t TCINV0:1; /*!< bit:     12  Inverted Event 0 Input Enable      */
    uint32_t TCINV1:1; /*!< bit:     13  Inverted Event 1 Input Enable      */
    uint32_t TCEI0:1; /*!< bit:     14  Timer/counter Event 0 Input Enable */
    uint32_t TCEI1:1; /*!< bit:     15  Timer/counter Event 1 Input Enable */
    uint32_t MCEI0:1; /*!< bit:     16  Match or Capture Channel 0 Event Input Enable */
    uint32_t MCEI1:1; /*!< bit:     17  Match or Capture Channel 1 Event Input Enable */
    uint32_t MCEI2:1; /*!< bit:     18  Match or Capture Channel 2 Event Input Enable */
    uint32_t MCEI3:1; /*!< bit:     19  Match or Capture Channel 3 Event Input Enable */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t MCEO0:1; /*!< bit:     24  Match or Capture Channel 0 Event Output Enable */
    uint32_t MCEO1:1; /*!< bit:     25  Match or Capture Channel 1 Event Output Enable */
    uint32_t MCEO2:1; /*!< bit:     26  Match or Capture Channel 2 Event Output Enable */
    uint32_t MCEO3:1; /*!< bit:     27  Match or Capture Channel 3 Event Output Enable */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :12; /*!< bit:  0..11  Reserved                           */
    uint32_t TCINV:2; /*!< bit: 12..13  Inverted Event x Input Enable      */
    uint32_t TCEI:2; /*!< bit: 14..15  Timer/counter Event x Input Enable */
    uint32_t MCEI:4; /*!< bit: 16..19  Match or Capture Channel x Event Input Enable */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t MCEO:4; /*!< bit: 24..27  Match or Capture Channel x Event Output Enable */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_EVCTRL_Type;


#define TCC_EVCTRL_OFFSET 0x20
#define TCC_EVCTRL_RESETVALUE _U_(0x00000000)

#define TCC_EVCTRL_EVACT0_Pos 0
#define TCC_EVCTRL_EVACT0_Msk (_U_(0x7) << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT0(value) (TCC_EVCTRL_EVACT0_Msk & ((value) << TCC_EVCTRL_EVACT0_Pos))
#define TCC_EVCTRL_EVACT0_OFF_Val _U_(0x0)
#define TCC_EVCTRL_EVACT0_RETRIGGER_Val _U_(0x1)
#define TCC_EVCTRL_EVACT0_COUNTEV_Val _U_(0x2)
#define TCC_EVCTRL_EVACT0_START_Val _U_(0x3)
#define TCC_EVCTRL_EVACT0_INC_Val _U_(0x4)
#define TCC_EVCTRL_EVACT0_COUNT_Val _U_(0x5)
#define TCC_EVCTRL_EVACT0_FAULT_Val _U_(0x7)
#define TCC_EVCTRL_EVACT0_OFF (TCC_EVCTRL_EVACT0_OFF_Val << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT0_RETRIGGER (TCC_EVCTRL_EVACT0_RETRIGGER_Val << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT0_COUNTEV (TCC_EVCTRL_EVACT0_COUNTEV_Val << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT0_START (TCC_EVCTRL_EVACT0_START_Val << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT0_INC (TCC_EVCTRL_EVACT0_INC_Val << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT0_COUNT (TCC_EVCTRL_EVACT0_COUNT_Val << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT0_FAULT (TCC_EVCTRL_EVACT0_FAULT_Val << TCC_EVCTRL_EVACT0_Pos)
#define TCC_EVCTRL_EVACT1_Pos 3
#define TCC_EVCTRL_EVACT1_Msk (_U_(0x7) << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1(value) (TCC_EVCTRL_EVACT1_Msk & ((value) << TCC_EVCTRL_EVACT1_Pos))
#define TCC_EVCTRL_EVACT1_OFF_Val _U_(0x0)
#define TCC_EVCTRL_EVACT1_RETRIGGER_Val _U_(0x1)
#define TCC_EVCTRL_EVACT1_DIR_Val _U_(0x2)
#define TCC_EVCTRL_EVACT1_STOP_Val _U_(0x3)
#define TCC_EVCTRL_EVACT1_DEC_Val _U_(0x4)
#define TCC_EVCTRL_EVACT1_PPW_Val _U_(0x5)
#define TCC_EVCTRL_EVACT1_PWP_Val _U_(0x6)
#define TCC_EVCTRL_EVACT1_FAULT_Val _U_(0x7)
#define TCC_EVCTRL_EVACT1_OFF (TCC_EVCTRL_EVACT1_OFF_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1_RETRIGGER (TCC_EVCTRL_EVACT1_RETRIGGER_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1_DIR (TCC_EVCTRL_EVACT1_DIR_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1_STOP (TCC_EVCTRL_EVACT1_STOP_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1_DEC (TCC_EVCTRL_EVACT1_DEC_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1_PPW (TCC_EVCTRL_EVACT1_PPW_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1_PWP (TCC_EVCTRL_EVACT1_PWP_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_EVACT1_FAULT (TCC_EVCTRL_EVACT1_FAULT_Val << TCC_EVCTRL_EVACT1_Pos)
#define TCC_EVCTRL_CNTSEL_Pos 6
#define TCC_EVCTRL_CNTSEL_Msk (_U_(0x3) << TCC_EVCTRL_CNTSEL_Pos)
#define TCC_EVCTRL_CNTSEL(value) (TCC_EVCTRL_CNTSEL_Msk & ((value) << TCC_EVCTRL_CNTSEL_Pos))
#define TCC_EVCTRL_CNTSEL_START_Val _U_(0x0)
#define TCC_EVCTRL_CNTSEL_END_Val _U_(0x1)
#define TCC_EVCTRL_CNTSEL_BETWEEN_Val _U_(0x2)
#define TCC_EVCTRL_CNTSEL_BOUNDARY_Val _U_(0x3)
#define TCC_EVCTRL_CNTSEL_START (TCC_EVCTRL_CNTSEL_START_Val << TCC_EVCTRL_CNTSEL_Pos)
#define TCC_EVCTRL_CNTSEL_END (TCC_EVCTRL_CNTSEL_END_Val << TCC_EVCTRL_CNTSEL_Pos)
#define TCC_EVCTRL_CNTSEL_BETWEEN (TCC_EVCTRL_CNTSEL_BETWEEN_Val << TCC_EVCTRL_CNTSEL_Pos)
#define TCC_EVCTRL_CNTSEL_BOUNDARY (TCC_EVCTRL_CNTSEL_BOUNDARY_Val << TCC_EVCTRL_CNTSEL_Pos)
#define TCC_EVCTRL_OVFEO_Pos 8
#define TCC_EVCTRL_OVFEO (_U_(0x1) << TCC_EVCTRL_OVFEO_Pos)
#define TCC_EVCTRL_TRGEO_Pos 9
#define TCC_EVCTRL_TRGEO (_U_(0x1) << TCC_EVCTRL_TRGEO_Pos)
#define TCC_EVCTRL_CNTEO_Pos 10
#define TCC_EVCTRL_CNTEO (_U_(0x1) << TCC_EVCTRL_CNTEO_Pos)
#define TCC_EVCTRL_TCINV0_Pos 12
#define TCC_EVCTRL_TCINV0 (_U_(1) << TCC_EVCTRL_TCINV0_Pos)
#define TCC_EVCTRL_TCINV1_Pos 13
#define TCC_EVCTRL_TCINV1 (_U_(1) << TCC_EVCTRL_TCINV1_Pos)
#define TCC_EVCTRL_TCINV_Pos 12
#define TCC_EVCTRL_TCINV_Msk (_U_(0x3) << TCC_EVCTRL_TCINV_Pos)
#define TCC_EVCTRL_TCINV(value) (TCC_EVCTRL_TCINV_Msk & ((value) << TCC_EVCTRL_TCINV_Pos))
#define TCC_EVCTRL_TCEI0_Pos 14
#define TCC_EVCTRL_TCEI0 (_U_(1) << TCC_EVCTRL_TCEI0_Pos)
#define TCC_EVCTRL_TCEI1_Pos 15
#define TCC_EVCTRL_TCEI1 (_U_(1) << TCC_EVCTRL_TCEI1_Pos)
#define TCC_EVCTRL_TCEI_Pos 14
#define TCC_EVCTRL_TCEI_Msk (_U_(0x3) << TCC_EVCTRL_TCEI_Pos)
#define TCC_EVCTRL_TCEI(value) (TCC_EVCTRL_TCEI_Msk & ((value) << TCC_EVCTRL_TCEI_Pos))
#define TCC_EVCTRL_MCEI0_Pos 16
#define TCC_EVCTRL_MCEI0 (_U_(1) << TCC_EVCTRL_MCEI0_Pos)
#define TCC_EVCTRL_MCEI1_Pos 17
#define TCC_EVCTRL_MCEI1 (_U_(1) << TCC_EVCTRL_MCEI1_Pos)
#define TCC_EVCTRL_MCEI2_Pos 18
#define TCC_EVCTRL_MCEI2 (_U_(1) << TCC_EVCTRL_MCEI2_Pos)
#define TCC_EVCTRL_MCEI3_Pos 19
#define TCC_EVCTRL_MCEI3 (_U_(1) << TCC_EVCTRL_MCEI3_Pos)
#define TCC_EVCTRL_MCEI_Pos 16
#define TCC_EVCTRL_MCEI_Msk (_U_(0xF) << TCC_EVCTRL_MCEI_Pos)
#define TCC_EVCTRL_MCEI(value) (TCC_EVCTRL_MCEI_Msk & ((value) << TCC_EVCTRL_MCEI_Pos))
#define TCC_EVCTRL_MCEO0_Pos 24
#define TCC_EVCTRL_MCEO0 (_U_(1) << TCC_EVCTRL_MCEO0_Pos)
#define TCC_EVCTRL_MCEO1_Pos 25
#define TCC_EVCTRL_MCEO1 (_U_(1) << TCC_EVCTRL_MCEO1_Pos)
#define TCC_EVCTRL_MCEO2_Pos 26
#define TCC_EVCTRL_MCEO2 (_U_(1) << TCC_EVCTRL_MCEO2_Pos)
#define TCC_EVCTRL_MCEO3_Pos 27
#define TCC_EVCTRL_MCEO3 (_U_(1) << TCC_EVCTRL_MCEO3_Pos)
#define TCC_EVCTRL_MCEO_Pos 24
#define TCC_EVCTRL_MCEO_Msk (_U_(0xF) << TCC_EVCTRL_MCEO_Pos)
#define TCC_EVCTRL_MCEO(value) (TCC_EVCTRL_MCEO_Msk & ((value) << TCC_EVCTRL_MCEO_Pos))
#define TCC_EVCTRL_MASK _U_(0x0F0FF7FF)

/* -------- TCC_INTENCLR : (TCC Offset: 0x24) (R/W 32) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint32_t OVF:1; /*!< bit:      0  Overflow Interrupt Enable          */
    uint32_t TRG:1; /*!< bit:      1  Retrigger Interrupt Enable         */
    uint32_t CNT:1; /*!< bit:      2  Counter Interrupt Enable           */
    uint32_t ERR:1; /*!< bit:      3  Error Interrupt Enable             */
    uint32_t :7; /*!< bit:  4..10  Reserved                           */
    uint32_t DFS:1; /*!< bit:     11  Non-Recoverable Debug Fault Interrupt Enable */
    uint32_t FAULTA:1; /*!< bit:     12  Recoverable Fault A Interrupt Enable */
    uint32_t FAULTB:1; /*!< bit:     13  Recoverable Fault B Interrupt Enable */
    uint32_t FAULT0:1; /*!< bit:     14  Non-Recoverable Fault 0 Interrupt Enable */
    uint32_t FAULT1:1; /*!< bit:     15  Non-Recoverable Fault 1 Interrupt Enable */
    uint32_t MC0:1; /*!< bit:     16  Match or Capture Channel 0 Interrupt Enable */
    uint32_t MC1:1; /*!< bit:     17  Match or Capture Channel 1 Interrupt Enable */
    uint32_t MC2:1; /*!< bit:     18  Match or Capture Channel 2 Interrupt Enable */
    uint32_t MC3:1; /*!< bit:     19  Match or Capture Channel 3 Interrupt Enable */
    uint32_t :12; /*!< bit: 20..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :16; /*!< bit:  0..15  Reserved                           */
    uint32_t MC:4; /*!< bit: 16..19  Match or Capture Channel x Interrupt Enable */
    uint32_t :12; /*!< bit: 20..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_INTENCLR_Type;


#define TCC_INTENCLR_OFFSET 0x24
#define TCC_INTENCLR_RESETVALUE _U_(0x00000000)

#define TCC_INTENCLR_OVF_Pos 0
#define TCC_INTENCLR_OVF (_U_(0x1) << TCC_INTENCLR_OVF_Pos)
#define TCC_INTENCLR_TRG_Pos 1
#define TCC_INTENCLR_TRG (_U_(0x1) << TCC_INTENCLR_TRG_Pos)
#define TCC_INTENCLR_CNT_Pos 2
#define TCC_INTENCLR_CNT (_U_(0x1) << TCC_INTENCLR_CNT_Pos)
#define TCC_INTENCLR_ERR_Pos 3
#define TCC_INTENCLR_ERR (_U_(0x1) << TCC_INTENCLR_ERR_Pos)
#define TCC_INTENCLR_DFS_Pos 11
#define TCC_INTENCLR_DFS (_U_(0x1) << TCC_INTENCLR_DFS_Pos)
#define TCC_INTENCLR_FAULTA_Pos 12
#define TCC_INTENCLR_FAULTA (_U_(0x1) << TCC_INTENCLR_FAULTA_Pos)
#define TCC_INTENCLR_FAULTB_Pos 13
#define TCC_INTENCLR_FAULTB (_U_(0x1) << TCC_INTENCLR_FAULTB_Pos)
#define TCC_INTENCLR_FAULT0_Pos 14
#define TCC_INTENCLR_FAULT0 (_U_(0x1) << TCC_INTENCLR_FAULT0_Pos)
#define TCC_INTENCLR_FAULT1_Pos 15
#define TCC_INTENCLR_FAULT1 (_U_(0x1) << TCC_INTENCLR_FAULT1_Pos)
#define TCC_INTENCLR_MC0_Pos 16
#define TCC_INTENCLR_MC0 (_U_(1) << TCC_INTENCLR_MC0_Pos)
#define TCC_INTENCLR_MC1_Pos 17
#define TCC_INTENCLR_MC1 (_U_(1) << TCC_INTENCLR_MC1_Pos)
#define TCC_INTENCLR_MC2_Pos 18
#define TCC_INTENCLR_MC2 (_U_(1) << TCC_INTENCLR_MC2_Pos)
#define TCC_INTENCLR_MC3_Pos 19
#define TCC_INTENCLR_MC3 (_U_(1) << TCC_INTENCLR_MC3_Pos)
#define TCC_INTENCLR_MC_Pos 16
#define TCC_INTENCLR_MC_Msk (_U_(0xF) << TCC_INTENCLR_MC_Pos)
#define TCC_INTENCLR_MC(value) (TCC_INTENCLR_MC_Msk & ((value) << TCC_INTENCLR_MC_Pos))
#define TCC_INTENCLR_MASK _U_(0x000FF80F)

/* -------- TCC_INTENSET : (TCC Offset: 0x28) (R/W 32) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint32_t OVF:1; /*!< bit:      0  Overflow Interrupt Enable          */
    uint32_t TRG:1; /*!< bit:      1  Retrigger Interrupt Enable         */
    uint32_t CNT:1; /*!< bit:      2  Counter Interrupt Enable           */
    uint32_t ERR:1; /*!< bit:      3  Error Interrupt Enable             */
    uint32_t :7; /*!< bit:  4..10  Reserved                           */
    uint32_t DFS:1; /*!< bit:     11  Non-Recoverable Debug Fault Interrupt Enable */
    uint32_t FAULTA:1; /*!< bit:     12  Recoverable Fault A Interrupt Enable */
    uint32_t FAULTB:1; /*!< bit:     13  Recoverable Fault B Interrupt Enable */
    uint32_t FAULT0:1; /*!< bit:     14  Non-Recoverable Fault 0 Interrupt Enable */
    uint32_t FAULT1:1; /*!< bit:     15  Non-Recoverable Fault 1 Interrupt Enable */
    uint32_t MC0:1; /*!< bit:     16  Match or Capture Channel 0 Interrupt Enable */
    uint32_t MC1:1; /*!< bit:     17  Match or Capture Channel 1 Interrupt Enable */
    uint32_t MC2:1; /*!< bit:     18  Match or Capture Channel 2 Interrupt Enable */
    uint32_t MC3:1; /*!< bit:     19  Match or Capture Channel 3 Interrupt Enable */
    uint32_t :12; /*!< bit: 20..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :16; /*!< bit:  0..15  Reserved                           */
    uint32_t MC:4; /*!< bit: 16..19  Match or Capture Channel x Interrupt Enable */
    uint32_t :12; /*!< bit: 20..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_INTENSET_Type;


#define TCC_INTENSET_OFFSET 0x28
#define TCC_INTENSET_RESETVALUE _U_(0x00000000)

#define TCC_INTENSET_OVF_Pos 0
#define TCC_INTENSET_OVF (_U_(0x1) << TCC_INTENSET_OVF_Pos)
#define TCC_INTENSET_TRG_Pos 1
#define TCC_INTENSET_TRG (_U_(0x1) << TCC_INTENSET_TRG_Pos)
#define TCC_INTENSET_CNT_Pos 2
#define TCC_INTENSET_CNT (_U_(0x1) << TCC_INTENSET_CNT_Pos)
#define TCC_INTENSET_ERR_Pos 3
#define TCC_INTENSET_ERR (_U_(0x1) << TCC_INTENSET_ERR_Pos)
#define TCC_INTENSET_DFS_Pos 11
#define TCC_INTENSET_DFS (_U_(0x1) << TCC_INTENSET_DFS_Pos)
#define TCC_INTENSET_FAULTA_Pos 12
#define TCC_INTENSET_FAULTA (_U_(0x1) << TCC_INTENSET_FAULTA_Pos)
#define TCC_INTENSET_FAULTB_Pos 13
#define TCC_INTENSET_FAULTB (_U_(0x1) << TCC_INTENSET_FAULTB_Pos)
#define TCC_INTENSET_FAULT0_Pos 14
#define TCC_INTENSET_FAULT0 (_U_(0x1) << TCC_INTENSET_FAULT0_Pos)
#define TCC_INTENSET_FAULT1_Pos 15
#define TCC_INTENSET_FAULT1 (_U_(0x1) << TCC_INTENSET_FAULT1_Pos)
#define TCC_INTENSET_MC0_Pos 16
#define TCC_INTENSET_MC0 (_U_(1) << TCC_INTENSET_MC0_Pos)
#define TCC_INTENSET_MC1_Pos 17
#define TCC_INTENSET_MC1 (_U_(1) << TCC_INTENSET_MC1_Pos)
#define TCC_INTENSET_MC2_Pos 18
#define TCC_INTENSET_MC2 (_U_(1) << TCC_INTENSET_MC2_Pos)
#define TCC_INTENSET_MC3_Pos 19
#define TCC_INTENSET_MC3 (_U_(1) << TCC_INTENSET_MC3_Pos)
#define TCC_INTENSET_MC_Pos 16
#define TCC_INTENSET_MC_Msk (_U_(0xF) << TCC_INTENSET_MC_Pos)
#define TCC_INTENSET_MC(value) (TCC_INTENSET_MC_Msk & ((value) << TCC_INTENSET_MC_Pos))
#define TCC_INTENSET_MASK _U_(0x000FF80F)

/* -------- TCC_INTFLAG : (TCC Offset: 0x2C) (R/W 32) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint32_t OVF:1; /*!< bit:      0  Overflow                           */
    volatile const uint32_t TRG:1; /*!< bit:      1  Retrigger                          */
    volatile const uint32_t CNT:1; /*!< bit:      2  Counter                            */
    volatile const uint32_t ERR:1; /*!< bit:      3  Error                              */
    volatile const uint32_t :7; /*!< bit:  4..10  Reserved                           */
    volatile const uint32_t DFS:1; /*!< bit:     11  Non-Recoverable Debug Fault        */
    volatile const uint32_t FAULTA:1; /*!< bit:     12  Recoverable Fault A                */
    volatile const uint32_t FAULTB:1; /*!< bit:     13  Recoverable Fault B                */
    volatile const uint32_t FAULT0:1; /*!< bit:     14  Non-Recoverable Fault 0            */
    volatile const uint32_t FAULT1:1; /*!< bit:     15  Non-Recoverable Fault 1            */
    volatile const uint32_t MC0:1; /*!< bit:     16  Match or Capture 0                 */
    volatile const uint32_t MC1:1; /*!< bit:     17  Match or Capture 1                 */
    volatile const uint32_t MC2:1; /*!< bit:     18  Match or Capture 2                 */
    volatile const uint32_t MC3:1; /*!< bit:     19  Match or Capture 3                 */
    volatile const uint32_t :12; /*!< bit: 20..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint32_t :16; /*!< bit:  0..15  Reserved                           */
    volatile const uint32_t MC:4; /*!< bit: 16..19  Match or Capture x                 */
    volatile const uint32_t :12; /*!< bit: 20..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_INTFLAG_Type;


#define TCC_INTFLAG_OFFSET 0x2C
#define TCC_INTFLAG_RESETVALUE _U_(0x00000000)

#define TCC_INTFLAG_OVF_Pos 0
#define TCC_INTFLAG_OVF (_U_(0x1) << TCC_INTFLAG_OVF_Pos)
#define TCC_INTFLAG_TRG_Pos 1
#define TCC_INTFLAG_TRG (_U_(0x1) << TCC_INTFLAG_TRG_Pos)
#define TCC_INTFLAG_CNT_Pos 2
#define TCC_INTFLAG_CNT (_U_(0x1) << TCC_INTFLAG_CNT_Pos)
#define TCC_INTFLAG_ERR_Pos 3
#define TCC_INTFLAG_ERR (_U_(0x1) << TCC_INTFLAG_ERR_Pos)
#define TCC_INTFLAG_DFS_Pos 11
#define TCC_INTFLAG_DFS (_U_(0x1) << TCC_INTFLAG_DFS_Pos)
#define TCC_INTFLAG_FAULTA_Pos 12
#define TCC_INTFLAG_FAULTA (_U_(0x1) << TCC_INTFLAG_FAULTA_Pos)
#define TCC_INTFLAG_FAULTB_Pos 13
#define TCC_INTFLAG_FAULTB (_U_(0x1) << TCC_INTFLAG_FAULTB_Pos)
#define TCC_INTFLAG_FAULT0_Pos 14
#define TCC_INTFLAG_FAULT0 (_U_(0x1) << TCC_INTFLAG_FAULT0_Pos)
#define TCC_INTFLAG_FAULT1_Pos 15
#define TCC_INTFLAG_FAULT1 (_U_(0x1) << TCC_INTFLAG_FAULT1_Pos)
#define TCC_INTFLAG_MC0_Pos 16
#define TCC_INTFLAG_MC0 (_U_(1) << TCC_INTFLAG_MC0_Pos)
#define TCC_INTFLAG_MC1_Pos 17
#define TCC_INTFLAG_MC1 (_U_(1) << TCC_INTFLAG_MC1_Pos)
#define TCC_INTFLAG_MC2_Pos 18
#define TCC_INTFLAG_MC2 (_U_(1) << TCC_INTFLAG_MC2_Pos)
#define TCC_INTFLAG_MC3_Pos 19
#define TCC_INTFLAG_MC3 (_U_(1) << TCC_INTFLAG_MC3_Pos)
#define TCC_INTFLAG_MC_Pos 16
#define TCC_INTFLAG_MC_Msk (_U_(0xF) << TCC_INTFLAG_MC_Pos)
#define TCC_INTFLAG_MC(value) (TCC_INTFLAG_MC_Msk & ((value) << TCC_INTFLAG_MC_Pos))
#define TCC_INTFLAG_MASK _U_(0x000FF80F)

/* -------- TCC_STATUS : (TCC Offset: 0x30) (R/W 32) Status -------- */

typedef union {
  struct {
    uint32_t STOP:1; /*!< bit:      0  Stop                               */
    uint32_t IDX:1; /*!< bit:      1  Ramp                               */
    uint32_t :1; /*!< bit:      2  Reserved                           */
    uint32_t DFS:1; /*!< bit:      3  Non-Recoverable Debug Fault State  */
    uint32_t SLAVE:1; /*!< bit:      4  Slave                              */
    uint32_t PATTBV:1; /*!< bit:      5  Pattern Buffer Valid               */
    uint32_t WAVEBV:1; /*!< bit:      6  Wave Buffer Valid                  */
    uint32_t PERBV:1; /*!< bit:      7  Period Buffer Valid                */
    uint32_t FAULTAIN:1; /*!< bit:      8  Recoverable Fault A Input          */
    uint32_t FAULTBIN:1; /*!< bit:      9  Recoverable Fault B Input          */
    uint32_t FAULT0IN:1; /*!< bit:     10  Non-Recoverable Fault0 Input       */
    uint32_t FAULT1IN:1; /*!< bit:     11  Non-Recoverable Fault1 Input       */
    uint32_t FAULTA:1; /*!< bit:     12  Recoverable Fault A State          */
    uint32_t FAULTB:1; /*!< bit:     13  Recoverable Fault B State          */
    uint32_t FAULT0:1; /*!< bit:     14  Non-Recoverable Fault 0 State      */
    uint32_t FAULT1:1; /*!< bit:     15  Non-Recoverable Fault 1 State      */
    uint32_t CCBV0:1; /*!< bit:     16  Compare Channel 0 Buffer Valid     */
    uint32_t CCBV1:1; /*!< bit:     17  Compare Channel 1 Buffer Valid     */
    uint32_t CCBV2:1; /*!< bit:     18  Compare Channel 2 Buffer Valid     */
    uint32_t CCBV3:1; /*!< bit:     19  Compare Channel 3 Buffer Valid     */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t CMP0:1; /*!< bit:     24  Compare Channel 0 Value            */
    uint32_t CMP1:1; /*!< bit:     25  Compare Channel 1 Value            */
    uint32_t CMP2:1; /*!< bit:     26  Compare Channel 2 Value            */
    uint32_t CMP3:1; /*!< bit:     27  Compare Channel 3 Value            */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :16; /*!< bit:  0..15  Reserved                           */
    uint32_t CCBV:4; /*!< bit: 16..19  Compare Channel x Buffer Valid     */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t CMP:4; /*!< bit: 24..27  Compare Channel x Value            */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_STATUS_Type;


#define TCC_STATUS_OFFSET 0x30
#define TCC_STATUS_RESETVALUE _U_(0x00000001)

#define TCC_STATUS_STOP_Pos 0
#define TCC_STATUS_STOP (_U_(0x1) << TCC_STATUS_STOP_Pos)
#define TCC_STATUS_IDX_Pos 1
#define TCC_STATUS_IDX (_U_(0x1) << TCC_STATUS_IDX_Pos)
#define TCC_STATUS_DFS_Pos 3
#define TCC_STATUS_DFS (_U_(0x1) << TCC_STATUS_DFS_Pos)
#define TCC_STATUS_SLAVE_Pos 4
#define TCC_STATUS_SLAVE (_U_(0x1) << TCC_STATUS_SLAVE_Pos)
#define TCC_STATUS_PATTBV_Pos 5
#define TCC_STATUS_PATTBV (_U_(0x1) << TCC_STATUS_PATTBV_Pos)
#define TCC_STATUS_WAVEBV_Pos 6
#define TCC_STATUS_WAVEBV (_U_(0x1) << TCC_STATUS_WAVEBV_Pos)
#define TCC_STATUS_PERBV_Pos 7
#define TCC_STATUS_PERBV (_U_(0x1) << TCC_STATUS_PERBV_Pos)
#define TCC_STATUS_FAULTAIN_Pos 8
#define TCC_STATUS_FAULTAIN (_U_(0x1) << TCC_STATUS_FAULTAIN_Pos)
#define TCC_STATUS_FAULTBIN_Pos 9
#define TCC_STATUS_FAULTBIN (_U_(0x1) << TCC_STATUS_FAULTBIN_Pos)
#define TCC_STATUS_FAULT0IN_Pos 10
#define TCC_STATUS_FAULT0IN (_U_(0x1) << TCC_STATUS_FAULT0IN_Pos)
#define TCC_STATUS_FAULT1IN_Pos 11
#define TCC_STATUS_FAULT1IN (_U_(0x1) << TCC_STATUS_FAULT1IN_Pos)
#define TCC_STATUS_FAULTA_Pos 12
#define TCC_STATUS_FAULTA (_U_(0x1) << TCC_STATUS_FAULTA_Pos)
#define TCC_STATUS_FAULTB_Pos 13
#define TCC_STATUS_FAULTB (_U_(0x1) << TCC_STATUS_FAULTB_Pos)
#define TCC_STATUS_FAULT0_Pos 14
#define TCC_STATUS_FAULT0 (_U_(0x1) << TCC_STATUS_FAULT0_Pos)
#define TCC_STATUS_FAULT1_Pos 15
#define TCC_STATUS_FAULT1 (_U_(0x1) << TCC_STATUS_FAULT1_Pos)
#define TCC_STATUS_CCBV0_Pos 16
#define TCC_STATUS_CCBV0 (_U_(1) << TCC_STATUS_CCBV0_Pos)
#define TCC_STATUS_CCBV1_Pos 17
#define TCC_STATUS_CCBV1 (_U_(1) << TCC_STATUS_CCBV1_Pos)
#define TCC_STATUS_CCBV2_Pos 18
#define TCC_STATUS_CCBV2 (_U_(1) << TCC_STATUS_CCBV2_Pos)
#define TCC_STATUS_CCBV3_Pos 19
#define TCC_STATUS_CCBV3 (_U_(1) << TCC_STATUS_CCBV3_Pos)
#define TCC_STATUS_CCBV_Pos 16
#define TCC_STATUS_CCBV_Msk (_U_(0xF) << TCC_STATUS_CCBV_Pos)
#define TCC_STATUS_CCBV(value) (TCC_STATUS_CCBV_Msk & ((value) << TCC_STATUS_CCBV_Pos))
#define TCC_STATUS_CMP0_Pos 24
#define TCC_STATUS_CMP0 (_U_(1) << TCC_STATUS_CMP0_Pos)
#define TCC_STATUS_CMP1_Pos 25
#define TCC_STATUS_CMP1 (_U_(1) << TCC_STATUS_CMP1_Pos)
#define TCC_STATUS_CMP2_Pos 26
#define TCC_STATUS_CMP2 (_U_(1) << TCC_STATUS_CMP2_Pos)
#define TCC_STATUS_CMP3_Pos 27
#define TCC_STATUS_CMP3 (_U_(1) << TCC_STATUS_CMP3_Pos)
#define TCC_STATUS_CMP_Pos 24
#define TCC_STATUS_CMP_Msk (_U_(0xF) << TCC_STATUS_CMP_Pos)
#define TCC_STATUS_CMP(value) (TCC_STATUS_CMP_Msk & ((value) << TCC_STATUS_CMP_Pos))
#define TCC_STATUS_MASK _U_(0x0F0FFFFB)

/* -------- TCC_COUNT : (TCC Offset: 0x34) (R/W 32) Count -------- */

typedef union {
  struct { // DITH4 mode
    uint32_t :4; /*!< bit:  0.. 3  Reserved                           */
    uint32_t COUNT:20; /*!< bit:  4..23  Counter Value                      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH4; /*!< Structure used for DITH4                        */
  struct { // DITH5 mode
    uint32_t :5; /*!< bit:  0.. 4  Reserved                           */
    uint32_t COUNT:19; /*!< bit:  5..23  Counter Value                      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH5; /*!< Structure used for DITH5                        */
  struct { // DITH6 mode
    uint32_t :6; /*!< bit:  0.. 5  Reserved                           */
    uint32_t COUNT:18; /*!< bit:  6..23  Counter Value                      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH6; /*!< Structure used for DITH6                        */
  struct {
    uint32_t COUNT:24; /*!< bit:  0..23  Counter Value                      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_COUNT_Type;


#define TCC_COUNT_OFFSET 0x34
#define TCC_COUNT_RESETVALUE _U_(0x00000000)

// DITH4 mode
#define TCC_COUNT_DITH4_COUNT_Pos 4
#define TCC_COUNT_DITH4_COUNT_Msk (_U_(0xFFFFF) << TCC_COUNT_DITH4_COUNT_Pos)
#define TCC_COUNT_DITH4_COUNT(value) (TCC_COUNT_DITH4_COUNT_Msk & ((value) << TCC_COUNT_DITH4_COUNT_Pos))
#define TCC_COUNT_DITH4_MASK _U_(0x00FFFFF0)

// DITH5 mode
#define TCC_COUNT_DITH5_COUNT_Pos 5
#define TCC_COUNT_DITH5_COUNT_Msk (_U_(0x7FFFF) << TCC_COUNT_DITH5_COUNT_Pos)
#define TCC_COUNT_DITH5_COUNT(value) (TCC_COUNT_DITH5_COUNT_Msk & ((value) << TCC_COUNT_DITH5_COUNT_Pos))
#define TCC_COUNT_DITH5_MASK _U_(0x00FFFFE0)

// DITH6 mode
#define TCC_COUNT_DITH6_COUNT_Pos 6
#define TCC_COUNT_DITH6_COUNT_Msk (_U_(0x3FFFF) << TCC_COUNT_DITH6_COUNT_Pos)
#define TCC_COUNT_DITH6_COUNT(value) (TCC_COUNT_DITH6_COUNT_Msk & ((value) << TCC_COUNT_DITH6_COUNT_Pos))
#define TCC_COUNT_DITH6_MASK _U_(0x00FFFFC0)

#define TCC_COUNT_COUNT_Pos 0
#define TCC_COUNT_COUNT_Msk (_U_(0xFFFFFF) << TCC_COUNT_COUNT_Pos)
#define TCC_COUNT_COUNT(value) (TCC_COUNT_COUNT_Msk & ((value) << TCC_COUNT_COUNT_Pos))
#define TCC_COUNT_MASK _U_(0x00FFFFFF)

/* -------- TCC_PATT : (TCC Offset: 0x38) (R/W 16) Pattern -------- */

typedef union {
  struct {
    uint16_t PGE0:1; /*!< bit:      0  Pattern Generator 0 Output Enable  */
    uint16_t PGE1:1; /*!< bit:      1  Pattern Generator 1 Output Enable  */
    uint16_t PGE2:1; /*!< bit:      2  Pattern Generator 2 Output Enable  */
    uint16_t PGE3:1; /*!< bit:      3  Pattern Generator 3 Output Enable  */
    uint16_t PGE4:1; /*!< bit:      4  Pattern Generator 4 Output Enable  */
    uint16_t PGE5:1; /*!< bit:      5  Pattern Generator 5 Output Enable  */
    uint16_t PGE6:1; /*!< bit:      6  Pattern Generator 6 Output Enable  */
    uint16_t PGE7:1; /*!< bit:      7  Pattern Generator 7 Output Enable  */
    uint16_t PGV0:1; /*!< bit:      8  Pattern Generator 0 Output Value   */
    uint16_t PGV1:1; /*!< bit:      9  Pattern Generator 1 Output Value   */
    uint16_t PGV2:1; /*!< bit:     10  Pattern Generator 2 Output Value   */
    uint16_t PGV3:1; /*!< bit:     11  Pattern Generator 3 Output Value   */
    uint16_t PGV4:1; /*!< bit:     12  Pattern Generator 4 Output Value   */
    uint16_t PGV5:1; /*!< bit:     13  Pattern Generator 5 Output Value   */
    uint16_t PGV6:1; /*!< bit:     14  Pattern Generator 6 Output Value   */
    uint16_t PGV7:1; /*!< bit:     15  Pattern Generator 7 Output Value   */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t PGE:8; /*!< bit:  0.. 7  Pattern Generator x Output Enable  */
    uint16_t PGV:8; /*!< bit:  8..15  Pattern Generator x Output Value   */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} TCC_PATT_Type;


#define TCC_PATT_OFFSET 0x38
#define TCC_PATT_RESETVALUE _U_(0x0000)

#define TCC_PATT_PGE0_Pos 0
#define TCC_PATT_PGE0 (_U_(1) << TCC_PATT_PGE0_Pos)
#define TCC_PATT_PGE1_Pos 1
#define TCC_PATT_PGE1 (_U_(1) << TCC_PATT_PGE1_Pos)
#define TCC_PATT_PGE2_Pos 2
#define TCC_PATT_PGE2 (_U_(1) << TCC_PATT_PGE2_Pos)
#define TCC_PATT_PGE3_Pos 3
#define TCC_PATT_PGE3 (_U_(1) << TCC_PATT_PGE3_Pos)
#define TCC_PATT_PGE4_Pos 4
#define TCC_PATT_PGE4 (_U_(1) << TCC_PATT_PGE4_Pos)
#define TCC_PATT_PGE5_Pos 5
#define TCC_PATT_PGE5 (_U_(1) << TCC_PATT_PGE5_Pos)
#define TCC_PATT_PGE6_Pos 6
#define TCC_PATT_PGE6 (_U_(1) << TCC_PATT_PGE6_Pos)
#define TCC_PATT_PGE7_Pos 7
#define TCC_PATT_PGE7 (_U_(1) << TCC_PATT_PGE7_Pos)
#define TCC_PATT_PGE_Pos 0
#define TCC_PATT_PGE_Msk (_U_(0xFF) << TCC_PATT_PGE_Pos)
#define TCC_PATT_PGE(value) (TCC_PATT_PGE_Msk & ((value) << TCC_PATT_PGE_Pos))
#define TCC_PATT_PGV0_Pos 8
#define TCC_PATT_PGV0 (_U_(1) << TCC_PATT_PGV0_Pos)
#define TCC_PATT_PGV1_Pos 9
#define TCC_PATT_PGV1 (_U_(1) << TCC_PATT_PGV1_Pos)
#define TCC_PATT_PGV2_Pos 10
#define TCC_PATT_PGV2 (_U_(1) << TCC_PATT_PGV2_Pos)
#define TCC_PATT_PGV3_Pos 11
#define TCC_PATT_PGV3 (_U_(1) << TCC_PATT_PGV3_Pos)
#define TCC_PATT_PGV4_Pos 12
#define TCC_PATT_PGV4 (_U_(1) << TCC_PATT_PGV4_Pos)
#define TCC_PATT_PGV5_Pos 13
#define TCC_PATT_PGV5 (_U_(1) << TCC_PATT_PGV5_Pos)
#define TCC_PATT_PGV6_Pos 14
#define TCC_PATT_PGV6 (_U_(1) << TCC_PATT_PGV6_Pos)
#define TCC_PATT_PGV7_Pos 15
#define TCC_PATT_PGV7 (_U_(1) << TCC_PATT_PGV7_Pos)
#define TCC_PATT_PGV_Pos 8
#define TCC_PATT_PGV_Msk (_U_(0xFF) << TCC_PATT_PGV_Pos)
#define TCC_PATT_PGV(value) (TCC_PATT_PGV_Msk & ((value) << TCC_PATT_PGV_Pos))
#define TCC_PATT_MASK _U_(0xFFFF)

/* -------- TCC_WAVE : (TCC Offset: 0x3C) (R/W 32) Waveform Control -------- */

typedef union {
  struct {
    uint32_t WAVEGEN:3; /*!< bit:  0.. 2  Waveform Generation                */
    uint32_t :1; /*!< bit:      3  Reserved                           */
    uint32_t RAMP:2; /*!< bit:  4.. 5  Ramp Mode                          */
    uint32_t :1; /*!< bit:      6  Reserved                           */
    uint32_t CIPEREN:1; /*!< bit:      7  Circular period Enable             */
    uint32_t CICCEN0:1; /*!< bit:      8  Circular Channel 0 Enable          */
    uint32_t CICCEN1:1; /*!< bit:      9  Circular Channel 1 Enable          */
    uint32_t CICCEN2:1; /*!< bit:     10  Circular Channel 2 Enable          */
    uint32_t CICCEN3:1; /*!< bit:     11  Circular Channel 3 Enable          */
    uint32_t :4; /*!< bit: 12..15  Reserved                           */
    uint32_t POL0:1; /*!< bit:     16  Channel 0 Polarity                 */
    uint32_t POL1:1; /*!< bit:     17  Channel 1 Polarity                 */
    uint32_t POL2:1; /*!< bit:     18  Channel 2 Polarity                 */
    uint32_t POL3:1; /*!< bit:     19  Channel 3 Polarity                 */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t SWAP0:1; /*!< bit:     24  Swap DTI Output Pair 0             */
    uint32_t SWAP1:1; /*!< bit:     25  Swap DTI Output Pair 1             */
    uint32_t SWAP2:1; /*!< bit:     26  Swap DTI Output Pair 2             */
    uint32_t SWAP3:1; /*!< bit:     27  Swap DTI Output Pair 3             */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :8; /*!< bit:  0.. 7  Reserved                           */
    uint32_t CICCEN:4; /*!< bit:  8..11  Circular Channel x Enable          */
    uint32_t :4; /*!< bit: 12..15  Reserved                           */
    uint32_t POL:4; /*!< bit: 16..19  Channel x Polarity                 */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t SWAP:4; /*!< bit: 24..27  Swap DTI Output Pair x             */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_WAVE_Type;


#define TCC_WAVE_OFFSET 0x3C
#define TCC_WAVE_RESETVALUE _U_(0x00000000)

#define TCC_WAVE_WAVEGEN_Pos 0
#define TCC_WAVE_WAVEGEN_Msk (_U_(0x7) << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_WAVEGEN(value) (TCC_WAVE_WAVEGEN_Msk & ((value) << TCC_WAVE_WAVEGEN_Pos))
#define TCC_WAVE_WAVEGEN_NFRQ_Val _U_(0x0)
#define TCC_WAVE_WAVEGEN_MFRQ_Val _U_(0x1)
#define TCC_WAVE_WAVEGEN_NPWM_Val _U_(0x2)
#define TCC_WAVE_WAVEGEN_DSCRITICAL_Val _U_(0x4)
#define TCC_WAVE_WAVEGEN_DSBOTTOM_Val _U_(0x5)
#define TCC_WAVE_WAVEGEN_DSBOTH_Val _U_(0x6)
#define TCC_WAVE_WAVEGEN_DSTOP_Val _U_(0x7)
#define TCC_WAVE_WAVEGEN_NFRQ (TCC_WAVE_WAVEGEN_NFRQ_Val << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_WAVEGEN_MFRQ (TCC_WAVE_WAVEGEN_MFRQ_Val << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_WAVEGEN_NPWM (TCC_WAVE_WAVEGEN_NPWM_Val << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_WAVEGEN_DSCRITICAL (TCC_WAVE_WAVEGEN_DSCRITICAL_Val << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_WAVEGEN_DSBOTTOM (TCC_WAVE_WAVEGEN_DSBOTTOM_Val << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_WAVEGEN_DSBOTH (TCC_WAVE_WAVEGEN_DSBOTH_Val << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_WAVEGEN_DSTOP (TCC_WAVE_WAVEGEN_DSTOP_Val << TCC_WAVE_WAVEGEN_Pos)
#define TCC_WAVE_RAMP_Pos 4
#define TCC_WAVE_RAMP_Msk (_U_(0x3) << TCC_WAVE_RAMP_Pos)
#define TCC_WAVE_RAMP(value) (TCC_WAVE_RAMP_Msk & ((value) << TCC_WAVE_RAMP_Pos))
#define TCC_WAVE_RAMP_RAMP1_Val _U_(0x0)
#define TCC_WAVE_RAMP_RAMP2A_Val _U_(0x1)
#define TCC_WAVE_RAMP_RAMP2_Val _U_(0x2)
#define TCC_WAVE_RAMP_RAMP1 (TCC_WAVE_RAMP_RAMP1_Val << TCC_WAVE_RAMP_Pos)
#define TCC_WAVE_RAMP_RAMP2A (TCC_WAVE_RAMP_RAMP2A_Val << TCC_WAVE_RAMP_Pos)
#define TCC_WAVE_RAMP_RAMP2 (TCC_WAVE_RAMP_RAMP2_Val << TCC_WAVE_RAMP_Pos)
#define TCC_WAVE_CIPEREN_Pos 7
#define TCC_WAVE_CIPEREN (_U_(0x1) << TCC_WAVE_CIPEREN_Pos)
#define TCC_WAVE_CICCEN0_Pos 8
#define TCC_WAVE_CICCEN0 (_U_(1) << TCC_WAVE_CICCEN0_Pos)
#define TCC_WAVE_CICCEN1_Pos 9
#define TCC_WAVE_CICCEN1 (_U_(1) << TCC_WAVE_CICCEN1_Pos)
#define TCC_WAVE_CICCEN2_Pos 10
#define TCC_WAVE_CICCEN2 (_U_(1) << TCC_WAVE_CICCEN2_Pos)
#define TCC_WAVE_CICCEN3_Pos 11
#define TCC_WAVE_CICCEN3 (_U_(1) << TCC_WAVE_CICCEN3_Pos)
#define TCC_WAVE_CICCEN_Pos 8
#define TCC_WAVE_CICCEN_Msk (_U_(0xF) << TCC_WAVE_CICCEN_Pos)
#define TCC_WAVE_CICCEN(value) (TCC_WAVE_CICCEN_Msk & ((value) << TCC_WAVE_CICCEN_Pos))
#define TCC_WAVE_POL0_Pos 16
#define TCC_WAVE_POL0 (_U_(1) << TCC_WAVE_POL0_Pos)
#define TCC_WAVE_POL1_Pos 17
#define TCC_WAVE_POL1 (_U_(1) << TCC_WAVE_POL1_Pos)
#define TCC_WAVE_POL2_Pos 18
#define TCC_WAVE_POL2 (_U_(1) << TCC_WAVE_POL2_Pos)
#define TCC_WAVE_POL3_Pos 19
#define TCC_WAVE_POL3 (_U_(1) << TCC_WAVE_POL3_Pos)
#define TCC_WAVE_POL_Pos 16
#define TCC_WAVE_POL_Msk (_U_(0xF) << TCC_WAVE_POL_Pos)
#define TCC_WAVE_POL(value) (TCC_WAVE_POL_Msk & ((value) << TCC_WAVE_POL_Pos))
#define TCC_WAVE_SWAP0_Pos 24
#define TCC_WAVE_SWAP0 (_U_(1) << TCC_WAVE_SWAP0_Pos)
#define TCC_WAVE_SWAP1_Pos 25
#define TCC_WAVE_SWAP1 (_U_(1) << TCC_WAVE_SWAP1_Pos)
#define TCC_WAVE_SWAP2_Pos 26
#define TCC_WAVE_SWAP2 (_U_(1) << TCC_WAVE_SWAP2_Pos)
#define TCC_WAVE_SWAP3_Pos 27
#define TCC_WAVE_SWAP3 (_U_(1) << TCC_WAVE_SWAP3_Pos)
#define TCC_WAVE_SWAP_Pos 24
#define TCC_WAVE_SWAP_Msk (_U_(0xF) << TCC_WAVE_SWAP_Pos)
#define TCC_WAVE_SWAP(value) (TCC_WAVE_SWAP_Msk & ((value) << TCC_WAVE_SWAP_Pos))
#define TCC_WAVE_MASK _U_(0x0F0F0FB7)

/* -------- TCC_PER : (TCC Offset: 0x40) (R/W 32) Period -------- */

typedef union {
  struct { // DITH4 mode
    uint32_t DITHERCY:4; /*!< bit:  0.. 3  Dithering Cycle Number             */
    uint32_t PER:20; /*!< bit:  4..23  Period Value                       */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH4; /*!< Structure used for DITH4                        */
  struct { // DITH5 mode
    uint32_t DITHERCY:5; /*!< bit:  0.. 4  Dithering Cycle Number             */
    uint32_t PER:19; /*!< bit:  5..23  Period Value                       */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH5; /*!< Structure used for DITH5                        */
  struct { // DITH6 mode
    uint32_t DITHERCY:6; /*!< bit:  0.. 5  Dithering Cycle Number             */
    uint32_t PER:18; /*!< bit:  6..23  Period Value                       */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH6; /*!< Structure used for DITH6                        */
  struct {
    uint32_t PER:24; /*!< bit:  0..23  Period Value                       */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_PER_Type;


#define TCC_PER_OFFSET 0x40
#define TCC_PER_RESETVALUE _U_(0xFFFFFFFF)

// DITH4 mode
#define TCC_PER_DITH4_DITHERCY_Pos 0
#define TCC_PER_DITH4_DITHERCY_Msk (_U_(0xF) << TCC_PER_DITH4_DITHERCY_Pos)
#define TCC_PER_DITH4_DITHERCY(value) (TCC_PER_DITH4_DITHERCY_Msk & ((value) << TCC_PER_DITH4_DITHERCY_Pos))
#define TCC_PER_DITH4_PER_Pos 4
#define TCC_PER_DITH4_PER_Msk (_U_(0xFFFFF) << TCC_PER_DITH4_PER_Pos)
#define TCC_PER_DITH4_PER(value) (TCC_PER_DITH4_PER_Msk & ((value) << TCC_PER_DITH4_PER_Pos))
#define TCC_PER_DITH4_MASK _U_(0x00FFFFFF)

// DITH5 mode
#define TCC_PER_DITH5_DITHERCY_Pos 0
#define TCC_PER_DITH5_DITHERCY_Msk (_U_(0x1F) << TCC_PER_DITH5_DITHERCY_Pos)
#define TCC_PER_DITH5_DITHERCY(value) (TCC_PER_DITH5_DITHERCY_Msk & ((value) << TCC_PER_DITH5_DITHERCY_Pos))
#define TCC_PER_DITH5_PER_Pos 5
#define TCC_PER_DITH5_PER_Msk (_U_(0x7FFFF) << TCC_PER_DITH5_PER_Pos)
#define TCC_PER_DITH5_PER(value) (TCC_PER_DITH5_PER_Msk & ((value) << TCC_PER_DITH5_PER_Pos))
#define TCC_PER_DITH5_MASK _U_(0x00FFFFFF)

// DITH6 mode
#define TCC_PER_DITH6_DITHERCY_Pos 0
#define TCC_PER_DITH6_DITHERCY_Msk (_U_(0x3F) << TCC_PER_DITH6_DITHERCY_Pos)
#define TCC_PER_DITH6_DITHERCY(value) (TCC_PER_DITH6_DITHERCY_Msk & ((value) << TCC_PER_DITH6_DITHERCY_Pos))
#define TCC_PER_DITH6_PER_Pos 6
#define TCC_PER_DITH6_PER_Msk (_U_(0x3FFFF) << TCC_PER_DITH6_PER_Pos)
#define TCC_PER_DITH6_PER(value) (TCC_PER_DITH6_PER_Msk & ((value) << TCC_PER_DITH6_PER_Pos))
#define TCC_PER_DITH6_MASK _U_(0x00FFFFFF)

#define TCC_PER_PER_Pos 0
#define TCC_PER_PER_Msk (_U_(0xFFFFFF) << TCC_PER_PER_Pos)
#define TCC_PER_PER(value) (TCC_PER_PER_Msk & ((value) << TCC_PER_PER_Pos))
#define TCC_PER_MASK _U_(0x00FFFFFF)

/* -------- TCC_CC : (TCC Offset: 0x44) (R/W 32) Compare and Capture -------- */

typedef union {
  struct { // DITH4 mode
    uint32_t DITHERCY:4; /*!< bit:  0.. 3  Dithering Cycle Number             */
    uint32_t CC:20; /*!< bit:  4..23  Channel Compare/Capture Value      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH4; /*!< Structure used for DITH4                        */
  struct { // DITH5 mode
    uint32_t DITHERCY:5; /*!< bit:  0.. 4  Dithering Cycle Number             */
    uint32_t CC:19; /*!< bit:  5..23  Channel Compare/Capture Value      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH5; /*!< Structure used for DITH5                        */
  struct { // DITH6 mode
    uint32_t DITHERCY:6; /*!< bit:  0.. 5  Dithering Cycle Number             */
    uint32_t CC:18; /*!< bit:  6..23  Channel Compare/Capture Value      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH6; /*!< Structure used for DITH6                        */
  struct {
    uint32_t CC:24; /*!< bit:  0..23  Channel Compare/Capture Value      */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_CC_Type;


#define TCC_CC_OFFSET 0x44
#define TCC_CC_RESETVALUE _U_(0x00000000)

// DITH4 mode
#define TCC_CC_DITH4_DITHERCY_Pos 0
#define TCC_CC_DITH4_DITHERCY_Msk (_U_(0xF) << TCC_CC_DITH4_DITHERCY_Pos)
#define TCC_CC_DITH4_DITHERCY(value) (TCC_CC_DITH4_DITHERCY_Msk & ((value) << TCC_CC_DITH4_DITHERCY_Pos))
#define TCC_CC_DITH4_CC_Pos 4
#define TCC_CC_DITH4_CC_Msk (_U_(0xFFFFF) << TCC_CC_DITH4_CC_Pos)
#define TCC_CC_DITH4_CC(value) (TCC_CC_DITH4_CC_Msk & ((value) << TCC_CC_DITH4_CC_Pos))
#define TCC_CC_DITH4_MASK _U_(0x00FFFFFF)

// DITH5 mode
#define TCC_CC_DITH5_DITHERCY_Pos 0
#define TCC_CC_DITH5_DITHERCY_Msk (_U_(0x1F) << TCC_CC_DITH5_DITHERCY_Pos)
#define TCC_CC_DITH5_DITHERCY(value) (TCC_CC_DITH5_DITHERCY_Msk & ((value) << TCC_CC_DITH5_DITHERCY_Pos))
#define TCC_CC_DITH5_CC_Pos 5
#define TCC_CC_DITH5_CC_Msk (_U_(0x7FFFF) << TCC_CC_DITH5_CC_Pos)
#define TCC_CC_DITH5_CC(value) (TCC_CC_DITH5_CC_Msk & ((value) << TCC_CC_DITH5_CC_Pos))
#define TCC_CC_DITH5_MASK _U_(0x00FFFFFF)

// DITH6 mode
#define TCC_CC_DITH6_DITHERCY_Pos 0
#define TCC_CC_DITH6_DITHERCY_Msk (_U_(0x3F) << TCC_CC_DITH6_DITHERCY_Pos)
#define TCC_CC_DITH6_DITHERCY(value) (TCC_CC_DITH6_DITHERCY_Msk & ((value) << TCC_CC_DITH6_DITHERCY_Pos))
#define TCC_CC_DITH6_CC_Pos 6
#define TCC_CC_DITH6_CC_Msk (_U_(0x3FFFF) << TCC_CC_DITH6_CC_Pos)
#define TCC_CC_DITH6_CC(value) (TCC_CC_DITH6_CC_Msk & ((value) << TCC_CC_DITH6_CC_Pos))
#define TCC_CC_DITH6_MASK _U_(0x00FFFFFF)

#define TCC_CC_CC_Pos 0
#define TCC_CC_CC_Msk (_U_(0xFFFFFF) << TCC_CC_CC_Pos)
#define TCC_CC_CC(value) (TCC_CC_CC_Msk & ((value) << TCC_CC_CC_Pos))
#define TCC_CC_MASK _U_(0x00FFFFFF)

/* -------- TCC_PATTB : (TCC Offset: 0x64) (R/W 16) Pattern Buffer -------- */

typedef union {
  struct {
    uint16_t PGEB0:1; /*!< bit:      0  Pattern Generator 0 Output Enable Buffer */
    uint16_t PGEB1:1; /*!< bit:      1  Pattern Generator 1 Output Enable Buffer */
    uint16_t PGEB2:1; /*!< bit:      2  Pattern Generator 2 Output Enable Buffer */
    uint16_t PGEB3:1; /*!< bit:      3  Pattern Generator 3 Output Enable Buffer */
    uint16_t PGEB4:1; /*!< bit:      4  Pattern Generator 4 Output Enable Buffer */
    uint16_t PGEB5:1; /*!< bit:      5  Pattern Generator 5 Output Enable Buffer */
    uint16_t PGEB6:1; /*!< bit:      6  Pattern Generator 6 Output Enable Buffer */
    uint16_t PGEB7:1; /*!< bit:      7  Pattern Generator 7 Output Enable Buffer */
    uint16_t PGVB0:1; /*!< bit:      8  Pattern Generator 0 Output Enable  */
    uint16_t PGVB1:1; /*!< bit:      9  Pattern Generator 1 Output Enable  */
    uint16_t PGVB2:1; /*!< bit:     10  Pattern Generator 2 Output Enable  */
    uint16_t PGVB3:1; /*!< bit:     11  Pattern Generator 3 Output Enable  */
    uint16_t PGVB4:1; /*!< bit:     12  Pattern Generator 4 Output Enable  */
    uint16_t PGVB5:1; /*!< bit:     13  Pattern Generator 5 Output Enable  */
    uint16_t PGVB6:1; /*!< bit:     14  Pattern Generator 6 Output Enable  */
    uint16_t PGVB7:1; /*!< bit:     15  Pattern Generator 7 Output Enable  */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t PGEB:8; /*!< bit:  0.. 7  Pattern Generator x Output Enable Buffer */
    uint16_t PGVB:8; /*!< bit:  8..15  Pattern Generator x Output Enable  */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} TCC_PATTB_Type;


#define TCC_PATTB_OFFSET 0x64
#define TCC_PATTB_RESETVALUE _U_(0x0000)

#define TCC_PATTB_PGEB0_Pos 0
#define TCC_PATTB_PGEB0 (_U_(1) << TCC_PATTB_PGEB0_Pos)
#define TCC_PATTB_PGEB1_Pos 1
#define TCC_PATTB_PGEB1 (_U_(1) << TCC_PATTB_PGEB1_Pos)
#define TCC_PATTB_PGEB2_Pos 2
#define TCC_PATTB_PGEB2 (_U_(1) << TCC_PATTB_PGEB2_Pos)
#define TCC_PATTB_PGEB3_Pos 3
#define TCC_PATTB_PGEB3 (_U_(1) << TCC_PATTB_PGEB3_Pos)
#define TCC_PATTB_PGEB4_Pos 4
#define TCC_PATTB_PGEB4 (_U_(1) << TCC_PATTB_PGEB4_Pos)
#define TCC_PATTB_PGEB5_Pos 5
#define TCC_PATTB_PGEB5 (_U_(1) << TCC_PATTB_PGEB5_Pos)
#define TCC_PATTB_PGEB6_Pos 6
#define TCC_PATTB_PGEB6 (_U_(1) << TCC_PATTB_PGEB6_Pos)
#define TCC_PATTB_PGEB7_Pos 7
#define TCC_PATTB_PGEB7 (_U_(1) << TCC_PATTB_PGEB7_Pos)
#define TCC_PATTB_PGEB_Pos 0
#define TCC_PATTB_PGEB_Msk (_U_(0xFF) << TCC_PATTB_PGEB_Pos)
#define TCC_PATTB_PGEB(value) (TCC_PATTB_PGEB_Msk & ((value) << TCC_PATTB_PGEB_Pos))
#define TCC_PATTB_PGVB0_Pos 8
#define TCC_PATTB_PGVB0 (_U_(1) << TCC_PATTB_PGVB0_Pos)
#define TCC_PATTB_PGVB1_Pos 9
#define TCC_PATTB_PGVB1 (_U_(1) << TCC_PATTB_PGVB1_Pos)
#define TCC_PATTB_PGVB2_Pos 10
#define TCC_PATTB_PGVB2 (_U_(1) << TCC_PATTB_PGVB2_Pos)
#define TCC_PATTB_PGVB3_Pos 11
#define TCC_PATTB_PGVB3 (_U_(1) << TCC_PATTB_PGVB3_Pos)
#define TCC_PATTB_PGVB4_Pos 12
#define TCC_PATTB_PGVB4 (_U_(1) << TCC_PATTB_PGVB4_Pos)
#define TCC_PATTB_PGVB5_Pos 13
#define TCC_PATTB_PGVB5 (_U_(1) << TCC_PATTB_PGVB5_Pos)
#define TCC_PATTB_PGVB6_Pos 14
#define TCC_PATTB_PGVB6 (_U_(1) << TCC_PATTB_PGVB6_Pos)
#define TCC_PATTB_PGVB7_Pos 15
#define TCC_PATTB_PGVB7 (_U_(1) << TCC_PATTB_PGVB7_Pos)
#define TCC_PATTB_PGVB_Pos 8
#define TCC_PATTB_PGVB_Msk (_U_(0xFF) << TCC_PATTB_PGVB_Pos)
#define TCC_PATTB_PGVB(value) (TCC_PATTB_PGVB_Msk & ((value) << TCC_PATTB_PGVB_Pos))
#define TCC_PATTB_MASK _U_(0xFFFF)

/* -------- TCC_WAVEB : (TCC Offset: 0x68) (R/W 32) Waveform Control Buffer -------- */

typedef union {
  struct {
    uint32_t WAVEGENB:3; /*!< bit:  0.. 2  Waveform Generation Buffer         */
    uint32_t :1; /*!< bit:      3  Reserved                           */
    uint32_t RAMPB:2; /*!< bit:  4.. 5  Ramp Mode Buffer                   */
    uint32_t :1; /*!< bit:      6  Reserved                           */
    uint32_t CIPERENB:1; /*!< bit:      7  Circular Period Enable Buffer      */
    uint32_t CICCENB0:1; /*!< bit:      8  Circular Channel 0 Enable Buffer   */
    uint32_t CICCENB1:1; /*!< bit:      9  Circular Channel 1 Enable Buffer   */
    uint32_t CICCENB2:1; /*!< bit:     10  Circular Channel 2 Enable Buffer   */
    uint32_t CICCENB3:1; /*!< bit:     11  Circular Channel 3 Enable Buffer   */
    uint32_t :4; /*!< bit: 12..15  Reserved                           */
    uint32_t POLB0:1; /*!< bit:     16  Channel 0 Polarity Buffer          */
    uint32_t POLB1:1; /*!< bit:     17  Channel 1 Polarity Buffer          */
    uint32_t POLB2:1; /*!< bit:     18  Channel 2 Polarity Buffer          */
    uint32_t POLB3:1; /*!< bit:     19  Channel 3 Polarity Buffer          */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t SWAPB0:1; /*!< bit:     24  Swap DTI Output Pair 0 Buffer      */
    uint32_t SWAPB1:1; /*!< bit:     25  Swap DTI Output Pair 1 Buffer      */
    uint32_t SWAPB2:1; /*!< bit:     26  Swap DTI Output Pair 2 Buffer      */
    uint32_t SWAPB3:1; /*!< bit:     27  Swap DTI Output Pair 3 Buffer      */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint32_t :8; /*!< bit:  0.. 7  Reserved                           */
    uint32_t CICCENB:4; /*!< bit:  8..11  Circular Channel x Enable Buffer   */
    uint32_t :4; /*!< bit: 12..15  Reserved                           */
    uint32_t POLB:4; /*!< bit: 16..19  Channel x Polarity Buffer          */
    uint32_t :4; /*!< bit: 20..23  Reserved                           */
    uint32_t SWAPB:4; /*!< bit: 24..27  Swap DTI Output Pair x Buffer      */
    uint32_t :4; /*!< bit: 28..31  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_WAVEB_Type;


#define TCC_WAVEB_OFFSET 0x68
#define TCC_WAVEB_RESETVALUE _U_(0x00000000)

#define TCC_WAVEB_WAVEGENB_Pos 0
#define TCC_WAVEB_WAVEGENB_Msk (_U_(0x7) << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_WAVEGENB(value) (TCC_WAVEB_WAVEGENB_Msk & ((value) << TCC_WAVEB_WAVEGENB_Pos))
#define TCC_WAVEB_WAVEGENB_NFRQ_Val _U_(0x0)
#define TCC_WAVEB_WAVEGENB_MFRQ_Val _U_(0x1)
#define TCC_WAVEB_WAVEGENB_NPWM_Val _U_(0x2)
#define TCC_WAVEB_WAVEGENB_DSCRITICAL_Val _U_(0x4)
#define TCC_WAVEB_WAVEGENB_DSBOTTOM_Val _U_(0x5)
#define TCC_WAVEB_WAVEGENB_DSBOTH_Val _U_(0x6)
#define TCC_WAVEB_WAVEGENB_DSTOP_Val _U_(0x7)
#define TCC_WAVEB_WAVEGENB_NFRQ (TCC_WAVEB_WAVEGENB_NFRQ_Val << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_WAVEGENB_MFRQ (TCC_WAVEB_WAVEGENB_MFRQ_Val << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_WAVEGENB_NPWM (TCC_WAVEB_WAVEGENB_NPWM_Val << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_WAVEGENB_DSCRITICAL (TCC_WAVEB_WAVEGENB_DSCRITICAL_Val << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_WAVEGENB_DSBOTTOM (TCC_WAVEB_WAVEGENB_DSBOTTOM_Val << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_WAVEGENB_DSBOTH (TCC_WAVEB_WAVEGENB_DSBOTH_Val << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_WAVEGENB_DSTOP (TCC_WAVEB_WAVEGENB_DSTOP_Val << TCC_WAVEB_WAVEGENB_Pos)
#define TCC_WAVEB_RAMPB_Pos 4
#define TCC_WAVEB_RAMPB_Msk (_U_(0x3) << TCC_WAVEB_RAMPB_Pos)
#define TCC_WAVEB_RAMPB(value) (TCC_WAVEB_RAMPB_Msk & ((value) << TCC_WAVEB_RAMPB_Pos))
#define TCC_WAVEB_RAMPB_RAMP1_Val _U_(0x0)
#define TCC_WAVEB_RAMPB_RAMP2A_Val _U_(0x1)
#define TCC_WAVEB_RAMPB_RAMP2_Val _U_(0x2)
#define TCC_WAVEB_RAMPB_RAMP1 (TCC_WAVEB_RAMPB_RAMP1_Val << TCC_WAVEB_RAMPB_Pos)
#define TCC_WAVEB_RAMPB_RAMP2A (TCC_WAVEB_RAMPB_RAMP2A_Val << TCC_WAVEB_RAMPB_Pos)
#define TCC_WAVEB_RAMPB_RAMP2 (TCC_WAVEB_RAMPB_RAMP2_Val << TCC_WAVEB_RAMPB_Pos)
#define TCC_WAVEB_CIPERENB_Pos 7
#define TCC_WAVEB_CIPERENB (_U_(0x1) << TCC_WAVEB_CIPERENB_Pos)
#define TCC_WAVEB_CICCENB0_Pos 8
#define TCC_WAVEB_CICCENB0 (_U_(1) << TCC_WAVEB_CICCENB0_Pos)
#define TCC_WAVEB_CICCENB1_Pos 9
#define TCC_WAVEB_CICCENB1 (_U_(1) << TCC_WAVEB_CICCENB1_Pos)
#define TCC_WAVEB_CICCENB2_Pos 10
#define TCC_WAVEB_CICCENB2 (_U_(1) << TCC_WAVEB_CICCENB2_Pos)
#define TCC_WAVEB_CICCENB3_Pos 11
#define TCC_WAVEB_CICCENB3 (_U_(1) << TCC_WAVEB_CICCENB3_Pos)
#define TCC_WAVEB_CICCENB_Pos 8
#define TCC_WAVEB_CICCENB_Msk (_U_(0xF) << TCC_WAVEB_CICCENB_Pos)
#define TCC_WAVEB_CICCENB(value) (TCC_WAVEB_CICCENB_Msk & ((value) << TCC_WAVEB_CICCENB_Pos))
#define TCC_WAVEB_POLB0_Pos 16
#define TCC_WAVEB_POLB0 (_U_(1) << TCC_WAVEB_POLB0_Pos)
#define TCC_WAVEB_POLB1_Pos 17
#define TCC_WAVEB_POLB1 (_U_(1) << TCC_WAVEB_POLB1_Pos)
#define TCC_WAVEB_POLB2_Pos 18
#define TCC_WAVEB_POLB2 (_U_(1) << TCC_WAVEB_POLB2_Pos)
#define TCC_WAVEB_POLB3_Pos 19
#define TCC_WAVEB_POLB3 (_U_(1) << TCC_WAVEB_POLB3_Pos)
#define TCC_WAVEB_POLB_Pos 16
#define TCC_WAVEB_POLB_Msk (_U_(0xF) << TCC_WAVEB_POLB_Pos)
#define TCC_WAVEB_POLB(value) (TCC_WAVEB_POLB_Msk & ((value) << TCC_WAVEB_POLB_Pos))
#define TCC_WAVEB_SWAPB0_Pos 24
#define TCC_WAVEB_SWAPB0 (_U_(1) << TCC_WAVEB_SWAPB0_Pos)
#define TCC_WAVEB_SWAPB1_Pos 25
#define TCC_WAVEB_SWAPB1 (_U_(1) << TCC_WAVEB_SWAPB1_Pos)
#define TCC_WAVEB_SWAPB2_Pos 26
#define TCC_WAVEB_SWAPB2 (_U_(1) << TCC_WAVEB_SWAPB2_Pos)
#define TCC_WAVEB_SWAPB3_Pos 27
#define TCC_WAVEB_SWAPB3 (_U_(1) << TCC_WAVEB_SWAPB3_Pos)
#define TCC_WAVEB_SWAPB_Pos 24
#define TCC_WAVEB_SWAPB_Msk (_U_(0xF) << TCC_WAVEB_SWAPB_Pos)
#define TCC_WAVEB_SWAPB(value) (TCC_WAVEB_SWAPB_Msk & ((value) << TCC_WAVEB_SWAPB_Pos))
#define TCC_WAVEB_MASK _U_(0x0F0F0FB7)

/* -------- TCC_PERB : (TCC Offset: 0x6C) (R/W 32) Period Buffer -------- */

typedef union {
  struct { // DITH4 mode
    uint32_t DITHERCYB:4; /*!< bit:  0.. 3  Dithering Buffer Cycle Number      */
    uint32_t PERB:20; /*!< bit:  4..23  Period Buffer Value                */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH4; /*!< Structure used for DITH4                        */
  struct { // DITH5 mode
    uint32_t DITHERCYB:5; /*!< bit:  0.. 4  Dithering Buffer Cycle Number      */
    uint32_t PERB:19; /*!< bit:  5..23  Period Buffer Value                */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH5; /*!< Structure used for DITH5                        */
  struct { // DITH6 mode
    uint32_t DITHERCYB:6; /*!< bit:  0.. 5  Dithering Buffer Cycle Number      */
    uint32_t PERB:18; /*!< bit:  6..23  Period Buffer Value                */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH6; /*!< Structure used for DITH6                        */
  struct {
    uint32_t PERB:24; /*!< bit:  0..23  Period Buffer Value                */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_PERB_Type;


#define TCC_PERB_OFFSET 0x6C
#define TCC_PERB_RESETVALUE _U_(0xFFFFFFFF)

// DITH4 mode
#define TCC_PERB_DITH4_DITHERCYB_Pos 0
#define TCC_PERB_DITH4_DITHERCYB_Msk (_U_(0xF) << TCC_PERB_DITH4_DITHERCYB_Pos)
#define TCC_PERB_DITH4_DITHERCYB(value) (TCC_PERB_DITH4_DITHERCYB_Msk & ((value) << TCC_PERB_DITH4_DITHERCYB_Pos))
#define TCC_PERB_DITH4_PERB_Pos 4
#define TCC_PERB_DITH4_PERB_Msk (_U_(0xFFFFF) << TCC_PERB_DITH4_PERB_Pos)
#define TCC_PERB_DITH4_PERB(value) (TCC_PERB_DITH4_PERB_Msk & ((value) << TCC_PERB_DITH4_PERB_Pos))
#define TCC_PERB_DITH4_MASK _U_(0x00FFFFFF)

// DITH5 mode
#define TCC_PERB_DITH5_DITHERCYB_Pos 0
#define TCC_PERB_DITH5_DITHERCYB_Msk (_U_(0x1F) << TCC_PERB_DITH5_DITHERCYB_Pos)
#define TCC_PERB_DITH5_DITHERCYB(value) (TCC_PERB_DITH5_DITHERCYB_Msk & ((value) << TCC_PERB_DITH5_DITHERCYB_Pos))
#define TCC_PERB_DITH5_PERB_Pos 5
#define TCC_PERB_DITH5_PERB_Msk (_U_(0x7FFFF) << TCC_PERB_DITH5_PERB_Pos)
#define TCC_PERB_DITH5_PERB(value) (TCC_PERB_DITH5_PERB_Msk & ((value) << TCC_PERB_DITH5_PERB_Pos))
#define TCC_PERB_DITH5_MASK _U_(0x00FFFFFF)

// DITH6 mode
#define TCC_PERB_DITH6_DITHERCYB_Pos 0
#define TCC_PERB_DITH6_DITHERCYB_Msk (_U_(0x3F) << TCC_PERB_DITH6_DITHERCYB_Pos)
#define TCC_PERB_DITH6_DITHERCYB(value) (TCC_PERB_DITH6_DITHERCYB_Msk & ((value) << TCC_PERB_DITH6_DITHERCYB_Pos))
#define TCC_PERB_DITH6_PERB_Pos 6
#define TCC_PERB_DITH6_PERB_Msk (_U_(0x3FFFF) << TCC_PERB_DITH6_PERB_Pos)
#define TCC_PERB_DITH6_PERB(value) (TCC_PERB_DITH6_PERB_Msk & ((value) << TCC_PERB_DITH6_PERB_Pos))
#define TCC_PERB_DITH6_MASK _U_(0x00FFFFFF)

#define TCC_PERB_PERB_Pos 0
#define TCC_PERB_PERB_Msk (_U_(0xFFFFFF) << TCC_PERB_PERB_Pos)
#define TCC_PERB_PERB(value) (TCC_PERB_PERB_Msk & ((value) << TCC_PERB_PERB_Pos))
#define TCC_PERB_MASK _U_(0x00FFFFFF)

/* -------- TCC_CCB : (TCC Offset: 0x70) (R/W 32) Compare and Capture Buffer -------- */

typedef union {
  struct { // DITH4 mode
    uint32_t DITHERCYB:4; /*!< bit:  0.. 3  Dithering Buffer Cycle Number      */
    uint32_t CCB:20; /*!< bit:  4..23  Channel Compare/Capture Buffer Value */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH4; /*!< Structure used for DITH4                        */
  struct { // DITH5 mode
    uint32_t DITHERCYB:5; /*!< bit:  0.. 4  Dithering Buffer Cycle Number      */
    uint32_t CCB:19; /*!< bit:  5..23  Channel Compare/Capture Buffer Value */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH5; /*!< Structure used for DITH5                        */
  struct { // DITH6 mode
    uint32_t DITHERCYB:6; /*!< bit:  0.. 5  Dithering Buffer Cycle Number      */
    uint32_t CCB:18; /*!< bit:  6..23  Channel Compare/Capture Buffer Value */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } DITH6; /*!< Structure used for DITH6                        */
  struct {
    uint32_t CCB:24; /*!< bit:  0..23  Channel Compare/Capture Buffer Value */
    uint32_t :8; /*!< bit: 24..31  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} TCC_CCB_Type;


#define TCC_CCB_OFFSET 0x70
#define TCC_CCB_RESETVALUE _U_(0x00000000)

// DITH4 mode
#define TCC_CCB_DITH4_DITHERCYB_Pos 0
#define TCC_CCB_DITH4_DITHERCYB_Msk (_U_(0xF) << TCC_CCB_DITH4_DITHERCYB_Pos)
#define TCC_CCB_DITH4_DITHERCYB(value) (TCC_CCB_DITH4_DITHERCYB_Msk & ((value) << TCC_CCB_DITH4_DITHERCYB_Pos))
#define TCC_CCB_DITH4_CCB_Pos 4
#define TCC_CCB_DITH4_CCB_Msk (_U_(0xFFFFF) << TCC_CCB_DITH4_CCB_Pos)
#define TCC_CCB_DITH4_CCB(value) (TCC_CCB_DITH4_CCB_Msk & ((value) << TCC_CCB_DITH4_CCB_Pos))
#define TCC_CCB_DITH4_MASK _U_(0x00FFFFFF)

// DITH5 mode
#define TCC_CCB_DITH5_DITHERCYB_Pos 0
#define TCC_CCB_DITH5_DITHERCYB_Msk (_U_(0x1F) << TCC_CCB_DITH5_DITHERCYB_Pos)
#define TCC_CCB_DITH5_DITHERCYB(value) (TCC_CCB_DITH5_DITHERCYB_Msk & ((value) << TCC_CCB_DITH5_DITHERCYB_Pos))
#define TCC_CCB_DITH5_CCB_Pos 5
#define TCC_CCB_DITH5_CCB_Msk (_U_(0x7FFFF) << TCC_CCB_DITH5_CCB_Pos)
#define TCC_CCB_DITH5_CCB(value) (TCC_CCB_DITH5_CCB_Msk & ((value) << TCC_CCB_DITH5_CCB_Pos))
#define TCC_CCB_DITH5_MASK _U_(0x00FFFFFF)

// DITH6 mode
#define TCC_CCB_DITH6_DITHERCYB_Pos 0
#define TCC_CCB_DITH6_DITHERCYB_Msk (_U_(0x3F) << TCC_CCB_DITH6_DITHERCYB_Pos)
#define TCC_CCB_DITH6_DITHERCYB(value) (TCC_CCB_DITH6_DITHERCYB_Msk & ((value) << TCC_CCB_DITH6_DITHERCYB_Pos))
#define TCC_CCB_DITH6_CCB_Pos 6
#define TCC_CCB_DITH6_CCB_Msk (_U_(0x3FFFF) << TCC_CCB_DITH6_CCB_Pos)
#define TCC_CCB_DITH6_CCB(value) (TCC_CCB_DITH6_CCB_Msk & ((value) << TCC_CCB_DITH6_CCB_Pos))
#define TCC_CCB_DITH6_MASK _U_(0x00FFFFFF)

#define TCC_CCB_CCB_Pos 0
#define TCC_CCB_CCB_Msk (_U_(0xFFFFFF) << TCC_CCB_CCB_Pos)
#define TCC_CCB_CCB(value) (TCC_CCB_CCB_Msk & ((value) << TCC_CCB_CCB_Pos))
#define TCC_CCB_MASK _U_(0x00FFFFFF)

/** \brief TCC hardware registers */

typedef struct {
  volatile TCC_CTRLA_Type CTRLA; /**< \brief Offset: 0x00 (R/W 32) Control A */
  volatile TCC_CTRLBCLR_Type CTRLBCLR; /**< \brief Offset: 0x04 (R/W  8) Control B Clear */
  volatile TCC_CTRLBSET_Type CTRLBSET; /**< \brief Offset: 0x05 (R/W  8) Control B Set */
       RoReg8 Reserved1[0x2];
  volatile const TCC_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x08 (R/  32) Synchronization Busy */
  volatile TCC_FCTRLA_Type FCTRLA; /**< \brief Offset: 0x0C (R/W 32) Recoverable Fault A Configuration */
  volatile TCC_FCTRLB_Type FCTRLB; /**< \brief Offset: 0x10 (R/W 32) Recoverable Fault B Configuration */
  volatile TCC_WEXCTRL_Type WEXCTRL; /**< \brief Offset: 0x14 (R/W 32) Waveform Extension Configuration */
  volatile TCC_DRVCTRL_Type DRVCTRL; /**< \brief Offset: 0x18 (R/W 32) Driver Control */
       RoReg8 Reserved2[0x2];
  volatile TCC_DBGCTRL_Type DBGCTRL; /**< \brief Offset: 0x1E (R/W  8) Debug Control */
       RoReg8 Reserved3[0x1];
  volatile TCC_EVCTRL_Type EVCTRL; /**< \brief Offset: 0x20 (R/W 32) Event Control */
  volatile TCC_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x24 (R/W 32) Interrupt Enable Clear */
  volatile TCC_INTENSET_Type INTENSET; /**< \brief Offset: 0x28 (R/W 32) Interrupt Enable Set */
  volatile TCC_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x2C (R/W 32) Interrupt Flag Status and Clear */
  volatile TCC_STATUS_Type STATUS; /**< \brief Offset: 0x30 (R/W 32) Status */
  volatile TCC_COUNT_Type COUNT; /**< \brief Offset: 0x34 (R/W 32) Count */
  volatile TCC_PATT_Type PATT; /**< \brief Offset: 0x38 (R/W 16) Pattern */
       RoReg8 Reserved4[0x2];
  volatile TCC_WAVE_Type WAVE; /**< \brief Offset: 0x3C (R/W 32) Waveform Control */
  volatile TCC_PER_Type PER; /**< \brief Offset: 0x40 (R/W 32) Period */
  volatile TCC_CC_Type CC[4]; /**< \brief Offset: 0x44 (R/W 32) Compare and Capture */
       RoReg8 Reserved5[0x10];
  volatile TCC_PATTB_Type PATTB; /**< \brief Offset: 0x64 (R/W 16) Pattern Buffer */
       RoReg8 Reserved6[0x2];
  volatile TCC_WAVEB_Type WAVEB; /**< \brief Offset: 0x68 (R/W 32) Waveform Control Buffer */
  volatile TCC_PERB_Type PERB; /**< \brief Offset: 0x6C (R/W 32) Period Buffer */
  volatile TCC_CCB_Type CCB[4]; /**< \brief Offset: 0x70 (R/W 32) Compare and Capture Buffer */
} Tcc;


/*@}*/
# 264 "asf4/samd21/include/samd21e18a.h" 2
#include "component/usb.h"
# 264 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/usb.h" 1
/**
 * \file
 *
 * \brief Component description for USB
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_USB_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR USB */
/* ========================================================================== */
/** \addtogroup SAMD21_USB Universal Serial Bus */
/*@{*/

#define USB_U2222 
#define REV_USB 0x101

/* -------- USB_CTRLA : (USB Offset: 0x000) (R/W  8) Control A -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset                     */
    uint8_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint8_t RUNSTDBY:1; /*!< bit:      2  Run in Standby Mode                */
    uint8_t :4; /*!< bit:  3.. 6  Reserved                           */
    uint8_t MODE:1; /*!< bit:      7  Operating Mode                     */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_CTRLA_Type;


#define USB_CTRLA_OFFSET 0x000
#define USB_CTRLA_RESETVALUE _U_(0x00)

#define USB_CTRLA_SWRST_Pos 0
#define USB_CTRLA_SWRST (_U_(0x1) << USB_CTRLA_SWRST_Pos)
#define USB_CTRLA_ENABLE_Pos 1
#define USB_CTRLA_ENABLE (_U_(0x1) << USB_CTRLA_ENABLE_Pos)
#define USB_CTRLA_RUNSTDBY_Pos 2
#define USB_CTRLA_RUNSTDBY (_U_(0x1) << USB_CTRLA_RUNSTDBY_Pos)
#define USB_CTRLA_MODE_Pos 7
#define USB_CTRLA_MODE (_U_(0x1) << USB_CTRLA_MODE_Pos)
#define USB_CTRLA_MODE_DEVICE_Val _U_(0x0)
#define USB_CTRLA_MODE_HOST_Val _U_(0x1)
#define USB_CTRLA_MODE_DEVICE (USB_CTRLA_MODE_DEVICE_Val << USB_CTRLA_MODE_Pos)
#define USB_CTRLA_MODE_HOST (USB_CTRLA_MODE_HOST_Val << USB_CTRLA_MODE_Pos)
#define USB_CTRLA_MASK _U_(0x87)

/* -------- USB_SYNCBUSY : (USB Offset: 0x002) (R/   8) Synchronization Busy -------- */

typedef union {
  struct {
    uint8_t SWRST:1; /*!< bit:      0  Software Reset Synchronization Busy */
    uint8_t ENABLE:1; /*!< bit:      1  Enable Synchronization Busy        */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_SYNCBUSY_Type;


#define USB_SYNCBUSY_OFFSET 0x002
#define USB_SYNCBUSY_RESETVALUE _U_(0x00)

#define USB_SYNCBUSY_SWRST_Pos 0
#define USB_SYNCBUSY_SWRST (_U_(0x1) << USB_SYNCBUSY_SWRST_Pos)
#define USB_SYNCBUSY_ENABLE_Pos 1
#define USB_SYNCBUSY_ENABLE (_U_(0x1) << USB_SYNCBUSY_ENABLE_Pos)
#define USB_SYNCBUSY_MASK _U_(0x03)

/* -------- USB_QOSCTRL : (USB Offset: 0x003) (R/W  8) USB Quality Of Service -------- */

typedef union {
  struct {
    uint8_t CQOS:2; /*!< bit:  0.. 1  Configuration Quality of Service   */
    uint8_t DQOS:2; /*!< bit:  2.. 3  Data Quality of Service            */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_QOSCTRL_Type;


#define USB_QOSCTRL_OFFSET 0x003
#define USB_QOSCTRL_RESETVALUE _U_(0x05)

#define USB_QOSCTRL_CQOS_Pos 0
#define USB_QOSCTRL_CQOS_Msk (_U_(0x3) << USB_QOSCTRL_CQOS_Pos)
#define USB_QOSCTRL_CQOS(value) (USB_QOSCTRL_CQOS_Msk & ((value) << USB_QOSCTRL_CQOS_Pos))
#define USB_QOSCTRL_CQOS_DISABLE_Val _U_(0x0)
#define USB_QOSCTRL_CQOS_LOW_Val _U_(0x1)
#define USB_QOSCTRL_CQOS_MEDIUM_Val _U_(0x2)
#define USB_QOSCTRL_CQOS_HIGH_Val _U_(0x3)
#define USB_QOSCTRL_CQOS_DISABLE (USB_QOSCTRL_CQOS_DISABLE_Val << USB_QOSCTRL_CQOS_Pos)
#define USB_QOSCTRL_CQOS_LOW (USB_QOSCTRL_CQOS_LOW_Val << USB_QOSCTRL_CQOS_Pos)
#define USB_QOSCTRL_CQOS_MEDIUM (USB_QOSCTRL_CQOS_MEDIUM_Val << USB_QOSCTRL_CQOS_Pos)
#define USB_QOSCTRL_CQOS_HIGH (USB_QOSCTRL_CQOS_HIGH_Val << USB_QOSCTRL_CQOS_Pos)
#define USB_QOSCTRL_DQOS_Pos 2
#define USB_QOSCTRL_DQOS_Msk (_U_(0x3) << USB_QOSCTRL_DQOS_Pos)
#define USB_QOSCTRL_DQOS(value) (USB_QOSCTRL_DQOS_Msk & ((value) << USB_QOSCTRL_DQOS_Pos))
#define USB_QOSCTRL_DQOS_DISABLE_Val _U_(0x0)
#define USB_QOSCTRL_DQOS_LOW_Val _U_(0x1)
#define USB_QOSCTRL_DQOS_MEDIUM_Val _U_(0x2)
#define USB_QOSCTRL_DQOS_HIGH_Val _U_(0x3)
#define USB_QOSCTRL_DQOS_DISABLE (USB_QOSCTRL_DQOS_DISABLE_Val << USB_QOSCTRL_DQOS_Pos)
#define USB_QOSCTRL_DQOS_LOW (USB_QOSCTRL_DQOS_LOW_Val << USB_QOSCTRL_DQOS_Pos)
#define USB_QOSCTRL_DQOS_MEDIUM (USB_QOSCTRL_DQOS_MEDIUM_Val << USB_QOSCTRL_DQOS_Pos)
#define USB_QOSCTRL_DQOS_HIGH (USB_QOSCTRL_DQOS_HIGH_Val << USB_QOSCTRL_DQOS_Pos)
#define USB_QOSCTRL_MASK _U_(0x0F)

/* -------- USB_DEVICE_CTRLB : (USB Offset: 0x008) (R/W 16) DEVICE DEVICE Control B -------- */

typedef union {
  struct {
    uint16_t DETACH:1; /*!< bit:      0  Detach                             */
    uint16_t UPRSM:1; /*!< bit:      1  Upstream Resume                    */
    uint16_t SPDCONF:2; /*!< bit:  2.. 3  Speed Configuration                */
    uint16_t NREPLY:1; /*!< bit:      4  No Reply                           */
    uint16_t TSTJ:1; /*!< bit:      5  Test mode J                        */
    uint16_t TSTK:1; /*!< bit:      6  Test mode K                        */
    uint16_t TSTPCKT:1; /*!< bit:      7  Test packet mode                   */
    uint16_t OPMODE2:1; /*!< bit:      8  Specific Operational Mode          */
    uint16_t GNAK:1; /*!< bit:      9  Global NAK                         */
    uint16_t LPMHDSK:2; /*!< bit: 10..11  Link Power Management Handshake    */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_DEVICE_CTRLB_Type;


#define USB_DEVICE_CTRLB_OFFSET 0x008
#define USB_DEVICE_CTRLB_RESETVALUE _U_(0x0001)

#define USB_DEVICE_CTRLB_DETACH_Pos 0
#define USB_DEVICE_CTRLB_DETACH (_U_(0x1) << USB_DEVICE_CTRLB_DETACH_Pos)
#define USB_DEVICE_CTRLB_UPRSM_Pos 1
#define USB_DEVICE_CTRLB_UPRSM (_U_(0x1) << USB_DEVICE_CTRLB_UPRSM_Pos)
#define USB_DEVICE_CTRLB_SPDCONF_Pos 2
#define USB_DEVICE_CTRLB_SPDCONF_Msk (_U_(0x3) << USB_DEVICE_CTRLB_SPDCONF_Pos)
#define USB_DEVICE_CTRLB_SPDCONF(value) (USB_DEVICE_CTRLB_SPDCONF_Msk & ((value) << USB_DEVICE_CTRLB_SPDCONF_Pos))
#define USB_DEVICE_CTRLB_SPDCONF_FS_Val _U_(0x0)
#define USB_DEVICE_CTRLB_SPDCONF_LS_Val _U_(0x1)
#define USB_DEVICE_CTRLB_SPDCONF_HS_Val _U_(0x2)
#define USB_DEVICE_CTRLB_SPDCONF_HSTM_Val _U_(0x3)
#define USB_DEVICE_CTRLB_SPDCONF_FS (USB_DEVICE_CTRLB_SPDCONF_FS_Val << USB_DEVICE_CTRLB_SPDCONF_Pos)
#define USB_DEVICE_CTRLB_SPDCONF_LS (USB_DEVICE_CTRLB_SPDCONF_LS_Val << USB_DEVICE_CTRLB_SPDCONF_Pos)
#define USB_DEVICE_CTRLB_SPDCONF_HS (USB_DEVICE_CTRLB_SPDCONF_HS_Val << USB_DEVICE_CTRLB_SPDCONF_Pos)
#define USB_DEVICE_CTRLB_SPDCONF_HSTM (USB_DEVICE_CTRLB_SPDCONF_HSTM_Val << USB_DEVICE_CTRLB_SPDCONF_Pos)
#define USB_DEVICE_CTRLB_NREPLY_Pos 4
#define USB_DEVICE_CTRLB_NREPLY (_U_(0x1) << USB_DEVICE_CTRLB_NREPLY_Pos)
#define USB_DEVICE_CTRLB_TSTJ_Pos 5
#define USB_DEVICE_CTRLB_TSTJ (_U_(0x1) << USB_DEVICE_CTRLB_TSTJ_Pos)
#define USB_DEVICE_CTRLB_TSTK_Pos 6
#define USB_DEVICE_CTRLB_TSTK (_U_(0x1) << USB_DEVICE_CTRLB_TSTK_Pos)
#define USB_DEVICE_CTRLB_TSTPCKT_Pos 7
#define USB_DEVICE_CTRLB_TSTPCKT (_U_(0x1) << USB_DEVICE_CTRLB_TSTPCKT_Pos)
#define USB_DEVICE_CTRLB_OPMODE2_Pos 8
#define USB_DEVICE_CTRLB_OPMODE2 (_U_(0x1) << USB_DEVICE_CTRLB_OPMODE2_Pos)
#define USB_DEVICE_CTRLB_GNAK_Pos 9
#define USB_DEVICE_CTRLB_GNAK (_U_(0x1) << USB_DEVICE_CTRLB_GNAK_Pos)
#define USB_DEVICE_CTRLB_LPMHDSK_Pos 10
#define USB_DEVICE_CTRLB_LPMHDSK_Msk (_U_(0x3) << USB_DEVICE_CTRLB_LPMHDSK_Pos)
#define USB_DEVICE_CTRLB_LPMHDSK(value) (USB_DEVICE_CTRLB_LPMHDSK_Msk & ((value) << USB_DEVICE_CTRLB_LPMHDSK_Pos))
#define USB_DEVICE_CTRLB_LPMHDSK_NO_Val _U_(0x0)
#define USB_DEVICE_CTRLB_LPMHDSK_ACK_Val _U_(0x1)
#define USB_DEVICE_CTRLB_LPMHDSK_NYET_Val _U_(0x2)
#define USB_DEVICE_CTRLB_LPMHDSK_STALL_Val _U_(0x3)
#define USB_DEVICE_CTRLB_LPMHDSK_NO (USB_DEVICE_CTRLB_LPMHDSK_NO_Val << USB_DEVICE_CTRLB_LPMHDSK_Pos)
#define USB_DEVICE_CTRLB_LPMHDSK_ACK (USB_DEVICE_CTRLB_LPMHDSK_ACK_Val << USB_DEVICE_CTRLB_LPMHDSK_Pos)
#define USB_DEVICE_CTRLB_LPMHDSK_NYET (USB_DEVICE_CTRLB_LPMHDSK_NYET_Val << USB_DEVICE_CTRLB_LPMHDSK_Pos)
#define USB_DEVICE_CTRLB_LPMHDSK_STALL (USB_DEVICE_CTRLB_LPMHDSK_STALL_Val << USB_DEVICE_CTRLB_LPMHDSK_Pos)
#define USB_DEVICE_CTRLB_MASK _U_(0x0FFF)

/* -------- USB_HOST_CTRLB : (USB Offset: 0x008) (R/W 16) HOST HOST Control B -------- */

typedef union {
  struct {
    uint16_t :1; /*!< bit:      0  Reserved                           */
    uint16_t RESUME:1; /*!< bit:      1  Send USB Resume                    */
    uint16_t SPDCONF:2; /*!< bit:  2.. 3  Speed Configuration for Host       */
    uint16_t :1; /*!< bit:      4  Reserved                           */
    uint16_t TSTJ:1; /*!< bit:      5  Test mode J                        */
    uint16_t TSTK:1; /*!< bit:      6  Test mode K                        */
    uint16_t :1; /*!< bit:      7  Reserved                           */
    uint16_t SOFE:1; /*!< bit:      8  Start of Frame Generation Enable   */
    uint16_t BUSRESET:1; /*!< bit:      9  Send USB Reset                     */
    uint16_t VBUSOK:1; /*!< bit:     10  VBUS is OK                         */
    uint16_t L1RESUME:1; /*!< bit:     11  Send L1 Resume                     */
    uint16_t :4; /*!< bit: 12..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_CTRLB_Type;


#define USB_HOST_CTRLB_OFFSET 0x008
#define USB_HOST_CTRLB_RESETVALUE _U_(0x0000)

#define USB_HOST_CTRLB_RESUME_Pos 1
#define USB_HOST_CTRLB_RESUME (_U_(0x1) << USB_HOST_CTRLB_RESUME_Pos)
#define USB_HOST_CTRLB_SPDCONF_Pos 2
#define USB_HOST_CTRLB_SPDCONF_Msk (_U_(0x3) << USB_HOST_CTRLB_SPDCONF_Pos)
#define USB_HOST_CTRLB_SPDCONF(value) (USB_HOST_CTRLB_SPDCONF_Msk & ((value) << USB_HOST_CTRLB_SPDCONF_Pos))
#define USB_HOST_CTRLB_SPDCONF_NORMAL_Val _U_(0x0)
#define USB_HOST_CTRLB_SPDCONF_FS_Val _U_(0x3)
#define USB_HOST_CTRLB_SPDCONF_NORMAL (USB_HOST_CTRLB_SPDCONF_NORMAL_Val << USB_HOST_CTRLB_SPDCONF_Pos)
#define USB_HOST_CTRLB_SPDCONF_FS (USB_HOST_CTRLB_SPDCONF_FS_Val << USB_HOST_CTRLB_SPDCONF_Pos)
#define USB_HOST_CTRLB_TSTJ_Pos 5
#define USB_HOST_CTRLB_TSTJ (_U_(0x1) << USB_HOST_CTRLB_TSTJ_Pos)
#define USB_HOST_CTRLB_TSTK_Pos 6
#define USB_HOST_CTRLB_TSTK (_U_(0x1) << USB_HOST_CTRLB_TSTK_Pos)
#define USB_HOST_CTRLB_SOFE_Pos 8
#define USB_HOST_CTRLB_SOFE (_U_(0x1) << USB_HOST_CTRLB_SOFE_Pos)
#define USB_HOST_CTRLB_BUSRESET_Pos 9
#define USB_HOST_CTRLB_BUSRESET (_U_(0x1) << USB_HOST_CTRLB_BUSRESET_Pos)
#define USB_HOST_CTRLB_VBUSOK_Pos 10
#define USB_HOST_CTRLB_VBUSOK (_U_(0x1) << USB_HOST_CTRLB_VBUSOK_Pos)
#define USB_HOST_CTRLB_L1RESUME_Pos 11
#define USB_HOST_CTRLB_L1RESUME (_U_(0x1) << USB_HOST_CTRLB_L1RESUME_Pos)
#define USB_HOST_CTRLB_MASK _U_(0x0F6E)

/* -------- USB_DEVICE_DADD : (USB Offset: 0x00A) (R/W  8) DEVICE DEVICE Device Address -------- */

typedef union {
  struct {
    uint8_t DADD:7; /*!< bit:  0.. 6  Device Address                     */
    uint8_t ADDEN:1; /*!< bit:      7  Device Address Enable              */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_DADD_Type;


#define USB_DEVICE_DADD_OFFSET 0x00A
#define USB_DEVICE_DADD_RESETVALUE _U_(0x00)

#define USB_DEVICE_DADD_DADD_Pos 0
#define USB_DEVICE_DADD_DADD_Msk (_U_(0x7F) << USB_DEVICE_DADD_DADD_Pos)
#define USB_DEVICE_DADD_DADD(value) (USB_DEVICE_DADD_DADD_Msk & ((value) << USB_DEVICE_DADD_DADD_Pos))
#define USB_DEVICE_DADD_ADDEN_Pos 7
#define USB_DEVICE_DADD_ADDEN (_U_(0x1) << USB_DEVICE_DADD_ADDEN_Pos)
#define USB_DEVICE_DADD_MASK _U_(0xFF)

/* -------- USB_HOST_HSOFC : (USB Offset: 0x00A) (R/W  8) HOST HOST Host Start Of Frame Control -------- */

typedef union {
  struct {
    uint8_t FLENC:4; /*!< bit:  0.. 3  Frame Length Control               */
    uint8_t :3; /*!< bit:  4.. 6  Reserved                           */
    uint8_t FLENCE:1; /*!< bit:      7  Frame Length Control Enable        */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_HSOFC_Type;


#define USB_HOST_HSOFC_OFFSET 0x00A
#define USB_HOST_HSOFC_RESETVALUE _U_(0x00)

#define USB_HOST_HSOFC_FLENC_Pos 0
#define USB_HOST_HSOFC_FLENC_Msk (_U_(0xF) << USB_HOST_HSOFC_FLENC_Pos)
#define USB_HOST_HSOFC_FLENC(value) (USB_HOST_HSOFC_FLENC_Msk & ((value) << USB_HOST_HSOFC_FLENC_Pos))
#define USB_HOST_HSOFC_FLENCE_Pos 7
#define USB_HOST_HSOFC_FLENCE (_U_(0x1) << USB_HOST_HSOFC_FLENCE_Pos)
#define USB_HOST_HSOFC_MASK _U_(0x8F)

/* -------- USB_DEVICE_STATUS : (USB Offset: 0x00C) (R/   8) DEVICE DEVICE Status -------- */

typedef union {
  struct {
    uint8_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint8_t SPEED:2; /*!< bit:  2.. 3  Speed Status                       */
    uint8_t :2; /*!< bit:  4.. 5  Reserved                           */
    uint8_t LINESTATE:2; /*!< bit:  6.. 7  USB Line State Status              */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_STATUS_Type;


#define USB_DEVICE_STATUS_OFFSET 0x00C
#define USB_DEVICE_STATUS_RESETVALUE _U_(0x40)

#define USB_DEVICE_STATUS_SPEED_Pos 2
#define USB_DEVICE_STATUS_SPEED_Msk (_U_(0x3) << USB_DEVICE_STATUS_SPEED_Pos)
#define USB_DEVICE_STATUS_SPEED(value) (USB_DEVICE_STATUS_SPEED_Msk & ((value) << USB_DEVICE_STATUS_SPEED_Pos))
#define USB_DEVICE_STATUS_SPEED_FS_Val _U_(0x0)
#define USB_DEVICE_STATUS_SPEED_HS_Val _U_(0x1)
#define USB_DEVICE_STATUS_SPEED_LS_Val _U_(0x2)
#define USB_DEVICE_STATUS_SPEED_FS (USB_DEVICE_STATUS_SPEED_FS_Val << USB_DEVICE_STATUS_SPEED_Pos)
#define USB_DEVICE_STATUS_SPEED_HS (USB_DEVICE_STATUS_SPEED_HS_Val << USB_DEVICE_STATUS_SPEED_Pos)
#define USB_DEVICE_STATUS_SPEED_LS (USB_DEVICE_STATUS_SPEED_LS_Val << USB_DEVICE_STATUS_SPEED_Pos)
#define USB_DEVICE_STATUS_LINESTATE_Pos 6
#define USB_DEVICE_STATUS_LINESTATE_Msk (_U_(0x3) << USB_DEVICE_STATUS_LINESTATE_Pos)
#define USB_DEVICE_STATUS_LINESTATE(value) (USB_DEVICE_STATUS_LINESTATE_Msk & ((value) << USB_DEVICE_STATUS_LINESTATE_Pos))
#define USB_DEVICE_STATUS_LINESTATE_0_Val _U_(0x0)
#define USB_DEVICE_STATUS_LINESTATE_1_Val _U_(0x1)
#define USB_DEVICE_STATUS_LINESTATE_2_Val _U_(0x2)
#define USB_DEVICE_STATUS_LINESTATE_0 (USB_DEVICE_STATUS_LINESTATE_0_Val << USB_DEVICE_STATUS_LINESTATE_Pos)
#define USB_DEVICE_STATUS_LINESTATE_1 (USB_DEVICE_STATUS_LINESTATE_1_Val << USB_DEVICE_STATUS_LINESTATE_Pos)
#define USB_DEVICE_STATUS_LINESTATE_2 (USB_DEVICE_STATUS_LINESTATE_2_Val << USB_DEVICE_STATUS_LINESTATE_Pos)
#define USB_DEVICE_STATUS_MASK _U_(0xCC)

/* -------- USB_HOST_STATUS : (USB Offset: 0x00C) (R/W  8) HOST HOST Status -------- */

typedef union {
  struct {
    uint8_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint8_t SPEED:2; /*!< bit:  2.. 3  Speed Status                       */
    uint8_t :2; /*!< bit:  4.. 5  Reserved                           */
    uint8_t LINESTATE:2; /*!< bit:  6.. 7  USB Line State Status              */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_STATUS_Type;


#define USB_HOST_STATUS_OFFSET 0x00C
#define USB_HOST_STATUS_RESETVALUE _U_(0x00)

#define USB_HOST_STATUS_SPEED_Pos 2
#define USB_HOST_STATUS_SPEED_Msk (_U_(0x3) << USB_HOST_STATUS_SPEED_Pos)
#define USB_HOST_STATUS_SPEED(value) (USB_HOST_STATUS_SPEED_Msk & ((value) << USB_HOST_STATUS_SPEED_Pos))
#define USB_HOST_STATUS_LINESTATE_Pos 6
#define USB_HOST_STATUS_LINESTATE_Msk (_U_(0x3) << USB_HOST_STATUS_LINESTATE_Pos)
#define USB_HOST_STATUS_LINESTATE(value) (USB_HOST_STATUS_LINESTATE_Msk & ((value) << USB_HOST_STATUS_LINESTATE_Pos))
#define USB_HOST_STATUS_MASK _U_(0xCC)

/* -------- USB_FSMSTATUS : (USB Offset: 0x00D) (R/   8) Finite State Machine Status -------- */

typedef union {
  struct {
    uint8_t FSMSTATE:7; /*!< bit:  0.. 6  Fine State Machine Status          */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_FSMSTATUS_Type;


#define USB_FSMSTATUS_OFFSET 0x00D
#define USB_FSMSTATUS_RESETVALUE _U_(0x01)

#define USB_FSMSTATUS_FSMSTATE_Pos 0
#define USB_FSMSTATUS_FSMSTATE_Msk (_U_(0x7F) << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_FSMSTATE(value) (USB_FSMSTATUS_FSMSTATE_Msk & ((value) << USB_FSMSTATUS_FSMSTATE_Pos))
#define USB_FSMSTATUS_FSMSTATE_OFF_Val _U_(0x1)
#define USB_FSMSTATUS_FSMSTATE_ON_Val _U_(0x2)
#define USB_FSMSTATUS_FSMSTATE_SUSPEND_Val _U_(0x4)
#define USB_FSMSTATUS_FSMSTATE_SLEEP_Val _U_(0x8)
#define USB_FSMSTATUS_FSMSTATE_DNRESUME_Val _U_(0x10)
#define USB_FSMSTATUS_FSMSTATE_UPRESUME_Val _U_(0x20)
#define USB_FSMSTATUS_FSMSTATE_RESET_Val _U_(0x40)
#define USB_FSMSTATUS_FSMSTATE_OFF (USB_FSMSTATUS_FSMSTATE_OFF_Val << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_FSMSTATE_ON (USB_FSMSTATUS_FSMSTATE_ON_Val << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_FSMSTATE_SUSPEND (USB_FSMSTATUS_FSMSTATE_SUSPEND_Val << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_FSMSTATE_SLEEP (USB_FSMSTATUS_FSMSTATE_SLEEP_Val << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_FSMSTATE_DNRESUME (USB_FSMSTATUS_FSMSTATE_DNRESUME_Val << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_FSMSTATE_UPRESUME (USB_FSMSTATUS_FSMSTATE_UPRESUME_Val << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_FSMSTATE_RESET (USB_FSMSTATUS_FSMSTATE_RESET_Val << USB_FSMSTATUS_FSMSTATE_Pos)
#define USB_FSMSTATUS_MASK _U_(0x7F)

/* -------- USB_DEVICE_FNUM : (USB Offset: 0x010) (R/  16) DEVICE DEVICE Device Frame Number -------- */

typedef union {
  struct {
    uint16_t MFNUM:3; /*!< bit:  0.. 2  Micro Frame Number                 */
    uint16_t FNUM:11; /*!< bit:  3..13  Frame Number                       */
    uint16_t :1; /*!< bit:     14  Reserved                           */
    uint16_t FNCERR:1; /*!< bit:     15  Frame Number CRC Error             */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_DEVICE_FNUM_Type;


#define USB_DEVICE_FNUM_OFFSET 0x010
#define USB_DEVICE_FNUM_RESETVALUE _U_(0x0000)

#define USB_DEVICE_FNUM_MFNUM_Pos 0
#define USB_DEVICE_FNUM_MFNUM_Msk (_U_(0x7) << USB_DEVICE_FNUM_MFNUM_Pos)
#define USB_DEVICE_FNUM_MFNUM(value) (USB_DEVICE_FNUM_MFNUM_Msk & ((value) << USB_DEVICE_FNUM_MFNUM_Pos))
#define USB_DEVICE_FNUM_FNUM_Pos 3
#define USB_DEVICE_FNUM_FNUM_Msk (_U_(0x7FF) << USB_DEVICE_FNUM_FNUM_Pos)
#define USB_DEVICE_FNUM_FNUM(value) (USB_DEVICE_FNUM_FNUM_Msk & ((value) << USB_DEVICE_FNUM_FNUM_Pos))
#define USB_DEVICE_FNUM_FNCERR_Pos 15
#define USB_DEVICE_FNUM_FNCERR (_U_(0x1) << USB_DEVICE_FNUM_FNCERR_Pos)
#define USB_DEVICE_FNUM_MASK _U_(0xBFFF)

/* -------- USB_HOST_FNUM : (USB Offset: 0x010) (R/W 16) HOST HOST Host Frame Number -------- */

typedef union {
  struct {
    uint16_t MFNUM:3; /*!< bit:  0.. 2  Micro Frame Number                 */
    uint16_t FNUM:11; /*!< bit:  3..13  Frame Number                       */
    uint16_t :2; /*!< bit: 14..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_FNUM_Type;


#define USB_HOST_FNUM_OFFSET 0x010
#define USB_HOST_FNUM_RESETVALUE _U_(0x0000)

#define USB_HOST_FNUM_MFNUM_Pos 0
#define USB_HOST_FNUM_MFNUM_Msk (_U_(0x7) << USB_HOST_FNUM_MFNUM_Pos)
#define USB_HOST_FNUM_MFNUM(value) (USB_HOST_FNUM_MFNUM_Msk & ((value) << USB_HOST_FNUM_MFNUM_Pos))
#define USB_HOST_FNUM_FNUM_Pos 3
#define USB_HOST_FNUM_FNUM_Msk (_U_(0x7FF) << USB_HOST_FNUM_FNUM_Pos)
#define USB_HOST_FNUM_FNUM(value) (USB_HOST_FNUM_FNUM_Msk & ((value) << USB_HOST_FNUM_FNUM_Pos))
#define USB_HOST_FNUM_MASK _U_(0x3FFF)

/* -------- USB_HOST_FLENHIGH : (USB Offset: 0x012) (R/   8) HOST HOST Host Frame Length -------- */

typedef union {
  struct {
    uint8_t FLENHIGH:8; /*!< bit:  0.. 7  Frame Length                       */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_FLENHIGH_Type;


#define USB_HOST_FLENHIGH_OFFSET 0x012
#define USB_HOST_FLENHIGH_RESETVALUE _U_(0x00)

#define USB_HOST_FLENHIGH_FLENHIGH_Pos 0
#define USB_HOST_FLENHIGH_FLENHIGH_Msk (_U_(0xFF) << USB_HOST_FLENHIGH_FLENHIGH_Pos)
#define USB_HOST_FLENHIGH_FLENHIGH(value) (USB_HOST_FLENHIGH_FLENHIGH_Msk & ((value) << USB_HOST_FLENHIGH_FLENHIGH_Pos))
#define USB_HOST_FLENHIGH_MASK _U_(0xFF)

/* -------- USB_DEVICE_INTENCLR : (USB Offset: 0x014) (R/W 16) DEVICE DEVICE Device Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint16_t SUSPEND:1; /*!< bit:      0  Suspend Interrupt Enable           */
    uint16_t MSOF:1; /*!< bit:      1  Micro Start of Frame Interrupt Enable in High Speed Mode */
    uint16_t SOF:1; /*!< bit:      2  Start Of Frame Interrupt Enable    */
    uint16_t EORST:1; /*!< bit:      3  End of Reset Interrupt Enable      */
    uint16_t WAKEUP:1; /*!< bit:      4  Wake Up Interrupt Enable           */
    uint16_t EORSM:1; /*!< bit:      5  End Of Resume Interrupt Enable     */
    uint16_t UPRSM:1; /*!< bit:      6  Upstream Resume Interrupt Enable   */
    uint16_t RAMACER:1; /*!< bit:      7  Ram Access Interrupt Enable        */
    uint16_t LPMNYET:1; /*!< bit:      8  Link Power Management Not Yet Interrupt Enable */
    uint16_t LPMSUSP:1; /*!< bit:      9  Link Power Management Suspend Interrupt Enable */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_DEVICE_INTENCLR_Type;


#define USB_DEVICE_INTENCLR_OFFSET 0x014
#define USB_DEVICE_INTENCLR_RESETVALUE _U_(0x0000)

#define USB_DEVICE_INTENCLR_SUSPEND_Pos 0
#define USB_DEVICE_INTENCLR_SUSPEND (_U_(0x1) << USB_DEVICE_INTENCLR_SUSPEND_Pos)
#define USB_DEVICE_INTENCLR_MSOF_Pos 1
#define USB_DEVICE_INTENCLR_MSOF (_U_(0x1) << USB_DEVICE_INTENCLR_MSOF_Pos)
#define USB_DEVICE_INTENCLR_SOF_Pos 2
#define USB_DEVICE_INTENCLR_SOF (_U_(0x1) << USB_DEVICE_INTENCLR_SOF_Pos)
#define USB_DEVICE_INTENCLR_EORST_Pos 3
#define USB_DEVICE_INTENCLR_EORST (_U_(0x1) << USB_DEVICE_INTENCLR_EORST_Pos)
#define USB_DEVICE_INTENCLR_WAKEUP_Pos 4
#define USB_DEVICE_INTENCLR_WAKEUP (_U_(0x1) << USB_DEVICE_INTENCLR_WAKEUP_Pos)
#define USB_DEVICE_INTENCLR_EORSM_Pos 5
#define USB_DEVICE_INTENCLR_EORSM (_U_(0x1) << USB_DEVICE_INTENCLR_EORSM_Pos)
#define USB_DEVICE_INTENCLR_UPRSM_Pos 6
#define USB_DEVICE_INTENCLR_UPRSM (_U_(0x1) << USB_DEVICE_INTENCLR_UPRSM_Pos)
#define USB_DEVICE_INTENCLR_RAMACER_Pos 7
#define USB_DEVICE_INTENCLR_RAMACER (_U_(0x1) << USB_DEVICE_INTENCLR_RAMACER_Pos)
#define USB_DEVICE_INTENCLR_LPMNYET_Pos 8
#define USB_DEVICE_INTENCLR_LPMNYET (_U_(0x1) << USB_DEVICE_INTENCLR_LPMNYET_Pos)
#define USB_DEVICE_INTENCLR_LPMSUSP_Pos 9
#define USB_DEVICE_INTENCLR_LPMSUSP (_U_(0x1) << USB_DEVICE_INTENCLR_LPMSUSP_Pos)
#define USB_DEVICE_INTENCLR_MASK _U_(0x03FF)

/* -------- USB_HOST_INTENCLR : (USB Offset: 0x014) (R/W 16) HOST HOST Host Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint16_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint16_t HSOF:1; /*!< bit:      2  Host Start Of Frame Interrupt Disable */
    uint16_t RST:1; /*!< bit:      3  BUS Reset Interrupt Disable        */
    uint16_t WAKEUP:1; /*!< bit:      4  Wake Up Interrupt Disable          */
    uint16_t DNRSM:1; /*!< bit:      5  DownStream to Device Interrupt Disable */
    uint16_t UPRSM:1; /*!< bit:      6  Upstream Resume from Device Interrupt Disable */
    uint16_t RAMACER:1; /*!< bit:      7  Ram Access Interrupt Disable       */
    uint16_t DCONN:1; /*!< bit:      8  Device Connection Interrupt Disable */
    uint16_t DDISC:1; /*!< bit:      9  Device Disconnection Interrupt Disable */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_INTENCLR_Type;


#define USB_HOST_INTENCLR_OFFSET 0x014
#define USB_HOST_INTENCLR_RESETVALUE _U_(0x0000)

#define USB_HOST_INTENCLR_HSOF_Pos 2
#define USB_HOST_INTENCLR_HSOF (_U_(0x1) << USB_HOST_INTENCLR_HSOF_Pos)
#define USB_HOST_INTENCLR_RST_Pos 3
#define USB_HOST_INTENCLR_RST (_U_(0x1) << USB_HOST_INTENCLR_RST_Pos)
#define USB_HOST_INTENCLR_WAKEUP_Pos 4
#define USB_HOST_INTENCLR_WAKEUP (_U_(0x1) << USB_HOST_INTENCLR_WAKEUP_Pos)
#define USB_HOST_INTENCLR_DNRSM_Pos 5
#define USB_HOST_INTENCLR_DNRSM (_U_(0x1) << USB_HOST_INTENCLR_DNRSM_Pos)
#define USB_HOST_INTENCLR_UPRSM_Pos 6
#define USB_HOST_INTENCLR_UPRSM (_U_(0x1) << USB_HOST_INTENCLR_UPRSM_Pos)
#define USB_HOST_INTENCLR_RAMACER_Pos 7
#define USB_HOST_INTENCLR_RAMACER (_U_(0x1) << USB_HOST_INTENCLR_RAMACER_Pos)
#define USB_HOST_INTENCLR_DCONN_Pos 8
#define USB_HOST_INTENCLR_DCONN (_U_(0x1) << USB_HOST_INTENCLR_DCONN_Pos)
#define USB_HOST_INTENCLR_DDISC_Pos 9
#define USB_HOST_INTENCLR_DDISC (_U_(0x1) << USB_HOST_INTENCLR_DDISC_Pos)
#define USB_HOST_INTENCLR_MASK _U_(0x03FC)

/* -------- USB_DEVICE_INTENSET : (USB Offset: 0x018) (R/W 16) DEVICE DEVICE Device Interrupt Enable Set -------- */

typedef union {
  struct {
    uint16_t SUSPEND:1; /*!< bit:      0  Suspend Interrupt Enable           */
    uint16_t MSOF:1; /*!< bit:      1  Micro Start of Frame Interrupt Enable in High Speed Mode */
    uint16_t SOF:1; /*!< bit:      2  Start Of Frame Interrupt Enable    */
    uint16_t EORST:1; /*!< bit:      3  End of Reset Interrupt Enable      */
    uint16_t WAKEUP:1; /*!< bit:      4  Wake Up Interrupt Enable           */
    uint16_t EORSM:1; /*!< bit:      5  End Of Resume Interrupt Enable     */
    uint16_t UPRSM:1; /*!< bit:      6  Upstream Resume Interrupt Enable   */
    uint16_t RAMACER:1; /*!< bit:      7  Ram Access Interrupt Enable        */
    uint16_t LPMNYET:1; /*!< bit:      8  Link Power Management Not Yet Interrupt Enable */
    uint16_t LPMSUSP:1; /*!< bit:      9  Link Power Management Suspend Interrupt Enable */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_DEVICE_INTENSET_Type;


#define USB_DEVICE_INTENSET_OFFSET 0x018
#define USB_DEVICE_INTENSET_RESETVALUE _U_(0x0000)

#define USB_DEVICE_INTENSET_SUSPEND_Pos 0
#define USB_DEVICE_INTENSET_SUSPEND (_U_(0x1) << USB_DEVICE_INTENSET_SUSPEND_Pos)
#define USB_DEVICE_INTENSET_MSOF_Pos 1
#define USB_DEVICE_INTENSET_MSOF (_U_(0x1) << USB_DEVICE_INTENSET_MSOF_Pos)
#define USB_DEVICE_INTENSET_SOF_Pos 2
#define USB_DEVICE_INTENSET_SOF (_U_(0x1) << USB_DEVICE_INTENSET_SOF_Pos)
#define USB_DEVICE_INTENSET_EORST_Pos 3
#define USB_DEVICE_INTENSET_EORST (_U_(0x1) << USB_DEVICE_INTENSET_EORST_Pos)
#define USB_DEVICE_INTENSET_WAKEUP_Pos 4
#define USB_DEVICE_INTENSET_WAKEUP (_U_(0x1) << USB_DEVICE_INTENSET_WAKEUP_Pos)
#define USB_DEVICE_INTENSET_EORSM_Pos 5
#define USB_DEVICE_INTENSET_EORSM (_U_(0x1) << USB_DEVICE_INTENSET_EORSM_Pos)
#define USB_DEVICE_INTENSET_UPRSM_Pos 6
#define USB_DEVICE_INTENSET_UPRSM (_U_(0x1) << USB_DEVICE_INTENSET_UPRSM_Pos)
#define USB_DEVICE_INTENSET_RAMACER_Pos 7
#define USB_DEVICE_INTENSET_RAMACER (_U_(0x1) << USB_DEVICE_INTENSET_RAMACER_Pos)
#define USB_DEVICE_INTENSET_LPMNYET_Pos 8
#define USB_DEVICE_INTENSET_LPMNYET (_U_(0x1) << USB_DEVICE_INTENSET_LPMNYET_Pos)
#define USB_DEVICE_INTENSET_LPMSUSP_Pos 9
#define USB_DEVICE_INTENSET_LPMSUSP (_U_(0x1) << USB_DEVICE_INTENSET_LPMSUSP_Pos)
#define USB_DEVICE_INTENSET_MASK _U_(0x03FF)

/* -------- USB_HOST_INTENSET : (USB Offset: 0x018) (R/W 16) HOST HOST Host Interrupt Enable Set -------- */

typedef union {
  struct {
    uint16_t :2; /*!< bit:  0.. 1  Reserved                           */
    uint16_t HSOF:1; /*!< bit:      2  Host Start Of Frame Interrupt Enable */
    uint16_t RST:1; /*!< bit:      3  Bus Reset Interrupt Enable         */
    uint16_t WAKEUP:1; /*!< bit:      4  Wake Up Interrupt Enable           */
    uint16_t DNRSM:1; /*!< bit:      5  DownStream to the Device Interrupt Enable */
    uint16_t UPRSM:1; /*!< bit:      6  Upstream Resume fromthe device Interrupt Enable */
    uint16_t RAMACER:1; /*!< bit:      7  Ram Access Interrupt Enable        */
    uint16_t DCONN:1; /*!< bit:      8  Link Power Management Interrupt Enable */
    uint16_t DDISC:1; /*!< bit:      9  Device Disconnection Interrupt Enable */
    uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_INTENSET_Type;


#define USB_HOST_INTENSET_OFFSET 0x018
#define USB_HOST_INTENSET_RESETVALUE _U_(0x0000)

#define USB_HOST_INTENSET_HSOF_Pos 2
#define USB_HOST_INTENSET_HSOF (_U_(0x1) << USB_HOST_INTENSET_HSOF_Pos)
#define USB_HOST_INTENSET_RST_Pos 3
#define USB_HOST_INTENSET_RST (_U_(0x1) << USB_HOST_INTENSET_RST_Pos)
#define USB_HOST_INTENSET_WAKEUP_Pos 4
#define USB_HOST_INTENSET_WAKEUP (_U_(0x1) << USB_HOST_INTENSET_WAKEUP_Pos)
#define USB_HOST_INTENSET_DNRSM_Pos 5
#define USB_HOST_INTENSET_DNRSM (_U_(0x1) << USB_HOST_INTENSET_DNRSM_Pos)
#define USB_HOST_INTENSET_UPRSM_Pos 6
#define USB_HOST_INTENSET_UPRSM (_U_(0x1) << USB_HOST_INTENSET_UPRSM_Pos)
#define USB_HOST_INTENSET_RAMACER_Pos 7
#define USB_HOST_INTENSET_RAMACER (_U_(0x1) << USB_HOST_INTENSET_RAMACER_Pos)
#define USB_HOST_INTENSET_DCONN_Pos 8
#define USB_HOST_INTENSET_DCONN (_U_(0x1) << USB_HOST_INTENSET_DCONN_Pos)
#define USB_HOST_INTENSET_DDISC_Pos 9
#define USB_HOST_INTENSET_DDISC (_U_(0x1) << USB_HOST_INTENSET_DDISC_Pos)
#define USB_HOST_INTENSET_MASK _U_(0x03FC)

/* -------- USB_DEVICE_INTFLAG : (USB Offset: 0x01C) (R/W 16) DEVICE DEVICE Device Interrupt Flag -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint16_t SUSPEND:1; /*!< bit:      0  Suspend                            */
    volatile const uint16_t MSOF:1; /*!< bit:      1  Micro Start of Frame in High Speed Mode */
    volatile const uint16_t SOF:1; /*!< bit:      2  Start Of Frame                     */
    volatile const uint16_t EORST:1; /*!< bit:      3  End of Reset                       */
    volatile const uint16_t WAKEUP:1; /*!< bit:      4  Wake Up                            */
    volatile const uint16_t EORSM:1; /*!< bit:      5  End Of Resume                      */
    volatile const uint16_t UPRSM:1; /*!< bit:      6  Upstream Resume                    */
    volatile const uint16_t RAMACER:1; /*!< bit:      7  Ram Access                         */
    volatile const uint16_t LPMNYET:1; /*!< bit:      8  Link Power Management Not Yet      */
    volatile const uint16_t LPMSUSP:1; /*!< bit:      9  Link Power Management Suspend      */
    volatile const uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_DEVICE_INTFLAG_Type;


#define USB_DEVICE_INTFLAG_OFFSET 0x01C
#define USB_DEVICE_INTFLAG_RESETVALUE _U_(0x0000)

#define USB_DEVICE_INTFLAG_SUSPEND_Pos 0
#define USB_DEVICE_INTFLAG_SUSPEND (_U_(0x1) << USB_DEVICE_INTFLAG_SUSPEND_Pos)
#define USB_DEVICE_INTFLAG_MSOF_Pos 1
#define USB_DEVICE_INTFLAG_MSOF (_U_(0x1) << USB_DEVICE_INTFLAG_MSOF_Pos)
#define USB_DEVICE_INTFLAG_SOF_Pos 2
#define USB_DEVICE_INTFLAG_SOF (_U_(0x1) << USB_DEVICE_INTFLAG_SOF_Pos)
#define USB_DEVICE_INTFLAG_EORST_Pos 3
#define USB_DEVICE_INTFLAG_EORST (_U_(0x1) << USB_DEVICE_INTFLAG_EORST_Pos)
#define USB_DEVICE_INTFLAG_WAKEUP_Pos 4
#define USB_DEVICE_INTFLAG_WAKEUP (_U_(0x1) << USB_DEVICE_INTFLAG_WAKEUP_Pos)
#define USB_DEVICE_INTFLAG_EORSM_Pos 5
#define USB_DEVICE_INTFLAG_EORSM (_U_(0x1) << USB_DEVICE_INTFLAG_EORSM_Pos)
#define USB_DEVICE_INTFLAG_UPRSM_Pos 6
#define USB_DEVICE_INTFLAG_UPRSM (_U_(0x1) << USB_DEVICE_INTFLAG_UPRSM_Pos)
#define USB_DEVICE_INTFLAG_RAMACER_Pos 7
#define USB_DEVICE_INTFLAG_RAMACER (_U_(0x1) << USB_DEVICE_INTFLAG_RAMACER_Pos)
#define USB_DEVICE_INTFLAG_LPMNYET_Pos 8
#define USB_DEVICE_INTFLAG_LPMNYET (_U_(0x1) << USB_DEVICE_INTFLAG_LPMNYET_Pos)
#define USB_DEVICE_INTFLAG_LPMSUSP_Pos 9
#define USB_DEVICE_INTFLAG_LPMSUSP (_U_(0x1) << USB_DEVICE_INTFLAG_LPMSUSP_Pos)
#define USB_DEVICE_INTFLAG_MASK _U_(0x03FF)

/* -------- USB_HOST_INTFLAG : (USB Offset: 0x01C) (R/W 16) HOST HOST Host Interrupt Flag -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint16_t :2; /*!< bit:  0.. 1  Reserved                           */
    volatile const uint16_t HSOF:1; /*!< bit:      2  Host Start Of Frame                */
    volatile const uint16_t RST:1; /*!< bit:      3  Bus Reset                          */
    volatile const uint16_t WAKEUP:1; /*!< bit:      4  Wake Up                            */
    volatile const uint16_t DNRSM:1; /*!< bit:      5  Downstream                         */
    volatile const uint16_t UPRSM:1; /*!< bit:      6  Upstream Resume from the Device    */
    volatile const uint16_t RAMACER:1; /*!< bit:      7  Ram Access                         */
    volatile const uint16_t DCONN:1; /*!< bit:      8  Device Connection                  */
    volatile const uint16_t DDISC:1; /*!< bit:      9  Device Disconnection               */
    volatile const uint16_t :6; /*!< bit: 10..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_INTFLAG_Type;


#define USB_HOST_INTFLAG_OFFSET 0x01C
#define USB_HOST_INTFLAG_RESETVALUE _U_(0x0000)

#define USB_HOST_INTFLAG_HSOF_Pos 2
#define USB_HOST_INTFLAG_HSOF (_U_(0x1) << USB_HOST_INTFLAG_HSOF_Pos)
#define USB_HOST_INTFLAG_RST_Pos 3
#define USB_HOST_INTFLAG_RST (_U_(0x1) << USB_HOST_INTFLAG_RST_Pos)
#define USB_HOST_INTFLAG_WAKEUP_Pos 4
#define USB_HOST_INTFLAG_WAKEUP (_U_(0x1) << USB_HOST_INTFLAG_WAKEUP_Pos)
#define USB_HOST_INTFLAG_DNRSM_Pos 5
#define USB_HOST_INTFLAG_DNRSM (_U_(0x1) << USB_HOST_INTFLAG_DNRSM_Pos)
#define USB_HOST_INTFLAG_UPRSM_Pos 6
#define USB_HOST_INTFLAG_UPRSM (_U_(0x1) << USB_HOST_INTFLAG_UPRSM_Pos)
#define USB_HOST_INTFLAG_RAMACER_Pos 7
#define USB_HOST_INTFLAG_RAMACER (_U_(0x1) << USB_HOST_INTFLAG_RAMACER_Pos)
#define USB_HOST_INTFLAG_DCONN_Pos 8
#define USB_HOST_INTFLAG_DCONN (_U_(0x1) << USB_HOST_INTFLAG_DCONN_Pos)
#define USB_HOST_INTFLAG_DDISC_Pos 9
#define USB_HOST_INTFLAG_DDISC (_U_(0x1) << USB_HOST_INTFLAG_DDISC_Pos)
#define USB_HOST_INTFLAG_MASK _U_(0x03FC)

/* -------- USB_DEVICE_EPINTSMRY : (USB Offset: 0x020) (R/  16) DEVICE DEVICE End Point Interrupt Summary -------- */

typedef union {
  struct {
    uint16_t EPINT0:1; /*!< bit:      0  End Point 0 Interrupt              */
    uint16_t EPINT1:1; /*!< bit:      1  End Point 1 Interrupt              */
    uint16_t EPINT2:1; /*!< bit:      2  End Point 2 Interrupt              */
    uint16_t EPINT3:1; /*!< bit:      3  End Point 3 Interrupt              */
    uint16_t EPINT4:1; /*!< bit:      4  End Point 4 Interrupt              */
    uint16_t EPINT5:1; /*!< bit:      5  End Point 5 Interrupt              */
    uint16_t EPINT6:1; /*!< bit:      6  End Point 6 Interrupt              */
    uint16_t EPINT7:1; /*!< bit:      7  End Point 7 Interrupt              */
    uint16_t :8; /*!< bit:  8..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t EPINT:8; /*!< bit:  0.. 7  End Point x Interrupt              */
    uint16_t :8; /*!< bit:  8..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPINTSMRY_Type;


#define USB_DEVICE_EPINTSMRY_OFFSET 0x020
#define USB_DEVICE_EPINTSMRY_RESETVALUE _U_(0x0000)

#define USB_DEVICE_EPINTSMRY_EPINT0_Pos 0
#define USB_DEVICE_EPINTSMRY_EPINT0 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT0_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT1_Pos 1
#define USB_DEVICE_EPINTSMRY_EPINT1 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT1_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT2_Pos 2
#define USB_DEVICE_EPINTSMRY_EPINT2 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT2_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT3_Pos 3
#define USB_DEVICE_EPINTSMRY_EPINT3 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT3_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT4_Pos 4
#define USB_DEVICE_EPINTSMRY_EPINT4 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT4_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT5_Pos 5
#define USB_DEVICE_EPINTSMRY_EPINT5 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT5_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT6_Pos 6
#define USB_DEVICE_EPINTSMRY_EPINT6 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT6_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT7_Pos 7
#define USB_DEVICE_EPINTSMRY_EPINT7 (_U_(1) << USB_DEVICE_EPINTSMRY_EPINT7_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT_Pos 0
#define USB_DEVICE_EPINTSMRY_EPINT_Msk (_U_(0xFF) << USB_DEVICE_EPINTSMRY_EPINT_Pos)
#define USB_DEVICE_EPINTSMRY_EPINT(value) (USB_DEVICE_EPINTSMRY_EPINT_Msk & ((value) << USB_DEVICE_EPINTSMRY_EPINT_Pos))
#define USB_DEVICE_EPINTSMRY_MASK _U_(0x00FF)

/* -------- USB_HOST_PINTSMRY : (USB Offset: 0x020) (R/  16) HOST HOST Pipe Interrupt Summary -------- */

typedef union {
  struct {
    uint16_t EPINT0:1; /*!< bit:      0  Pipe 0 Interrupt                   */
    uint16_t EPINT1:1; /*!< bit:      1  Pipe 1 Interrupt                   */
    uint16_t EPINT2:1; /*!< bit:      2  Pipe 2 Interrupt                   */
    uint16_t EPINT3:1; /*!< bit:      3  Pipe 3 Interrupt                   */
    uint16_t EPINT4:1; /*!< bit:      4  Pipe 4 Interrupt                   */
    uint16_t EPINT5:1; /*!< bit:      5  Pipe 5 Interrupt                   */
    uint16_t EPINT6:1; /*!< bit:      6  Pipe 6 Interrupt                   */
    uint16_t EPINT7:1; /*!< bit:      7  Pipe 7 Interrupt                   */
    uint16_t :8; /*!< bit:  8..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint16_t EPINT:8; /*!< bit:  0.. 7  Pipe x Interrupt                   */
    uint16_t :8; /*!< bit:  8..15  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_PINTSMRY_Type;


#define USB_HOST_PINTSMRY_OFFSET 0x020
#define USB_HOST_PINTSMRY_RESETVALUE _U_(0x0000)

#define USB_HOST_PINTSMRY_EPINT0_Pos 0
#define USB_HOST_PINTSMRY_EPINT0 (_U_(1) << USB_HOST_PINTSMRY_EPINT0_Pos)
#define USB_HOST_PINTSMRY_EPINT1_Pos 1
#define USB_HOST_PINTSMRY_EPINT1 (_U_(1) << USB_HOST_PINTSMRY_EPINT1_Pos)
#define USB_HOST_PINTSMRY_EPINT2_Pos 2
#define USB_HOST_PINTSMRY_EPINT2 (_U_(1) << USB_HOST_PINTSMRY_EPINT2_Pos)
#define USB_HOST_PINTSMRY_EPINT3_Pos 3
#define USB_HOST_PINTSMRY_EPINT3 (_U_(1) << USB_HOST_PINTSMRY_EPINT3_Pos)
#define USB_HOST_PINTSMRY_EPINT4_Pos 4
#define USB_HOST_PINTSMRY_EPINT4 (_U_(1) << USB_HOST_PINTSMRY_EPINT4_Pos)
#define USB_HOST_PINTSMRY_EPINT5_Pos 5
#define USB_HOST_PINTSMRY_EPINT5 (_U_(1) << USB_HOST_PINTSMRY_EPINT5_Pos)
#define USB_HOST_PINTSMRY_EPINT6_Pos 6
#define USB_HOST_PINTSMRY_EPINT6 (_U_(1) << USB_HOST_PINTSMRY_EPINT6_Pos)
#define USB_HOST_PINTSMRY_EPINT7_Pos 7
#define USB_HOST_PINTSMRY_EPINT7 (_U_(1) << USB_HOST_PINTSMRY_EPINT7_Pos)
#define USB_HOST_PINTSMRY_EPINT_Pos 0
#define USB_HOST_PINTSMRY_EPINT_Msk (_U_(0xFF) << USB_HOST_PINTSMRY_EPINT_Pos)
#define USB_HOST_PINTSMRY_EPINT(value) (USB_HOST_PINTSMRY_EPINT_Msk & ((value) << USB_HOST_PINTSMRY_EPINT_Pos))
#define USB_HOST_PINTSMRY_MASK _U_(0x00FF)

/* -------- USB_DESCADD : (USB Offset: 0x024) (R/W 32) Descriptor Address -------- */

typedef union {
  struct {
    uint32_t DESCADD:32; /*!< bit:  0..31  Descriptor Address Value           */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} USB_DESCADD_Type;


#define USB_DESCADD_OFFSET 0x024
#define USB_DESCADD_RESETVALUE _U_(0x00000000)

#define USB_DESCADD_DESCADD_Pos 0
#define USB_DESCADD_DESCADD_Msk (_U_(0xFFFFFFFF) << USB_DESCADD_DESCADD_Pos)
#define USB_DESCADD_DESCADD(value) (USB_DESCADD_DESCADD_Msk & ((value) << USB_DESCADD_DESCADD_Pos))
#define USB_DESCADD_MASK _U_(0xFFFFFFFF)

/* -------- USB_PADCAL : (USB Offset: 0x028) (R/W 16) USB PAD Calibration -------- */

typedef union {
  struct {
    uint16_t TRANSP:5; /*!< bit:  0.. 4  USB Pad Transp calibration         */
    uint16_t :1; /*!< bit:      5  Reserved                           */
    uint16_t TRANSN:5; /*!< bit:  6..10  USB Pad Transn calibration         */
    uint16_t :1; /*!< bit:     11  Reserved                           */
    uint16_t TRIM:3; /*!< bit: 12..14  USB Pad Trim calibration           */
    uint16_t :1; /*!< bit:     15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_PADCAL_Type;


#define USB_PADCAL_OFFSET 0x028
#define USB_PADCAL_RESETVALUE _U_(0x0000)

#define USB_PADCAL_TRANSP_Pos 0
#define USB_PADCAL_TRANSP_Msk (_U_(0x1F) << USB_PADCAL_TRANSP_Pos)
#define USB_PADCAL_TRANSP(value) (USB_PADCAL_TRANSP_Msk & ((value) << USB_PADCAL_TRANSP_Pos))
#define USB_PADCAL_TRANSN_Pos 6
#define USB_PADCAL_TRANSN_Msk (_U_(0x1F) << USB_PADCAL_TRANSN_Pos)
#define USB_PADCAL_TRANSN(value) (USB_PADCAL_TRANSN_Msk & ((value) << USB_PADCAL_TRANSN_Pos))
#define USB_PADCAL_TRIM_Pos 12
#define USB_PADCAL_TRIM_Msk (_U_(0x7) << USB_PADCAL_TRIM_Pos)
#define USB_PADCAL_TRIM(value) (USB_PADCAL_TRIM_Msk & ((value) << USB_PADCAL_TRIM_Pos))
#define USB_PADCAL_MASK _U_(0x77DF)

/* -------- USB_DEVICE_EPCFG : (USB Offset: 0x100) (R/W  8) DEVICE DEVICE_ENDPOINT End Point Configuration -------- */

typedef union {
  struct {
    uint8_t EPTYPE0:3; /*!< bit:  0.. 2  End Point Type0                    */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t EPTYPE1:3; /*!< bit:  4.. 6  End Point Type1                    */
    uint8_t NYETDIS:1; /*!< bit:      7  NYET Token Disable                 */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPCFG_Type;


#define USB_DEVICE_EPCFG_OFFSET 0x100
#define USB_DEVICE_EPCFG_RESETVALUE _U_(0x00)

#define USB_DEVICE_EPCFG_EPTYPE0_Pos 0
#define USB_DEVICE_EPCFG_EPTYPE0_Msk (_U_(0x7) << USB_DEVICE_EPCFG_EPTYPE0_Pos)
#define USB_DEVICE_EPCFG_EPTYPE0(value) (USB_DEVICE_EPCFG_EPTYPE0_Msk & ((value) << USB_DEVICE_EPCFG_EPTYPE0_Pos))
#define USB_DEVICE_EPCFG_EPTYPE1_Pos 4
#define USB_DEVICE_EPCFG_EPTYPE1_Msk (_U_(0x7) << USB_DEVICE_EPCFG_EPTYPE1_Pos)
#define USB_DEVICE_EPCFG_EPTYPE1(value) (USB_DEVICE_EPCFG_EPTYPE1_Msk & ((value) << USB_DEVICE_EPCFG_EPTYPE1_Pos))
#define USB_DEVICE_EPCFG_NYETDIS_Pos 7
#define USB_DEVICE_EPCFG_NYETDIS (_U_(0x1) << USB_DEVICE_EPCFG_NYETDIS_Pos)
#define USB_DEVICE_EPCFG_MASK _U_(0xF7)

/* -------- USB_HOST_PCFG : (USB Offset: 0x100) (R/W  8) HOST HOST_PIPE End Point Configuration -------- */

typedef union {
  struct {
    uint8_t PTOKEN:2; /*!< bit:  0.. 1  Pipe Token                         */
    uint8_t BK:1; /*!< bit:      2  Pipe Bank                          */
    uint8_t PTYPE:3; /*!< bit:  3.. 5  Pipe Type                          */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_PCFG_Type;


#define USB_HOST_PCFG_OFFSET 0x100
#define USB_HOST_PCFG_RESETVALUE _U_(0x00)

#define USB_HOST_PCFG_PTOKEN_Pos 0
#define USB_HOST_PCFG_PTOKEN_Msk (_U_(0x3) << USB_HOST_PCFG_PTOKEN_Pos)
#define USB_HOST_PCFG_PTOKEN(value) (USB_HOST_PCFG_PTOKEN_Msk & ((value) << USB_HOST_PCFG_PTOKEN_Pos))
#define USB_HOST_PCFG_BK_Pos 2
#define USB_HOST_PCFG_BK (_U_(0x1) << USB_HOST_PCFG_BK_Pos)
#define USB_HOST_PCFG_PTYPE_Pos 3
#define USB_HOST_PCFG_PTYPE_Msk (_U_(0x7) << USB_HOST_PCFG_PTYPE_Pos)
#define USB_HOST_PCFG_PTYPE(value) (USB_HOST_PCFG_PTYPE_Msk & ((value) << USB_HOST_PCFG_PTYPE_Pos))
#define USB_HOST_PCFG_MASK _U_(0x3F)

/* -------- USB_HOST_BINTERVAL : (USB Offset: 0x103) (R/W  8) HOST HOST_PIPE Bus Access Period of Pipe -------- */

typedef union {
  struct {
    uint8_t BITINTERVAL:8; /*!< bit:  0.. 7  Bit Interval                       */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_BINTERVAL_Type;


#define USB_HOST_BINTERVAL_OFFSET 0x103
#define USB_HOST_BINTERVAL_RESETVALUE _U_(0x00)

#define USB_HOST_BINTERVAL_BITINTERVAL_Pos 0
#define USB_HOST_BINTERVAL_BITINTERVAL_Msk (_U_(0xFF) << USB_HOST_BINTERVAL_BITINTERVAL_Pos)
#define USB_HOST_BINTERVAL_BITINTERVAL(value) (USB_HOST_BINTERVAL_BITINTERVAL_Msk & ((value) << USB_HOST_BINTERVAL_BITINTERVAL_Pos))
#define USB_HOST_BINTERVAL_MASK _U_(0xFF)

/* -------- USB_DEVICE_EPSTATUSCLR : (USB Offset: 0x104) ( /W  8) DEVICE DEVICE_ENDPOINT End Point Pipe Status Clear -------- */

typedef union {
  struct {
    uint8_t DTGLOUT:1; /*!< bit:      0  Data Toggle OUT Clear              */
    uint8_t DTGLIN:1; /*!< bit:      1  Data Toggle IN Clear               */
    uint8_t CURBK:1; /*!< bit:      2  Curren Bank Clear                  */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t STALLRQ0:1; /*!< bit:      4  Stall 0 Request Clear              */
    uint8_t STALLRQ1:1; /*!< bit:      5  Stall 1 Request Clear              */
    uint8_t BK0RDY:1; /*!< bit:      6  Bank 0 Ready Clear                 */
    uint8_t BK1RDY:1; /*!< bit:      7  Bank 1 Ready Clear                 */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t :4; /*!< bit:  0.. 3  Reserved                           */
    uint8_t STALLRQ:2; /*!< bit:  4.. 5  Stall x Request Clear              */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPSTATUSCLR_Type;


#define USB_DEVICE_EPSTATUSCLR_OFFSET 0x104
#define USB_DEVICE_EPSTATUSCLR_RESETVALUE _U_(0x00)

#define USB_DEVICE_EPSTATUSCLR_DTGLOUT_Pos 0
#define USB_DEVICE_EPSTATUSCLR_DTGLOUT (_U_(0x1) << USB_DEVICE_EPSTATUSCLR_DTGLOUT_Pos)
#define USB_DEVICE_EPSTATUSCLR_DTGLIN_Pos 1
#define USB_DEVICE_EPSTATUSCLR_DTGLIN (_U_(0x1) << USB_DEVICE_EPSTATUSCLR_DTGLIN_Pos)
#define USB_DEVICE_EPSTATUSCLR_CURBK_Pos 2
#define USB_DEVICE_EPSTATUSCLR_CURBK (_U_(0x1) << USB_DEVICE_EPSTATUSCLR_CURBK_Pos)
#define USB_DEVICE_EPSTATUSCLR_STALLRQ0_Pos 4
#define USB_DEVICE_EPSTATUSCLR_STALLRQ0 (_U_(1) << USB_DEVICE_EPSTATUSCLR_STALLRQ0_Pos)
#define USB_DEVICE_EPSTATUSCLR_STALLRQ1_Pos 5
#define USB_DEVICE_EPSTATUSCLR_STALLRQ1 (_U_(1) << USB_DEVICE_EPSTATUSCLR_STALLRQ1_Pos)
#define USB_DEVICE_EPSTATUSCLR_STALLRQ_Pos 4
#define USB_DEVICE_EPSTATUSCLR_STALLRQ_Msk (_U_(0x3) << USB_DEVICE_EPSTATUSCLR_STALLRQ_Pos)
#define USB_DEVICE_EPSTATUSCLR_STALLRQ(value) (USB_DEVICE_EPSTATUSCLR_STALLRQ_Msk & ((value) << USB_DEVICE_EPSTATUSCLR_STALLRQ_Pos))
#define USB_DEVICE_EPSTATUSCLR_BK0RDY_Pos 6
#define USB_DEVICE_EPSTATUSCLR_BK0RDY (_U_(0x1) << USB_DEVICE_EPSTATUSCLR_BK0RDY_Pos)
#define USB_DEVICE_EPSTATUSCLR_BK1RDY_Pos 7
#define USB_DEVICE_EPSTATUSCLR_BK1RDY (_U_(0x1) << USB_DEVICE_EPSTATUSCLR_BK1RDY_Pos)
#define USB_DEVICE_EPSTATUSCLR_MASK _U_(0xF7)

/* -------- USB_HOST_PSTATUSCLR : (USB Offset: 0x104) ( /W  8) HOST HOST_PIPE End Point Pipe Status Clear -------- */

typedef union {
  struct {
    uint8_t DTGL:1; /*!< bit:      0  Data Toggle clear                  */
    uint8_t :1; /*!< bit:      1  Reserved                           */
    uint8_t CURBK:1; /*!< bit:      2  Curren Bank clear                  */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t PFREEZE:1; /*!< bit:      4  Pipe Freeze Clear                  */
    uint8_t :1; /*!< bit:      5  Reserved                           */
    uint8_t BK0RDY:1; /*!< bit:      6  Bank 0 Ready Clear                 */
    uint8_t BK1RDY:1; /*!< bit:      7  Bank 1 Ready Clear                 */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_PSTATUSCLR_Type;


#define USB_HOST_PSTATUSCLR_OFFSET 0x104
#define USB_HOST_PSTATUSCLR_RESETVALUE _U_(0x00)

#define USB_HOST_PSTATUSCLR_DTGL_Pos 0
#define USB_HOST_PSTATUSCLR_DTGL (_U_(0x1) << USB_HOST_PSTATUSCLR_DTGL_Pos)
#define USB_HOST_PSTATUSCLR_CURBK_Pos 2
#define USB_HOST_PSTATUSCLR_CURBK (_U_(0x1) << USB_HOST_PSTATUSCLR_CURBK_Pos)
#define USB_HOST_PSTATUSCLR_PFREEZE_Pos 4
#define USB_HOST_PSTATUSCLR_PFREEZE (_U_(0x1) << USB_HOST_PSTATUSCLR_PFREEZE_Pos)
#define USB_HOST_PSTATUSCLR_BK0RDY_Pos 6
#define USB_HOST_PSTATUSCLR_BK0RDY (_U_(0x1) << USB_HOST_PSTATUSCLR_BK0RDY_Pos)
#define USB_HOST_PSTATUSCLR_BK1RDY_Pos 7
#define USB_HOST_PSTATUSCLR_BK1RDY (_U_(0x1) << USB_HOST_PSTATUSCLR_BK1RDY_Pos)
#define USB_HOST_PSTATUSCLR_MASK _U_(0xD5)

/* -------- USB_DEVICE_EPSTATUSSET : (USB Offset: 0x105) ( /W  8) DEVICE DEVICE_ENDPOINT End Point Pipe Status Set -------- */

typedef union {
  struct {
    uint8_t DTGLOUT:1; /*!< bit:      0  Data Toggle OUT Set                */
    uint8_t DTGLIN:1; /*!< bit:      1  Data Toggle IN Set                 */
    uint8_t CURBK:1; /*!< bit:      2  Current Bank Set                   */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t STALLRQ0:1; /*!< bit:      4  Stall 0 Request Set                */
    uint8_t STALLRQ1:1; /*!< bit:      5  Stall 1 Request Set                */
    uint8_t BK0RDY:1; /*!< bit:      6  Bank 0 Ready Set                   */
    uint8_t BK1RDY:1; /*!< bit:      7  Bank 1 Ready Set                   */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t :4; /*!< bit:  0.. 3  Reserved                           */
    uint8_t STALLRQ:2; /*!< bit:  4.. 5  Stall x Request Set                */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPSTATUSSET_Type;


#define USB_DEVICE_EPSTATUSSET_OFFSET 0x105
#define USB_DEVICE_EPSTATUSSET_RESETVALUE _U_(0x00)

#define USB_DEVICE_EPSTATUSSET_DTGLOUT_Pos 0
#define USB_DEVICE_EPSTATUSSET_DTGLOUT (_U_(0x1) << USB_DEVICE_EPSTATUSSET_DTGLOUT_Pos)
#define USB_DEVICE_EPSTATUSSET_DTGLIN_Pos 1
#define USB_DEVICE_EPSTATUSSET_DTGLIN (_U_(0x1) << USB_DEVICE_EPSTATUSSET_DTGLIN_Pos)
#define USB_DEVICE_EPSTATUSSET_CURBK_Pos 2
#define USB_DEVICE_EPSTATUSSET_CURBK (_U_(0x1) << USB_DEVICE_EPSTATUSSET_CURBK_Pos)
#define USB_DEVICE_EPSTATUSSET_STALLRQ0_Pos 4
#define USB_DEVICE_EPSTATUSSET_STALLRQ0 (_U_(1) << USB_DEVICE_EPSTATUSSET_STALLRQ0_Pos)
#define USB_DEVICE_EPSTATUSSET_STALLRQ1_Pos 5
#define USB_DEVICE_EPSTATUSSET_STALLRQ1 (_U_(1) << USB_DEVICE_EPSTATUSSET_STALLRQ1_Pos)
#define USB_DEVICE_EPSTATUSSET_STALLRQ_Pos 4
#define USB_DEVICE_EPSTATUSSET_STALLRQ_Msk (_U_(0x3) << USB_DEVICE_EPSTATUSSET_STALLRQ_Pos)
#define USB_DEVICE_EPSTATUSSET_STALLRQ(value) (USB_DEVICE_EPSTATUSSET_STALLRQ_Msk & ((value) << USB_DEVICE_EPSTATUSSET_STALLRQ_Pos))
#define USB_DEVICE_EPSTATUSSET_BK0RDY_Pos 6
#define USB_DEVICE_EPSTATUSSET_BK0RDY (_U_(0x1) << USB_DEVICE_EPSTATUSSET_BK0RDY_Pos)
#define USB_DEVICE_EPSTATUSSET_BK1RDY_Pos 7
#define USB_DEVICE_EPSTATUSSET_BK1RDY (_U_(0x1) << USB_DEVICE_EPSTATUSSET_BK1RDY_Pos)
#define USB_DEVICE_EPSTATUSSET_MASK _U_(0xF7)

/* -------- USB_HOST_PSTATUSSET : (USB Offset: 0x105) ( /W  8) HOST HOST_PIPE End Point Pipe Status Set -------- */

typedef union {
  struct {
    uint8_t DTGL:1; /*!< bit:      0  Data Toggle Set                    */
    uint8_t :1; /*!< bit:      1  Reserved                           */
    uint8_t CURBK:1; /*!< bit:      2  Current Bank Set                   */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t PFREEZE:1; /*!< bit:      4  Pipe Freeze Set                    */
    uint8_t :1; /*!< bit:      5  Reserved                           */
    uint8_t BK0RDY:1; /*!< bit:      6  Bank 0 Ready Set                   */
    uint8_t BK1RDY:1; /*!< bit:      7  Bank 1 Ready Set                   */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_PSTATUSSET_Type;


#define USB_HOST_PSTATUSSET_OFFSET 0x105
#define USB_HOST_PSTATUSSET_RESETVALUE _U_(0x00)

#define USB_HOST_PSTATUSSET_DTGL_Pos 0
#define USB_HOST_PSTATUSSET_DTGL (_U_(0x1) << USB_HOST_PSTATUSSET_DTGL_Pos)
#define USB_HOST_PSTATUSSET_CURBK_Pos 2
#define USB_HOST_PSTATUSSET_CURBK (_U_(0x1) << USB_HOST_PSTATUSSET_CURBK_Pos)
#define USB_HOST_PSTATUSSET_PFREEZE_Pos 4
#define USB_HOST_PSTATUSSET_PFREEZE (_U_(0x1) << USB_HOST_PSTATUSSET_PFREEZE_Pos)
#define USB_HOST_PSTATUSSET_BK0RDY_Pos 6
#define USB_HOST_PSTATUSSET_BK0RDY (_U_(0x1) << USB_HOST_PSTATUSSET_BK0RDY_Pos)
#define USB_HOST_PSTATUSSET_BK1RDY_Pos 7
#define USB_HOST_PSTATUSSET_BK1RDY (_U_(0x1) << USB_HOST_PSTATUSSET_BK1RDY_Pos)
#define USB_HOST_PSTATUSSET_MASK _U_(0xD5)

/* -------- USB_DEVICE_EPSTATUS : (USB Offset: 0x106) (R/   8) DEVICE DEVICE_ENDPOINT End Point Pipe Status -------- */

typedef union {
  struct {
    uint8_t DTGLOUT:1; /*!< bit:      0  Data Toggle Out                    */
    uint8_t DTGLIN:1; /*!< bit:      1  Data Toggle In                     */
    uint8_t CURBK:1; /*!< bit:      2  Current Bank                       */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t STALLRQ0:1; /*!< bit:      4  Stall 0 Request                    */
    uint8_t STALLRQ1:1; /*!< bit:      5  Stall 1 Request                    */
    uint8_t BK0RDY:1; /*!< bit:      6  Bank 0 ready                       */
    uint8_t BK1RDY:1; /*!< bit:      7  Bank 1 ready                       */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t :4; /*!< bit:  0.. 3  Reserved                           */
    uint8_t STALLRQ:2; /*!< bit:  4.. 5  Stall x Request                    */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPSTATUS_Type;


#define USB_DEVICE_EPSTATUS_OFFSET 0x106
#define USB_DEVICE_EPSTATUS_RESETVALUE _U_(0x00)

#define USB_DEVICE_EPSTATUS_DTGLOUT_Pos 0
#define USB_DEVICE_EPSTATUS_DTGLOUT (_U_(0x1) << USB_DEVICE_EPSTATUS_DTGLOUT_Pos)
#define USB_DEVICE_EPSTATUS_DTGLIN_Pos 1
#define USB_DEVICE_EPSTATUS_DTGLIN (_U_(0x1) << USB_DEVICE_EPSTATUS_DTGLIN_Pos)
#define USB_DEVICE_EPSTATUS_CURBK_Pos 2
#define USB_DEVICE_EPSTATUS_CURBK (_U_(0x1) << USB_DEVICE_EPSTATUS_CURBK_Pos)
#define USB_DEVICE_EPSTATUS_STALLRQ0_Pos 4
#define USB_DEVICE_EPSTATUS_STALLRQ0 (_U_(1) << USB_DEVICE_EPSTATUS_STALLRQ0_Pos)
#define USB_DEVICE_EPSTATUS_STALLRQ1_Pos 5
#define USB_DEVICE_EPSTATUS_STALLRQ1 (_U_(1) << USB_DEVICE_EPSTATUS_STALLRQ1_Pos)
#define USB_DEVICE_EPSTATUS_STALLRQ_Pos 4
#define USB_DEVICE_EPSTATUS_STALLRQ_Msk (_U_(0x3) << USB_DEVICE_EPSTATUS_STALLRQ_Pos)
#define USB_DEVICE_EPSTATUS_STALLRQ(value) (USB_DEVICE_EPSTATUS_STALLRQ_Msk & ((value) << USB_DEVICE_EPSTATUS_STALLRQ_Pos))
#define USB_DEVICE_EPSTATUS_BK0RDY_Pos 6
#define USB_DEVICE_EPSTATUS_BK0RDY (_U_(0x1) << USB_DEVICE_EPSTATUS_BK0RDY_Pos)
#define USB_DEVICE_EPSTATUS_BK1RDY_Pos 7
#define USB_DEVICE_EPSTATUS_BK1RDY (_U_(0x1) << USB_DEVICE_EPSTATUS_BK1RDY_Pos)
#define USB_DEVICE_EPSTATUS_MASK _U_(0xF7)

/* -------- USB_HOST_PSTATUS : (USB Offset: 0x106) (R/   8) HOST HOST_PIPE End Point Pipe Status -------- */

typedef union {
  struct {
    uint8_t DTGL:1; /*!< bit:      0  Data Toggle                        */
    uint8_t :1; /*!< bit:      1  Reserved                           */
    uint8_t CURBK:1; /*!< bit:      2  Current Bank                       */
    uint8_t :1; /*!< bit:      3  Reserved                           */
    uint8_t PFREEZE:1; /*!< bit:      4  Pipe Freeze                        */
    uint8_t :1; /*!< bit:      5  Reserved                           */
    uint8_t BK0RDY:1; /*!< bit:      6  Bank 0 ready                       */
    uint8_t BK1RDY:1; /*!< bit:      7  Bank 1 ready                       */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_PSTATUS_Type;


#define USB_HOST_PSTATUS_OFFSET 0x106
#define USB_HOST_PSTATUS_RESETVALUE _U_(0x00)

#define USB_HOST_PSTATUS_DTGL_Pos 0
#define USB_HOST_PSTATUS_DTGL (_U_(0x1) << USB_HOST_PSTATUS_DTGL_Pos)
#define USB_HOST_PSTATUS_CURBK_Pos 2
#define USB_HOST_PSTATUS_CURBK (_U_(0x1) << USB_HOST_PSTATUS_CURBK_Pos)
#define USB_HOST_PSTATUS_PFREEZE_Pos 4
#define USB_HOST_PSTATUS_PFREEZE (_U_(0x1) << USB_HOST_PSTATUS_PFREEZE_Pos)
#define USB_HOST_PSTATUS_BK0RDY_Pos 6
#define USB_HOST_PSTATUS_BK0RDY (_U_(0x1) << USB_HOST_PSTATUS_BK0RDY_Pos)
#define USB_HOST_PSTATUS_BK1RDY_Pos 7
#define USB_HOST_PSTATUS_BK1RDY (_U_(0x1) << USB_HOST_PSTATUS_BK1RDY_Pos)
#define USB_HOST_PSTATUS_MASK _U_(0xD5)

/* -------- USB_DEVICE_EPINTFLAG : (USB Offset: 0x107) (R/W  8) DEVICE DEVICE_ENDPOINT End Point Interrupt Flag -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t TRCPT0:1; /*!< bit:      0  Transfer Complete 0                */
    volatile const uint8_t TRCPT1:1; /*!< bit:      1  Transfer Complete 1                */
    volatile const uint8_t TRFAIL0:1; /*!< bit:      2  Error Flow 0                       */
    volatile const uint8_t TRFAIL1:1; /*!< bit:      3  Error Flow 1                       */
    volatile const uint8_t RXSTP:1; /*!< bit:      4  Received Setup                     */
    volatile const uint8_t STALL0:1; /*!< bit:      5  Stall 0 In/out                     */
    volatile const uint8_t STALL1:1; /*!< bit:      6  Stall 1 In/out                     */
    volatile const uint8_t :1; /*!< bit:      7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint8_t TRCPT:2; /*!< bit:  0.. 1  Transfer Complete x                */
    volatile const uint8_t TRFAIL:2; /*!< bit:  2.. 3  Error Flow x                       */
    volatile const uint8_t :1; /*!< bit:      4  Reserved                           */
    volatile const uint8_t STALL:2; /*!< bit:  5.. 6  Stall x In/out                     */
    volatile const uint8_t :1; /*!< bit:      7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPINTFLAG_Type;


#define USB_DEVICE_EPINTFLAG_OFFSET 0x107
#define USB_DEVICE_EPINTFLAG_RESETVALUE _U_(0x00)

#define USB_DEVICE_EPINTFLAG_TRCPT0_Pos 0
#define USB_DEVICE_EPINTFLAG_TRCPT0 (_U_(1) << USB_DEVICE_EPINTFLAG_TRCPT0_Pos)
#define USB_DEVICE_EPINTFLAG_TRCPT1_Pos 1
#define USB_DEVICE_EPINTFLAG_TRCPT1 (_U_(1) << USB_DEVICE_EPINTFLAG_TRCPT1_Pos)
#define USB_DEVICE_EPINTFLAG_TRCPT_Pos 0
#define USB_DEVICE_EPINTFLAG_TRCPT_Msk (_U_(0x3) << USB_DEVICE_EPINTFLAG_TRCPT_Pos)
#define USB_DEVICE_EPINTFLAG_TRCPT(value) (USB_DEVICE_EPINTFLAG_TRCPT_Msk & ((value) << USB_DEVICE_EPINTFLAG_TRCPT_Pos))
#define USB_DEVICE_EPINTFLAG_TRFAIL0_Pos 2
#define USB_DEVICE_EPINTFLAG_TRFAIL0 (_U_(1) << USB_DEVICE_EPINTFLAG_TRFAIL0_Pos)
#define USB_DEVICE_EPINTFLAG_TRFAIL1_Pos 3
#define USB_DEVICE_EPINTFLAG_TRFAIL1 (_U_(1) << USB_DEVICE_EPINTFLAG_TRFAIL1_Pos)
#define USB_DEVICE_EPINTFLAG_TRFAIL_Pos 2
#define USB_DEVICE_EPINTFLAG_TRFAIL_Msk (_U_(0x3) << USB_DEVICE_EPINTFLAG_TRFAIL_Pos)
#define USB_DEVICE_EPINTFLAG_TRFAIL(value) (USB_DEVICE_EPINTFLAG_TRFAIL_Msk & ((value) << USB_DEVICE_EPINTFLAG_TRFAIL_Pos))
#define USB_DEVICE_EPINTFLAG_RXSTP_Pos 4
#define USB_DEVICE_EPINTFLAG_RXSTP (_U_(0x1) << USB_DEVICE_EPINTFLAG_RXSTP_Pos)
#define USB_DEVICE_EPINTFLAG_STALL0_Pos 5
#define USB_DEVICE_EPINTFLAG_STALL0 (_U_(1) << USB_DEVICE_EPINTFLAG_STALL0_Pos)
#define USB_DEVICE_EPINTFLAG_STALL1_Pos 6
#define USB_DEVICE_EPINTFLAG_STALL1 (_U_(1) << USB_DEVICE_EPINTFLAG_STALL1_Pos)
#define USB_DEVICE_EPINTFLAG_STALL_Pos 5
#define USB_DEVICE_EPINTFLAG_STALL_Msk (_U_(0x3) << USB_DEVICE_EPINTFLAG_STALL_Pos)
#define USB_DEVICE_EPINTFLAG_STALL(value) (USB_DEVICE_EPINTFLAG_STALL_Msk & ((value) << USB_DEVICE_EPINTFLAG_STALL_Pos))
#define USB_DEVICE_EPINTFLAG_MASK _U_(0x7F)

/* -------- USB_HOST_PINTFLAG : (USB Offset: 0x107) (R/W  8) HOST HOST_PIPE Pipe Interrupt Flag -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t TRCPT0:1; /*!< bit:      0  Transfer Complete 0 Interrupt Flag */
    volatile const uint8_t TRCPT1:1; /*!< bit:      1  Transfer Complete 1 Interrupt Flag */
    volatile const uint8_t TRFAIL:1; /*!< bit:      2  Error Flow Interrupt Flag          */
    volatile const uint8_t PERR:1; /*!< bit:      3  Pipe Error Interrupt Flag          */
    volatile const uint8_t TXSTP:1; /*!< bit:      4  Transmit  Setup Interrupt Flag     */
    volatile const uint8_t STALL:1; /*!< bit:      5  Stall Interrupt Flag               */
    volatile const uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    volatile const uint8_t TRCPT:2; /*!< bit:  0.. 1  Transfer Complete x Interrupt Flag */
    volatile const uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_PINTFLAG_Type;


#define USB_HOST_PINTFLAG_OFFSET 0x107
#define USB_HOST_PINTFLAG_RESETVALUE _U_(0x00)

#define USB_HOST_PINTFLAG_TRCPT0_Pos 0
#define USB_HOST_PINTFLAG_TRCPT0 (_U_(1) << USB_HOST_PINTFLAG_TRCPT0_Pos)
#define USB_HOST_PINTFLAG_TRCPT1_Pos 1
#define USB_HOST_PINTFLAG_TRCPT1 (_U_(1) << USB_HOST_PINTFLAG_TRCPT1_Pos)
#define USB_HOST_PINTFLAG_TRCPT_Pos 0
#define USB_HOST_PINTFLAG_TRCPT_Msk (_U_(0x3) << USB_HOST_PINTFLAG_TRCPT_Pos)
#define USB_HOST_PINTFLAG_TRCPT(value) (USB_HOST_PINTFLAG_TRCPT_Msk & ((value) << USB_HOST_PINTFLAG_TRCPT_Pos))
#define USB_HOST_PINTFLAG_TRFAIL_Pos 2
#define USB_HOST_PINTFLAG_TRFAIL (_U_(0x1) << USB_HOST_PINTFLAG_TRFAIL_Pos)
#define USB_HOST_PINTFLAG_PERR_Pos 3
#define USB_HOST_PINTFLAG_PERR (_U_(0x1) << USB_HOST_PINTFLAG_PERR_Pos)
#define USB_HOST_PINTFLAG_TXSTP_Pos 4
#define USB_HOST_PINTFLAG_TXSTP (_U_(0x1) << USB_HOST_PINTFLAG_TXSTP_Pos)
#define USB_HOST_PINTFLAG_STALL_Pos 5
#define USB_HOST_PINTFLAG_STALL (_U_(0x1) << USB_HOST_PINTFLAG_STALL_Pos)
#define USB_HOST_PINTFLAG_MASK _U_(0x3F)

/* -------- USB_DEVICE_EPINTENCLR : (USB Offset: 0x108) (R/W  8) DEVICE DEVICE_ENDPOINT End Point Interrupt Clear Flag -------- */

typedef union {
  struct {
    uint8_t TRCPT0:1; /*!< bit:      0  Transfer Complete 0 Interrupt Disable */
    uint8_t TRCPT1:1; /*!< bit:      1  Transfer Complete 1 Interrupt Disable */
    uint8_t TRFAIL0:1; /*!< bit:      2  Error Flow 0 Interrupt Disable     */
    uint8_t TRFAIL1:1; /*!< bit:      3  Error Flow 1 Interrupt Disable     */
    uint8_t RXSTP:1; /*!< bit:      4  Received Setup Interrupt Disable   */
    uint8_t STALL0:1; /*!< bit:      5  Stall 0 In/Out Interrupt Disable   */
    uint8_t STALL1:1; /*!< bit:      6  Stall 1 In/Out Interrupt Disable   */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t TRCPT:2; /*!< bit:  0.. 1  Transfer Complete x Interrupt Disable */
    uint8_t TRFAIL:2; /*!< bit:  2.. 3  Error Flow x Interrupt Disable     */
    uint8_t :1; /*!< bit:      4  Reserved                           */
    uint8_t STALL:2; /*!< bit:  5.. 6  Stall x In/Out Interrupt Disable   */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPINTENCLR_Type;


#define USB_DEVICE_EPINTENCLR_OFFSET 0x108
#define USB_DEVICE_EPINTENCLR_RESETVALUE _U_(0x00)

#define USB_DEVICE_EPINTENCLR_TRCPT0_Pos 0
#define USB_DEVICE_EPINTENCLR_TRCPT0 (_U_(1) << USB_DEVICE_EPINTENCLR_TRCPT0_Pos)
#define USB_DEVICE_EPINTENCLR_TRCPT1_Pos 1
#define USB_DEVICE_EPINTENCLR_TRCPT1 (_U_(1) << USB_DEVICE_EPINTENCLR_TRCPT1_Pos)
#define USB_DEVICE_EPINTENCLR_TRCPT_Pos 0
#define USB_DEVICE_EPINTENCLR_TRCPT_Msk (_U_(0x3) << USB_DEVICE_EPINTENCLR_TRCPT_Pos)
#define USB_DEVICE_EPINTENCLR_TRCPT(value) (USB_DEVICE_EPINTENCLR_TRCPT_Msk & ((value) << USB_DEVICE_EPINTENCLR_TRCPT_Pos))
#define USB_DEVICE_EPINTENCLR_TRFAIL0_Pos 2
#define USB_DEVICE_EPINTENCLR_TRFAIL0 (_U_(1) << USB_DEVICE_EPINTENCLR_TRFAIL0_Pos)
#define USB_DEVICE_EPINTENCLR_TRFAIL1_Pos 3
#define USB_DEVICE_EPINTENCLR_TRFAIL1 (_U_(1) << USB_DEVICE_EPINTENCLR_TRFAIL1_Pos)
#define USB_DEVICE_EPINTENCLR_TRFAIL_Pos 2
#define USB_DEVICE_EPINTENCLR_TRFAIL_Msk (_U_(0x3) << USB_DEVICE_EPINTENCLR_TRFAIL_Pos)
#define USB_DEVICE_EPINTENCLR_TRFAIL(value) (USB_DEVICE_EPINTENCLR_TRFAIL_Msk & ((value) << USB_DEVICE_EPINTENCLR_TRFAIL_Pos))
#define USB_DEVICE_EPINTENCLR_RXSTP_Pos 4
#define USB_DEVICE_EPINTENCLR_RXSTP (_U_(0x1) << USB_DEVICE_EPINTENCLR_RXSTP_Pos)
#define USB_DEVICE_EPINTENCLR_STALL0_Pos 5
#define USB_DEVICE_EPINTENCLR_STALL0 (_U_(1) << USB_DEVICE_EPINTENCLR_STALL0_Pos)
#define USB_DEVICE_EPINTENCLR_STALL1_Pos 6
#define USB_DEVICE_EPINTENCLR_STALL1 (_U_(1) << USB_DEVICE_EPINTENCLR_STALL1_Pos)
#define USB_DEVICE_EPINTENCLR_STALL_Pos 5
#define USB_DEVICE_EPINTENCLR_STALL_Msk (_U_(0x3) << USB_DEVICE_EPINTENCLR_STALL_Pos)
#define USB_DEVICE_EPINTENCLR_STALL(value) (USB_DEVICE_EPINTENCLR_STALL_Msk & ((value) << USB_DEVICE_EPINTENCLR_STALL_Pos))
#define USB_DEVICE_EPINTENCLR_MASK _U_(0x7F)

/* -------- USB_HOST_PINTENCLR : (USB Offset: 0x108) (R/W  8) HOST HOST_PIPE Pipe Interrupt Flag Clear -------- */

typedef union {
  struct {
    uint8_t TRCPT0:1; /*!< bit:      0  Transfer Complete 0 Disable        */
    uint8_t TRCPT1:1; /*!< bit:      1  Transfer Complete 1 Disable        */
    uint8_t TRFAIL:1; /*!< bit:      2  Error Flow Interrupt Disable       */
    uint8_t PERR:1; /*!< bit:      3  Pipe Error Interrupt Disable       */
    uint8_t TXSTP:1; /*!< bit:      4  Transmit  Setup Interrupt Disable  */
    uint8_t STALL:1; /*!< bit:      5  Stall Inetrrupt Disable            */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t TRCPT:2; /*!< bit:  0.. 1  Transfer Complete x Disable        */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_PINTENCLR_Type;


#define USB_HOST_PINTENCLR_OFFSET 0x108
#define USB_HOST_PINTENCLR_RESETVALUE _U_(0x00)

#define USB_HOST_PINTENCLR_TRCPT0_Pos 0
#define USB_HOST_PINTENCLR_TRCPT0 (_U_(1) << USB_HOST_PINTENCLR_TRCPT0_Pos)
#define USB_HOST_PINTENCLR_TRCPT1_Pos 1
#define USB_HOST_PINTENCLR_TRCPT1 (_U_(1) << USB_HOST_PINTENCLR_TRCPT1_Pos)
#define USB_HOST_PINTENCLR_TRCPT_Pos 0
#define USB_HOST_PINTENCLR_TRCPT_Msk (_U_(0x3) << USB_HOST_PINTENCLR_TRCPT_Pos)
#define USB_HOST_PINTENCLR_TRCPT(value) (USB_HOST_PINTENCLR_TRCPT_Msk & ((value) << USB_HOST_PINTENCLR_TRCPT_Pos))
#define USB_HOST_PINTENCLR_TRFAIL_Pos 2
#define USB_HOST_PINTENCLR_TRFAIL (_U_(0x1) << USB_HOST_PINTENCLR_TRFAIL_Pos)
#define USB_HOST_PINTENCLR_PERR_Pos 3
#define USB_HOST_PINTENCLR_PERR (_U_(0x1) << USB_HOST_PINTENCLR_PERR_Pos)
#define USB_HOST_PINTENCLR_TXSTP_Pos 4
#define USB_HOST_PINTENCLR_TXSTP (_U_(0x1) << USB_HOST_PINTENCLR_TXSTP_Pos)
#define USB_HOST_PINTENCLR_STALL_Pos 5
#define USB_HOST_PINTENCLR_STALL (_U_(0x1) << USB_HOST_PINTENCLR_STALL_Pos)
#define USB_HOST_PINTENCLR_MASK _U_(0x3F)

/* -------- USB_DEVICE_EPINTENSET : (USB Offset: 0x109) (R/W  8) DEVICE DEVICE_ENDPOINT End Point Interrupt Set Flag -------- */

typedef union {
  struct {
    uint8_t TRCPT0:1; /*!< bit:      0  Transfer Complete 0 Interrupt Enable */
    uint8_t TRCPT1:1; /*!< bit:      1  Transfer Complete 1 Interrupt Enable */
    uint8_t TRFAIL0:1; /*!< bit:      2  Error Flow 0 Interrupt Enable      */
    uint8_t TRFAIL1:1; /*!< bit:      3  Error Flow 1 Interrupt Enable      */
    uint8_t RXSTP:1; /*!< bit:      4  Received Setup Interrupt Enable    */
    uint8_t STALL0:1; /*!< bit:      5  Stall 0 In/out Interrupt enable    */
    uint8_t STALL1:1; /*!< bit:      6  Stall 1 In/out Interrupt enable    */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t TRCPT:2; /*!< bit:  0.. 1  Transfer Complete x Interrupt Enable */
    uint8_t TRFAIL:2; /*!< bit:  2.. 3  Error Flow x Interrupt Enable      */
    uint8_t :1; /*!< bit:      4  Reserved                           */
    uint8_t STALL:2; /*!< bit:  5.. 6  Stall x In/out Interrupt enable    */
    uint8_t :1; /*!< bit:      7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EPINTENSET_Type;


#define USB_DEVICE_EPINTENSET_OFFSET 0x109
#define USB_DEVICE_EPINTENSET_RESETVALUE _U_(0x00)

#define USB_DEVICE_EPINTENSET_TRCPT0_Pos 0
#define USB_DEVICE_EPINTENSET_TRCPT0 (_U_(1) << USB_DEVICE_EPINTENSET_TRCPT0_Pos)
#define USB_DEVICE_EPINTENSET_TRCPT1_Pos 1
#define USB_DEVICE_EPINTENSET_TRCPT1 (_U_(1) << USB_DEVICE_EPINTENSET_TRCPT1_Pos)
#define USB_DEVICE_EPINTENSET_TRCPT_Pos 0
#define USB_DEVICE_EPINTENSET_TRCPT_Msk (_U_(0x3) << USB_DEVICE_EPINTENSET_TRCPT_Pos)
#define USB_DEVICE_EPINTENSET_TRCPT(value) (USB_DEVICE_EPINTENSET_TRCPT_Msk & ((value) << USB_DEVICE_EPINTENSET_TRCPT_Pos))
#define USB_DEVICE_EPINTENSET_TRFAIL0_Pos 2
#define USB_DEVICE_EPINTENSET_TRFAIL0 (_U_(1) << USB_DEVICE_EPINTENSET_TRFAIL0_Pos)
#define USB_DEVICE_EPINTENSET_TRFAIL1_Pos 3
#define USB_DEVICE_EPINTENSET_TRFAIL1 (_U_(1) << USB_DEVICE_EPINTENSET_TRFAIL1_Pos)
#define USB_DEVICE_EPINTENSET_TRFAIL_Pos 2
#define USB_DEVICE_EPINTENSET_TRFAIL_Msk (_U_(0x3) << USB_DEVICE_EPINTENSET_TRFAIL_Pos)
#define USB_DEVICE_EPINTENSET_TRFAIL(value) (USB_DEVICE_EPINTENSET_TRFAIL_Msk & ((value) << USB_DEVICE_EPINTENSET_TRFAIL_Pos))
#define USB_DEVICE_EPINTENSET_RXSTP_Pos 4
#define USB_DEVICE_EPINTENSET_RXSTP (_U_(0x1) << USB_DEVICE_EPINTENSET_RXSTP_Pos)
#define USB_DEVICE_EPINTENSET_STALL0_Pos 5
#define USB_DEVICE_EPINTENSET_STALL0 (_U_(1) << USB_DEVICE_EPINTENSET_STALL0_Pos)
#define USB_DEVICE_EPINTENSET_STALL1_Pos 6
#define USB_DEVICE_EPINTENSET_STALL1 (_U_(1) << USB_DEVICE_EPINTENSET_STALL1_Pos)
#define USB_DEVICE_EPINTENSET_STALL_Pos 5
#define USB_DEVICE_EPINTENSET_STALL_Msk (_U_(0x3) << USB_DEVICE_EPINTENSET_STALL_Pos)
#define USB_DEVICE_EPINTENSET_STALL(value) (USB_DEVICE_EPINTENSET_STALL_Msk & ((value) << USB_DEVICE_EPINTENSET_STALL_Pos))
#define USB_DEVICE_EPINTENSET_MASK _U_(0x7F)

/* -------- USB_HOST_PINTENSET : (USB Offset: 0x109) (R/W  8) HOST HOST_PIPE Pipe Interrupt Flag Set -------- */

typedef union {
  struct {
    uint8_t TRCPT0:1; /*!< bit:      0  Transfer Complete 0 Interrupt Enable */
    uint8_t TRCPT1:1; /*!< bit:      1  Transfer Complete 1 Interrupt Enable */
    uint8_t TRFAIL:1; /*!< bit:      2  Error Flow Interrupt Enable        */
    uint8_t PERR:1; /*!< bit:      3  Pipe Error Interrupt Enable        */
    uint8_t TXSTP:1; /*!< bit:      4  Transmit  Setup Interrupt Enable   */
    uint8_t STALL:1; /*!< bit:      5  Stall Interrupt Enable             */
    uint8_t :2; /*!< bit:  6.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  struct {
    uint8_t TRCPT:2; /*!< bit:  0.. 1  Transfer Complete x Interrupt Enable */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } vec; /*!< Structure used for vec  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_PINTENSET_Type;


#define USB_HOST_PINTENSET_OFFSET 0x109
#define USB_HOST_PINTENSET_RESETVALUE _U_(0x00)

#define USB_HOST_PINTENSET_TRCPT0_Pos 0
#define USB_HOST_PINTENSET_TRCPT0 (_U_(1) << USB_HOST_PINTENSET_TRCPT0_Pos)
#define USB_HOST_PINTENSET_TRCPT1_Pos 1
#define USB_HOST_PINTENSET_TRCPT1 (_U_(1) << USB_HOST_PINTENSET_TRCPT1_Pos)
#define USB_HOST_PINTENSET_TRCPT_Pos 0
#define USB_HOST_PINTENSET_TRCPT_Msk (_U_(0x3) << USB_HOST_PINTENSET_TRCPT_Pos)
#define USB_HOST_PINTENSET_TRCPT(value) (USB_HOST_PINTENSET_TRCPT_Msk & ((value) << USB_HOST_PINTENSET_TRCPT_Pos))
#define USB_HOST_PINTENSET_TRFAIL_Pos 2
#define USB_HOST_PINTENSET_TRFAIL (_U_(0x1) << USB_HOST_PINTENSET_TRFAIL_Pos)
#define USB_HOST_PINTENSET_PERR_Pos 3
#define USB_HOST_PINTENSET_PERR (_U_(0x1) << USB_HOST_PINTENSET_PERR_Pos)
#define USB_HOST_PINTENSET_TXSTP_Pos 4
#define USB_HOST_PINTENSET_TXSTP (_U_(0x1) << USB_HOST_PINTENSET_TXSTP_Pos)
#define USB_HOST_PINTENSET_STALL_Pos 5
#define USB_HOST_PINTENSET_STALL (_U_(0x1) << USB_HOST_PINTENSET_STALL_Pos)
#define USB_HOST_PINTENSET_MASK _U_(0x3F)

/* -------- USB_DEVICE_ADDR : (USB Offset: 0x000) (R/W 32) DEVICE DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer -------- */

typedef union {
  struct {
    uint32_t ADDR:32; /*!< bit:  0..31  Adress of data buffer              */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} USB_DEVICE_ADDR_Type;


#define USB_DEVICE_ADDR_OFFSET 0x000

#define USB_DEVICE_ADDR_ADDR_Pos 0
#define USB_DEVICE_ADDR_ADDR_Msk (_U_(0xFFFFFFFF) << USB_DEVICE_ADDR_ADDR_Pos)
#define USB_DEVICE_ADDR_ADDR(value) (USB_DEVICE_ADDR_ADDR_Msk & ((value) << USB_DEVICE_ADDR_ADDR_Pos))
#define USB_DEVICE_ADDR_MASK _U_(0xFFFFFFFF)

/* -------- USB_HOST_ADDR : (USB Offset: 0x000) (R/W 32) HOST HOST_DESC_BANK Host Bank, Adress of Data Buffer -------- */

typedef union {
  struct {
    uint32_t ADDR:32; /*!< bit:  0..31  Adress of data buffer              */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} USB_HOST_ADDR_Type;


#define USB_HOST_ADDR_OFFSET 0x000

#define USB_HOST_ADDR_ADDR_Pos 0
#define USB_HOST_ADDR_ADDR_Msk (_U_(0xFFFFFFFF) << USB_HOST_ADDR_ADDR_Pos)
#define USB_HOST_ADDR_ADDR(value) (USB_HOST_ADDR_ADDR_Msk & ((value) << USB_HOST_ADDR_ADDR_Pos))
#define USB_HOST_ADDR_MASK _U_(0xFFFFFFFF)

/* -------- USB_DEVICE_PCKSIZE : (USB Offset: 0x004) (R/W 32) DEVICE DEVICE_DESC_BANK Endpoint Bank, Packet Size -------- */

typedef union {
  struct {
    uint32_t BYTE_COUNT:14; /*!< bit:  0..13  Byte Count                         */
    uint32_t MULTI_PACKET_SIZE:14; /*!< bit: 14..27  Multi Packet In or Out size        */
    uint32_t SIZE:3; /*!< bit: 28..30  Enpoint size                       */
    uint32_t AUTO_ZLP:1; /*!< bit:     31  Automatic Zero Length Packet       */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} USB_DEVICE_PCKSIZE_Type;


#define USB_DEVICE_PCKSIZE_OFFSET 0x004

#define USB_DEVICE_PCKSIZE_BYTE_COUNT_Pos 0
#define USB_DEVICE_PCKSIZE_BYTE_COUNT_Msk (_U_(0x3FFF) << USB_DEVICE_PCKSIZE_BYTE_COUNT_Pos)
#define USB_DEVICE_PCKSIZE_BYTE_COUNT(value) (USB_DEVICE_PCKSIZE_BYTE_COUNT_Msk & ((value) << USB_DEVICE_PCKSIZE_BYTE_COUNT_Pos))
#define USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Pos 14
#define USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Msk (_U_(0x3FFF) << USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Pos)
#define USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(value) (USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Msk & ((value) << USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Pos))
#define USB_DEVICE_PCKSIZE_SIZE_Pos 28
#define USB_DEVICE_PCKSIZE_SIZE_Msk (_U_(0x7) << USB_DEVICE_PCKSIZE_SIZE_Pos)
#define USB_DEVICE_PCKSIZE_SIZE(value) (USB_DEVICE_PCKSIZE_SIZE_Msk & ((value) << USB_DEVICE_PCKSIZE_SIZE_Pos))
#define USB_DEVICE_PCKSIZE_AUTO_ZLP_Pos 31
#define USB_DEVICE_PCKSIZE_AUTO_ZLP (_U_(0x1) << USB_DEVICE_PCKSIZE_AUTO_ZLP_Pos)
#define USB_DEVICE_PCKSIZE_MASK _U_(0xFFFFFFFF)

/* -------- USB_HOST_PCKSIZE : (USB Offset: 0x004) (R/W 32) HOST HOST_DESC_BANK Host Bank, Packet Size -------- */

typedef union {
  struct {
    uint32_t BYTE_COUNT:14; /*!< bit:  0..13  Byte Count                         */
    uint32_t MULTI_PACKET_SIZE:14; /*!< bit: 14..27  Multi Packet In or Out size        */
    uint32_t SIZE:3; /*!< bit: 28..30  Pipe size                          */
    uint32_t AUTO_ZLP:1; /*!< bit:     31  Automatic Zero Length Packet       */
  } bit; /*!< Structure used for bit  access                  */
  uint32_t reg; /*!< Type      used for register access              */
} USB_HOST_PCKSIZE_Type;


#define USB_HOST_PCKSIZE_OFFSET 0x004

#define USB_HOST_PCKSIZE_BYTE_COUNT_Pos 0
#define USB_HOST_PCKSIZE_BYTE_COUNT_Msk (_U_(0x3FFF) << USB_HOST_PCKSIZE_BYTE_COUNT_Pos)
#define USB_HOST_PCKSIZE_BYTE_COUNT(value) (USB_HOST_PCKSIZE_BYTE_COUNT_Msk & ((value) << USB_HOST_PCKSIZE_BYTE_COUNT_Pos))
#define USB_HOST_PCKSIZE_MULTI_PACKET_SIZE_Pos 14
#define USB_HOST_PCKSIZE_MULTI_PACKET_SIZE_Msk (_U_(0x3FFF) << USB_HOST_PCKSIZE_MULTI_PACKET_SIZE_Pos)
#define USB_HOST_PCKSIZE_MULTI_PACKET_SIZE(value) (USB_HOST_PCKSIZE_MULTI_PACKET_SIZE_Msk & ((value) << USB_HOST_PCKSIZE_MULTI_PACKET_SIZE_Pos))
#define USB_HOST_PCKSIZE_SIZE_Pos 28
#define USB_HOST_PCKSIZE_SIZE_Msk (_U_(0x7) << USB_HOST_PCKSIZE_SIZE_Pos)
#define USB_HOST_PCKSIZE_SIZE(value) (USB_HOST_PCKSIZE_SIZE_Msk & ((value) << USB_HOST_PCKSIZE_SIZE_Pos))
#define USB_HOST_PCKSIZE_AUTO_ZLP_Pos 31
#define USB_HOST_PCKSIZE_AUTO_ZLP (_U_(0x1) << USB_HOST_PCKSIZE_AUTO_ZLP_Pos)
#define USB_HOST_PCKSIZE_MASK _U_(0xFFFFFFFF)

/* -------- USB_DEVICE_EXTREG : (USB Offset: 0x008) (R/W 16) DEVICE DEVICE_DESC_BANK Endpoint Bank, Extended -------- */

typedef union {
  struct {
    uint16_t SUBPID:4; /*!< bit:  0.. 3  SUBPID field send with extended token */
    uint16_t VARIABLE:11; /*!< bit:  4..14  Variable field send with extended token */
    uint16_t :1; /*!< bit:     15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_DEVICE_EXTREG_Type;


#define USB_DEVICE_EXTREG_OFFSET 0x008

#define USB_DEVICE_EXTREG_SUBPID_Pos 0
#define USB_DEVICE_EXTREG_SUBPID_Msk (_U_(0xF) << USB_DEVICE_EXTREG_SUBPID_Pos)
#define USB_DEVICE_EXTREG_SUBPID(value) (USB_DEVICE_EXTREG_SUBPID_Msk & ((value) << USB_DEVICE_EXTREG_SUBPID_Pos))
#define USB_DEVICE_EXTREG_VARIABLE_Pos 4
#define USB_DEVICE_EXTREG_VARIABLE_Msk (_U_(0x7FF) << USB_DEVICE_EXTREG_VARIABLE_Pos)
#define USB_DEVICE_EXTREG_VARIABLE(value) (USB_DEVICE_EXTREG_VARIABLE_Msk & ((value) << USB_DEVICE_EXTREG_VARIABLE_Pos))
#define USB_DEVICE_EXTREG_MASK _U_(0x7FFF)

/* -------- USB_HOST_EXTREG : (USB Offset: 0x008) (R/W 16) HOST HOST_DESC_BANK Host Bank, Extended -------- */

typedef union {
  struct {
    uint16_t SUBPID:4; /*!< bit:  0.. 3  SUBPID field send with extended token */
    uint16_t VARIABLE:11; /*!< bit:  4..14  Variable field send with extended token */
    uint16_t :1; /*!< bit:     15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_EXTREG_Type;


#define USB_HOST_EXTREG_OFFSET 0x008

#define USB_HOST_EXTREG_SUBPID_Pos 0
#define USB_HOST_EXTREG_SUBPID_Msk (_U_(0xF) << USB_HOST_EXTREG_SUBPID_Pos)
#define USB_HOST_EXTREG_SUBPID(value) (USB_HOST_EXTREG_SUBPID_Msk & ((value) << USB_HOST_EXTREG_SUBPID_Pos))
#define USB_HOST_EXTREG_VARIABLE_Pos 4
#define USB_HOST_EXTREG_VARIABLE_Msk (_U_(0x7FF) << USB_HOST_EXTREG_VARIABLE_Pos)
#define USB_HOST_EXTREG_VARIABLE(value) (USB_HOST_EXTREG_VARIABLE_Msk & ((value) << USB_HOST_EXTREG_VARIABLE_Pos))
#define USB_HOST_EXTREG_MASK _U_(0x7FFF)

/* -------- USB_DEVICE_STATUS_BK : (USB Offset: 0x00A) (R/W  8) DEVICE DEVICE_DESC_BANK Enpoint Bank, Status of Bank -------- */

typedef union {
  struct {
    uint8_t CRCERR:1; /*!< bit:      0  CRC Error Status                   */
    uint8_t ERRORFLOW:1; /*!< bit:      1  Error Flow Status                  */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_DEVICE_STATUS_BK_Type;


#define USB_DEVICE_STATUS_BK_OFFSET 0x00A

#define USB_DEVICE_STATUS_BK_CRCERR_Pos 0
#define USB_DEVICE_STATUS_BK_CRCERR (_U_(0x1) << USB_DEVICE_STATUS_BK_CRCERR_Pos)
#define USB_DEVICE_STATUS_BK_ERRORFLOW_Pos 1
#define USB_DEVICE_STATUS_BK_ERRORFLOW (_U_(0x1) << USB_DEVICE_STATUS_BK_ERRORFLOW_Pos)
#define USB_DEVICE_STATUS_BK_MASK _U_(0x03)

/* -------- USB_HOST_STATUS_BK : (USB Offset: 0x00A) (R/W  8) HOST HOST_DESC_BANK Host Bank, Status of Bank -------- */

typedef union {
  struct {
    uint8_t CRCERR:1; /*!< bit:      0  CRC Error Status                   */
    uint8_t ERRORFLOW:1; /*!< bit:      1  Error Flow Status                  */
    uint8_t :6; /*!< bit:  2.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} USB_HOST_STATUS_BK_Type;


#define USB_HOST_STATUS_BK_OFFSET 0x00A

#define USB_HOST_STATUS_BK_CRCERR_Pos 0
#define USB_HOST_STATUS_BK_CRCERR (_U_(0x1) << USB_HOST_STATUS_BK_CRCERR_Pos)
#define USB_HOST_STATUS_BK_ERRORFLOW_Pos 1
#define USB_HOST_STATUS_BK_ERRORFLOW (_U_(0x1) << USB_HOST_STATUS_BK_ERRORFLOW_Pos)
#define USB_HOST_STATUS_BK_MASK _U_(0x03)

/* -------- USB_HOST_CTRL_PIPE : (USB Offset: 0x00C) (R/W 16) HOST HOST_DESC_BANK Host Bank, Host Control Pipe -------- */

typedef union {
  struct {
    uint16_t PDADDR:7; /*!< bit:  0.. 6  Pipe Device Adress                 */
    uint16_t :1; /*!< bit:      7  Reserved                           */
    uint16_t PEPNUM:4; /*!< bit:  8..11  Pipe Endpoint Number               */
    uint16_t PERMAX:4; /*!< bit: 12..15  Pipe Error Max Number              */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_CTRL_PIPE_Type;


#define USB_HOST_CTRL_PIPE_OFFSET 0x00C
#define USB_HOST_CTRL_PIPE_RESETVALUE _U_(0x0000)

#define USB_HOST_CTRL_PIPE_PDADDR_Pos 0
#define USB_HOST_CTRL_PIPE_PDADDR_Msk (_U_(0x7F) << USB_HOST_CTRL_PIPE_PDADDR_Pos)
#define USB_HOST_CTRL_PIPE_PDADDR(value) (USB_HOST_CTRL_PIPE_PDADDR_Msk & ((value) << USB_HOST_CTRL_PIPE_PDADDR_Pos))
#define USB_HOST_CTRL_PIPE_PEPNUM_Pos 8
#define USB_HOST_CTRL_PIPE_PEPNUM_Msk (_U_(0xF) << USB_HOST_CTRL_PIPE_PEPNUM_Pos)
#define USB_HOST_CTRL_PIPE_PEPNUM(value) (USB_HOST_CTRL_PIPE_PEPNUM_Msk & ((value) << USB_HOST_CTRL_PIPE_PEPNUM_Pos))
#define USB_HOST_CTRL_PIPE_PERMAX_Pos 12
#define USB_HOST_CTRL_PIPE_PERMAX_Msk (_U_(0xF) << USB_HOST_CTRL_PIPE_PERMAX_Pos)
#define USB_HOST_CTRL_PIPE_PERMAX(value) (USB_HOST_CTRL_PIPE_PERMAX_Msk & ((value) << USB_HOST_CTRL_PIPE_PERMAX_Pos))
#define USB_HOST_CTRL_PIPE_MASK _U_(0xFF7F)

/* -------- USB_HOST_STATUS_PIPE : (USB Offset: 0x00E) (R/W 16) HOST HOST_DESC_BANK Host Bank, Host Status Pipe -------- */

typedef union {
  struct {
    uint16_t DTGLER:1; /*!< bit:      0  Data Toggle Error                  */
    uint16_t DAPIDER:1; /*!< bit:      1  Data PID Error                     */
    uint16_t PIDER:1; /*!< bit:      2  PID Error                          */
    uint16_t TOUTER:1; /*!< bit:      3  Time Out Error                     */
    uint16_t CRC16ER:1; /*!< bit:      4  CRC16 Error                        */
    uint16_t ERCNT:3; /*!< bit:  5.. 7  Pipe Error Count                   */
    uint16_t :8; /*!< bit:  8..15  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint16_t reg; /*!< Type      used for register access              */
} USB_HOST_STATUS_PIPE_Type;


#define USB_HOST_STATUS_PIPE_OFFSET 0x00E

#define USB_HOST_STATUS_PIPE_DTGLER_Pos 0
#define USB_HOST_STATUS_PIPE_DTGLER (_U_(0x1) << USB_HOST_STATUS_PIPE_DTGLER_Pos)
#define USB_HOST_STATUS_PIPE_DAPIDER_Pos 1
#define USB_HOST_STATUS_PIPE_DAPIDER (_U_(0x1) << USB_HOST_STATUS_PIPE_DAPIDER_Pos)
#define USB_HOST_STATUS_PIPE_PIDER_Pos 2
#define USB_HOST_STATUS_PIPE_PIDER (_U_(0x1) << USB_HOST_STATUS_PIPE_PIDER_Pos)
#define USB_HOST_STATUS_PIPE_TOUTER_Pos 3
#define USB_HOST_STATUS_PIPE_TOUTER (_U_(0x1) << USB_HOST_STATUS_PIPE_TOUTER_Pos)
#define USB_HOST_STATUS_PIPE_CRC16ER_Pos 4
#define USB_HOST_STATUS_PIPE_CRC16ER (_U_(0x1) << USB_HOST_STATUS_PIPE_CRC16ER_Pos)
#define USB_HOST_STATUS_PIPE_ERCNT_Pos 5
#define USB_HOST_STATUS_PIPE_ERCNT_Msk (_U_(0x7) << USB_HOST_STATUS_PIPE_ERCNT_Pos)
#define USB_HOST_STATUS_PIPE_ERCNT(value) (USB_HOST_STATUS_PIPE_ERCNT_Msk & ((value) << USB_HOST_STATUS_PIPE_ERCNT_Pos))
#define USB_HOST_STATUS_PIPE_MASK _U_(0x00FF)

/** \brief UsbDeviceDescBank SRAM registers */

typedef struct {
  volatile USB_DEVICE_ADDR_Type ADDR; /**< \brief Offset: 0x000 (R/W 32) DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer */
  volatile USB_DEVICE_PCKSIZE_Type PCKSIZE; /**< \brief Offset: 0x004 (R/W 32) DEVICE_DESC_BANK Endpoint Bank, Packet Size */
  volatile USB_DEVICE_EXTREG_Type EXTREG; /**< \brief Offset: 0x008 (R/W 16) DEVICE_DESC_BANK Endpoint Bank, Extended */
  volatile USB_DEVICE_STATUS_BK_Type STATUS_BK; /**< \brief Offset: 0x00A (R/W  8) DEVICE_DESC_BANK Enpoint Bank, Status of Bank */
       RoReg8 Reserved1[0x5];
} UsbDeviceDescBank;


/** \brief UsbHostDescBank SRAM registers */

typedef struct {
  volatile USB_HOST_ADDR_Type ADDR; /**< \brief Offset: 0x000 (R/W 32) HOST_DESC_BANK Host Bank, Adress of Data Buffer */
  volatile USB_HOST_PCKSIZE_Type PCKSIZE; /**< \brief Offset: 0x004 (R/W 32) HOST_DESC_BANK Host Bank, Packet Size */
  volatile USB_HOST_EXTREG_Type EXTREG; /**< \brief Offset: 0x008 (R/W 16) HOST_DESC_BANK Host Bank, Extended */
  volatile USB_HOST_STATUS_BK_Type STATUS_BK; /**< \brief Offset: 0x00A (R/W  8) HOST_DESC_BANK Host Bank, Status of Bank */
       RoReg8 Reserved1[0x1];
  volatile USB_HOST_CTRL_PIPE_Type CTRL_PIPE; /**< \brief Offset: 0x00C (R/W 16) HOST_DESC_BANK Host Bank, Host Control Pipe */
  volatile USB_HOST_STATUS_PIPE_Type STATUS_PIPE; /**< \brief Offset: 0x00E (R/W 16) HOST_DESC_BANK Host Bank, Host Status Pipe */
} UsbHostDescBank;


/** \brief UsbDeviceEndpoint hardware registers */

typedef struct {
  volatile USB_DEVICE_EPCFG_Type EPCFG; /**< \brief Offset: 0x000 (R/W  8) DEVICE_ENDPOINT End Point Configuration */
       RoReg8 Reserved1[0x3];
  volatile USB_DEVICE_EPSTATUSCLR_Type EPSTATUSCLR; /**< \brief Offset: 0x004 ( /W  8) DEVICE_ENDPOINT End Point Pipe Status Clear */
  volatile USB_DEVICE_EPSTATUSSET_Type EPSTATUSSET; /**< \brief Offset: 0x005 ( /W  8) DEVICE_ENDPOINT End Point Pipe Status Set */
  volatile const USB_DEVICE_EPSTATUS_Type EPSTATUS; /**< \brief Offset: 0x006 (R/   8) DEVICE_ENDPOINT End Point Pipe Status */
  volatile USB_DEVICE_EPINTFLAG_Type EPINTFLAG; /**< \brief Offset: 0x007 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Flag */
  volatile USB_DEVICE_EPINTENCLR_Type EPINTENCLR; /**< \brief Offset: 0x008 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Clear Flag */
  volatile USB_DEVICE_EPINTENSET_Type EPINTENSET; /**< \brief Offset: 0x009 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Set Flag */
       RoReg8 Reserved2[0x16];
} UsbDeviceEndpoint;


/** \brief UsbHostPipe hardware registers */

typedef struct {
  volatile USB_HOST_PCFG_Type PCFG; /**< \brief Offset: 0x000 (R/W  8) HOST_PIPE End Point Configuration */
       RoReg8 Reserved1[0x2];
  volatile USB_HOST_BINTERVAL_Type BINTERVAL; /**< \brief Offset: 0x003 (R/W  8) HOST_PIPE Bus Access Period of Pipe */
  volatile USB_HOST_PSTATUSCLR_Type PSTATUSCLR; /**< \brief Offset: 0x004 ( /W  8) HOST_PIPE End Point Pipe Status Clear */
  volatile USB_HOST_PSTATUSSET_Type PSTATUSSET; /**< \brief Offset: 0x005 ( /W  8) HOST_PIPE End Point Pipe Status Set */
  volatile const USB_HOST_PSTATUS_Type PSTATUS; /**< \brief Offset: 0x006 (R/   8) HOST_PIPE End Point Pipe Status */
  volatile USB_HOST_PINTFLAG_Type PINTFLAG; /**< \brief Offset: 0x007 (R/W  8) HOST_PIPE Pipe Interrupt Flag */
  volatile USB_HOST_PINTENCLR_Type PINTENCLR; /**< \brief Offset: 0x008 (R/W  8) HOST_PIPE Pipe Interrupt Flag Clear */
  volatile USB_HOST_PINTENSET_Type PINTENSET; /**< \brief Offset: 0x009 (R/W  8) HOST_PIPE Pipe Interrupt Flag Set */
       RoReg8 Reserved2[0x16];
} UsbHostPipe;


/** \brief USB_DEVICE APB hardware registers */

typedef struct { /* USB is Device */
  volatile USB_CTRLA_Type CTRLA; /**< \brief Offset: 0x000 (R/W  8) Control A */
       RoReg8 Reserved1[0x1];
  volatile const USB_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x002 (R/   8) Synchronization Busy */
  volatile USB_QOSCTRL_Type QOSCTRL; /**< \brief Offset: 0x003 (R/W  8) USB Quality Of Service */
       RoReg8 Reserved2[0x4];
  volatile USB_DEVICE_CTRLB_Type CTRLB; /**< \brief Offset: 0x008 (R/W 16) DEVICE Control B */
  volatile USB_DEVICE_DADD_Type DADD; /**< \brief Offset: 0x00A (R/W  8) DEVICE Device Address */
       RoReg8 Reserved3[0x1];
  volatile const USB_DEVICE_STATUS_Type STATUS; /**< \brief Offset: 0x00C (R/   8) DEVICE Status */
  volatile const USB_FSMSTATUS_Type FSMSTATUS; /**< \brief Offset: 0x00D (R/   8) Finite State Machine Status */
       RoReg8 Reserved4[0x2];
  volatile const USB_DEVICE_FNUM_Type FNUM; /**< \brief Offset: 0x010 (R/  16) DEVICE Device Frame Number */
       RoReg8 Reserved5[0x2];
  volatile USB_DEVICE_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x014 (R/W 16) DEVICE Device Interrupt Enable Clear */
       RoReg8 Reserved6[0x2];
  volatile USB_DEVICE_INTENSET_Type INTENSET; /**< \brief Offset: 0x018 (R/W 16) DEVICE Device Interrupt Enable Set */
       RoReg8 Reserved7[0x2];
  volatile USB_DEVICE_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x01C (R/W 16) DEVICE Device Interrupt Flag */
       RoReg8 Reserved8[0x2];
  volatile const USB_DEVICE_EPINTSMRY_Type EPINTSMRY; /**< \brief Offset: 0x020 (R/  16) DEVICE End Point Interrupt Summary */
       RoReg8 Reserved9[0x2];
  volatile USB_DESCADD_Type DESCADD; /**< \brief Offset: 0x024 (R/W 32) Descriptor Address */
  volatile USB_PADCAL_Type PADCAL; /**< \brief Offset: 0x028 (R/W 16) USB PAD Calibration */
       RoReg8 Reserved10[0xD6];
       UsbDeviceEndpoint DeviceEndpoint[8]; /**< \brief Offset: 0x100 UsbDeviceEndpoint groups [EPT_NUM] */
} UsbDevice;


/** \brief USB_HOST hardware registers */

typedef struct { /* USB is Host */
  volatile USB_CTRLA_Type CTRLA; /**< \brief Offset: 0x000 (R/W  8) Control A */
       RoReg8 Reserved1[0x1];
  volatile const USB_SYNCBUSY_Type SYNCBUSY; /**< \brief Offset: 0x002 (R/   8) Synchronization Busy */
  volatile USB_QOSCTRL_Type QOSCTRL; /**< \brief Offset: 0x003 (R/W  8) USB Quality Of Service */
       RoReg8 Reserved2[0x4];
  volatile USB_HOST_CTRLB_Type CTRLB; /**< \brief Offset: 0x008 (R/W 16) HOST Control B */
  volatile USB_HOST_HSOFC_Type HSOFC; /**< \brief Offset: 0x00A (R/W  8) HOST Host Start Of Frame Control */
       RoReg8 Reserved3[0x1];
  volatile USB_HOST_STATUS_Type STATUS; /**< \brief Offset: 0x00C (R/W  8) HOST Status */
  volatile const USB_FSMSTATUS_Type FSMSTATUS; /**< \brief Offset: 0x00D (R/   8) Finite State Machine Status */
       RoReg8 Reserved4[0x2];
  volatile USB_HOST_FNUM_Type FNUM; /**< \brief Offset: 0x010 (R/W 16) HOST Host Frame Number */
  volatile const USB_HOST_FLENHIGH_Type FLENHIGH; /**< \brief Offset: 0x012 (R/   8) HOST Host Frame Length */
       RoReg8 Reserved5[0x1];
  volatile USB_HOST_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x014 (R/W 16) HOST Host Interrupt Enable Clear */
       RoReg8 Reserved6[0x2];
  volatile USB_HOST_INTENSET_Type INTENSET; /**< \brief Offset: 0x018 (R/W 16) HOST Host Interrupt Enable Set */
       RoReg8 Reserved7[0x2];
  volatile USB_HOST_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x01C (R/W 16) HOST Host Interrupt Flag */
       RoReg8 Reserved8[0x2];
  volatile const USB_HOST_PINTSMRY_Type PINTSMRY; /**< \brief Offset: 0x020 (R/  16) HOST Pipe Interrupt Summary */
       RoReg8 Reserved9[0x2];
  volatile USB_DESCADD_Type DESCADD; /**< \brief Offset: 0x024 (R/W 32) Descriptor Address */
  volatile USB_PADCAL_Type PADCAL; /**< \brief Offset: 0x028 (R/W 16) USB PAD Calibration */
       RoReg8 Reserved10[0xD6];
       UsbHostPipe HostPipe[8]; /**< \brief Offset: 0x100 UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED] */
} UsbHost;


/** \brief USB_DEVICE Descriptor SRAM registers */

typedef struct { /* USB is Device */
       UsbDeviceDescBank DeviceDescBank[2]; /**< \brief Offset: 0x000 UsbDeviceDescBank groups */
} UsbDeviceDescriptor;


/** \brief USB_HOST Descriptor SRAM registers */

typedef struct { /* USB is Host */
       UsbHostDescBank HostDescBank[2]; /**< \brief Offset: 0x000 UsbHostDescBank groups [2*HOST_IMPLEMENTED] */
} UsbHostDescriptor;


#define SECTION_USB_DESCRIPTOR 


typedef union {
       UsbDevice DEVICE; /**< \brief Offset: 0x000 USB is Device */
       UsbHost HOST; /**< \brief Offset: 0x000 USB is Host */
} Usb;


/*@}*/
# 265 "asf4/samd21/include/samd21e18a.h" 2
#include "component/wdt.h"
# 265 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/component/wdt.h" 1
/**
 * \file
 *
 * \brief Component description for WDT
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_WDT_COMPONENT_ 

/* ========================================================================== */
/**  SOFTWARE API DEFINITION FOR WDT */
/* ========================================================================== */
/** \addtogroup SAMD21_WDT Watchdog Timer */
/*@{*/

#define WDT_U2203 
#define REV_WDT 0x200

/* -------- WDT_CTRL : (WDT Offset: 0x0) (R/W  8) Control -------- */

typedef union {
  struct {
    uint8_t :1; /*!< bit:      0  Reserved                           */
    uint8_t ENABLE:1; /*!< bit:      1  Enable                             */
    uint8_t WEN:1; /*!< bit:      2  Watchdog Timer Window Mode Enable  */
    uint8_t :4; /*!< bit:  3.. 6  Reserved                           */
    uint8_t ALWAYSON:1; /*!< bit:      7  Always-On                          */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_CTRL_Type;


#define WDT_CTRL_OFFSET 0x0
#define WDT_CTRL_RESETVALUE _U_(0x00)

#define WDT_CTRL_ENABLE_Pos 1
#define WDT_CTRL_ENABLE (_U_(0x1) << WDT_CTRL_ENABLE_Pos)
#define WDT_CTRL_WEN_Pos 2
#define WDT_CTRL_WEN (_U_(0x1) << WDT_CTRL_WEN_Pos)
#define WDT_CTRL_ALWAYSON_Pos 7
#define WDT_CTRL_ALWAYSON (_U_(0x1) << WDT_CTRL_ALWAYSON_Pos)
#define WDT_CTRL_MASK _U_(0x86)

/* -------- WDT_CONFIG : (WDT Offset: 0x1) (R/W  8) Configuration -------- */

typedef union {
  struct {
    uint8_t PER:4; /*!< bit:  0.. 3  Time-Out Period                    */
    uint8_t WINDOW:4; /*!< bit:  4.. 7  Window Mode Time-Out Period        */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_CONFIG_Type;


#define WDT_CONFIG_OFFSET 0x1
#define WDT_CONFIG_RESETVALUE _U_(0xBB)

#define WDT_CONFIG_PER_Pos 0
#define WDT_CONFIG_PER_Msk (_U_(0xF) << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER(value) (WDT_CONFIG_PER_Msk & ((value) << WDT_CONFIG_PER_Pos))
#define WDT_CONFIG_PER_8_Val _U_(0x0)
#define WDT_CONFIG_PER_16_Val _U_(0x1)
#define WDT_CONFIG_PER_32_Val _U_(0x2)
#define WDT_CONFIG_PER_64_Val _U_(0x3)
#define WDT_CONFIG_PER_128_Val _U_(0x4)
#define WDT_CONFIG_PER_256_Val _U_(0x5)
#define WDT_CONFIG_PER_512_Val _U_(0x6)
#define WDT_CONFIG_PER_1K_Val _U_(0x7)
#define WDT_CONFIG_PER_2K_Val _U_(0x8)
#define WDT_CONFIG_PER_4K_Val _U_(0x9)
#define WDT_CONFIG_PER_8K_Val _U_(0xA)
#define WDT_CONFIG_PER_16K_Val _U_(0xB)
#define WDT_CONFIG_PER_8 (WDT_CONFIG_PER_8_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_16 (WDT_CONFIG_PER_16_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_32 (WDT_CONFIG_PER_32_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_64 (WDT_CONFIG_PER_64_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_128 (WDT_CONFIG_PER_128_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_256 (WDT_CONFIG_PER_256_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_512 (WDT_CONFIG_PER_512_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_1K (WDT_CONFIG_PER_1K_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_2K (WDT_CONFIG_PER_2K_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_4K (WDT_CONFIG_PER_4K_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_8K (WDT_CONFIG_PER_8K_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_PER_16K (WDT_CONFIG_PER_16K_Val << WDT_CONFIG_PER_Pos)
#define WDT_CONFIG_WINDOW_Pos 4
#define WDT_CONFIG_WINDOW_Msk (_U_(0xF) << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW(value) (WDT_CONFIG_WINDOW_Msk & ((value) << WDT_CONFIG_WINDOW_Pos))
#define WDT_CONFIG_WINDOW_8_Val _U_(0x0)
#define WDT_CONFIG_WINDOW_16_Val _U_(0x1)
#define WDT_CONFIG_WINDOW_32_Val _U_(0x2)
#define WDT_CONFIG_WINDOW_64_Val _U_(0x3)
#define WDT_CONFIG_WINDOW_128_Val _U_(0x4)
#define WDT_CONFIG_WINDOW_256_Val _U_(0x5)
#define WDT_CONFIG_WINDOW_512_Val _U_(0x6)
#define WDT_CONFIG_WINDOW_1K_Val _U_(0x7)
#define WDT_CONFIG_WINDOW_2K_Val _U_(0x8)
#define WDT_CONFIG_WINDOW_4K_Val _U_(0x9)
#define WDT_CONFIG_WINDOW_8K_Val _U_(0xA)
#define WDT_CONFIG_WINDOW_16K_Val _U_(0xB)
#define WDT_CONFIG_WINDOW_8 (WDT_CONFIG_WINDOW_8_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_16 (WDT_CONFIG_WINDOW_16_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_32 (WDT_CONFIG_WINDOW_32_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_64 (WDT_CONFIG_WINDOW_64_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_128 (WDT_CONFIG_WINDOW_128_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_256 (WDT_CONFIG_WINDOW_256_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_512 (WDT_CONFIG_WINDOW_512_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_1K (WDT_CONFIG_WINDOW_1K_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_2K (WDT_CONFIG_WINDOW_2K_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_4K (WDT_CONFIG_WINDOW_4K_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_8K (WDT_CONFIG_WINDOW_8K_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_WINDOW_16K (WDT_CONFIG_WINDOW_16K_Val << WDT_CONFIG_WINDOW_Pos)
#define WDT_CONFIG_MASK _U_(0xFF)

/* -------- WDT_EWCTRL : (WDT Offset: 0x2) (R/W  8) Early Warning Interrupt Control -------- */

typedef union {
  struct {
    uint8_t EWOFFSET:4; /*!< bit:  0.. 3  Early Warning Interrupt Time Offset */
    uint8_t :4; /*!< bit:  4.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_EWCTRL_Type;


#define WDT_EWCTRL_OFFSET 0x2
#define WDT_EWCTRL_RESETVALUE _U_(0x0B)

#define WDT_EWCTRL_EWOFFSET_Pos 0
#define WDT_EWCTRL_EWOFFSET_Msk (_U_(0xF) << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET(value) (WDT_EWCTRL_EWOFFSET_Msk & ((value) << WDT_EWCTRL_EWOFFSET_Pos))
#define WDT_EWCTRL_EWOFFSET_8_Val _U_(0x0)
#define WDT_EWCTRL_EWOFFSET_16_Val _U_(0x1)
#define WDT_EWCTRL_EWOFFSET_32_Val _U_(0x2)
#define WDT_EWCTRL_EWOFFSET_64_Val _U_(0x3)
#define WDT_EWCTRL_EWOFFSET_128_Val _U_(0x4)
#define WDT_EWCTRL_EWOFFSET_256_Val _U_(0x5)
#define WDT_EWCTRL_EWOFFSET_512_Val _U_(0x6)
#define WDT_EWCTRL_EWOFFSET_1K_Val _U_(0x7)
#define WDT_EWCTRL_EWOFFSET_2K_Val _U_(0x8)
#define WDT_EWCTRL_EWOFFSET_4K_Val _U_(0x9)
#define WDT_EWCTRL_EWOFFSET_8K_Val _U_(0xA)
#define WDT_EWCTRL_EWOFFSET_16K_Val _U_(0xB)
#define WDT_EWCTRL_EWOFFSET_8 (WDT_EWCTRL_EWOFFSET_8_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_16 (WDT_EWCTRL_EWOFFSET_16_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_32 (WDT_EWCTRL_EWOFFSET_32_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_64 (WDT_EWCTRL_EWOFFSET_64_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_128 (WDT_EWCTRL_EWOFFSET_128_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_256 (WDT_EWCTRL_EWOFFSET_256_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_512 (WDT_EWCTRL_EWOFFSET_512_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_1K (WDT_EWCTRL_EWOFFSET_1K_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_2K (WDT_EWCTRL_EWOFFSET_2K_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_4K (WDT_EWCTRL_EWOFFSET_4K_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_8K (WDT_EWCTRL_EWOFFSET_8K_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_EWOFFSET_16K (WDT_EWCTRL_EWOFFSET_16K_Val << WDT_EWCTRL_EWOFFSET_Pos)
#define WDT_EWCTRL_MASK _U_(0x0F)

/* -------- WDT_INTENCLR : (WDT Offset: 0x4) (R/W  8) Interrupt Enable Clear -------- */

typedef union {
  struct {
    uint8_t EW:1; /*!< bit:      0  Early Warning Interrupt Enable     */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_INTENCLR_Type;


#define WDT_INTENCLR_OFFSET 0x4
#define WDT_INTENCLR_RESETVALUE _U_(0x00)

#define WDT_INTENCLR_EW_Pos 0
#define WDT_INTENCLR_EW (_U_(0x1) << WDT_INTENCLR_EW_Pos)
#define WDT_INTENCLR_MASK _U_(0x01)

/* -------- WDT_INTENSET : (WDT Offset: 0x5) (R/W  8) Interrupt Enable Set -------- */

typedef union {
  struct {
    uint8_t EW:1; /*!< bit:      0  Early Warning Interrupt Enable     */
    uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_INTENSET_Type;


#define WDT_INTENSET_OFFSET 0x5
#define WDT_INTENSET_RESETVALUE _U_(0x00)

#define WDT_INTENSET_EW_Pos 0
#define WDT_INTENSET_EW (_U_(0x1) << WDT_INTENSET_EW_Pos)
#define WDT_INTENSET_MASK _U_(0x01)

/* -------- WDT_INTFLAG : (WDT Offset: 0x6) (R/W  8) Interrupt Flag Status and Clear -------- */

typedef union { // __I to avoid read-modify-write on write-to-clear register
  struct {
    volatile const uint8_t EW:1; /*!< bit:      0  Early Warning                      */
    volatile const uint8_t :7; /*!< bit:  1.. 7  Reserved                           */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_INTFLAG_Type;


#define WDT_INTFLAG_OFFSET 0x6
#define WDT_INTFLAG_RESETVALUE _U_(0x00)

#define WDT_INTFLAG_EW_Pos 0
#define WDT_INTFLAG_EW (_U_(0x1) << WDT_INTFLAG_EW_Pos)
#define WDT_INTFLAG_MASK _U_(0x01)

/* -------- WDT_STATUS : (WDT Offset: 0x7) (R/   8) Status -------- */

typedef union {
  struct {
    uint8_t :7; /*!< bit:  0.. 6  Reserved                           */
    uint8_t SYNCBUSY:1; /*!< bit:      7  Synchronization Busy               */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_STATUS_Type;


#define WDT_STATUS_OFFSET 0x7
#define WDT_STATUS_RESETVALUE _U_(0x00)

#define WDT_STATUS_SYNCBUSY_Pos 7
#define WDT_STATUS_SYNCBUSY (_U_(0x1) << WDT_STATUS_SYNCBUSY_Pos)
#define WDT_STATUS_MASK _U_(0x80)

/* -------- WDT_CLEAR : (WDT Offset: 0x8) ( /W  8) Clear -------- */

typedef union {
  struct {
    uint8_t CLEAR:8; /*!< bit:  0.. 7  Watchdog Clear                     */
  } bit; /*!< Structure used for bit  access                  */
  uint8_t reg; /*!< Type      used for register access              */
} WDT_CLEAR_Type;


#define WDT_CLEAR_OFFSET 0x8
#define WDT_CLEAR_RESETVALUE _U_(0x00)

#define WDT_CLEAR_CLEAR_Pos 0
#define WDT_CLEAR_CLEAR_Msk (_U_(0xFF) << WDT_CLEAR_CLEAR_Pos)
#define WDT_CLEAR_CLEAR(value) (WDT_CLEAR_CLEAR_Msk & ((value) << WDT_CLEAR_CLEAR_Pos))
#define WDT_CLEAR_CLEAR_KEY_Val _U_(0xA5)
#define WDT_CLEAR_CLEAR_KEY (WDT_CLEAR_CLEAR_KEY_Val << WDT_CLEAR_CLEAR_Pos)
#define WDT_CLEAR_MASK _U_(0xFF)

/** \brief WDT hardware registers */

typedef struct {
  volatile WDT_CTRL_Type CTRL; /**< \brief Offset: 0x0 (R/W  8) Control */
  volatile WDT_CONFIG_Type CONFIG; /**< \brief Offset: 0x1 (R/W  8) Configuration */
  volatile WDT_EWCTRL_Type EWCTRL; /**< \brief Offset: 0x2 (R/W  8) Early Warning Interrupt Control */
       RoReg8 Reserved1[0x1];
  volatile WDT_INTENCLR_Type INTENCLR; /**< \brief Offset: 0x4 (R/W  8) Interrupt Enable Clear */
  volatile WDT_INTENSET_Type INTENSET; /**< \brief Offset: 0x5 (R/W  8) Interrupt Enable Set */
  volatile WDT_INTFLAG_Type INTFLAG; /**< \brief Offset: 0x6 (R/W  8) Interrupt Flag Status and Clear */
  volatile const WDT_STATUS_Type STATUS; /**< \brief Offset: 0x7 (R/   8) Status */
  volatile WDT_CLEAR_Type CLEAR; /**< \brief Offset: 0x8 ( /W  8) Clear */
} Wdt;


/*@}*/
# 266 "asf4/samd21/include/samd21e18a.h" 2
/*@}*/

/* ************************************************************************** */
/**  REGISTERS ACCESS DEFINITIONS FOR SAMD21E18A */
/* ************************************************************************** */
/** \defgroup SAMD21E18A_reg Registers Access Definitions */
/*@{*/

#include "instance/ac.h"
# 274 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/ac.h" 1
/**
 * \file
 *
 * \brief Instance description for AC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_AC_INSTANCE_ 

/* ========== Register definition for AC peripheral ========== */
# 50 "asf4/samd21/include/instance/ac.h"
#define REG_AC_CTRLA (*(RwReg8 *)0x42004400UL)
#define REG_AC_CTRLB (*(WoReg8 *)0x42004401UL)
#define REG_AC_EVCTRL (*(RwReg16*)0x42004402UL)
#define REG_AC_INTENCLR (*(RwReg8 *)0x42004404UL)
#define REG_AC_INTENSET (*(RwReg8 *)0x42004405UL)
#define REG_AC_INTFLAG (*(RwReg8 *)0x42004406UL)
#define REG_AC_STATUSA (*(RoReg8 *)0x42004408UL)
#define REG_AC_STATUSB (*(RoReg8 *)0x42004409UL)
#define REG_AC_STATUSC (*(RoReg8 *)0x4200440AUL)
#define REG_AC_WINCTRL (*(RwReg8 *)0x4200440CUL)
#define REG_AC_COMPCTRL0 (*(RwReg *)0x42004410UL)
#define REG_AC_COMPCTRL1 (*(RwReg *)0x42004414UL)
#define REG_AC_SCALER0 (*(RwReg8 *)0x42004420UL)
#define REG_AC_SCALER1 (*(RwReg8 *)0x42004421UL)


/* ========== Instance parameters for AC peripheral ========== */
#define AC_CMP_NUM 2
#define AC_GCLK_ID_ANA 32
#define AC_GCLK_ID_DIG 31
#define AC_NUM_CMP 2
#define AC_PAIRS 1
# 275 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/adc.h"
# 275 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/adc.h" 1
/**
 * \file
 *
 * \brief Instance description for ADC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_ADC_INSTANCE_ 

/* ========== Register definition for ADC peripheral ========== */
# 56 "asf4/samd21/include/instance/adc.h"
#define REG_ADC_CTRLA (*(RwReg8 *)0x42004000UL)
#define REG_ADC_REFCTRL (*(RwReg8 *)0x42004001UL)
#define REG_ADC_AVGCTRL (*(RwReg8 *)0x42004002UL)
#define REG_ADC_SAMPCTRL (*(RwReg8 *)0x42004003UL)
#define REG_ADC_CTRLB (*(RwReg16*)0x42004004UL)
#define REG_ADC_WINCTRL (*(RwReg8 *)0x42004008UL)
#define REG_ADC_SWTRIG (*(RwReg8 *)0x4200400CUL)
#define REG_ADC_INPUTCTRL (*(RwReg *)0x42004010UL)
#define REG_ADC_EVCTRL (*(RwReg8 *)0x42004014UL)
#define REG_ADC_INTENCLR (*(RwReg8 *)0x42004016UL)
#define REG_ADC_INTENSET (*(RwReg8 *)0x42004017UL)
#define REG_ADC_INTFLAG (*(RwReg8 *)0x42004018UL)
#define REG_ADC_STATUS (*(RoReg8 *)0x42004019UL)
#define REG_ADC_RESULT (*(RoReg16*)0x4200401AUL)
#define REG_ADC_WINLT (*(RwReg16*)0x4200401CUL)
#define REG_ADC_WINUT (*(RwReg16*)0x42004020UL)
#define REG_ADC_GAINCORR (*(RwReg16*)0x42004024UL)
#define REG_ADC_OFFSETCORR (*(RwReg16*)0x42004026UL)
#define REG_ADC_CALIB (*(RwReg16*)0x42004028UL)
#define REG_ADC_DBGCTRL (*(RwReg8 *)0x4200402AUL)


/* ========== Instance parameters for ADC peripheral ========== */
#define ADC_DMAC_ID_RESRDY 39
#define ADC_EXTCHANNEL_MSB 19
#define ADC_GCLK_ID 30
#define ADC_RESULT_BITS 16
#define ADC_RESULT_MSB 15
# 276 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/dac.h"
# 276 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/dac.h" 1
/**
 * \file
 *
 * \brief Instance description for DAC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_DAC_INSTANCE_ 

/* ========== Register definition for DAC peripheral ========== */
# 45 "asf4/samd21/include/instance/dac.h"
#define REG_DAC_CTRLA (*(RwReg8 *)0x42004800UL)
#define REG_DAC_CTRLB (*(RwReg8 *)0x42004801UL)
#define REG_DAC_EVCTRL (*(RwReg8 *)0x42004802UL)
#define REG_DAC_INTENCLR (*(RwReg8 *)0x42004804UL)
#define REG_DAC_INTENSET (*(RwReg8 *)0x42004805UL)
#define REG_DAC_INTFLAG (*(RwReg8 *)0x42004806UL)
#define REG_DAC_STATUS (*(RoReg8 *)0x42004807UL)
#define REG_DAC_DATA (*(RwReg16*)0x42004808UL)
#define REG_DAC_DATABUF (*(RwReg16*)0x4200480CUL)


/* ========== Instance parameters for DAC peripheral ========== */
#define DAC_DMAC_ID_EMPTY 40
#define DAC_GCLK_ID 33
# 277 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/dmac.h"
# 277 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/dmac.h" 1
/**
 * \file
 *
 * \brief Instance description for DMAC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_DMAC_INSTANCE_ 

/* ========== Register definition for DMAC peripheral ========== */
# 59 "asf4/samd21/include/instance/dmac.h"
#define REG_DMAC_CTRL (*(RwReg16*)0x41004800UL)
#define REG_DMAC_CRCCTRL (*(RwReg16*)0x41004802UL)
#define REG_DMAC_CRCDATAIN (*(RwReg *)0x41004804UL)
#define REG_DMAC_CRCCHKSUM (*(RwReg *)0x41004808UL)
#define REG_DMAC_CRCSTATUS (*(RwReg8 *)0x4100480CUL)
#define REG_DMAC_DBGCTRL (*(RwReg8 *)0x4100480DUL)
#define REG_DMAC_QOSCTRL (*(RwReg8 *)0x4100480EUL)
#define REG_DMAC_SWTRIGCTRL (*(RwReg *)0x41004810UL)
#define REG_DMAC_PRICTRL0 (*(RwReg *)0x41004814UL)
#define REG_DMAC_INTPEND (*(RwReg16*)0x41004820UL)
#define REG_DMAC_INTSTATUS (*(RoReg *)0x41004824UL)
#define REG_DMAC_BUSYCH (*(RoReg *)0x41004828UL)
#define REG_DMAC_PENDCH (*(RoReg *)0x4100482CUL)
#define REG_DMAC_ACTIVE (*(RoReg *)0x41004830UL)
#define REG_DMAC_BASEADDR (*(RwReg *)0x41004834UL)
#define REG_DMAC_WRBADDR (*(RwReg *)0x41004838UL)
#define REG_DMAC_CHID (*(RwReg8 *)0x4100483FUL)
#define REG_DMAC_CHCTRLA (*(RwReg8 *)0x41004840UL)
#define REG_DMAC_CHCTRLB (*(RwReg *)0x41004844UL)
#define REG_DMAC_CHINTENCLR (*(RwReg8 *)0x4100484CUL)
#define REG_DMAC_CHINTENSET (*(RwReg8 *)0x4100484DUL)
#define REG_DMAC_CHINTFLAG (*(RwReg8 *)0x4100484EUL)
#define REG_DMAC_CHSTATUS (*(RoReg8 *)0x4100484FUL)


/* ========== Instance parameters for DMAC peripheral ========== */
#define DMAC_CH_BITS 4
#define DMAC_CH_NUM 12
#define DMAC_CLK_AHB_ID 5
#define DMAC_EVIN_NUM 4
#define DMAC_EVOUT_NUM 4
#define DMAC_LVL_BITS 2
#define DMAC_LVL_NUM 4
#define DMAC_TRIG_BITS 6
#define DMAC_TRIG_NUM 45
# 278 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/dsu.h"
# 278 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/dsu.h" 1
/**
 * \file
 *
 * \brief Instance description for DSU
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_DSU_INSTANCE_ 

/* ========== Register definition for DSU peripheral ========== */
# 58 "asf4/samd21/include/instance/dsu.h"
#define REG_DSU_CTRL (*(WoReg8 *)0x41002000UL)
#define REG_DSU_STATUSA (*(RwReg8 *)0x41002001UL)
#define REG_DSU_STATUSB (*(RoReg8 *)0x41002002UL)
#define REG_DSU_ADDR (*(RwReg *)0x41002004UL)
#define REG_DSU_LENGTH (*(RwReg *)0x41002008UL)
#define REG_DSU_DATA (*(RwReg *)0x4100200CUL)
#define REG_DSU_DCC0 (*(RwReg *)0x41002010UL)
#define REG_DSU_DCC1 (*(RwReg *)0x41002014UL)
#define REG_DSU_DID (*(RoReg *)0x41002018UL)
#define REG_DSU_ENTRY (*(RoReg *)0x41003000UL)
#define REG_DSU_ENTRY1 (*(RoReg *)0x41003004UL)
#define REG_DSU_END (*(RoReg *)0x41003008UL)
#define REG_DSU_MEMTYPE (*(RoReg *)0x41003FCCUL)
#define REG_DSU_PID4 (*(RoReg *)0x41003FD0UL)
#define REG_DSU_PID0 (*(RoReg *)0x41003FE0UL)
#define REG_DSU_PID1 (*(RoReg *)0x41003FE4UL)
#define REG_DSU_PID2 (*(RoReg *)0x41003FE8UL)
#define REG_DSU_PID3 (*(RoReg *)0x41003FECUL)
#define REG_DSU_CID0 (*(RoReg *)0x41003FF0UL)
#define REG_DSU_CID1 (*(RoReg *)0x41003FF4UL)
#define REG_DSU_CID2 (*(RoReg *)0x41003FF8UL)
#define REG_DSU_CID3 (*(RoReg *)0x41003FFCUL)


/* ========== Instance parameters for DSU peripheral ========== */
#define DSU_CLK_HSB_ID 3
# 279 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/eic.h"
# 279 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/eic.h" 1
/**
 * \file
 *
 * \brief Instance description for EIC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_EIC_INSTANCE_ 

/* ========== Register definition for EIC peripheral ========== */
# 47 "asf4/samd21/include/instance/eic.h"
#define REG_EIC_CTRL (*(RwReg8 *)0x40001800UL)
#define REG_EIC_STATUS (*(RoReg8 *)0x40001801UL)
#define REG_EIC_NMICTRL (*(RwReg8 *)0x40001802UL)
#define REG_EIC_NMIFLAG (*(RwReg8 *)0x40001803UL)
#define REG_EIC_EVCTRL (*(RwReg *)0x40001804UL)
#define REG_EIC_INTENCLR (*(RwReg *)0x40001808UL)
#define REG_EIC_INTENSET (*(RwReg *)0x4000180CUL)
#define REG_EIC_INTFLAG (*(RwReg *)0x40001810UL)
#define REG_EIC_WAKEUP (*(RwReg *)0x40001814UL)
#define REG_EIC_CONFIG0 (*(RwReg *)0x40001818UL)
#define REG_EIC_CONFIG1 (*(RwReg *)0x4000181CUL)


/* ========== Instance parameters for EIC peripheral ========== */
#define EIC_CONFIG_NUM 2
#define EIC_GCLK_ID 5
# 280 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/evsys.h"
# 280 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/evsys.h" 1
/**
 * \file
 *
 * \brief Instance description for EVSYS
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_EVSYS_INSTANCE_ 

/* ========== Register definition for EVSYS peripheral ========== */
# 43 "asf4/samd21/include/instance/evsys.h"
#define REG_EVSYS_CTRL (*(WoReg8 *)0x42000400UL)
#define REG_EVSYS_CHANNEL (*(RwReg *)0x42000404UL)
#define REG_EVSYS_USER (*(RwReg16*)0x42000408UL)
#define REG_EVSYS_CHSTATUS (*(RoReg *)0x4200040CUL)
#define REG_EVSYS_INTENCLR (*(RwReg *)0x42000410UL)
#define REG_EVSYS_INTENSET (*(RwReg *)0x42000414UL)
#define REG_EVSYS_INTFLAG (*(RwReg *)0x42000418UL)


/* ========== Instance parameters for EVSYS peripheral ========== */
#define EVSYS_CHANNELS 12
#define EVSYS_CHANNELS_BITS 4
#define EVSYS_CHANNELS_MSB 11
#define EVSYS_EXTEVT_NUM 0
#define EVSYS_GCLK_ID_0 7
#define EVSYS_GCLK_ID_1 8
#define EVSYS_GCLK_ID_2 9
#define EVSYS_GCLK_ID_3 10
#define EVSYS_GCLK_ID_4 11
#define EVSYS_GCLK_ID_5 12
#define EVSYS_GCLK_ID_6 13
#define EVSYS_GCLK_ID_7 14
#define EVSYS_GCLK_ID_8 15
#define EVSYS_GCLK_ID_9 16
#define EVSYS_GCLK_ID_10 17
#define EVSYS_GCLK_ID_11 18
#define EVSYS_GCLK_ID_LSB 7
#define EVSYS_GCLK_ID_MSB 18
#define EVSYS_GCLK_ID_SIZE 12
#define EVSYS_GENERATORS 73
#define EVSYS_GENERATORS_BITS 7
#define EVSYS_USERS 29
#define EVSYS_USERS_BITS 5

// GENERATORS
#define EVSYS_ID_GEN_RTC_CMP_0 1
#define EVSYS_ID_GEN_RTC_CMP_1 2
#define EVSYS_ID_GEN_RTC_OVF 3
#define EVSYS_ID_GEN_RTC_PER_0 4
#define EVSYS_ID_GEN_RTC_PER_1 5
#define EVSYS_ID_GEN_RTC_PER_2 6
#define EVSYS_ID_GEN_RTC_PER_3 7
#define EVSYS_ID_GEN_RTC_PER_4 8
#define EVSYS_ID_GEN_RTC_PER_5 9
#define EVSYS_ID_GEN_RTC_PER_6 10
#define EVSYS_ID_GEN_RTC_PER_7 11
#define EVSYS_ID_GEN_EIC_EXTINT_0 12
#define EVSYS_ID_GEN_EIC_EXTINT_1 13
#define EVSYS_ID_GEN_EIC_EXTINT_2 14
#define EVSYS_ID_GEN_EIC_EXTINT_3 15
#define EVSYS_ID_GEN_EIC_EXTINT_4 16
#define EVSYS_ID_GEN_EIC_EXTINT_5 17
#define EVSYS_ID_GEN_EIC_EXTINT_6 18
#define EVSYS_ID_GEN_EIC_EXTINT_7 19
#define EVSYS_ID_GEN_EIC_EXTINT_8 20
#define EVSYS_ID_GEN_EIC_EXTINT_9 21
#define EVSYS_ID_GEN_EIC_EXTINT_10 22
#define EVSYS_ID_GEN_EIC_EXTINT_11 23
#define EVSYS_ID_GEN_EIC_EXTINT_12 24
#define EVSYS_ID_GEN_EIC_EXTINT_13 25
#define EVSYS_ID_GEN_EIC_EXTINT_14 26
#define EVSYS_ID_GEN_EIC_EXTINT_15 27
#define EVSYS_ID_GEN_EIC_EXTINT_16 28
#define EVSYS_ID_GEN_EIC_EXTINT_17 29
#define EVSYS_ID_GEN_DMAC_CH_0 30
#define EVSYS_ID_GEN_DMAC_CH_1 31
#define EVSYS_ID_GEN_DMAC_CH_2 32
#define EVSYS_ID_GEN_DMAC_CH_3 33
#define EVSYS_ID_GEN_TCC0_OVF 34
#define EVSYS_ID_GEN_TCC0_TRG 35
#define EVSYS_ID_GEN_TCC0_CNT 36
#define EVSYS_ID_GEN_TCC0_MCX_0 37
#define EVSYS_ID_GEN_TCC0_MCX_1 38
#define EVSYS_ID_GEN_TCC0_MCX_2 39
#define EVSYS_ID_GEN_TCC0_MCX_3 40
#define EVSYS_ID_GEN_TCC1_OVF 41
#define EVSYS_ID_GEN_TCC1_TRG 42
#define EVSYS_ID_GEN_TCC1_CNT 43
#define EVSYS_ID_GEN_TCC1_MCX_0 44
#define EVSYS_ID_GEN_TCC1_MCX_1 45
#define EVSYS_ID_GEN_TCC2_OVF 46
#define EVSYS_ID_GEN_TCC2_TRG 47
#define EVSYS_ID_GEN_TCC2_CNT 48
#define EVSYS_ID_GEN_TCC2_MCX_0 49
#define EVSYS_ID_GEN_TCC2_MCX_1 50
#define EVSYS_ID_GEN_TC3_OVF 51
#define EVSYS_ID_GEN_TC3_MCX_0 52
#define EVSYS_ID_GEN_TC3_MCX_1 53
#define EVSYS_ID_GEN_TC4_OVF 54
#define EVSYS_ID_GEN_TC4_MCX_0 55
#define EVSYS_ID_GEN_TC4_MCX_1 56
#define EVSYS_ID_GEN_TC5_OVF 57
#define EVSYS_ID_GEN_TC5_MCX_0 58
#define EVSYS_ID_GEN_TC5_MCX_1 59
#define EVSYS_ID_GEN_TC6_OVF 60
#define EVSYS_ID_GEN_TC6_MCX_0 61
#define EVSYS_ID_GEN_TC6_MCX_1 62
#define EVSYS_ID_GEN_TC7_OVF 63
#define EVSYS_ID_GEN_TC7_MCX_0 64
#define EVSYS_ID_GEN_TC7_MCX_1 65
#define EVSYS_ID_GEN_ADC_RESRDY 66
#define EVSYS_ID_GEN_ADC_WINMON 67
#define EVSYS_ID_GEN_AC_COMP_0 68
#define EVSYS_ID_GEN_AC_COMP_1 69
#define EVSYS_ID_GEN_AC_WIN_0 70
#define EVSYS_ID_GEN_DAC_EMPTY 71

// USERS
#define EVSYS_ID_USER_DMAC_CH_0 0
#define EVSYS_ID_USER_DMAC_CH_1 1
#define EVSYS_ID_USER_DMAC_CH_2 2
#define EVSYS_ID_USER_DMAC_CH_3 3
#define EVSYS_ID_USER_TCC0_EV_0 4
#define EVSYS_ID_USER_TCC0_EV_1 5
#define EVSYS_ID_USER_TCC0_MC_0 6
#define EVSYS_ID_USER_TCC0_MC_1 7
#define EVSYS_ID_USER_TCC0_MC_2 8
#define EVSYS_ID_USER_TCC0_MC_3 9
#define EVSYS_ID_USER_TCC1_EV_0 10
#define EVSYS_ID_USER_TCC1_EV_1 11
#define EVSYS_ID_USER_TCC1_MC_0 12
#define EVSYS_ID_USER_TCC1_MC_1 13
#define EVSYS_ID_USER_TCC2_EV_0 14
#define EVSYS_ID_USER_TCC2_EV_1 15
#define EVSYS_ID_USER_TCC2_MC_0 16
#define EVSYS_ID_USER_TCC2_MC_1 17
#define EVSYS_ID_USER_TC3_EVU 18
#define EVSYS_ID_USER_TC4_EVU 19
#define EVSYS_ID_USER_TC5_EVU 20
#define EVSYS_ID_USER_TC6_EVU 21
#define EVSYS_ID_USER_TC7_EVU 22
#define EVSYS_ID_USER_ADC_START 23
#define EVSYS_ID_USER_ADC_SYNC 24
#define EVSYS_ID_USER_AC_SOC_0 25
#define EVSYS_ID_USER_AC_SOC_1 26
#define EVSYS_ID_USER_DAC_START 27
# 281 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/gclk.h"
# 281 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/gclk.h" 1
/**
 * \file
 *
 * \brief Instance description for GCLK
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_GCLK_INSTANCE_ 

/* ========== Register definition for GCLK peripheral ========== */







#define REG_GCLK_CTRL (*(RwReg8 *)0x40000C00UL)
#define REG_GCLK_STATUS (*(RoReg8 *)0x40000C01UL)
#define REG_GCLK_CLKCTRL (*(RwReg16*)0x40000C02UL)
#define REG_GCLK_GENCTRL (*(RwReg *)0x40000C04UL)
#define REG_GCLK_GENDIV (*(RwReg *)0x40000C08UL)


/* ========== Instance parameters for GCLK peripheral ========== */
#define GCLK_GENDIV_BITS 16
#define GCLK_GEN_NUM 9
#define GCLK_GEN_NUM_MSB 8
#define GCLK_GEN_SOURCE_NUM_MSB 8
#define GCLK_NUM 37
#define GCLK_SOURCE_DFLL48M 7
#define GCLK_SOURCE_DPLL96M 8
#define GCLK_SOURCE_GCLKGEN1 2
#define GCLK_SOURCE_GCLKIN 1
#define GCLK_SOURCE_NUM 9
#define GCLK_SOURCE_OSCULP32K 3
#define GCLK_SOURCE_OSC8M 6
#define GCLK_SOURCE_OSC32K 4
#define GCLK_SOURCE_XOSC 0
#define GCLK_SOURCE_XOSC32K 5
# 282 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/sbmatrix.h"
# 282 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/sbmatrix.h" 1
/**
 * \file
 *
 * \brief Instance description for SBMATRIX
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SBMATRIX_INSTANCE_ 

/* ========== Register definition for SBMATRIX peripheral ========== */
# 84 "asf4/samd21/include/instance/sbmatrix.h"
#define REG_SBMATRIX_PRAS0 (*(RwReg *)0x41007080UL)
#define REG_SBMATRIX_PRBS0 (*(RwReg *)0x41007084UL)
#define REG_SBMATRIX_PRAS1 (*(RwReg *)0x41007088UL)
#define REG_SBMATRIX_PRBS1 (*(RwReg *)0x4100708CUL)
#define REG_SBMATRIX_PRAS2 (*(RwReg *)0x41007090UL)
#define REG_SBMATRIX_PRBS2 (*(RwReg *)0x41007094UL)
#define REG_SBMATRIX_PRAS3 (*(RwReg *)0x41007098UL)
#define REG_SBMATRIX_PRBS3 (*(RwReg *)0x4100709CUL)
#define REG_SBMATRIX_PRAS4 (*(RwReg *)0x410070A0UL)
#define REG_SBMATRIX_PRBS4 (*(RwReg *)0x410070A4UL)
#define REG_SBMATRIX_PRAS5 (*(RwReg *)0x410070A8UL)
#define REG_SBMATRIX_PRBS5 (*(RwReg *)0x410070ACUL)
#define REG_SBMATRIX_PRAS6 (*(RwReg *)0x410070B0UL)
#define REG_SBMATRIX_PRBS6 (*(RwReg *)0x410070B4UL)
#define REG_SBMATRIX_PRAS7 (*(RwReg *)0x410070B8UL)
#define REG_SBMATRIX_PRBS7 (*(RwReg *)0x410070BCUL)
#define REG_SBMATRIX_PRAS8 (*(RwReg *)0x410070C0UL)
#define REG_SBMATRIX_PRBS8 (*(RwReg *)0x410070C4UL)
#define REG_SBMATRIX_PRAS9 (*(RwReg *)0x410070C8UL)
#define REG_SBMATRIX_PRBS9 (*(RwReg *)0x410070CCUL)
#define REG_SBMATRIX_PRAS10 (*(RwReg *)0x410070D0UL)
#define REG_SBMATRIX_PRBS10 (*(RwReg *)0x410070D4UL)
#define REG_SBMATRIX_PRAS11 (*(RwReg *)0x410070D8UL)
#define REG_SBMATRIX_PRBS11 (*(RwReg *)0x410070DCUL)
#define REG_SBMATRIX_PRAS12 (*(RwReg *)0x410070E0UL)
#define REG_SBMATRIX_PRBS12 (*(RwReg *)0x410070E4UL)
#define REG_SBMATRIX_PRAS13 (*(RwReg *)0x410070E8UL)
#define REG_SBMATRIX_PRBS13 (*(RwReg *)0x410070ECUL)
#define REG_SBMATRIX_PRAS14 (*(RwReg *)0x410070F0UL)
#define REG_SBMATRIX_PRBS14 (*(RwReg *)0x410070F4UL)
#define REG_SBMATRIX_PRAS15 (*(RwReg *)0x410070F8UL)
#define REG_SBMATRIX_PRBS15 (*(RwReg *)0x410070FCUL)
#define REG_SBMATRIX_SFR0 (*(RwReg *)0x41007110UL)
#define REG_SBMATRIX_SFR1 (*(RwReg *)0x41007114UL)
#define REG_SBMATRIX_SFR2 (*(RwReg *)0x41007118UL)
#define REG_SBMATRIX_SFR3 (*(RwReg *)0x4100711CUL)
#define REG_SBMATRIX_SFR4 (*(RwReg *)0x41007120UL)
#define REG_SBMATRIX_SFR5 (*(RwReg *)0x41007124UL)
#define REG_SBMATRIX_SFR6 (*(RwReg *)0x41007128UL)
#define REG_SBMATRIX_SFR7 (*(RwReg *)0x4100712CUL)
#define REG_SBMATRIX_SFR8 (*(RwReg *)0x41007130UL)
#define REG_SBMATRIX_SFR9 (*(RwReg *)0x41007134UL)
#define REG_SBMATRIX_SFR10 (*(RwReg *)0x41007138UL)
#define REG_SBMATRIX_SFR11 (*(RwReg *)0x4100713CUL)
#define REG_SBMATRIX_SFR12 (*(RwReg *)0x41007140UL)
#define REG_SBMATRIX_SFR13 (*(RwReg *)0x41007144UL)
#define REG_SBMATRIX_SFR14 (*(RwReg *)0x41007148UL)
#define REG_SBMATRIX_SFR15 (*(RwReg *)0x4100714CUL)


/* ========== Instance parameters for SBMATRIX peripheral ========== */
#define SBMATRIX_DEFINED 
/* ========== Instance parameters for SBMATRIX ========== */
#define SBMATRIX_SLAVE_FLASH 0
#define SBMATRIX_SLAVE_HPB0 1
#define SBMATRIX_SLAVE_HPB1 2
#define SBMATRIX_SLAVE_HPB2 3
#define SBMATRIX_SLAVE_HMCRAMC0 4
#define SBMATRIX_SLAVE_HMCRAMC0_ALT0 5
#define SBMATRIX_SLAVE_HMCRAMC0_ALT1 6
#define SBMATRIX_SLAVE_NUM 7

#define SBMATRIX_MASTER_CM0PLUS 0
#define SBMATRIX_MASTER_DSU 1
#define SBMATRIX_MASTER_DMAC 2
#define SBMATRIX_MASTER_NUM 3
# 283 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/i2s.h"
# 283 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/i2s.h" 1
/**
 * \file
 *
 * \brief Instance description for I2S
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_I2S_INSTANCE_ 

/* ========== Register definition for I2S peripheral ========== */
# 47 "asf4/samd21/include/instance/i2s.h"
#define REG_I2S_CTRLA (*(RwReg8 *)0x42005000UL)
#define REG_I2S_CLKCTRL0 (*(RwReg *)0x42005004UL)
#define REG_I2S_CLKCTRL1 (*(RwReg *)0x42005008UL)
#define REG_I2S_INTENCLR (*(RwReg16*)0x4200500CUL)
#define REG_I2S_INTENSET (*(RwReg16*)0x42005010UL)
#define REG_I2S_INTFLAG (*(RwReg16*)0x42005014UL)
#define REG_I2S_SYNCBUSY (*(RoReg16*)0x42005018UL)
#define REG_I2S_SERCTRL0 (*(RwReg *)0x42005020UL)
#define REG_I2S_SERCTRL1 (*(RwReg *)0x42005024UL)
#define REG_I2S_DATA0 (*(RwReg *)0x42005030UL)
#define REG_I2S_DATA1 (*(RwReg *)0x42005034UL)


/* ========== Instance parameters for I2S peripheral ========== */
#define I2S_CLK_NUM 2
#define I2S_DMAC_ID_RX_0 41
#define I2S_DMAC_ID_RX_1 42
#define I2S_DMAC_ID_RX_LSB 41
#define I2S_DMAC_ID_RX_MSB 42
#define I2S_DMAC_ID_RX_SIZE 2
#define I2S_DMAC_ID_TX_0 43
#define I2S_DMAC_ID_TX_1 44
#define I2S_DMAC_ID_TX_LSB 43
#define I2S_DMAC_ID_TX_MSB 44
#define I2S_DMAC_ID_TX_SIZE 2
#define I2S_GCLK_ID_0 35
#define I2S_GCLK_ID_1 36
#define I2S_GCLK_ID_LSB 35
#define I2S_GCLK_ID_MSB 36
#define I2S_GCLK_ID_SIZE 2
#define I2S_MAX_SLOTS 8
#define I2S_SER_NUM 2
# 284 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/mtb.h"
# 284 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/mtb.h" 1
/**
 * \file
 *
 * \brief Instance description for MTB
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_MTB_INSTANCE_ 

/* ========== Register definition for MTB peripheral ========== */
# 61 "asf4/samd21/include/instance/mtb.h"
#define REG_MTB_POSITION (*(RwReg *)0x41006000UL)
#define REG_MTB_MASTER (*(RwReg *)0x41006004UL)
#define REG_MTB_FLOW (*(RwReg *)0x41006008UL)
#define REG_MTB_BASE (*(RoReg *)0x4100600CUL)
#define REG_MTB_ITCTRL (*(RwReg *)0x41006F00UL)
#define REG_MTB_CLAIMSET (*(RwReg *)0x41006FA0UL)
#define REG_MTB_CLAIMCLR (*(RwReg *)0x41006FA4UL)
#define REG_MTB_LOCKACCESS (*(RwReg *)0x41006FB0UL)
#define REG_MTB_LOCKSTATUS (*(RoReg *)0x41006FB4UL)
#define REG_MTB_AUTHSTATUS (*(RoReg *)0x41006FB8UL)
#define REG_MTB_DEVARCH (*(RoReg *)0x41006FBCUL)
#define REG_MTB_DEVID (*(RoReg *)0x41006FC8UL)
#define REG_MTB_DEVTYPE (*(RoReg *)0x41006FCCUL)
#define REG_MTB_PID4 (*(RoReg *)0x41006FD0UL)
#define REG_MTB_PID5 (*(RoReg *)0x41006FD4UL)
#define REG_MTB_PID6 (*(RoReg *)0x41006FD8UL)
#define REG_MTB_PID7 (*(RoReg *)0x41006FDCUL)
#define REG_MTB_PID0 (*(RoReg *)0x41006FE0UL)
#define REG_MTB_PID1 (*(RoReg *)0x41006FE4UL)
#define REG_MTB_PID2 (*(RoReg *)0x41006FE8UL)
#define REG_MTB_PID3 (*(RoReg *)0x41006FECUL)
#define REG_MTB_CID0 (*(RoReg *)0x41006FF0UL)
#define REG_MTB_CID1 (*(RoReg *)0x41006FF4UL)
#define REG_MTB_CID2 (*(RoReg *)0x41006FF8UL)
#define REG_MTB_CID3 (*(RoReg *)0x41006FFCUL)
# 285 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/nvmctrl.h"
# 285 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/nvmctrl.h" 1
/**
 * \file
 *
 * \brief Instance description for NVMCTRL
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_NVMCTRL_INSTANCE_ 

/* ========== Register definition for NVMCTRL peripheral ========== */
# 45 "asf4/samd21/include/instance/nvmctrl.h"
#define REG_NVMCTRL_CTRLA (*(RwReg16*)0x41004000UL)
#define REG_NVMCTRL_CTRLB (*(RwReg *)0x41004004UL)
#define REG_NVMCTRL_PARAM (*(RwReg *)0x41004008UL)
#define REG_NVMCTRL_INTENCLR (*(RwReg8 *)0x4100400CUL)
#define REG_NVMCTRL_INTENSET (*(RwReg8 *)0x41004010UL)
#define REG_NVMCTRL_INTFLAG (*(RwReg8 *)0x41004014UL)
#define REG_NVMCTRL_STATUS (*(RwReg16*)0x41004018UL)
#define REG_NVMCTRL_ADDR (*(RwReg *)0x4100401CUL)
#define REG_NVMCTRL_LOCK (*(RwReg16*)0x41004020UL)


/* ========== Instance parameters for NVMCTRL peripheral ========== */
#define NVMCTRL_AUX0_ADDRESS 0x00804000
#define NVMCTRL_AUX1_ADDRESS 0x00806000
#define NVMCTRL_AUX2_ADDRESS 0x00808000
#define NVMCTRL_AUX3_ADDRESS 0x0080A000
#define NVMCTRL_CLK_AHB_ID 4
#define NVMCTRL_FACTORY_WORD_IMPLEMENTED_MASK 0xC0000007FFFFFFFF
#define NVMCTRL_FLASH_SIZE 262144
#define NVMCTRL_LOCKBIT_ADDRESS 0x00802000
#define NVMCTRL_PAGE_HW 32
#define NVMCTRL_PAGE_SIZE 64
#define NVMCTRL_PAGE_W 16
#define NVMCTRL_PMSB 3
#define NVMCTRL_PSZ_BITS 6
#define NVMCTRL_ROW_PAGES 4
#define NVMCTRL_ROW_SIZE 256
#define NVMCTRL_TEMP_LOG_ADDRESS 0x00806030
#define NVMCTRL_USER_PAGE_ADDRESS 0x00800000
#define NVMCTRL_USER_PAGE_OFFSET 0x00800000
#define NVMCTRL_USER_WORD_IMPLEMENTED_MASK 0xC01FFFFFFFFFFFFF
# 286 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/pac0.h"
# 286 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/pac0.h" 1
/**
 * \file
 *
 * \brief Instance description for PAC0
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PAC0_INSTANCE_ 

/* ========== Register definition for PAC0 peripheral ========== */




#define REG_PAC0_WPCLR (*(RwReg *)0x40000000UL)
#define REG_PAC0_WPSET (*(RwReg *)0x40000004UL)


/* ========== Instance parameters for PAC0 peripheral ========== */
#define PAC0_WPROT_DEFAULT_VAL 0x00000000
# 287 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/pac1.h"
# 287 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/pac1.h" 1
/**
 * \file
 *
 * \brief Instance description for PAC1
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PAC1_INSTANCE_ 

/* ========== Register definition for PAC1 peripheral ========== */




#define REG_PAC1_WPCLR (*(RwReg *)0x41000000UL)
#define REG_PAC1_WPSET (*(RwReg *)0x41000004UL)


/* ========== Instance parameters for PAC1 peripheral ========== */
#define PAC1_WPROT_DEFAULT_VAL 0x00000002
# 288 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/pac2.h"
# 288 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/pac2.h" 1
/**
 * \file
 *
 * \brief Instance description for PAC2
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PAC2_INSTANCE_ 

/* ========== Register definition for PAC2 peripheral ========== */




#define REG_PAC2_WPCLR (*(RwReg *)0x42000000UL)
#define REG_PAC2_WPSET (*(RwReg *)0x42000004UL)


/* ========== Instance parameters for PAC2 peripheral ========== */
#define PAC2_WPROT_DEFAULT_VAL 0x00800000
# 289 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/pm.h"
# 289 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/pm.h" 1
/**
 * \file
 *
 * \brief Instance description for PM
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PM_INSTANCE_ 

/* ========== Register definition for PM peripheral ========== */
# 50 "asf4/samd21/include/instance/pm.h"
#define REG_PM_CTRL (*(RwReg8 *)0x40000400UL)
#define REG_PM_SLEEP (*(RwReg8 *)0x40000401UL)
#define REG_PM_CPUSEL (*(RwReg8 *)0x40000408UL)
#define REG_PM_APBASEL (*(RwReg8 *)0x40000409UL)
#define REG_PM_APBBSEL (*(RwReg8 *)0x4000040AUL)
#define REG_PM_APBCSEL (*(RwReg8 *)0x4000040BUL)
#define REG_PM_AHBMASK (*(RwReg *)0x40000414UL)
#define REG_PM_APBAMASK (*(RwReg *)0x40000418UL)
#define REG_PM_APBBMASK (*(RwReg *)0x4000041CUL)
#define REG_PM_APBCMASK (*(RwReg *)0x40000420UL)
#define REG_PM_INTENCLR (*(RwReg8 *)0x40000434UL)
#define REG_PM_INTENSET (*(RwReg8 *)0x40000435UL)
#define REG_PM_INTFLAG (*(RwReg8 *)0x40000436UL)
#define REG_PM_RCAUSE (*(RoReg8 *)0x40000438UL)


/* ========== Instance parameters for PM peripheral ========== */
#define PM_CTRL_MCSEL_DFLL48M 3
#define PM_CTRL_MCSEL_GCLK 0
#define PM_CTRL_MCSEL_OSC8M 1
#define PM_CTRL_MCSEL_XOSC 2
#define PM_PM_CLK_APB_NUM 2
# 290 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/port.h"
# 290 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/port.h" 1
/**
 * \file
 *
 * \brief Instance description for PORT
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_PORT_INSTANCE_ 

/* ========== Register definition for PORT peripheral ========== */
# 62 "asf4/samd21/include/instance/port.h"
#define REG_PORT_DIR0 (*(RwReg *)0x41004400UL)
#define REG_PORT_DIRCLR0 (*(RwReg *)0x41004404UL)
#define REG_PORT_DIRSET0 (*(RwReg *)0x41004408UL)
#define REG_PORT_DIRTGL0 (*(RwReg *)0x4100440CUL)
#define REG_PORT_OUT0 (*(RwReg *)0x41004410UL)
#define REG_PORT_OUTCLR0 (*(RwReg *)0x41004414UL)
#define REG_PORT_OUTSET0 (*(RwReg *)0x41004418UL)
#define REG_PORT_OUTTGL0 (*(RwReg *)0x4100441CUL)
#define REG_PORT_IN0 (*(RoReg *)0x41004420UL)
#define REG_PORT_CTRL0 (*(RwReg *)0x41004424UL)
#define REG_PORT_WRCONFIG0 (*(WoReg *)0x41004428UL)
#define REG_PORT_PMUX0 (*(RwReg *)0x41004430UL)
#define REG_PORT_PINCFG0 (*(RwReg *)0x41004440UL)
#define REG_PORT_DIR1 (*(RwReg *)0x41004480UL)
#define REG_PORT_DIRCLR1 (*(RwReg *)0x41004484UL)
#define REG_PORT_DIRSET1 (*(RwReg *)0x41004488UL)
#define REG_PORT_DIRTGL1 (*(RwReg *)0x4100448CUL)
#define REG_PORT_OUT1 (*(RwReg *)0x41004490UL)
#define REG_PORT_OUTCLR1 (*(RwReg *)0x41004494UL)
#define REG_PORT_OUTSET1 (*(RwReg *)0x41004498UL)
#define REG_PORT_OUTTGL1 (*(RwReg *)0x4100449CUL)
#define REG_PORT_IN1 (*(RoReg *)0x410044A0UL)
#define REG_PORT_CTRL1 (*(RwReg *)0x410044A4UL)
#define REG_PORT_WRCONFIG1 (*(WoReg *)0x410044A8UL)
#define REG_PORT_PMUX1 (*(RwReg *)0x410044B0UL)
#define REG_PORT_PINCFG1 (*(RwReg *)0x410044C0UL)


/* ========== Instance parameters for PORT peripheral ========== */
#define PORT_BITS 84
#define PORT_DIR_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_DIR_IMPLEMENTED { 0xDBFFFFFF, 0xC0C3FFFF, 0x000FFFFF }
#define PORT_DRVSTR 1
#define PORT_DRVSTR_DEFAULT_VAL { 0xD8FFFFFF, 0xC0C3FFFF, 0x000FFFFF }
#define PORT_DRVSTR_IMPLEMENTED { 0xD8FFFFFF, 0xC0C3FFFF, 0x000FFFFF }
#define PORT_EVENT_IMPLEMENTED { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_INEN_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_INEN_IMPLEMENTED { 0xD8FFFFFF, 0xC0C3FFFF, 0x000FFFFF }
#define PORT_ODRAIN 0
#define PORT_ODRAIN_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_ODRAIN_IMPLEMENTED { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_OUT_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_OUT_IMPLEMENTED { 0xDBFFFFFF, 0xC0C3FFFF, 0x000FFFFF }
#define PORT_PIN_IMPLEMENTED { 0xDBFFFFFF, 0xC0C3FFFF, 0x000FFFFF }
#define PORT_PMUXBIT0_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_PMUXBIT0_IMPLEMENTED { 0xDBFFFFFF, 0xC0C3FFFF, 0x000D0000 }
#define PORT_PMUXBIT1_DEFAULT_VAL { 0x40000000, 0x00000000, 0x00000000 }
#define PORT_PMUXBIT1_IMPLEMENTED { 0xDBFFFFF3, 0xC0C3FF0F, 0x00000000 }
#define PORT_PMUXBIT2_DEFAULT_VAL { 0x40000000, 0x00000000, 0x00000000 }
#define PORT_PMUXBIT2_IMPLEMENTED { 0xDBFFFFF3, 0xC0C3FF0F, 0x000D0000 }
#define PORT_PMUXBIT3_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_PMUXBIT3_IMPLEMENTED { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_PMUXEN_DEFAULT_VAL { 0x64000000, 0x3F3C0000, 0x00000000 }
#define PORT_PMUXEN_IMPLEMENTED { 0xDBFFFFFF, 0xC0C3FFFF, 0x000F7FFE }
#define PORT_PULLEN_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_PULLEN_IMPLEMENTED { 0xDBFFFFFF, 0xC0C3FFFF, 0x000FFFFF }
#define PORT_SLEWLIM 0
#define PORT_SLEWLIM_DEFAULT_VAL { 0x00000000, 0x00000000, 0x00000000 }
#define PORT_SLEWLIM_IMPLEMENTED { 0x00000000, 0x00000000, 0x00000000 }
# 291 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/rtc.h"
# 291 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/rtc.h" 1
/**
 * \file
 *
 * \brief Instance description for RTC
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_RTC_INSTANCE_ 

/* ========== Register definition for RTC peripheral ========== */
# 64 "asf4/samd21/include/instance/rtc.h"
#define REG_RTC_READREQ (*(RwReg16*)0x40001402UL)
#define REG_RTC_STATUS (*(RwReg8 *)0x4000140AUL)
#define REG_RTC_DBGCTRL (*(RwReg8 *)0x4000140BUL)
#define REG_RTC_FREQCORR (*(RwReg8 *)0x4000140CUL)
#define REG_RTC_MODE0_CTRL (*(RwReg16*)0x40001400UL)
#define REG_RTC_MODE0_EVCTRL (*(RwReg16*)0x40001404UL)
#define REG_RTC_MODE0_INTENCLR (*(RwReg8 *)0x40001406UL)
#define REG_RTC_MODE0_INTENSET (*(RwReg8 *)0x40001407UL)
#define REG_RTC_MODE0_INTFLAG (*(RwReg8 *)0x40001408UL)
#define REG_RTC_MODE0_COUNT (*(RwReg *)0x40001410UL)
#define REG_RTC_MODE0_COMP0 (*(RwReg *)0x40001418UL)
#define REG_RTC_MODE1_CTRL (*(RwReg16*)0x40001400UL)
#define REG_RTC_MODE1_EVCTRL (*(RwReg16*)0x40001404UL)
#define REG_RTC_MODE1_INTENCLR (*(RwReg8 *)0x40001406UL)
#define REG_RTC_MODE1_INTENSET (*(RwReg8 *)0x40001407UL)
#define REG_RTC_MODE1_INTFLAG (*(RwReg8 *)0x40001408UL)
#define REG_RTC_MODE1_COUNT (*(RwReg16*)0x40001410UL)
#define REG_RTC_MODE1_PER (*(RwReg16*)0x40001414UL)
#define REG_RTC_MODE1_COMP0 (*(RwReg16*)0x40001418UL)
#define REG_RTC_MODE1_COMP1 (*(RwReg16*)0x4000141AUL)
#define REG_RTC_MODE2_CTRL (*(RwReg16*)0x40001400UL)
#define REG_RTC_MODE2_EVCTRL (*(RwReg16*)0x40001404UL)
#define REG_RTC_MODE2_INTENCLR (*(RwReg8 *)0x40001406UL)
#define REG_RTC_MODE2_INTENSET (*(RwReg8 *)0x40001407UL)
#define REG_RTC_MODE2_INTFLAG (*(RwReg8 *)0x40001408UL)
#define REG_RTC_MODE2_CLOCK (*(RwReg *)0x40001410UL)
#define REG_RTC_MODE2_ALARM_ALARM0 (*(RwReg *)0x40001418UL)
#define REG_RTC_MODE2_ALARM_MASK0 (*(RwReg *)0x4000141CUL)


/* ========== Instance parameters for RTC peripheral ========== */
#define RTC_ALARM_NUM 1
#define RTC_COMP16_NUM 2
#define RTC_COMP32_NUM 1
#define RTC_GCLK_ID 4
#define RTC_NUM_OF_ALARMS 1
#define RTC_NUM_OF_COMP16 2
#define RTC_NUM_OF_COMP32 1
# 292 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/sercom0.h"
# 292 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/sercom0.h" 1
/**
 * \file
 *
 * \brief Instance description for SERCOM0
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SERCOM0_INSTANCE_ 

/* ========== Register definition for SERCOM0 peripheral ========== */
# 78 "asf4/samd21/include/instance/sercom0.h"
#define REG_SERCOM0_I2CM_CTRLA (*(RwReg *)0x42000800UL)
#define REG_SERCOM0_I2CM_CTRLB (*(RwReg *)0x42000804UL)
#define REG_SERCOM0_I2CM_BAUD (*(RwReg *)0x4200080CUL)
#define REG_SERCOM0_I2CM_INTENCLR (*(RwReg8 *)0x42000814UL)
#define REG_SERCOM0_I2CM_INTENSET (*(RwReg8 *)0x42000816UL)
#define REG_SERCOM0_I2CM_INTFLAG (*(RwReg8 *)0x42000818UL)
#define REG_SERCOM0_I2CM_STATUS (*(RwReg16*)0x4200081AUL)
#define REG_SERCOM0_I2CM_SYNCBUSY (*(RoReg *)0x4200081CUL)
#define REG_SERCOM0_I2CM_ADDR (*(RwReg *)0x42000824UL)
#define REG_SERCOM0_I2CM_DATA (*(RwReg8 *)0x42000828UL)
#define REG_SERCOM0_I2CM_DBGCTRL (*(RwReg8 *)0x42000830UL)
#define REG_SERCOM0_I2CS_CTRLA (*(RwReg *)0x42000800UL)
#define REG_SERCOM0_I2CS_CTRLB (*(RwReg *)0x42000804UL)
#define REG_SERCOM0_I2CS_INTENCLR (*(RwReg8 *)0x42000814UL)
#define REG_SERCOM0_I2CS_INTENSET (*(RwReg8 *)0x42000816UL)
#define REG_SERCOM0_I2CS_INTFLAG (*(RwReg8 *)0x42000818UL)
#define REG_SERCOM0_I2CS_STATUS (*(RwReg16*)0x4200081AUL)
#define REG_SERCOM0_I2CS_SYNCBUSY (*(RoReg *)0x4200081CUL)
#define REG_SERCOM0_I2CS_ADDR (*(RwReg *)0x42000824UL)
#define REG_SERCOM0_I2CS_DATA (*(RwReg8 *)0x42000828UL)
#define REG_SERCOM0_SPI_CTRLA (*(RwReg *)0x42000800UL)
#define REG_SERCOM0_SPI_CTRLB (*(RwReg *)0x42000804UL)
#define REG_SERCOM0_SPI_BAUD (*(RwReg8 *)0x4200080CUL)
#define REG_SERCOM0_SPI_INTENCLR (*(RwReg8 *)0x42000814UL)
#define REG_SERCOM0_SPI_INTENSET (*(RwReg8 *)0x42000816UL)
#define REG_SERCOM0_SPI_INTFLAG (*(RwReg8 *)0x42000818UL)
#define REG_SERCOM0_SPI_STATUS (*(RwReg16*)0x4200081AUL)
#define REG_SERCOM0_SPI_SYNCBUSY (*(RoReg *)0x4200081CUL)
#define REG_SERCOM0_SPI_ADDR (*(RwReg *)0x42000824UL)
#define REG_SERCOM0_SPI_DATA (*(RwReg *)0x42000828UL)
#define REG_SERCOM0_SPI_DBGCTRL (*(RwReg8 *)0x42000830UL)
#define REG_SERCOM0_USART_CTRLA (*(RwReg *)0x42000800UL)
#define REG_SERCOM0_USART_CTRLB (*(RwReg *)0x42000804UL)
#define REG_SERCOM0_USART_BAUD (*(RwReg16*)0x4200080CUL)
#define REG_SERCOM0_USART_RXPL (*(RwReg8 *)0x4200080EUL)
#define REG_SERCOM0_USART_INTENCLR (*(RwReg8 *)0x42000814UL)
#define REG_SERCOM0_USART_INTENSET (*(RwReg8 *)0x42000816UL)
#define REG_SERCOM0_USART_INTFLAG (*(RwReg8 *)0x42000818UL)
#define REG_SERCOM0_USART_STATUS (*(RwReg16*)0x4200081AUL)
#define REG_SERCOM0_USART_SYNCBUSY (*(RoReg *)0x4200081CUL)
#define REG_SERCOM0_USART_DATA (*(RwReg16*)0x42000828UL)
#define REG_SERCOM0_USART_DBGCTRL (*(RwReg8 *)0x42000830UL)


/* ========== Instance parameters for SERCOM0 peripheral ========== */
#define SERCOM0_DMAC_ID_RX 1
#define SERCOM0_DMAC_ID_TX 2
#define SERCOM0_GCLK_ID_CORE 20
#define SERCOM0_GCLK_ID_SLOW 19
#define SERCOM0_INT_MSB 6
# 293 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/sercom1.h"
# 293 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/sercom1.h" 1
/**
 * \file
 *
 * \brief Instance description for SERCOM1
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SERCOM1_INSTANCE_ 

/* ========== Register definition for SERCOM1 peripheral ========== */
# 78 "asf4/samd21/include/instance/sercom1.h"
#define REG_SERCOM1_I2CM_CTRLA (*(RwReg *)0x42000C00UL)
#define REG_SERCOM1_I2CM_CTRLB (*(RwReg *)0x42000C04UL)
#define REG_SERCOM1_I2CM_BAUD (*(RwReg *)0x42000C0CUL)
#define REG_SERCOM1_I2CM_INTENCLR (*(RwReg8 *)0x42000C14UL)
#define REG_SERCOM1_I2CM_INTENSET (*(RwReg8 *)0x42000C16UL)
#define REG_SERCOM1_I2CM_INTFLAG (*(RwReg8 *)0x42000C18UL)
#define REG_SERCOM1_I2CM_STATUS (*(RwReg16*)0x42000C1AUL)
#define REG_SERCOM1_I2CM_SYNCBUSY (*(RoReg *)0x42000C1CUL)
#define REG_SERCOM1_I2CM_ADDR (*(RwReg *)0x42000C24UL)
#define REG_SERCOM1_I2CM_DATA (*(RwReg8 *)0x42000C28UL)
#define REG_SERCOM1_I2CM_DBGCTRL (*(RwReg8 *)0x42000C30UL)
#define REG_SERCOM1_I2CS_CTRLA (*(RwReg *)0x42000C00UL)
#define REG_SERCOM1_I2CS_CTRLB (*(RwReg *)0x42000C04UL)
#define REG_SERCOM1_I2CS_INTENCLR (*(RwReg8 *)0x42000C14UL)
#define REG_SERCOM1_I2CS_INTENSET (*(RwReg8 *)0x42000C16UL)
#define REG_SERCOM1_I2CS_INTFLAG (*(RwReg8 *)0x42000C18UL)
#define REG_SERCOM1_I2CS_STATUS (*(RwReg16*)0x42000C1AUL)
#define REG_SERCOM1_I2CS_SYNCBUSY (*(RoReg *)0x42000C1CUL)
#define REG_SERCOM1_I2CS_ADDR (*(RwReg *)0x42000C24UL)
#define REG_SERCOM1_I2CS_DATA (*(RwReg8 *)0x42000C28UL)
#define REG_SERCOM1_SPI_CTRLA (*(RwReg *)0x42000C00UL)
#define REG_SERCOM1_SPI_CTRLB (*(RwReg *)0x42000C04UL)
#define REG_SERCOM1_SPI_BAUD (*(RwReg8 *)0x42000C0CUL)
#define REG_SERCOM1_SPI_INTENCLR (*(RwReg8 *)0x42000C14UL)
#define REG_SERCOM1_SPI_INTENSET (*(RwReg8 *)0x42000C16UL)
#define REG_SERCOM1_SPI_INTFLAG (*(RwReg8 *)0x42000C18UL)
#define REG_SERCOM1_SPI_STATUS (*(RwReg16*)0x42000C1AUL)
#define REG_SERCOM1_SPI_SYNCBUSY (*(RoReg *)0x42000C1CUL)
#define REG_SERCOM1_SPI_ADDR (*(RwReg *)0x42000C24UL)
#define REG_SERCOM1_SPI_DATA (*(RwReg *)0x42000C28UL)
#define REG_SERCOM1_SPI_DBGCTRL (*(RwReg8 *)0x42000C30UL)
#define REG_SERCOM1_USART_CTRLA (*(RwReg *)0x42000C00UL)
#define REG_SERCOM1_USART_CTRLB (*(RwReg *)0x42000C04UL)
#define REG_SERCOM1_USART_BAUD (*(RwReg16*)0x42000C0CUL)
#define REG_SERCOM1_USART_RXPL (*(RwReg8 *)0x42000C0EUL)
#define REG_SERCOM1_USART_INTENCLR (*(RwReg8 *)0x42000C14UL)
#define REG_SERCOM1_USART_INTENSET (*(RwReg8 *)0x42000C16UL)
#define REG_SERCOM1_USART_INTFLAG (*(RwReg8 *)0x42000C18UL)
#define REG_SERCOM1_USART_STATUS (*(RwReg16*)0x42000C1AUL)
#define REG_SERCOM1_USART_SYNCBUSY (*(RoReg *)0x42000C1CUL)
#define REG_SERCOM1_USART_DATA (*(RwReg16*)0x42000C28UL)
#define REG_SERCOM1_USART_DBGCTRL (*(RwReg8 *)0x42000C30UL)


/* ========== Instance parameters for SERCOM1 peripheral ========== */
#define SERCOM1_DMAC_ID_RX 3
#define SERCOM1_DMAC_ID_TX 4
#define SERCOM1_GCLK_ID_CORE 21
#define SERCOM1_GCLK_ID_SLOW 19
#define SERCOM1_INT_MSB 6
# 294 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/sercom2.h"
# 294 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/sercom2.h" 1
/**
 * \file
 *
 * \brief Instance description for SERCOM2
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SERCOM2_INSTANCE_ 

/* ========== Register definition for SERCOM2 peripheral ========== */
# 78 "asf4/samd21/include/instance/sercom2.h"
#define REG_SERCOM2_I2CM_CTRLA (*(RwReg *)0x42001000UL)
#define REG_SERCOM2_I2CM_CTRLB (*(RwReg *)0x42001004UL)
#define REG_SERCOM2_I2CM_BAUD (*(RwReg *)0x4200100CUL)
#define REG_SERCOM2_I2CM_INTENCLR (*(RwReg8 *)0x42001014UL)
#define REG_SERCOM2_I2CM_INTENSET (*(RwReg8 *)0x42001016UL)
#define REG_SERCOM2_I2CM_INTFLAG (*(RwReg8 *)0x42001018UL)
#define REG_SERCOM2_I2CM_STATUS (*(RwReg16*)0x4200101AUL)
#define REG_SERCOM2_I2CM_SYNCBUSY (*(RoReg *)0x4200101CUL)
#define REG_SERCOM2_I2CM_ADDR (*(RwReg *)0x42001024UL)
#define REG_SERCOM2_I2CM_DATA (*(RwReg8 *)0x42001028UL)
#define REG_SERCOM2_I2CM_DBGCTRL (*(RwReg8 *)0x42001030UL)
#define REG_SERCOM2_I2CS_CTRLA (*(RwReg *)0x42001000UL)
#define REG_SERCOM2_I2CS_CTRLB (*(RwReg *)0x42001004UL)
#define REG_SERCOM2_I2CS_INTENCLR (*(RwReg8 *)0x42001014UL)
#define REG_SERCOM2_I2CS_INTENSET (*(RwReg8 *)0x42001016UL)
#define REG_SERCOM2_I2CS_INTFLAG (*(RwReg8 *)0x42001018UL)
#define REG_SERCOM2_I2CS_STATUS (*(RwReg16*)0x4200101AUL)
#define REG_SERCOM2_I2CS_SYNCBUSY (*(RoReg *)0x4200101CUL)
#define REG_SERCOM2_I2CS_ADDR (*(RwReg *)0x42001024UL)
#define REG_SERCOM2_I2CS_DATA (*(RwReg8 *)0x42001028UL)
#define REG_SERCOM2_SPI_CTRLA (*(RwReg *)0x42001000UL)
#define REG_SERCOM2_SPI_CTRLB (*(RwReg *)0x42001004UL)
#define REG_SERCOM2_SPI_BAUD (*(RwReg8 *)0x4200100CUL)
#define REG_SERCOM2_SPI_INTENCLR (*(RwReg8 *)0x42001014UL)
#define REG_SERCOM2_SPI_INTENSET (*(RwReg8 *)0x42001016UL)
#define REG_SERCOM2_SPI_INTFLAG (*(RwReg8 *)0x42001018UL)
#define REG_SERCOM2_SPI_STATUS (*(RwReg16*)0x4200101AUL)
#define REG_SERCOM2_SPI_SYNCBUSY (*(RoReg *)0x4200101CUL)
#define REG_SERCOM2_SPI_ADDR (*(RwReg *)0x42001024UL)
#define REG_SERCOM2_SPI_DATA (*(RwReg *)0x42001028UL)
#define REG_SERCOM2_SPI_DBGCTRL (*(RwReg8 *)0x42001030UL)
#define REG_SERCOM2_USART_CTRLA (*(RwReg *)0x42001000UL)
#define REG_SERCOM2_USART_CTRLB (*(RwReg *)0x42001004UL)
#define REG_SERCOM2_USART_BAUD (*(RwReg16*)0x4200100CUL)
#define REG_SERCOM2_USART_RXPL (*(RwReg8 *)0x4200100EUL)
#define REG_SERCOM2_USART_INTENCLR (*(RwReg8 *)0x42001014UL)
#define REG_SERCOM2_USART_INTENSET (*(RwReg8 *)0x42001016UL)
#define REG_SERCOM2_USART_INTFLAG (*(RwReg8 *)0x42001018UL)
#define REG_SERCOM2_USART_STATUS (*(RwReg16*)0x4200101AUL)
#define REG_SERCOM2_USART_SYNCBUSY (*(RoReg *)0x4200101CUL)
#define REG_SERCOM2_USART_DATA (*(RwReg16*)0x42001028UL)
#define REG_SERCOM2_USART_DBGCTRL (*(RwReg8 *)0x42001030UL)


/* ========== Instance parameters for SERCOM2 peripheral ========== */
#define SERCOM2_DMAC_ID_RX 5
#define SERCOM2_DMAC_ID_TX 6
#define SERCOM2_GCLK_ID_CORE 22
#define SERCOM2_GCLK_ID_SLOW 19
#define SERCOM2_INT_MSB 6
# 295 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/sercom3.h"
# 295 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/sercom3.h" 1
/**
 * \file
 *
 * \brief Instance description for SERCOM3
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SERCOM3_INSTANCE_ 

/* ========== Register definition for SERCOM3 peripheral ========== */
# 78 "asf4/samd21/include/instance/sercom3.h"
#define REG_SERCOM3_I2CM_CTRLA (*(RwReg *)0x42001400UL)
#define REG_SERCOM3_I2CM_CTRLB (*(RwReg *)0x42001404UL)
#define REG_SERCOM3_I2CM_BAUD (*(RwReg *)0x4200140CUL)
#define REG_SERCOM3_I2CM_INTENCLR (*(RwReg8 *)0x42001414UL)
#define REG_SERCOM3_I2CM_INTENSET (*(RwReg8 *)0x42001416UL)
#define REG_SERCOM3_I2CM_INTFLAG (*(RwReg8 *)0x42001418UL)
#define REG_SERCOM3_I2CM_STATUS (*(RwReg16*)0x4200141AUL)
#define REG_SERCOM3_I2CM_SYNCBUSY (*(RoReg *)0x4200141CUL)
#define REG_SERCOM3_I2CM_ADDR (*(RwReg *)0x42001424UL)
#define REG_SERCOM3_I2CM_DATA (*(RwReg8 *)0x42001428UL)
#define REG_SERCOM3_I2CM_DBGCTRL (*(RwReg8 *)0x42001430UL)
#define REG_SERCOM3_I2CS_CTRLA (*(RwReg *)0x42001400UL)
#define REG_SERCOM3_I2CS_CTRLB (*(RwReg *)0x42001404UL)
#define REG_SERCOM3_I2CS_INTENCLR (*(RwReg8 *)0x42001414UL)
#define REG_SERCOM3_I2CS_INTENSET (*(RwReg8 *)0x42001416UL)
#define REG_SERCOM3_I2CS_INTFLAG (*(RwReg8 *)0x42001418UL)
#define REG_SERCOM3_I2CS_STATUS (*(RwReg16*)0x4200141AUL)
#define REG_SERCOM3_I2CS_SYNCBUSY (*(RoReg *)0x4200141CUL)
#define REG_SERCOM3_I2CS_ADDR (*(RwReg *)0x42001424UL)
#define REG_SERCOM3_I2CS_DATA (*(RwReg8 *)0x42001428UL)
#define REG_SERCOM3_SPI_CTRLA (*(RwReg *)0x42001400UL)
#define REG_SERCOM3_SPI_CTRLB (*(RwReg *)0x42001404UL)
#define REG_SERCOM3_SPI_BAUD (*(RwReg8 *)0x4200140CUL)
#define REG_SERCOM3_SPI_INTENCLR (*(RwReg8 *)0x42001414UL)
#define REG_SERCOM3_SPI_INTENSET (*(RwReg8 *)0x42001416UL)
#define REG_SERCOM3_SPI_INTFLAG (*(RwReg8 *)0x42001418UL)
#define REG_SERCOM3_SPI_STATUS (*(RwReg16*)0x4200141AUL)
#define REG_SERCOM3_SPI_SYNCBUSY (*(RoReg *)0x4200141CUL)
#define REG_SERCOM3_SPI_ADDR (*(RwReg *)0x42001424UL)
#define REG_SERCOM3_SPI_DATA (*(RwReg *)0x42001428UL)
#define REG_SERCOM3_SPI_DBGCTRL (*(RwReg8 *)0x42001430UL)
#define REG_SERCOM3_USART_CTRLA (*(RwReg *)0x42001400UL)
#define REG_SERCOM3_USART_CTRLB (*(RwReg *)0x42001404UL)
#define REG_SERCOM3_USART_BAUD (*(RwReg16*)0x4200140CUL)
#define REG_SERCOM3_USART_RXPL (*(RwReg8 *)0x4200140EUL)
#define REG_SERCOM3_USART_INTENCLR (*(RwReg8 *)0x42001414UL)
#define REG_SERCOM3_USART_INTENSET (*(RwReg8 *)0x42001416UL)
#define REG_SERCOM3_USART_INTFLAG (*(RwReg8 *)0x42001418UL)
#define REG_SERCOM3_USART_STATUS (*(RwReg16*)0x4200141AUL)
#define REG_SERCOM3_USART_SYNCBUSY (*(RoReg *)0x4200141CUL)
#define REG_SERCOM3_USART_DATA (*(RwReg16*)0x42001428UL)
#define REG_SERCOM3_USART_DBGCTRL (*(RwReg8 *)0x42001430UL)


/* ========== Instance parameters for SERCOM3 peripheral ========== */
#define SERCOM3_DMAC_ID_RX 7
#define SERCOM3_DMAC_ID_TX 8
#define SERCOM3_GCLK_ID_CORE 23
#define SERCOM3_GCLK_ID_SLOW 19
#define SERCOM3_INT_MSB 6
# 296 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/sysctrl.h"
# 296 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/sysctrl.h" 1
/**
 * \file
 *
 * \brief Instance description for SYSCTRL
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_SYSCTRL_INSTANCE_ 

/* ========== Register definition for SYSCTRL peripheral ========== */
# 56 "asf4/samd21/include/instance/sysctrl.h"
#define REG_SYSCTRL_INTENCLR (*(RwReg *)0x40000800UL)
#define REG_SYSCTRL_INTENSET (*(RwReg *)0x40000804UL)
#define REG_SYSCTRL_INTFLAG (*(RwReg *)0x40000808UL)
#define REG_SYSCTRL_PCLKSR (*(RoReg *)0x4000080CUL)
#define REG_SYSCTRL_XOSC (*(RwReg16*)0x40000810UL)
#define REG_SYSCTRL_XOSC32K (*(RwReg16*)0x40000814UL)
#define REG_SYSCTRL_OSC32K (*(RwReg *)0x40000818UL)
#define REG_SYSCTRL_OSCULP32K (*(RwReg8 *)0x4000081CUL)
#define REG_SYSCTRL_OSC8M (*(RwReg *)0x40000820UL)
#define REG_SYSCTRL_DFLLCTRL (*(RwReg16*)0x40000824UL)
#define REG_SYSCTRL_DFLLVAL (*(RwReg *)0x40000828UL)
#define REG_SYSCTRL_DFLLMUL (*(RwReg *)0x4000082CUL)
#define REG_SYSCTRL_DFLLSYNC (*(RwReg8 *)0x40000830UL)
#define REG_SYSCTRL_BOD33 (*(RwReg *)0x40000834UL)
#define REG_SYSCTRL_VREG (*(RwReg16*)0x4000083CUL)
#define REG_SYSCTRL_VREF (*(RwReg *)0x40000840UL)
#define REG_SYSCTRL_DPLLCTRLA (*(RwReg8 *)0x40000844UL)
#define REG_SYSCTRL_DPLLRATIO (*(RwReg *)0x40000848UL)
#define REG_SYSCTRL_DPLLCTRLB (*(RwReg *)0x4000084CUL)
#define REG_SYSCTRL_DPLLSTATUS (*(RoReg8 *)0x40000850UL)


/* ========== Instance parameters for SYSCTRL peripheral ========== */
#define SYSCTRL_BGAP_CALIB_MSB 11
#define SYSCTRL_BOD33_CALIB_MSB 5
#define SYSCTRL_DFLL48M_COARSE_MSB 5
#define SYSCTRL_DFLL48M_FINE_MSB 9
#define SYSCTRL_GCLK_ID_DFLL48 0
#define SYSCTRL_GCLK_ID_FDPLL 1
#define SYSCTRL_GCLK_ID_FDPLL32K 2
#define SYSCTRL_OSC32K_COARSE_CALIB_MSB 6
#define SYSCTRL_POR33_ENTEST_MSB 1
#define SYSCTRL_SYSTEM_CLOCK 1000000
#define SYSCTRL_ULPVREF_DIVLEV_MSB 3
#define SYSCTRL_ULPVREG_FORCEGAIN_MSB 1
#define SYSCTRL_ULPVREG_RAMREFSEL_MSB 2
#define SYSCTRL_VREF_CONTROL_MSB 48
#define SYSCTRL_VREF_STATUS_MSB 7
#define SYSCTRL_VREG_LEVEL_MSB 2
#define SYSCTRL_BOD12_VERSION 0x111
#define SYSCTRL_BOD33_VERSION 0x111
#define SYSCTRL_DFLL48M_VERSION 0x301
#define SYSCTRL_FDPLL_VERSION 0x111
#define SYSCTRL_OSCULP32K_VERSION 0x111
#define SYSCTRL_OSC8M_VERSION 0x120
#define SYSCTRL_OSC32K_VERSION 0x1101
#define SYSCTRL_VREF_VERSION 0x200
#define SYSCTRL_VREG_VERSION 0x201
#define SYSCTRL_XOSC_VERSION 0x1111
#define SYSCTRL_XOSC32K_VERSION 0x1111
# 297 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/tc3.h"
# 297 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/tc3.h" 1
/**
 * \file
 *
 * \brief Instance description for TC3
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TC3_INSTANCE_ 

/* ========== Register definition for TC3 peripheral ========== */
# 57 "asf4/samd21/include/instance/tc3.h"
#define REG_TC3_CTRLA (*(RwReg16*)0x42002C00UL)
#define REG_TC3_READREQ (*(RwReg16*)0x42002C02UL)
#define REG_TC3_CTRLBCLR (*(RwReg8 *)0x42002C04UL)
#define REG_TC3_CTRLBSET (*(RwReg8 *)0x42002C05UL)
#define REG_TC3_CTRLC (*(RwReg8 *)0x42002C06UL)
#define REG_TC3_DBGCTRL (*(RwReg8 *)0x42002C08UL)
#define REG_TC3_EVCTRL (*(RwReg16*)0x42002C0AUL)
#define REG_TC3_INTENCLR (*(RwReg8 *)0x42002C0CUL)
#define REG_TC3_INTENSET (*(RwReg8 *)0x42002C0DUL)
#define REG_TC3_INTFLAG (*(RwReg8 *)0x42002C0EUL)
#define REG_TC3_STATUS (*(RoReg8 *)0x42002C0FUL)
#define REG_TC3_COUNT16_COUNT (*(RwReg16*)0x42002C10UL)
#define REG_TC3_COUNT16_CC0 (*(RwReg16*)0x42002C18UL)
#define REG_TC3_COUNT16_CC1 (*(RwReg16*)0x42002C1AUL)
#define REG_TC3_COUNT32_COUNT (*(RwReg *)0x42002C10UL)
#define REG_TC3_COUNT32_CC0 (*(RwReg *)0x42002C18UL)
#define REG_TC3_COUNT32_CC1 (*(RwReg *)0x42002C1CUL)
#define REG_TC3_COUNT8_COUNT (*(RwReg8 *)0x42002C10UL)
#define REG_TC3_COUNT8_PER (*(RwReg8 *)0x42002C14UL)
#define REG_TC3_COUNT8_CC0 (*(RwReg8 *)0x42002C18UL)
#define REG_TC3_COUNT8_CC1 (*(RwReg8 *)0x42002C19UL)


/* ========== Instance parameters for TC3 peripheral ========== */
#define TC3_CC8_NUM 2
#define TC3_CC16_NUM 2
#define TC3_CC32_NUM 2
#define TC3_DITHERING_EXT 0
#define TC3_DMAC_ID_MC_0 25
#define TC3_DMAC_ID_MC_1 26
#define TC3_DMAC_ID_MC_LSB 25
#define TC3_DMAC_ID_MC_MSB 26
#define TC3_DMAC_ID_MC_SIZE 2
#define TC3_DMAC_ID_OVF 24
#define TC3_GCLK_ID 27
#define TC3_MASTER 0
#define TC3_OW_NUM 2
#define TC3_PERIOD_EXT 0
#define TC3_SHADOW_EXT 0
# 298 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/tc4.h"
# 298 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/tc4.h" 1
/**
 * \file
 *
 * \brief Instance description for TC4
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TC4_INSTANCE_ 

/* ========== Register definition for TC4 peripheral ========== */
# 57 "asf4/samd21/include/instance/tc4.h"
#define REG_TC4_CTRLA (*(RwReg16*)0x42003000UL)
#define REG_TC4_READREQ (*(RwReg16*)0x42003002UL)
#define REG_TC4_CTRLBCLR (*(RwReg8 *)0x42003004UL)
#define REG_TC4_CTRLBSET (*(RwReg8 *)0x42003005UL)
#define REG_TC4_CTRLC (*(RwReg8 *)0x42003006UL)
#define REG_TC4_DBGCTRL (*(RwReg8 *)0x42003008UL)
#define REG_TC4_EVCTRL (*(RwReg16*)0x4200300AUL)
#define REG_TC4_INTENCLR (*(RwReg8 *)0x4200300CUL)
#define REG_TC4_INTENSET (*(RwReg8 *)0x4200300DUL)
#define REG_TC4_INTFLAG (*(RwReg8 *)0x4200300EUL)
#define REG_TC4_STATUS (*(RoReg8 *)0x4200300FUL)
#define REG_TC4_COUNT16_COUNT (*(RwReg16*)0x42003010UL)
#define REG_TC4_COUNT16_CC0 (*(RwReg16*)0x42003018UL)
#define REG_TC4_COUNT16_CC1 (*(RwReg16*)0x4200301AUL)
#define REG_TC4_COUNT32_COUNT (*(RwReg *)0x42003010UL)
#define REG_TC4_COUNT32_CC0 (*(RwReg *)0x42003018UL)
#define REG_TC4_COUNT32_CC1 (*(RwReg *)0x4200301CUL)
#define REG_TC4_COUNT8_COUNT (*(RwReg8 *)0x42003010UL)
#define REG_TC4_COUNT8_PER (*(RwReg8 *)0x42003014UL)
#define REG_TC4_COUNT8_CC0 (*(RwReg8 *)0x42003018UL)
#define REG_TC4_COUNT8_CC1 (*(RwReg8 *)0x42003019UL)


/* ========== Instance parameters for TC4 peripheral ========== */
#define TC4_CC8_NUM 2
#define TC4_CC16_NUM 2
#define TC4_CC32_NUM 2
#define TC4_DITHERING_EXT 0
#define TC4_DMAC_ID_MC_0 28
#define TC4_DMAC_ID_MC_1 29
#define TC4_DMAC_ID_MC_LSB 28
#define TC4_DMAC_ID_MC_MSB 29
#define TC4_DMAC_ID_MC_SIZE 2
#define TC4_DMAC_ID_OVF 27
#define TC4_GCLK_ID 28
#define TC4_MASTER 1
#define TC4_OW_NUM 2
#define TC4_PERIOD_EXT 0
#define TC4_SHADOW_EXT 0
# 299 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/tc5.h"
# 299 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/tc5.h" 1
/**
 * \file
 *
 * \brief Instance description for TC5
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TC5_INSTANCE_ 

/* ========== Register definition for TC5 peripheral ========== */
# 57 "asf4/samd21/include/instance/tc5.h"
#define REG_TC5_CTRLA (*(RwReg16*)0x42003400UL)
#define REG_TC5_READREQ (*(RwReg16*)0x42003402UL)
#define REG_TC5_CTRLBCLR (*(RwReg8 *)0x42003404UL)
#define REG_TC5_CTRLBSET (*(RwReg8 *)0x42003405UL)
#define REG_TC5_CTRLC (*(RwReg8 *)0x42003406UL)
#define REG_TC5_DBGCTRL (*(RwReg8 *)0x42003408UL)
#define REG_TC5_EVCTRL (*(RwReg16*)0x4200340AUL)
#define REG_TC5_INTENCLR (*(RwReg8 *)0x4200340CUL)
#define REG_TC5_INTENSET (*(RwReg8 *)0x4200340DUL)
#define REG_TC5_INTFLAG (*(RwReg8 *)0x4200340EUL)
#define REG_TC5_STATUS (*(RoReg8 *)0x4200340FUL)
#define REG_TC5_COUNT16_COUNT (*(RwReg16*)0x42003410UL)
#define REG_TC5_COUNT16_CC0 (*(RwReg16*)0x42003418UL)
#define REG_TC5_COUNT16_CC1 (*(RwReg16*)0x4200341AUL)
#define REG_TC5_COUNT32_COUNT (*(RwReg *)0x42003410UL)
#define REG_TC5_COUNT32_CC0 (*(RwReg *)0x42003418UL)
#define REG_TC5_COUNT32_CC1 (*(RwReg *)0x4200341CUL)
#define REG_TC5_COUNT8_COUNT (*(RwReg8 *)0x42003410UL)
#define REG_TC5_COUNT8_PER (*(RwReg8 *)0x42003414UL)
#define REG_TC5_COUNT8_CC0 (*(RwReg8 *)0x42003418UL)
#define REG_TC5_COUNT8_CC1 (*(RwReg8 *)0x42003419UL)


/* ========== Instance parameters for TC5 peripheral ========== */
#define TC5_CC8_NUM 2
#define TC5_CC16_NUM 2
#define TC5_CC32_NUM 2
#define TC5_DITHERING_EXT 0
#define TC5_DMAC_ID_MC_0 31
#define TC5_DMAC_ID_MC_1 32
#define TC5_DMAC_ID_MC_LSB 31
#define TC5_DMAC_ID_MC_MSB 32
#define TC5_DMAC_ID_MC_SIZE 2
#define TC5_DMAC_ID_OVF 30
#define TC5_GCLK_ID 28
#define TC5_MASTER 0
#define TC5_OW_NUM 2
#define TC5_PERIOD_EXT 0
#define TC5_SHADOW_EXT 0
# 300 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/tcc0.h"
# 300 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/tcc0.h" 1
/**
 * \file
 *
 * \brief Instance description for TCC0
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TCC0_INSTANCE_ 

/* ========== Register definition for TCC0 peripheral ========== */
# 65 "asf4/samd21/include/instance/tcc0.h"
#define REG_TCC0_CTRLA (*(RwReg *)0x42002000UL)
#define REG_TCC0_CTRLBCLR (*(RwReg8 *)0x42002004UL)
#define REG_TCC0_CTRLBSET (*(RwReg8 *)0x42002005UL)
#define REG_TCC0_SYNCBUSY (*(RoReg *)0x42002008UL)
#define REG_TCC0_FCTRLA (*(RwReg *)0x4200200CUL)
#define REG_TCC0_FCTRLB (*(RwReg *)0x42002010UL)
#define REG_TCC0_WEXCTRL (*(RwReg *)0x42002014UL)
#define REG_TCC0_DRVCTRL (*(RwReg *)0x42002018UL)
#define REG_TCC0_DBGCTRL (*(RwReg8 *)0x4200201EUL)
#define REG_TCC0_EVCTRL (*(RwReg *)0x42002020UL)
#define REG_TCC0_INTENCLR (*(RwReg *)0x42002024UL)
#define REG_TCC0_INTENSET (*(RwReg *)0x42002028UL)
#define REG_TCC0_INTFLAG (*(RwReg *)0x4200202CUL)
#define REG_TCC0_STATUS (*(RwReg *)0x42002030UL)
#define REG_TCC0_COUNT (*(RwReg *)0x42002034UL)
#define REG_TCC0_PATT (*(RwReg16*)0x42002038UL)
#define REG_TCC0_WAVE (*(RwReg *)0x4200203CUL)
#define REG_TCC0_PER (*(RwReg *)0x42002040UL)
#define REG_TCC0_CC0 (*(RwReg *)0x42002044UL)
#define REG_TCC0_CC1 (*(RwReg *)0x42002048UL)
#define REG_TCC0_CC2 (*(RwReg *)0x4200204CUL)
#define REG_TCC0_CC3 (*(RwReg *)0x42002050UL)
#define REG_TCC0_PATTB (*(RwReg16*)0x42002064UL)
#define REG_TCC0_WAVEB (*(RwReg *)0x42002068UL)
#define REG_TCC0_PERB (*(RwReg *)0x4200206CUL)
#define REG_TCC0_CCB0 (*(RwReg *)0x42002070UL)
#define REG_TCC0_CCB1 (*(RwReg *)0x42002074UL)
#define REG_TCC0_CCB2 (*(RwReg *)0x42002078UL)
#define REG_TCC0_CCB3 (*(RwReg *)0x4200207CUL)


/* ========== Instance parameters for TCC0 peripheral ========== */
#define TCC0_CC_NUM 4
#define TCC0_DITHERING 1
#define TCC0_DMAC_ID_MC_0 14
#define TCC0_DMAC_ID_MC_1 15
#define TCC0_DMAC_ID_MC_2 16
#define TCC0_DMAC_ID_MC_3 17
#define TCC0_DMAC_ID_MC_LSB 14
#define TCC0_DMAC_ID_MC_MSB 17
#define TCC0_DMAC_ID_MC_SIZE 4
#define TCC0_DMAC_ID_OVF 13
#define TCC0_DTI 1
#define TCC0_EXT 31
#define TCC0_GCLK_ID 26
#define TCC0_OTMX 1
#define TCC0_OW_NUM 8
#define TCC0_PG 1
#define TCC0_SIZE 24
#define TCC0_SWAP 1
#define TCC0_TYPE 0
# 301 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/tcc1.h"
# 301 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/tcc1.h" 1
/**
 * \file
 *
 * \brief Instance description for TCC1
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TCC1_INSTANCE_ 

/* ========== Register definition for TCC1 peripheral ========== */
# 60 "asf4/samd21/include/instance/tcc1.h"
#define REG_TCC1_CTRLA (*(RwReg *)0x42002400UL)
#define REG_TCC1_CTRLBCLR (*(RwReg8 *)0x42002404UL)
#define REG_TCC1_CTRLBSET (*(RwReg8 *)0x42002405UL)
#define REG_TCC1_SYNCBUSY (*(RoReg *)0x42002408UL)
#define REG_TCC1_FCTRLA (*(RwReg *)0x4200240CUL)
#define REG_TCC1_FCTRLB (*(RwReg *)0x42002410UL)
#define REG_TCC1_DRVCTRL (*(RwReg *)0x42002418UL)
#define REG_TCC1_DBGCTRL (*(RwReg8 *)0x4200241EUL)
#define REG_TCC1_EVCTRL (*(RwReg *)0x42002420UL)
#define REG_TCC1_INTENCLR (*(RwReg *)0x42002424UL)
#define REG_TCC1_INTENSET (*(RwReg *)0x42002428UL)
#define REG_TCC1_INTFLAG (*(RwReg *)0x4200242CUL)
#define REG_TCC1_STATUS (*(RwReg *)0x42002430UL)
#define REG_TCC1_COUNT (*(RwReg *)0x42002434UL)
#define REG_TCC1_PATT (*(RwReg16*)0x42002438UL)
#define REG_TCC1_WAVE (*(RwReg *)0x4200243CUL)
#define REG_TCC1_PER (*(RwReg *)0x42002440UL)
#define REG_TCC1_CC0 (*(RwReg *)0x42002444UL)
#define REG_TCC1_CC1 (*(RwReg *)0x42002448UL)
#define REG_TCC1_PATTB (*(RwReg16*)0x42002464UL)
#define REG_TCC1_WAVEB (*(RwReg *)0x42002468UL)
#define REG_TCC1_PERB (*(RwReg *)0x4200246CUL)
#define REG_TCC1_CCB0 (*(RwReg *)0x42002470UL)
#define REG_TCC1_CCB1 (*(RwReg *)0x42002474UL)


/* ========== Instance parameters for TCC1 peripheral ========== */
#define TCC1_CC_NUM 2
#define TCC1_DITHERING 1
#define TCC1_DMAC_ID_MC_0 19
#define TCC1_DMAC_ID_MC_1 20
#define TCC1_DMAC_ID_MC_LSB 19
#define TCC1_DMAC_ID_MC_MSB 20
#define TCC1_DMAC_ID_MC_SIZE 2
#define TCC1_DMAC_ID_OVF 18
#define TCC1_DTI 0
#define TCC1_EXT 24
#define TCC1_GCLK_ID 26
#define TCC1_OTMX 0
#define TCC1_OW_NUM 4
#define TCC1_PG 1
#define TCC1_SIZE 24
#define TCC1_SWAP 0
#define TCC1_TYPE 0
# 302 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/tcc2.h"
# 302 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/tcc2.h" 1
/**
 * \file
 *
 * \brief Instance description for TCC2
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_TCC2_INSTANCE_ 

/* ========== Register definition for TCC2 peripheral ========== */
# 58 "asf4/samd21/include/instance/tcc2.h"
#define REG_TCC2_CTRLA (*(RwReg *)0x42002800UL)
#define REG_TCC2_CTRLBCLR (*(RwReg8 *)0x42002804UL)
#define REG_TCC2_CTRLBSET (*(RwReg8 *)0x42002805UL)
#define REG_TCC2_SYNCBUSY (*(RoReg *)0x42002808UL)
#define REG_TCC2_FCTRLA (*(RwReg *)0x4200280CUL)
#define REG_TCC2_FCTRLB (*(RwReg *)0x42002810UL)
#define REG_TCC2_DRVCTRL (*(RwReg *)0x42002818UL)
#define REG_TCC2_DBGCTRL (*(RwReg8 *)0x4200281EUL)
#define REG_TCC2_EVCTRL (*(RwReg *)0x42002820UL)
#define REG_TCC2_INTENCLR (*(RwReg *)0x42002824UL)
#define REG_TCC2_INTENSET (*(RwReg *)0x42002828UL)
#define REG_TCC2_INTFLAG (*(RwReg *)0x4200282CUL)
#define REG_TCC2_STATUS (*(RwReg *)0x42002830UL)
#define REG_TCC2_COUNT (*(RwReg *)0x42002834UL)
#define REG_TCC2_WAVE (*(RwReg *)0x4200283CUL)
#define REG_TCC2_PER (*(RwReg *)0x42002840UL)
#define REG_TCC2_CC0 (*(RwReg *)0x42002844UL)
#define REG_TCC2_CC1 (*(RwReg *)0x42002848UL)
#define REG_TCC2_WAVEB (*(RwReg *)0x42002868UL)
#define REG_TCC2_PERB (*(RwReg *)0x4200286CUL)
#define REG_TCC2_CCB0 (*(RwReg *)0x42002870UL)
#define REG_TCC2_CCB1 (*(RwReg *)0x42002874UL)


/* ========== Instance parameters for TCC2 peripheral ========== */
#define TCC2_CC_NUM 2
#define TCC2_DITHERING 0
#define TCC2_DMAC_ID_MC_0 22
#define TCC2_DMAC_ID_MC_1 23
#define TCC2_DMAC_ID_MC_LSB 22
#define TCC2_DMAC_ID_MC_MSB 23
#define TCC2_DMAC_ID_MC_SIZE 2
#define TCC2_DMAC_ID_OVF 21
#define TCC2_DTI 0
#define TCC2_EXT 0
#define TCC2_GCLK_ID 27
#define TCC2_OTMX 0
#define TCC2_OW_NUM 2
#define TCC2_PG 0
#define TCC2_SIZE 16
#define TCC2_SWAP 0
#define TCC2_TYPE 0
# 303 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/usb.h"
# 303 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/usb.h" 1
/**
 * \file
 *
 * \brief Instance description for USB
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_USB_INSTANCE_ 

/* ========== Register definition for USB peripheral ========== */
# 179 "asf4/samd21/include/instance/usb.h"
#define REG_USB_CTRLA (*(RwReg8 *)0x41005000UL)
#define REG_USB_SYNCBUSY (*(RoReg8 *)0x41005002UL)
#define REG_USB_QOSCTRL (*(RwReg8 *)0x41005003UL)
#define REG_USB_FSMSTATUS (*(RoReg8 *)0x4100500DUL)
#define REG_USB_DESCADD (*(RwReg *)0x41005024UL)
#define REG_USB_PADCAL (*(RwReg16*)0x41005028UL)
#define REG_USB_DEVICE_CTRLB (*(RwReg16*)0x41005008UL)
#define REG_USB_DEVICE_DADD (*(RwReg8 *)0x4100500AUL)
#define REG_USB_DEVICE_STATUS (*(RoReg8 *)0x4100500CUL)
#define REG_USB_DEVICE_FNUM (*(RoReg16*)0x41005010UL)
#define REG_USB_DEVICE_INTENCLR (*(RwReg16*)0x41005014UL)
#define REG_USB_DEVICE_INTENSET (*(RwReg16*)0x41005018UL)
#define REG_USB_DEVICE_INTFLAG (*(RwReg16*)0x4100501CUL)
#define REG_USB_DEVICE_EPINTSMRY (*(RoReg16*)0x41005020UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG0 (*(RwReg8 *)0x41005100UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR0 (*(WoReg8 *)0x41005104UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET0 (*(WoReg8 *)0x41005105UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS0 (*(RoReg8 *)0x41005106UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG0 (*(RwReg8 *)0x41005107UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR0 (*(RwReg8 *)0x41005108UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET0 (*(RwReg8 *)0x41005109UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG1 (*(RwReg8 *)0x41005120UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR1 (*(WoReg8 *)0x41005124UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET1 (*(WoReg8 *)0x41005125UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS1 (*(RoReg8 *)0x41005126UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG1 (*(RwReg8 *)0x41005127UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR1 (*(RwReg8 *)0x41005128UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET1 (*(RwReg8 *)0x41005129UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG2 (*(RwReg8 *)0x41005140UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR2 (*(WoReg8 *)0x41005144UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET2 (*(WoReg8 *)0x41005145UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS2 (*(RoReg8 *)0x41005146UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG2 (*(RwReg8 *)0x41005147UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR2 (*(RwReg8 *)0x41005148UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET2 (*(RwReg8 *)0x41005149UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG3 (*(RwReg8 *)0x41005160UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR3 (*(WoReg8 *)0x41005164UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET3 (*(WoReg8 *)0x41005165UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS3 (*(RoReg8 *)0x41005166UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG3 (*(RwReg8 *)0x41005167UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR3 (*(RwReg8 *)0x41005168UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET3 (*(RwReg8 *)0x41005169UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG4 (*(RwReg8 *)0x41005180UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR4 (*(WoReg8 *)0x41005184UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET4 (*(WoReg8 *)0x41005185UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS4 (*(RoReg8 *)0x41005186UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG4 (*(RwReg8 *)0x41005187UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR4 (*(RwReg8 *)0x41005188UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET4 (*(RwReg8 *)0x41005189UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG5 (*(RwReg8 *)0x410051A0UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR5 (*(WoReg8 *)0x410051A4UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET5 (*(WoReg8 *)0x410051A5UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS5 (*(RoReg8 *)0x410051A6UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG5 (*(RwReg8 *)0x410051A7UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR5 (*(RwReg8 *)0x410051A8UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET5 (*(RwReg8 *)0x410051A9UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG6 (*(RwReg8 *)0x410051C0UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR6 (*(WoReg8 *)0x410051C4UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET6 (*(WoReg8 *)0x410051C5UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS6 (*(RoReg8 *)0x410051C6UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG6 (*(RwReg8 *)0x410051C7UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR6 (*(RwReg8 *)0x410051C8UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET6 (*(RwReg8 *)0x410051C9UL)
#define REG_USB_DEVICE_ENDPOINT_EPCFG7 (*(RwReg8 *)0x410051E0UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSCLR7 (*(WoReg8 *)0x410051E4UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUSSET7 (*(WoReg8 *)0x410051E5UL)
#define REG_USB_DEVICE_ENDPOINT_EPSTATUS7 (*(RoReg8 *)0x410051E6UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTFLAG7 (*(RwReg8 *)0x410051E7UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENCLR7 (*(RwReg8 *)0x410051E8UL)
#define REG_USB_DEVICE_ENDPOINT_EPINTENSET7 (*(RwReg8 *)0x410051E9UL)
#define REG_USB_HOST_CTRLB (*(RwReg16*)0x41005008UL)
#define REG_USB_HOST_HSOFC (*(RwReg8 *)0x4100500AUL)
#define REG_USB_HOST_STATUS (*(RwReg8 *)0x4100500CUL)
#define REG_USB_HOST_FNUM (*(RwReg16*)0x41005010UL)
#define REG_USB_HOST_FLENHIGH (*(RoReg8 *)0x41005012UL)
#define REG_USB_HOST_INTENCLR (*(RwReg16*)0x41005014UL)
#define REG_USB_HOST_INTENSET (*(RwReg16*)0x41005018UL)
#define REG_USB_HOST_INTFLAG (*(RwReg16*)0x4100501CUL)
#define REG_USB_HOST_PINTSMRY (*(RoReg16*)0x41005020UL)
#define REG_USB_HOST_PIPE_PCFG0 (*(RwReg8 *)0x41005100UL)
#define REG_USB_HOST_PIPE_BINTERVAL0 (*(RwReg8 *)0x41005103UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR0 (*(WoReg8 *)0x41005104UL)
#define REG_USB_HOST_PIPE_PSTATUSSET0 (*(WoReg8 *)0x41005105UL)
#define REG_USB_HOST_PIPE_PSTATUS0 (*(RoReg8 *)0x41005106UL)
#define REG_USB_HOST_PIPE_PINTFLAG0 (*(RwReg8 *)0x41005107UL)
#define REG_USB_HOST_PIPE_PINTENCLR0 (*(RwReg8 *)0x41005108UL)
#define REG_USB_HOST_PIPE_PINTENSET0 (*(RwReg8 *)0x41005109UL)
#define REG_USB_HOST_PIPE_PCFG1 (*(RwReg8 *)0x41005120UL)
#define REG_USB_HOST_PIPE_BINTERVAL1 (*(RwReg8 *)0x41005123UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR1 (*(WoReg8 *)0x41005124UL)
#define REG_USB_HOST_PIPE_PSTATUSSET1 (*(WoReg8 *)0x41005125UL)
#define REG_USB_HOST_PIPE_PSTATUS1 (*(RoReg8 *)0x41005126UL)
#define REG_USB_HOST_PIPE_PINTFLAG1 (*(RwReg8 *)0x41005127UL)
#define REG_USB_HOST_PIPE_PINTENCLR1 (*(RwReg8 *)0x41005128UL)
#define REG_USB_HOST_PIPE_PINTENSET1 (*(RwReg8 *)0x41005129UL)
#define REG_USB_HOST_PIPE_PCFG2 (*(RwReg8 *)0x41005140UL)
#define REG_USB_HOST_PIPE_BINTERVAL2 (*(RwReg8 *)0x41005143UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR2 (*(WoReg8 *)0x41005144UL)
#define REG_USB_HOST_PIPE_PSTATUSSET2 (*(WoReg8 *)0x41005145UL)
#define REG_USB_HOST_PIPE_PSTATUS2 (*(RoReg8 *)0x41005146UL)
#define REG_USB_HOST_PIPE_PINTFLAG2 (*(RwReg8 *)0x41005147UL)
#define REG_USB_HOST_PIPE_PINTENCLR2 (*(RwReg8 *)0x41005148UL)
#define REG_USB_HOST_PIPE_PINTENSET2 (*(RwReg8 *)0x41005149UL)
#define REG_USB_HOST_PIPE_PCFG3 (*(RwReg8 *)0x41005160UL)
#define REG_USB_HOST_PIPE_BINTERVAL3 (*(RwReg8 *)0x41005163UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR3 (*(WoReg8 *)0x41005164UL)
#define REG_USB_HOST_PIPE_PSTATUSSET3 (*(WoReg8 *)0x41005165UL)
#define REG_USB_HOST_PIPE_PSTATUS3 (*(RoReg8 *)0x41005166UL)
#define REG_USB_HOST_PIPE_PINTFLAG3 (*(RwReg8 *)0x41005167UL)
#define REG_USB_HOST_PIPE_PINTENCLR3 (*(RwReg8 *)0x41005168UL)
#define REG_USB_HOST_PIPE_PINTENSET3 (*(RwReg8 *)0x41005169UL)
#define REG_USB_HOST_PIPE_PCFG4 (*(RwReg8 *)0x41005180UL)
#define REG_USB_HOST_PIPE_BINTERVAL4 (*(RwReg8 *)0x41005183UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR4 (*(WoReg8 *)0x41005184UL)
#define REG_USB_HOST_PIPE_PSTATUSSET4 (*(WoReg8 *)0x41005185UL)
#define REG_USB_HOST_PIPE_PSTATUS4 (*(RoReg8 *)0x41005186UL)
#define REG_USB_HOST_PIPE_PINTFLAG4 (*(RwReg8 *)0x41005187UL)
#define REG_USB_HOST_PIPE_PINTENCLR4 (*(RwReg8 *)0x41005188UL)
#define REG_USB_HOST_PIPE_PINTENSET4 (*(RwReg8 *)0x41005189UL)
#define REG_USB_HOST_PIPE_PCFG5 (*(RwReg8 *)0x410051A0UL)
#define REG_USB_HOST_PIPE_BINTERVAL5 (*(RwReg8 *)0x410051A3UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR5 (*(WoReg8 *)0x410051A4UL)
#define REG_USB_HOST_PIPE_PSTATUSSET5 (*(WoReg8 *)0x410051A5UL)
#define REG_USB_HOST_PIPE_PSTATUS5 (*(RoReg8 *)0x410051A6UL)
#define REG_USB_HOST_PIPE_PINTFLAG5 (*(RwReg8 *)0x410051A7UL)
#define REG_USB_HOST_PIPE_PINTENCLR5 (*(RwReg8 *)0x410051A8UL)
#define REG_USB_HOST_PIPE_PINTENSET5 (*(RwReg8 *)0x410051A9UL)
#define REG_USB_HOST_PIPE_PCFG6 (*(RwReg8 *)0x410051C0UL)
#define REG_USB_HOST_PIPE_BINTERVAL6 (*(RwReg8 *)0x410051C3UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR6 (*(WoReg8 *)0x410051C4UL)
#define REG_USB_HOST_PIPE_PSTATUSSET6 (*(WoReg8 *)0x410051C5UL)
#define REG_USB_HOST_PIPE_PSTATUS6 (*(RoReg8 *)0x410051C6UL)
#define REG_USB_HOST_PIPE_PINTFLAG6 (*(RwReg8 *)0x410051C7UL)
#define REG_USB_HOST_PIPE_PINTENCLR6 (*(RwReg8 *)0x410051C8UL)
#define REG_USB_HOST_PIPE_PINTENSET6 (*(RwReg8 *)0x410051C9UL)
#define REG_USB_HOST_PIPE_PCFG7 (*(RwReg8 *)0x410051E0UL)
#define REG_USB_HOST_PIPE_BINTERVAL7 (*(RwReg8 *)0x410051E3UL)
#define REG_USB_HOST_PIPE_PSTATUSCLR7 (*(WoReg8 *)0x410051E4UL)
#define REG_USB_HOST_PIPE_PSTATUSSET7 (*(WoReg8 *)0x410051E5UL)
#define REG_USB_HOST_PIPE_PSTATUS7 (*(RoReg8 *)0x410051E6UL)
#define REG_USB_HOST_PIPE_PINTFLAG7 (*(RwReg8 *)0x410051E7UL)
#define REG_USB_HOST_PIPE_PINTENCLR7 (*(RwReg8 *)0x410051E8UL)
#define REG_USB_HOST_PIPE_PINTENSET7 (*(RwReg8 *)0x410051E9UL)


/* ========== Instance parameters for USB peripheral ========== */
#define USB_EPT_NBR 8
#define USB_EPT_NUM 8
#define USB_GCLK_ID 6
#define USB_PIPE_NUM 8
# 304 "asf4/samd21/include/samd21e18a.h" 2
#include "instance/wdt.h"
# 304 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/instance/wdt.h" 1
/**
 * \file
 *
 * \brief Instance description for WDT
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21_WDT_INSTANCE_ 

/* ========== Register definition for WDT peripheral ========== */
# 44 "asf4/samd21/include/instance/wdt.h"
#define REG_WDT_CTRL (*(RwReg8 *)0x40001000UL)
#define REG_WDT_CONFIG (*(RwReg8 *)0x40001001UL)
#define REG_WDT_EWCTRL (*(RwReg8 *)0x40001002UL)
#define REG_WDT_INTENCLR (*(RwReg8 *)0x40001004UL)
#define REG_WDT_INTENSET (*(RwReg8 *)0x40001005UL)
#define REG_WDT_INTFLAG (*(RwReg8 *)0x40001006UL)
#define REG_WDT_STATUS (*(RoReg8 *)0x40001007UL)
#define REG_WDT_CLEAR (*(WoReg8 *)0x40001008UL)


/* ========== Instance parameters for WDT peripheral ========== */
#define WDT_GCLK_ID 3
# 305 "asf4/samd21/include/samd21e18a.h" 2
/*@}*/

/* ************************************************************************** */
/**  PERIPHERAL ID DEFINITIONS FOR SAMD21E18A */
/* ************************************************************************** */
/** \defgroup SAMD21E18A_id Peripheral Ids Definitions */
/*@{*/

// Peripheral instances on HPB0 bridge
#define ID_PAC0 0
#define ID_PM 1
#define ID_SYSCTRL 2
#define ID_GCLK 3
#define ID_WDT 4
#define ID_RTC 5
#define ID_EIC 6

// Peripheral instances on HPB1 bridge
#define ID_PAC1 32
#define ID_DSU 33
#define ID_NVMCTRL 34
#define ID_PORT 35
#define ID_DMAC 36
#define ID_USB 37
#define ID_MTB 38
#define ID_SBMATRIX 39

// Peripheral instances on HPB2 bridge
#define ID_PAC2 64
#define ID_EVSYS 65
#define ID_SERCOM0 66
#define ID_SERCOM1 67
#define ID_SERCOM2 68
#define ID_SERCOM3 69
#define ID_TCC0 72
#define ID_TCC1 73
#define ID_TCC2 74
#define ID_TC3 75
#define ID_TC4 76
#define ID_TC5 77
#define ID_ADC 80
#define ID_AC 81
#define ID_DAC 82
#define ID_PTC 83
#define ID_I2S 84

#define ID_PERIPH_COUNT 85
/*@}*/

/* ************************************************************************** */
/**  BASE ADDRESS DEFINITIONS FOR SAMD21E18A */
/* ************************************************************************** */
/** \defgroup SAMD21E18A_base Peripheral Base Address Definitions */
/*@{*/
# 402 "asf4/samd21/include/samd21e18a.h"
#define AC ((Ac *)0x42004400UL)
#define AC_INST_NUM 1
#define AC_INSTS { AC }

#define ADC ((Adc *)0x42004000UL)
#define ADC_INST_NUM 1
#define ADC_INSTS { ADC }

#define DAC ((Dac *)0x42004800UL)
#define DAC_INST_NUM 1
#define DAC_INSTS { DAC }

#define DMAC ((Dmac *)0x41004800UL)
#define DMAC_INST_NUM 1
#define DMAC_INSTS { DMAC }

#define DSU ((Dsu *)0x41002000UL)
#define DSU_INST_NUM 1
#define DSU_INSTS { DSU }

#define EIC ((Eic *)0x40001800UL)
#define EIC_INST_NUM 1
#define EIC_INSTS { EIC }

#define EVSYS ((Evsys *)0x42000400UL)
#define EVSYS_INST_NUM 1
#define EVSYS_INSTS { EVSYS }

#define GCLK ((Gclk *)0x40000C00UL)
#define GCLK_INST_NUM 1
#define GCLK_INSTS { GCLK }

#define SBMATRIX ((Hmatrixb *)0x41007000UL)
#define HMATRIXB_INST_NUM 1
#define HMATRIXB_INSTS { SBMATRIX }

#define I2S ((I2s *)0x42005000UL)
#define I2S_INST_NUM 1
#define I2S_INSTS { I2S }

#define MTB ((Mtb *)0x41006000UL)
#define MTB_INST_NUM 1
#define MTB_INSTS { MTB }

#define NVMCTRL ((Nvmctrl *)0x41004000UL)
#define NVMCTRL_CAL (0x00800000UL)
#define NVMCTRL_LOCKBIT (0x00802000UL)
#define NVMCTRL_OTP1 (0x00806000UL)
#define NVMCTRL_OTP2 (0x00806008UL)
#define NVMCTRL_OTP4 (0x00806020UL)
#define NVMCTRL_TEMP_LOG (0x00806030UL)
#define NVMCTRL_USER (0x00804000UL)
#define NVMCTRL_INST_NUM 1
#define NVMCTRL_INSTS { NVMCTRL }

#define PAC0 ((Pac *)0x40000000UL)
#define PAC1 ((Pac *)0x41000000UL)
#define PAC2 ((Pac *)0x42000000UL)
#define PAC_INST_NUM 3
#define PAC_INSTS { PAC0, PAC1, PAC2 }

#define PM ((Pm *)0x40000400UL)
#define PM_INST_NUM 1
#define PM_INSTS { PM }

#define PORT ((Port *)0x41004400UL)
#define PORT_IOBUS ((Port *)0x60000000UL)
#define PORT_INST_NUM 1
#define PORT_INSTS { PORT }
#define PORT_IOBUS_INST_NUM 1
#define PORT_IOBUS_INSTS { PORT_IOBUS }

#define PTC ((void *)0x42004C00UL)
#define PTC_GCLK_ID 34
#define PTC_INST_NUM 1
#define PTC_INSTS { PTC }

#define RTC ((Rtc *)0x40001400UL)
#define RTC_INST_NUM 1
#define RTC_INSTS { RTC }

#define SERCOM0 ((Sercom *)0x42000800UL)
#define SERCOM1 ((Sercom *)0x42000C00UL)
#define SERCOM2 ((Sercom *)0x42001000UL)
#define SERCOM3 ((Sercom *)0x42001400UL)
#define SERCOM_INST_NUM 4
#define SERCOM_INSTS { SERCOM0, SERCOM1, SERCOM2, SERCOM3 }

#define SYSCTRL ((Sysctrl *)0x40000800UL)
#define SYSCTRL_INST_NUM 1
#define SYSCTRL_INSTS { SYSCTRL }

#define TC3 ((Tc *)0x42002C00UL)
#define TC4 ((Tc *)0x42003000UL)
#define TC5 ((Tc *)0x42003400UL)
#define TC_INST_NUM 3
#define TC_INSTS { TC3, TC4, TC5 }

#define TCC0 ((Tcc *)0x42002000UL)
#define TCC1 ((Tcc *)0x42002400UL)
#define TCC2 ((Tcc *)0x42002800UL)
#define TCC_INST_NUM 3
#define TCC_INSTS { TCC0, TCC1, TCC2 }

#define USB ((Usb *)0x41005000UL)
#define USB_INST_NUM 1
#define USB_INSTS { USB }

#define WDT ((Wdt *)0x40001000UL)
#define WDT_INST_NUM 1
#define WDT_INSTS { WDT }


/*@}*/

/* ************************************************************************** */
/**  PORT DEFINITIONS FOR SAMD21E18A */
/* ************************************************************************** */
/** \defgroup SAMD21E18A_port PORT Definitions */
/*@{*/

#include "pio/samd21e18a.h"
# 523 "asf4/samd21/include/samd21e18a.h"
# 1 "asf4/samd21/include/pio/samd21e18a.h" 1
/**
 * \file
 *
 * \brief Peripheral I/O description for SAMD21E18A
 *
 * Copyright (c) 2017 Microchip Technology Inc.
 *
 * \asf_license_start
 *
 * \page License
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the Licence at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \asf_license_stop
 *
 */


#define _SAMD21E18A_PIO_ 

#define PIN_PA00 0
#define PORT_PA00 (_UL_(1) << 0)
#define PIN_PA01 1
#define PORT_PA01 (_UL_(1) << 1)
#define PIN_PA02 2
#define PORT_PA02 (_UL_(1) << 2)
#define PIN_PA03 3
#define PORT_PA03 (_UL_(1) << 3)
#define PIN_PA04 4
#define PORT_PA04 (_UL_(1) << 4)
#define PIN_PA05 5
#define PORT_PA05 (_UL_(1) << 5)
#define PIN_PA06 6
#define PORT_PA06 (_UL_(1) << 6)
#define PIN_PA07 7
#define PORT_PA07 (_UL_(1) << 7)
#define PIN_PA08 8
#define PORT_PA08 (_UL_(1) << 8)
#define PIN_PA09 9
#define PORT_PA09 (_UL_(1) << 9)
#define PIN_PA10 10
#define PORT_PA10 (_UL_(1) << 10)
#define PIN_PA11 11
#define PORT_PA11 (_UL_(1) << 11)
#define PIN_PA14 14
#define PORT_PA14 (_UL_(1) << 14)
#define PIN_PA15 15
#define PORT_PA15 (_UL_(1) << 15)
#define PIN_PA16 16
#define PORT_PA16 (_UL_(1) << 16)
#define PIN_PA17 17
#define PORT_PA17 (_UL_(1) << 17)
#define PIN_PA18 18
#define PORT_PA18 (_UL_(1) << 18)
#define PIN_PA19 19
#define PORT_PA19 (_UL_(1) << 19)
#define PIN_PA22 22
#define PORT_PA22 (_UL_(1) << 22)
#define PIN_PA23 23
#define PORT_PA23 (_UL_(1) << 23)
#define PIN_PA24 24
#define PORT_PA24 (_UL_(1) << 24)
#define PIN_PA25 25
#define PORT_PA25 (_UL_(1) << 25)
#define PIN_PA27 27
#define PORT_PA27 (_UL_(1) << 27)
#define PIN_PA28 28
#define PORT_PA28 (_UL_(1) << 28)
#define PIN_PA30 30
#define PORT_PA30 (_UL_(1) << 30)
#define PIN_PA31 31
#define PORT_PA31 (_UL_(1) << 31)
/* ========== PORT definition for GCLK peripheral ========== */
#define PIN_PA14H_GCLK_IO0 _L_(14)
#define MUX_PA14H_GCLK_IO0 _L_(7)
#define PINMUX_PA14H_GCLK_IO0 ((PIN_PA14H_GCLK_IO0 << 16) | MUX_PA14H_GCLK_IO0)
#define PORT_PA14H_GCLK_IO0 (_UL_(1) << 14)
#define PIN_PA27H_GCLK_IO0 _L_(27)
#define MUX_PA27H_GCLK_IO0 _L_(7)
#define PINMUX_PA27H_GCLK_IO0 ((PIN_PA27H_GCLK_IO0 << 16) | MUX_PA27H_GCLK_IO0)
#define PORT_PA27H_GCLK_IO0 (_UL_(1) << 27)
#define PIN_PA28H_GCLK_IO0 _L_(28)
#define MUX_PA28H_GCLK_IO0 _L_(7)
#define PINMUX_PA28H_GCLK_IO0 ((PIN_PA28H_GCLK_IO0 << 16) | MUX_PA28H_GCLK_IO0)
#define PORT_PA28H_GCLK_IO0 (_UL_(1) << 28)
#define PIN_PA30H_GCLK_IO0 _L_(30)
#define MUX_PA30H_GCLK_IO0 _L_(7)
#define PINMUX_PA30H_GCLK_IO0 ((PIN_PA30H_GCLK_IO0 << 16) | MUX_PA30H_GCLK_IO0)
#define PORT_PA30H_GCLK_IO0 (_UL_(1) << 30)
#define PIN_PA15H_GCLK_IO1 _L_(15)
#define MUX_PA15H_GCLK_IO1 _L_(7)
#define PINMUX_PA15H_GCLK_IO1 ((PIN_PA15H_GCLK_IO1 << 16) | MUX_PA15H_GCLK_IO1)
#define PORT_PA15H_GCLK_IO1 (_UL_(1) << 15)
#define PIN_PA16H_GCLK_IO2 _L_(16)
#define MUX_PA16H_GCLK_IO2 _L_(7)
#define PINMUX_PA16H_GCLK_IO2 ((PIN_PA16H_GCLK_IO2 << 16) | MUX_PA16H_GCLK_IO2)
#define PORT_PA16H_GCLK_IO2 (_UL_(1) << 16)
#define PIN_PA17H_GCLK_IO3 _L_(17)
#define MUX_PA17H_GCLK_IO3 _L_(7)
#define PINMUX_PA17H_GCLK_IO3 ((PIN_PA17H_GCLK_IO3 << 16) | MUX_PA17H_GCLK_IO3)
#define PORT_PA17H_GCLK_IO3 (_UL_(1) << 17)
#define PIN_PA10H_GCLK_IO4 _L_(10)
#define MUX_PA10H_GCLK_IO4 _L_(7)
#define PINMUX_PA10H_GCLK_IO4 ((PIN_PA10H_GCLK_IO4 << 16) | MUX_PA10H_GCLK_IO4)
#define PORT_PA10H_GCLK_IO4 (_UL_(1) << 10)
#define PIN_PA11H_GCLK_IO5 _L_(11)
#define MUX_PA11H_GCLK_IO5 _L_(7)
#define PINMUX_PA11H_GCLK_IO5 ((PIN_PA11H_GCLK_IO5 << 16) | MUX_PA11H_GCLK_IO5)
#define PORT_PA11H_GCLK_IO5 (_UL_(1) << 11)
#define PIN_PA22H_GCLK_IO6 _L_(22)
#define MUX_PA22H_GCLK_IO6 _L_(7)
#define PINMUX_PA22H_GCLK_IO6 ((PIN_PA22H_GCLK_IO6 << 16) | MUX_PA22H_GCLK_IO6)
#define PORT_PA22H_GCLK_IO6 (_UL_(1) << 22)
#define PIN_PA23H_GCLK_IO7 _L_(23)
#define MUX_PA23H_GCLK_IO7 _L_(7)
#define PINMUX_PA23H_GCLK_IO7 ((PIN_PA23H_GCLK_IO7 << 16) | MUX_PA23H_GCLK_IO7)
#define PORT_PA23H_GCLK_IO7 (_UL_(1) << 23)
/* ========== PORT definition for EIC peripheral ========== */
#define PIN_PA16A_EIC_EXTINT0 _L_(16)
#define MUX_PA16A_EIC_EXTINT0 _L_(0)
#define PINMUX_PA16A_EIC_EXTINT0 ((PIN_PA16A_EIC_EXTINT0 << 16) | MUX_PA16A_EIC_EXTINT0)
#define PORT_PA16A_EIC_EXTINT0 (_UL_(1) << 16)
#define PIN_PA16A_EIC_EXTINT_NUM _L_(0)
#define PIN_PA00A_EIC_EXTINT0 _L_(0)
#define MUX_PA00A_EIC_EXTINT0 _L_(0)
#define PINMUX_PA00A_EIC_EXTINT0 ((PIN_PA00A_EIC_EXTINT0 << 16) | MUX_PA00A_EIC_EXTINT0)
#define PORT_PA00A_EIC_EXTINT0 (_UL_(1) << 0)
#define PIN_PA00A_EIC_EXTINT_NUM _L_(0)
#define PIN_PA17A_EIC_EXTINT1 _L_(17)
#define MUX_PA17A_EIC_EXTINT1 _L_(0)
#define PINMUX_PA17A_EIC_EXTINT1 ((PIN_PA17A_EIC_EXTINT1 << 16) | MUX_PA17A_EIC_EXTINT1)
#define PORT_PA17A_EIC_EXTINT1 (_UL_(1) << 17)
#define PIN_PA17A_EIC_EXTINT_NUM _L_(1)
#define PIN_PA01A_EIC_EXTINT1 _L_(1)
#define MUX_PA01A_EIC_EXTINT1 _L_(0)
#define PINMUX_PA01A_EIC_EXTINT1 ((PIN_PA01A_EIC_EXTINT1 << 16) | MUX_PA01A_EIC_EXTINT1)
#define PORT_PA01A_EIC_EXTINT1 (_UL_(1) << 1)
#define PIN_PA01A_EIC_EXTINT_NUM _L_(1)
#define PIN_PA18A_EIC_EXTINT2 _L_(18)
#define MUX_PA18A_EIC_EXTINT2 _L_(0)
#define PINMUX_PA18A_EIC_EXTINT2 ((PIN_PA18A_EIC_EXTINT2 << 16) | MUX_PA18A_EIC_EXTINT2)
#define PORT_PA18A_EIC_EXTINT2 (_UL_(1) << 18)
#define PIN_PA18A_EIC_EXTINT_NUM _L_(2)
#define PIN_PA02A_EIC_EXTINT2 _L_(2)
#define MUX_PA02A_EIC_EXTINT2 _L_(0)
#define PINMUX_PA02A_EIC_EXTINT2 ((PIN_PA02A_EIC_EXTINT2 << 16) | MUX_PA02A_EIC_EXTINT2)
#define PORT_PA02A_EIC_EXTINT2 (_UL_(1) << 2)
#define PIN_PA02A_EIC_EXTINT_NUM _L_(2)
#define PIN_PA03A_EIC_EXTINT3 _L_(3)
#define MUX_PA03A_EIC_EXTINT3 _L_(0)
#define PINMUX_PA03A_EIC_EXTINT3 ((PIN_PA03A_EIC_EXTINT3 << 16) | MUX_PA03A_EIC_EXTINT3)
#define PORT_PA03A_EIC_EXTINT3 (_UL_(1) << 3)
#define PIN_PA03A_EIC_EXTINT_NUM _L_(3)
#define PIN_PA19A_EIC_EXTINT3 _L_(19)
#define MUX_PA19A_EIC_EXTINT3 _L_(0)
#define PINMUX_PA19A_EIC_EXTINT3 ((PIN_PA19A_EIC_EXTINT3 << 16) | MUX_PA19A_EIC_EXTINT3)
#define PORT_PA19A_EIC_EXTINT3 (_UL_(1) << 19)
#define PIN_PA19A_EIC_EXTINT_NUM _L_(3)
#define PIN_PA04A_EIC_EXTINT4 _L_(4)
#define MUX_PA04A_EIC_EXTINT4 _L_(0)
#define PINMUX_PA04A_EIC_EXTINT4 ((PIN_PA04A_EIC_EXTINT4 << 16) | MUX_PA04A_EIC_EXTINT4)
#define PORT_PA04A_EIC_EXTINT4 (_UL_(1) << 4)
#define PIN_PA04A_EIC_EXTINT_NUM _L_(4)
#define PIN_PA05A_EIC_EXTINT5 _L_(5)
#define MUX_PA05A_EIC_EXTINT5 _L_(0)
#define PINMUX_PA05A_EIC_EXTINT5 ((PIN_PA05A_EIC_EXTINT5 << 16) | MUX_PA05A_EIC_EXTINT5)
#define PORT_PA05A_EIC_EXTINT5 (_UL_(1) << 5)
#define PIN_PA05A_EIC_EXTINT_NUM _L_(5)
#define PIN_PA06A_EIC_EXTINT6 _L_(6)
#define MUX_PA06A_EIC_EXTINT6 _L_(0)
#define PINMUX_PA06A_EIC_EXTINT6 ((PIN_PA06A_EIC_EXTINT6 << 16) | MUX_PA06A_EIC_EXTINT6)
#define PORT_PA06A_EIC_EXTINT6 (_UL_(1) << 6)
#define PIN_PA06A_EIC_EXTINT_NUM _L_(6)
#define PIN_PA22A_EIC_EXTINT6 _L_(22)
#define MUX_PA22A_EIC_EXTINT6 _L_(0)
#define PINMUX_PA22A_EIC_EXTINT6 ((PIN_PA22A_EIC_EXTINT6 << 16) | MUX_PA22A_EIC_EXTINT6)
#define PORT_PA22A_EIC_EXTINT6 (_UL_(1) << 22)
#define PIN_PA22A_EIC_EXTINT_NUM _L_(6)
#define PIN_PA07A_EIC_EXTINT7 _L_(7)
#define MUX_PA07A_EIC_EXTINT7 _L_(0)
#define PINMUX_PA07A_EIC_EXTINT7 ((PIN_PA07A_EIC_EXTINT7 << 16) | MUX_PA07A_EIC_EXTINT7)
#define PORT_PA07A_EIC_EXTINT7 (_UL_(1) << 7)
#define PIN_PA07A_EIC_EXTINT_NUM _L_(7)
#define PIN_PA23A_EIC_EXTINT7 _L_(23)
#define MUX_PA23A_EIC_EXTINT7 _L_(0)
#define PINMUX_PA23A_EIC_EXTINT7 ((PIN_PA23A_EIC_EXTINT7 << 16) | MUX_PA23A_EIC_EXTINT7)
#define PORT_PA23A_EIC_EXTINT7 (_UL_(1) << 23)
#define PIN_PA23A_EIC_EXTINT_NUM _L_(7)
#define PIN_PA28A_EIC_EXTINT8 _L_(28)
#define MUX_PA28A_EIC_EXTINT8 _L_(0)
#define PINMUX_PA28A_EIC_EXTINT8 ((PIN_PA28A_EIC_EXTINT8 << 16) | MUX_PA28A_EIC_EXTINT8)
#define PORT_PA28A_EIC_EXTINT8 (_UL_(1) << 28)
#define PIN_PA28A_EIC_EXTINT_NUM _L_(8)
#define PIN_PA09A_EIC_EXTINT9 _L_(9)
#define MUX_PA09A_EIC_EXTINT9 _L_(0)
#define PINMUX_PA09A_EIC_EXTINT9 ((PIN_PA09A_EIC_EXTINT9 << 16) | MUX_PA09A_EIC_EXTINT9)
#define PORT_PA09A_EIC_EXTINT9 (_UL_(1) << 9)
#define PIN_PA09A_EIC_EXTINT_NUM _L_(9)
#define PIN_PA10A_EIC_EXTINT10 _L_(10)
#define MUX_PA10A_EIC_EXTINT10 _L_(0)
#define PINMUX_PA10A_EIC_EXTINT10 ((PIN_PA10A_EIC_EXTINT10 << 16) | MUX_PA10A_EIC_EXTINT10)
#define PORT_PA10A_EIC_EXTINT10 (_UL_(1) << 10)
#define PIN_PA10A_EIC_EXTINT_NUM _L_(10)
#define PIN_PA30A_EIC_EXTINT10 _L_(30)
#define MUX_PA30A_EIC_EXTINT10 _L_(0)
#define PINMUX_PA30A_EIC_EXTINT10 ((PIN_PA30A_EIC_EXTINT10 << 16) | MUX_PA30A_EIC_EXTINT10)
#define PORT_PA30A_EIC_EXTINT10 (_UL_(1) << 30)
#define PIN_PA30A_EIC_EXTINT_NUM _L_(10)
#define PIN_PA11A_EIC_EXTINT11 _L_(11)
#define MUX_PA11A_EIC_EXTINT11 _L_(0)
#define PINMUX_PA11A_EIC_EXTINT11 ((PIN_PA11A_EIC_EXTINT11 << 16) | MUX_PA11A_EIC_EXTINT11)
#define PORT_PA11A_EIC_EXTINT11 (_UL_(1) << 11)
#define PIN_PA11A_EIC_EXTINT_NUM _L_(11)
#define PIN_PA31A_EIC_EXTINT11 _L_(31)
#define MUX_PA31A_EIC_EXTINT11 _L_(0)
#define PINMUX_PA31A_EIC_EXTINT11 ((PIN_PA31A_EIC_EXTINT11 << 16) | MUX_PA31A_EIC_EXTINT11)
#define PORT_PA31A_EIC_EXTINT11 (_UL_(1) << 31)
#define PIN_PA31A_EIC_EXTINT_NUM _L_(11)
#define PIN_PA24A_EIC_EXTINT12 _L_(24)
#define MUX_PA24A_EIC_EXTINT12 _L_(0)
#define PINMUX_PA24A_EIC_EXTINT12 ((PIN_PA24A_EIC_EXTINT12 << 16) | MUX_PA24A_EIC_EXTINT12)
#define PORT_PA24A_EIC_EXTINT12 (_UL_(1) << 24)
#define PIN_PA24A_EIC_EXTINT_NUM _L_(12)
#define PIN_PA25A_EIC_EXTINT13 _L_(25)
#define MUX_PA25A_EIC_EXTINT13 _L_(0)
#define PINMUX_PA25A_EIC_EXTINT13 ((PIN_PA25A_EIC_EXTINT13 << 16) | MUX_PA25A_EIC_EXTINT13)
#define PORT_PA25A_EIC_EXTINT13 (_UL_(1) << 25)
#define PIN_PA25A_EIC_EXTINT_NUM _L_(13)
#define PIN_PA14A_EIC_EXTINT14 _L_(14)
#define MUX_PA14A_EIC_EXTINT14 _L_(0)
#define PINMUX_PA14A_EIC_EXTINT14 ((PIN_PA14A_EIC_EXTINT14 << 16) | MUX_PA14A_EIC_EXTINT14)
#define PORT_PA14A_EIC_EXTINT14 (_UL_(1) << 14)
#define PIN_PA14A_EIC_EXTINT_NUM _L_(14)
#define PIN_PA15A_EIC_EXTINT15 _L_(15)
#define MUX_PA15A_EIC_EXTINT15 _L_(0)
#define PINMUX_PA15A_EIC_EXTINT15 ((PIN_PA15A_EIC_EXTINT15 << 16) | MUX_PA15A_EIC_EXTINT15)
#define PORT_PA15A_EIC_EXTINT15 (_UL_(1) << 15)
#define PIN_PA15A_EIC_EXTINT_NUM _L_(15)
#define PIN_PA27A_EIC_EXTINT15 _L_(27)
#define MUX_PA27A_EIC_EXTINT15 _L_(0)
#define PINMUX_PA27A_EIC_EXTINT15 ((PIN_PA27A_EIC_EXTINT15 << 16) | MUX_PA27A_EIC_EXTINT15)
#define PORT_PA27A_EIC_EXTINT15 (_UL_(1) << 27)
#define PIN_PA27A_EIC_EXTINT_NUM _L_(15)
#define PIN_PA08A_EIC_NMI _L_(8)
#define MUX_PA08A_EIC_NMI _L_(0)
#define PINMUX_PA08A_EIC_NMI ((PIN_PA08A_EIC_NMI << 16) | MUX_PA08A_EIC_NMI)
#define PORT_PA08A_EIC_NMI (_UL_(1) << 8)
/* ========== PORT definition for USB peripheral ========== */
#define PIN_PA24G_USB_DM _L_(24)
#define MUX_PA24G_USB_DM _L_(6)
#define PINMUX_PA24G_USB_DM ((PIN_PA24G_USB_DM << 16) | MUX_PA24G_USB_DM)
#define PORT_PA24G_USB_DM (_UL_(1) << 24)
#define PIN_PA25G_USB_DP _L_(25)
#define MUX_PA25G_USB_DP _L_(6)
#define PINMUX_PA25G_USB_DP ((PIN_PA25G_USB_DP << 16) | MUX_PA25G_USB_DP)
#define PORT_PA25G_USB_DP (_UL_(1) << 25)
#define PIN_PA23G_USB_SOF_1KHZ _L_(23)
#define MUX_PA23G_USB_SOF_1KHZ _L_(6)
#define PINMUX_PA23G_USB_SOF_1KHZ ((PIN_PA23G_USB_SOF_1KHZ << 16) | MUX_PA23G_USB_SOF_1KHZ)
#define PORT_PA23G_USB_SOF_1KHZ (_UL_(1) << 23)
/* ========== PORT definition for SERCOM0 peripheral ========== */
#define PIN_PA04D_SERCOM0_PAD0 _L_(4)
#define MUX_PA04D_SERCOM0_PAD0 _L_(3)
#define PINMUX_PA04D_SERCOM0_PAD0 ((PIN_PA04D_SERCOM0_PAD0 << 16) | MUX_PA04D_SERCOM0_PAD0)
#define PORT_PA04D_SERCOM0_PAD0 (_UL_(1) << 4)
#define PIN_PA08C_SERCOM0_PAD0 _L_(8)
#define MUX_PA08C_SERCOM0_PAD0 _L_(2)
#define PINMUX_PA08C_SERCOM0_PAD0 ((PIN_PA08C_SERCOM0_PAD0 << 16) | MUX_PA08C_SERCOM0_PAD0)
#define PORT_PA08C_SERCOM0_PAD0 (_UL_(1) << 8)
#define PIN_PA05D_SERCOM0_PAD1 _L_(5)
#define MUX_PA05D_SERCOM0_PAD1 _L_(3)
#define PINMUX_PA05D_SERCOM0_PAD1 ((PIN_PA05D_SERCOM0_PAD1 << 16) | MUX_PA05D_SERCOM0_PAD1)
#define PORT_PA05D_SERCOM0_PAD1 (_UL_(1) << 5)
#define PIN_PA09C_SERCOM0_PAD1 _L_(9)
#define MUX_PA09C_SERCOM0_PAD1 _L_(2)
#define PINMUX_PA09C_SERCOM0_PAD1 ((PIN_PA09C_SERCOM0_PAD1 << 16) | MUX_PA09C_SERCOM0_PAD1)
#define PORT_PA09C_SERCOM0_PAD1 (_UL_(1) << 9)
#define PIN_PA06D_SERCOM0_PAD2 _L_(6)
#define MUX_PA06D_SERCOM0_PAD2 _L_(3)
#define PINMUX_PA06D_SERCOM0_PAD2 ((PIN_PA06D_SERCOM0_PAD2 << 16) | MUX_PA06D_SERCOM0_PAD2)
#define PORT_PA06D_SERCOM0_PAD2 (_UL_(1) << 6)
#define PIN_PA10C_SERCOM0_PAD2 _L_(10)
#define MUX_PA10C_SERCOM0_PAD2 _L_(2)
#define PINMUX_PA10C_SERCOM0_PAD2 ((PIN_PA10C_SERCOM0_PAD2 << 16) | MUX_PA10C_SERCOM0_PAD2)
#define PORT_PA10C_SERCOM0_PAD2 (_UL_(1) << 10)
#define PIN_PA07D_SERCOM0_PAD3 _L_(7)
#define MUX_PA07D_SERCOM0_PAD3 _L_(3)
#define PINMUX_PA07D_SERCOM0_PAD3 ((PIN_PA07D_SERCOM0_PAD3 << 16) | MUX_PA07D_SERCOM0_PAD3)
#define PORT_PA07D_SERCOM0_PAD3 (_UL_(1) << 7)
#define PIN_PA11C_SERCOM0_PAD3 _L_(11)
#define MUX_PA11C_SERCOM0_PAD3 _L_(2)
#define PINMUX_PA11C_SERCOM0_PAD3 ((PIN_PA11C_SERCOM0_PAD3 << 16) | MUX_PA11C_SERCOM0_PAD3)
#define PORT_PA11C_SERCOM0_PAD3 (_UL_(1) << 11)
/* ========== PORT definition for SERCOM1 peripheral ========== */
#define PIN_PA16C_SERCOM1_PAD0 _L_(16)
#define MUX_PA16C_SERCOM1_PAD0 _L_(2)
#define PINMUX_PA16C_SERCOM1_PAD0 ((PIN_PA16C_SERCOM1_PAD0 << 16) | MUX_PA16C_SERCOM1_PAD0)
#define PORT_PA16C_SERCOM1_PAD0 (_UL_(1) << 16)
#define PIN_PA00D_SERCOM1_PAD0 _L_(0)
#define MUX_PA00D_SERCOM1_PAD0 _L_(3)
#define PINMUX_PA00D_SERCOM1_PAD0 ((PIN_PA00D_SERCOM1_PAD0 << 16) | MUX_PA00D_SERCOM1_PAD0)
#define PORT_PA00D_SERCOM1_PAD0 (_UL_(1) << 0)
#define PIN_PA17C_SERCOM1_PAD1 _L_(17)
#define MUX_PA17C_SERCOM1_PAD1 _L_(2)
#define PINMUX_PA17C_SERCOM1_PAD1 ((PIN_PA17C_SERCOM1_PAD1 << 16) | MUX_PA17C_SERCOM1_PAD1)
#define PORT_PA17C_SERCOM1_PAD1 (_UL_(1) << 17)
#define PIN_PA01D_SERCOM1_PAD1 _L_(1)
#define MUX_PA01D_SERCOM1_PAD1 _L_(3)
#define PINMUX_PA01D_SERCOM1_PAD1 ((PIN_PA01D_SERCOM1_PAD1 << 16) | MUX_PA01D_SERCOM1_PAD1)
#define PORT_PA01D_SERCOM1_PAD1 (_UL_(1) << 1)
#define PIN_PA30D_SERCOM1_PAD2 _L_(30)
#define MUX_PA30D_SERCOM1_PAD2 _L_(3)
#define PINMUX_PA30D_SERCOM1_PAD2 ((PIN_PA30D_SERCOM1_PAD2 << 16) | MUX_PA30D_SERCOM1_PAD2)
#define PORT_PA30D_SERCOM1_PAD2 (_UL_(1) << 30)
#define PIN_PA18C_SERCOM1_PAD2 _L_(18)
#define MUX_PA18C_SERCOM1_PAD2 _L_(2)
#define PINMUX_PA18C_SERCOM1_PAD2 ((PIN_PA18C_SERCOM1_PAD2 << 16) | MUX_PA18C_SERCOM1_PAD2)
#define PORT_PA18C_SERCOM1_PAD2 (_UL_(1) << 18)
#define PIN_PA31D_SERCOM1_PAD3 _L_(31)
#define MUX_PA31D_SERCOM1_PAD3 _L_(3)
#define PINMUX_PA31D_SERCOM1_PAD3 ((PIN_PA31D_SERCOM1_PAD3 << 16) | MUX_PA31D_SERCOM1_PAD3)
#define PORT_PA31D_SERCOM1_PAD3 (_UL_(1) << 31)
#define PIN_PA19C_SERCOM1_PAD3 _L_(19)
#define MUX_PA19C_SERCOM1_PAD3 _L_(2)
#define PINMUX_PA19C_SERCOM1_PAD3 ((PIN_PA19C_SERCOM1_PAD3 << 16) | MUX_PA19C_SERCOM1_PAD3)
#define PORT_PA19C_SERCOM1_PAD3 (_UL_(1) << 19)
/* ========== PORT definition for SERCOM2 peripheral ========== */
#define PIN_PA08D_SERCOM2_PAD0 _L_(8)
#define MUX_PA08D_SERCOM2_PAD0 _L_(3)
#define PINMUX_PA08D_SERCOM2_PAD0 ((PIN_PA08D_SERCOM2_PAD0 << 16) | MUX_PA08D_SERCOM2_PAD0)
#define PORT_PA08D_SERCOM2_PAD0 (_UL_(1) << 8)
#define PIN_PA09D_SERCOM2_PAD1 _L_(9)
#define MUX_PA09D_SERCOM2_PAD1 _L_(3)
#define PINMUX_PA09D_SERCOM2_PAD1 ((PIN_PA09D_SERCOM2_PAD1 << 16) | MUX_PA09D_SERCOM2_PAD1)
#define PORT_PA09D_SERCOM2_PAD1 (_UL_(1) << 9)
#define PIN_PA10D_SERCOM2_PAD2 _L_(10)
#define MUX_PA10D_SERCOM2_PAD2 _L_(3)
#define PINMUX_PA10D_SERCOM2_PAD2 ((PIN_PA10D_SERCOM2_PAD2 << 16) | MUX_PA10D_SERCOM2_PAD2)
#define PORT_PA10D_SERCOM2_PAD2 (_UL_(1) << 10)
#define PIN_PA14C_SERCOM2_PAD2 _L_(14)
#define MUX_PA14C_SERCOM2_PAD2 _L_(2)
#define PINMUX_PA14C_SERCOM2_PAD2 ((PIN_PA14C_SERCOM2_PAD2 << 16) | MUX_PA14C_SERCOM2_PAD2)
#define PORT_PA14C_SERCOM2_PAD2 (_UL_(1) << 14)
#define PIN_PA11D_SERCOM2_PAD3 _L_(11)
#define MUX_PA11D_SERCOM2_PAD3 _L_(3)
#define PINMUX_PA11D_SERCOM2_PAD3 ((PIN_PA11D_SERCOM2_PAD3 << 16) | MUX_PA11D_SERCOM2_PAD3)
#define PORT_PA11D_SERCOM2_PAD3 (_UL_(1) << 11)
#define PIN_PA15C_SERCOM2_PAD3 _L_(15)
#define MUX_PA15C_SERCOM2_PAD3 _L_(2)
#define PINMUX_PA15C_SERCOM2_PAD3 ((PIN_PA15C_SERCOM2_PAD3 << 16) | MUX_PA15C_SERCOM2_PAD3)
#define PORT_PA15C_SERCOM2_PAD3 (_UL_(1) << 15)
/* ========== PORT definition for SERCOM3 peripheral ========== */
#define PIN_PA16D_SERCOM3_PAD0 _L_(16)
#define MUX_PA16D_SERCOM3_PAD0 _L_(3)
#define PINMUX_PA16D_SERCOM3_PAD0 ((PIN_PA16D_SERCOM3_PAD0 << 16) | MUX_PA16D_SERCOM3_PAD0)
#define PORT_PA16D_SERCOM3_PAD0 (_UL_(1) << 16)
#define PIN_PA22C_SERCOM3_PAD0 _L_(22)
#define MUX_PA22C_SERCOM3_PAD0 _L_(2)
#define PINMUX_PA22C_SERCOM3_PAD0 ((PIN_PA22C_SERCOM3_PAD0 << 16) | MUX_PA22C_SERCOM3_PAD0)
#define PORT_PA22C_SERCOM3_PAD0 (_UL_(1) << 22)
#define PIN_PA17D_SERCOM3_PAD1 _L_(17)
#define MUX_PA17D_SERCOM3_PAD1 _L_(3)
#define PINMUX_PA17D_SERCOM3_PAD1 ((PIN_PA17D_SERCOM3_PAD1 << 16) | MUX_PA17D_SERCOM3_PAD1)
#define PORT_PA17D_SERCOM3_PAD1 (_UL_(1) << 17)
#define PIN_PA23C_SERCOM3_PAD1 _L_(23)
#define MUX_PA23C_SERCOM3_PAD1 _L_(2)
#define PINMUX_PA23C_SERCOM3_PAD1 ((PIN_PA23C_SERCOM3_PAD1 << 16) | MUX_PA23C_SERCOM3_PAD1)
#define PORT_PA23C_SERCOM3_PAD1 (_UL_(1) << 23)
#define PIN_PA18D_SERCOM3_PAD2 _L_(18)
#define MUX_PA18D_SERCOM3_PAD2 _L_(3)
#define PINMUX_PA18D_SERCOM3_PAD2 ((PIN_PA18D_SERCOM3_PAD2 << 16) | MUX_PA18D_SERCOM3_PAD2)
#define PORT_PA18D_SERCOM3_PAD2 (_UL_(1) << 18)
#define PIN_PA24C_SERCOM3_PAD2 _L_(24)
#define MUX_PA24C_SERCOM3_PAD2 _L_(2)
#define PINMUX_PA24C_SERCOM3_PAD2 ((PIN_PA24C_SERCOM3_PAD2 << 16) | MUX_PA24C_SERCOM3_PAD2)
#define PORT_PA24C_SERCOM3_PAD2 (_UL_(1) << 24)
#define PIN_PA19D_SERCOM3_PAD3 _L_(19)
#define MUX_PA19D_SERCOM3_PAD3 _L_(3)
#define PINMUX_PA19D_SERCOM3_PAD3 ((PIN_PA19D_SERCOM3_PAD3 << 16) | MUX_PA19D_SERCOM3_PAD3)
#define PORT_PA19D_SERCOM3_PAD3 (_UL_(1) << 19)
#define PIN_PA25C_SERCOM3_PAD3 _L_(25)
#define MUX_PA25C_SERCOM3_PAD3 _L_(2)
#define PINMUX_PA25C_SERCOM3_PAD3 ((PIN_PA25C_SERCOM3_PAD3 << 16) | MUX_PA25C_SERCOM3_PAD3)
#define PORT_PA25C_SERCOM3_PAD3 (_UL_(1) << 25)
/* ========== PORT definition for TCC0 peripheral ========== */
#define PIN_PA04E_TCC0_WO0 _L_(4)
#define MUX_PA04E_TCC0_WO0 _L_(4)
#define PINMUX_PA04E_TCC0_WO0 ((PIN_PA04E_TCC0_WO0 << 16) | MUX_PA04E_TCC0_WO0)
#define PORT_PA04E_TCC0_WO0 (_UL_(1) << 4)
#define PIN_PA08E_TCC0_WO0 _L_(8)
#define MUX_PA08E_TCC0_WO0 _L_(4)
#define PINMUX_PA08E_TCC0_WO0 ((PIN_PA08E_TCC0_WO0 << 16) | MUX_PA08E_TCC0_WO0)
#define PORT_PA08E_TCC0_WO0 (_UL_(1) << 8)
#define PIN_PA05E_TCC0_WO1 _L_(5)
#define MUX_PA05E_TCC0_WO1 _L_(4)
#define PINMUX_PA05E_TCC0_WO1 ((PIN_PA05E_TCC0_WO1 << 16) | MUX_PA05E_TCC0_WO1)
#define PORT_PA05E_TCC0_WO1 (_UL_(1) << 5)
#define PIN_PA09E_TCC0_WO1 _L_(9)
#define MUX_PA09E_TCC0_WO1 _L_(4)
#define PINMUX_PA09E_TCC0_WO1 ((PIN_PA09E_TCC0_WO1 << 16) | MUX_PA09E_TCC0_WO1)
#define PORT_PA09E_TCC0_WO1 (_UL_(1) << 9)
#define PIN_PA10F_TCC0_WO2 _L_(10)
#define MUX_PA10F_TCC0_WO2 _L_(5)
#define PINMUX_PA10F_TCC0_WO2 ((PIN_PA10F_TCC0_WO2 << 16) | MUX_PA10F_TCC0_WO2)
#define PORT_PA10F_TCC0_WO2 (_UL_(1) << 10)
#define PIN_PA18F_TCC0_WO2 _L_(18)
#define MUX_PA18F_TCC0_WO2 _L_(5)
#define PINMUX_PA18F_TCC0_WO2 ((PIN_PA18F_TCC0_WO2 << 16) | MUX_PA18F_TCC0_WO2)
#define PORT_PA18F_TCC0_WO2 (_UL_(1) << 18)
#define PIN_PA11F_TCC0_WO3 _L_(11)
#define MUX_PA11F_TCC0_WO3 _L_(5)
#define PINMUX_PA11F_TCC0_WO3 ((PIN_PA11F_TCC0_WO3 << 16) | MUX_PA11F_TCC0_WO3)
#define PORT_PA11F_TCC0_WO3 (_UL_(1) << 11)
#define PIN_PA19F_TCC0_WO3 _L_(19)
#define MUX_PA19F_TCC0_WO3 _L_(5)
#define PINMUX_PA19F_TCC0_WO3 ((PIN_PA19F_TCC0_WO3 << 16) | MUX_PA19F_TCC0_WO3)
#define PORT_PA19F_TCC0_WO3 (_UL_(1) << 19)
#define PIN_PA14F_TCC0_WO4 _L_(14)
#define MUX_PA14F_TCC0_WO4 _L_(5)
#define PINMUX_PA14F_TCC0_WO4 ((PIN_PA14F_TCC0_WO4 << 16) | MUX_PA14F_TCC0_WO4)
#define PORT_PA14F_TCC0_WO4 (_UL_(1) << 14)
#define PIN_PA22F_TCC0_WO4 _L_(22)
#define MUX_PA22F_TCC0_WO4 _L_(5)
#define PINMUX_PA22F_TCC0_WO4 ((PIN_PA22F_TCC0_WO4 << 16) | MUX_PA22F_TCC0_WO4)
#define PORT_PA22F_TCC0_WO4 (_UL_(1) << 22)
#define PIN_PA15F_TCC0_WO5 _L_(15)
#define MUX_PA15F_TCC0_WO5 _L_(5)
#define PINMUX_PA15F_TCC0_WO5 ((PIN_PA15F_TCC0_WO5 << 16) | MUX_PA15F_TCC0_WO5)
#define PORT_PA15F_TCC0_WO5 (_UL_(1) << 15)
#define PIN_PA23F_TCC0_WO5 _L_(23)
#define MUX_PA23F_TCC0_WO5 _L_(5)
#define PINMUX_PA23F_TCC0_WO5 ((PIN_PA23F_TCC0_WO5 << 16) | MUX_PA23F_TCC0_WO5)
#define PORT_PA23F_TCC0_WO5 (_UL_(1) << 23)
#define PIN_PA16F_TCC0_WO6 _L_(16)
#define MUX_PA16F_TCC0_WO6 _L_(5)
#define PINMUX_PA16F_TCC0_WO6 ((PIN_PA16F_TCC0_WO6 << 16) | MUX_PA16F_TCC0_WO6)
#define PORT_PA16F_TCC0_WO6 (_UL_(1) << 16)
#define PIN_PA17F_TCC0_WO7 _L_(17)
#define MUX_PA17F_TCC0_WO7 _L_(5)
#define PINMUX_PA17F_TCC0_WO7 ((PIN_PA17F_TCC0_WO7 << 16) | MUX_PA17F_TCC0_WO7)
#define PORT_PA17F_TCC0_WO7 (_UL_(1) << 17)
/* ========== PORT definition for TCC1 peripheral ========== */
#define PIN_PA06E_TCC1_WO0 _L_(6)
#define MUX_PA06E_TCC1_WO0 _L_(4)
#define PINMUX_PA06E_TCC1_WO0 ((PIN_PA06E_TCC1_WO0 << 16) | MUX_PA06E_TCC1_WO0)
#define PORT_PA06E_TCC1_WO0 (_UL_(1) << 6)
#define PIN_PA10E_TCC1_WO0 _L_(10)
#define MUX_PA10E_TCC1_WO0 _L_(4)
#define PINMUX_PA10E_TCC1_WO0 ((PIN_PA10E_TCC1_WO0 << 16) | MUX_PA10E_TCC1_WO0)
#define PORT_PA10E_TCC1_WO0 (_UL_(1) << 10)
#define PIN_PA30E_TCC1_WO0 _L_(30)
#define MUX_PA30E_TCC1_WO0 _L_(4)
#define PINMUX_PA30E_TCC1_WO0 ((PIN_PA30E_TCC1_WO0 << 16) | MUX_PA30E_TCC1_WO0)
#define PORT_PA30E_TCC1_WO0 (_UL_(1) << 30)
#define PIN_PA07E_TCC1_WO1 _L_(7)
#define MUX_PA07E_TCC1_WO1 _L_(4)
#define PINMUX_PA07E_TCC1_WO1 ((PIN_PA07E_TCC1_WO1 << 16) | MUX_PA07E_TCC1_WO1)
#define PORT_PA07E_TCC1_WO1 (_UL_(1) << 7)
#define PIN_PA11E_TCC1_WO1 _L_(11)
#define MUX_PA11E_TCC1_WO1 _L_(4)
#define PINMUX_PA11E_TCC1_WO1 ((PIN_PA11E_TCC1_WO1 << 16) | MUX_PA11E_TCC1_WO1)
#define PORT_PA11E_TCC1_WO1 (_UL_(1) << 11)
#define PIN_PA31E_TCC1_WO1 _L_(31)
#define MUX_PA31E_TCC1_WO1 _L_(4)
#define PINMUX_PA31E_TCC1_WO1 ((PIN_PA31E_TCC1_WO1 << 16) | MUX_PA31E_TCC1_WO1)
#define PORT_PA31E_TCC1_WO1 (_UL_(1) << 31)
#define PIN_PA08F_TCC1_WO2 _L_(8)
#define MUX_PA08F_TCC1_WO2 _L_(5)
#define PINMUX_PA08F_TCC1_WO2 ((PIN_PA08F_TCC1_WO2 << 16) | MUX_PA08F_TCC1_WO2)
#define PORT_PA08F_TCC1_WO2 (_UL_(1) << 8)
#define PIN_PA24F_TCC1_WO2 _L_(24)
#define MUX_PA24F_TCC1_WO2 _L_(5)
#define PINMUX_PA24F_TCC1_WO2 ((PIN_PA24F_TCC1_WO2 << 16) | MUX_PA24F_TCC1_WO2)
#define PORT_PA24F_TCC1_WO2 (_UL_(1) << 24)
#define PIN_PA09F_TCC1_WO3 _L_(9)
#define MUX_PA09F_TCC1_WO3 _L_(5)
#define PINMUX_PA09F_TCC1_WO3 ((PIN_PA09F_TCC1_WO3 << 16) | MUX_PA09F_TCC1_WO3)
#define PORT_PA09F_TCC1_WO3 (_UL_(1) << 9)
#define PIN_PA25F_TCC1_WO3 _L_(25)
#define MUX_PA25F_TCC1_WO3 _L_(5)
#define PINMUX_PA25F_TCC1_WO3 ((PIN_PA25F_TCC1_WO3 << 16) | MUX_PA25F_TCC1_WO3)
#define PORT_PA25F_TCC1_WO3 (_UL_(1) << 25)
/* ========== PORT definition for TCC2 peripheral ========== */
#define PIN_PA16E_TCC2_WO0 _L_(16)
#define MUX_PA16E_TCC2_WO0 _L_(4)
#define PINMUX_PA16E_TCC2_WO0 ((PIN_PA16E_TCC2_WO0 << 16) | MUX_PA16E_TCC2_WO0)
#define PORT_PA16E_TCC2_WO0 (_UL_(1) << 16)
#define PIN_PA00E_TCC2_WO0 _L_(0)
#define MUX_PA00E_TCC2_WO0 _L_(4)
#define PINMUX_PA00E_TCC2_WO0 ((PIN_PA00E_TCC2_WO0 << 16) | MUX_PA00E_TCC2_WO0)
#define PORT_PA00E_TCC2_WO0 (_UL_(1) << 0)
#define PIN_PA17E_TCC2_WO1 _L_(17)
#define MUX_PA17E_TCC2_WO1 _L_(4)
#define PINMUX_PA17E_TCC2_WO1 ((PIN_PA17E_TCC2_WO1 << 16) | MUX_PA17E_TCC2_WO1)
#define PORT_PA17E_TCC2_WO1 (_UL_(1) << 17)
#define PIN_PA01E_TCC2_WO1 _L_(1)
#define MUX_PA01E_TCC2_WO1 _L_(4)
#define PINMUX_PA01E_TCC2_WO1 ((PIN_PA01E_TCC2_WO1 << 16) | MUX_PA01E_TCC2_WO1)
#define PORT_PA01E_TCC2_WO1 (_UL_(1) << 1)
/* ========== PORT definition for TC3 peripheral ========== */
#define PIN_PA18E_TC3_WO0 _L_(18)
#define MUX_PA18E_TC3_WO0 _L_(4)
#define PINMUX_PA18E_TC3_WO0 ((PIN_PA18E_TC3_WO0 << 16) | MUX_PA18E_TC3_WO0)
#define PORT_PA18E_TC3_WO0 (_UL_(1) << 18)
#define PIN_PA14E_TC3_WO0 _L_(14)
#define MUX_PA14E_TC3_WO0 _L_(4)
#define PINMUX_PA14E_TC3_WO0 ((PIN_PA14E_TC3_WO0 << 16) | MUX_PA14E_TC3_WO0)
#define PORT_PA14E_TC3_WO0 (_UL_(1) << 14)
#define PIN_PA19E_TC3_WO1 _L_(19)
#define MUX_PA19E_TC3_WO1 _L_(4)
#define PINMUX_PA19E_TC3_WO1 ((PIN_PA19E_TC3_WO1 << 16) | MUX_PA19E_TC3_WO1)
#define PORT_PA19E_TC3_WO1 (_UL_(1) << 19)
#define PIN_PA15E_TC3_WO1 _L_(15)
#define MUX_PA15E_TC3_WO1 _L_(4)
#define PINMUX_PA15E_TC3_WO1 ((PIN_PA15E_TC3_WO1 << 16) | MUX_PA15E_TC3_WO1)
#define PORT_PA15E_TC3_WO1 (_UL_(1) << 15)
/* ========== PORT definition for TC4 peripheral ========== */
#define PIN_PA22E_TC4_WO0 _L_(22)
#define MUX_PA22E_TC4_WO0 _L_(4)
#define PINMUX_PA22E_TC4_WO0 ((PIN_PA22E_TC4_WO0 << 16) | MUX_PA22E_TC4_WO0)
#define PORT_PA22E_TC4_WO0 (_UL_(1) << 22)
#define PIN_PA23E_TC4_WO1 _L_(23)
#define MUX_PA23E_TC4_WO1 _L_(4)
#define PINMUX_PA23E_TC4_WO1 ((PIN_PA23E_TC4_WO1 << 16) | MUX_PA23E_TC4_WO1)
#define PORT_PA23E_TC4_WO1 (_UL_(1) << 23)
/* ========== PORT definition for TC5 peripheral ========== */
#define PIN_PA24E_TC5_WO0 _L_(24)
#define MUX_PA24E_TC5_WO0 _L_(4)
#define PINMUX_PA24E_TC5_WO0 ((PIN_PA24E_TC5_WO0 << 16) | MUX_PA24E_TC5_WO0)
#define PORT_PA24E_TC5_WO0 (_UL_(1) << 24)
#define PIN_PA25E_TC5_WO1 _L_(25)
#define MUX_PA25E_TC5_WO1 _L_(4)
#define PINMUX_PA25E_TC5_WO1 ((PIN_PA25E_TC5_WO1 << 16) | MUX_PA25E_TC5_WO1)
#define PORT_PA25E_TC5_WO1 (_UL_(1) << 25)
/* ========== PORT definition for ADC peripheral ========== */
#define PIN_PA02B_ADC_AIN0 _L_(2)
#define MUX_PA02B_ADC_AIN0 _L_(1)
#define PINMUX_PA02B_ADC_AIN0 ((PIN_PA02B_ADC_AIN0 << 16) | MUX_PA02B_ADC_AIN0)
#define PORT_PA02B_ADC_AIN0 (_UL_(1) << 2)
#define PIN_PA03B_ADC_AIN1 _L_(3)
#define MUX_PA03B_ADC_AIN1 _L_(1)
#define PINMUX_PA03B_ADC_AIN1 ((PIN_PA03B_ADC_AIN1 << 16) | MUX_PA03B_ADC_AIN1)
#define PORT_PA03B_ADC_AIN1 (_UL_(1) << 3)
#define PIN_PA04B_ADC_AIN4 _L_(4)
#define MUX_PA04B_ADC_AIN4 _L_(1)
#define PINMUX_PA04B_ADC_AIN4 ((PIN_PA04B_ADC_AIN4 << 16) | MUX_PA04B_ADC_AIN4)
#define PORT_PA04B_ADC_AIN4 (_UL_(1) << 4)
#define PIN_PA05B_ADC_AIN5 _L_(5)
#define MUX_PA05B_ADC_AIN5 _L_(1)
#define PINMUX_PA05B_ADC_AIN5 ((PIN_PA05B_ADC_AIN5 << 16) | MUX_PA05B_ADC_AIN5)
#define PORT_PA05B_ADC_AIN5 (_UL_(1) << 5)
#define PIN_PA06B_ADC_AIN6 _L_(6)
#define MUX_PA06B_ADC_AIN6 _L_(1)
#define PINMUX_PA06B_ADC_AIN6 ((PIN_PA06B_ADC_AIN6 << 16) | MUX_PA06B_ADC_AIN6)
#define PORT_PA06B_ADC_AIN6 (_UL_(1) << 6)
#define PIN_PA07B_ADC_AIN7 _L_(7)
#define MUX_PA07B_ADC_AIN7 _L_(1)
#define PINMUX_PA07B_ADC_AIN7 ((PIN_PA07B_ADC_AIN7 << 16) | MUX_PA07B_ADC_AIN7)
#define PORT_PA07B_ADC_AIN7 (_UL_(1) << 7)
#define PIN_PA08B_ADC_AIN16 _L_(8)
#define MUX_PA08B_ADC_AIN16 _L_(1)
#define PINMUX_PA08B_ADC_AIN16 ((PIN_PA08B_ADC_AIN16 << 16) | MUX_PA08B_ADC_AIN16)
#define PORT_PA08B_ADC_AIN16 (_UL_(1) << 8)
#define PIN_PA09B_ADC_AIN17 _L_(9)
#define MUX_PA09B_ADC_AIN17 _L_(1)
#define PINMUX_PA09B_ADC_AIN17 ((PIN_PA09B_ADC_AIN17 << 16) | MUX_PA09B_ADC_AIN17)
#define PORT_PA09B_ADC_AIN17 (_UL_(1) << 9)
#define PIN_PA10B_ADC_AIN18 _L_(10)
#define MUX_PA10B_ADC_AIN18 _L_(1)
#define PINMUX_PA10B_ADC_AIN18 ((PIN_PA10B_ADC_AIN18 << 16) | MUX_PA10B_ADC_AIN18)
#define PORT_PA10B_ADC_AIN18 (_UL_(1) << 10)
#define PIN_PA11B_ADC_AIN19 _L_(11)
#define MUX_PA11B_ADC_AIN19 _L_(1)
#define PINMUX_PA11B_ADC_AIN19 ((PIN_PA11B_ADC_AIN19 << 16) | MUX_PA11B_ADC_AIN19)
#define PORT_PA11B_ADC_AIN19 (_UL_(1) << 11)
#define PIN_PA04B_ADC_VREFP _L_(4)
#define MUX_PA04B_ADC_VREFP _L_(1)
#define PINMUX_PA04B_ADC_VREFP ((PIN_PA04B_ADC_VREFP << 16) | MUX_PA04B_ADC_VREFP)
#define PORT_PA04B_ADC_VREFP (_UL_(1) << 4)
/* ========== PORT definition for AC peripheral ========== */
#define PIN_PA04B_AC_AIN0 _L_(4)
#define MUX_PA04B_AC_AIN0 _L_(1)
#define PINMUX_PA04B_AC_AIN0 ((PIN_PA04B_AC_AIN0 << 16) | MUX_PA04B_AC_AIN0)
#define PORT_PA04B_AC_AIN0 (_UL_(1) << 4)
#define PIN_PA05B_AC_AIN1 _L_(5)
#define MUX_PA05B_AC_AIN1 _L_(1)
#define PINMUX_PA05B_AC_AIN1 ((PIN_PA05B_AC_AIN1 << 16) | MUX_PA05B_AC_AIN1)
#define PORT_PA05B_AC_AIN1 (_UL_(1) << 5)
#define PIN_PA06B_AC_AIN2 _L_(6)
#define MUX_PA06B_AC_AIN2 _L_(1)
#define PINMUX_PA06B_AC_AIN2 ((PIN_PA06B_AC_AIN2 << 16) | MUX_PA06B_AC_AIN2)
#define PORT_PA06B_AC_AIN2 (_UL_(1) << 6)
#define PIN_PA07B_AC_AIN3 _L_(7)
#define MUX_PA07B_AC_AIN3 _L_(1)
#define PINMUX_PA07B_AC_AIN3 ((PIN_PA07B_AC_AIN3 << 16) | MUX_PA07B_AC_AIN3)
#define PORT_PA07B_AC_AIN3 (_UL_(1) << 7)
#define PIN_PA18H_AC_CMP0 _L_(18)
#define MUX_PA18H_AC_CMP0 _L_(7)
#define PINMUX_PA18H_AC_CMP0 ((PIN_PA18H_AC_CMP0 << 16) | MUX_PA18H_AC_CMP0)
#define PORT_PA18H_AC_CMP0 (_UL_(1) << 18)
#define PIN_PA19H_AC_CMP1 _L_(19)
#define MUX_PA19H_AC_CMP1 _L_(7)
#define PINMUX_PA19H_AC_CMP1 ((PIN_PA19H_AC_CMP1 << 16) | MUX_PA19H_AC_CMP1)
#define PORT_PA19H_AC_CMP1 (_UL_(1) << 19)
/* ========== PORT definition for DAC peripheral ========== */
#define PIN_PA02B_DAC_VOUT _L_(2)
#define MUX_PA02B_DAC_VOUT _L_(1)
#define PINMUX_PA02B_DAC_VOUT ((PIN_PA02B_DAC_VOUT << 16) | MUX_PA02B_DAC_VOUT)
#define PORT_PA02B_DAC_VOUT (_UL_(1) << 2)
#define PIN_PA03B_DAC_VREFP _L_(3)
#define MUX_PA03B_DAC_VREFP _L_(1)
#define PINMUX_PA03B_DAC_VREFP ((PIN_PA03B_DAC_VREFP << 16) | MUX_PA03B_DAC_VREFP)
#define PORT_PA03B_DAC_VREFP (_UL_(1) << 3)
/* ========== PORT definition for I2S peripheral ========== */
#define PIN_PA11G_I2S_FS0 _L_(11)
#define MUX_PA11G_I2S_FS0 _L_(6)
#define PINMUX_PA11G_I2S_FS0 ((PIN_PA11G_I2S_FS0 << 16) | MUX_PA11G_I2S_FS0)
#define PORT_PA11G_I2S_FS0 (_UL_(1) << 11)
#define PIN_PA09G_I2S_MCK0 _L_(9)
#define MUX_PA09G_I2S_MCK0 _L_(6)
#define PINMUX_PA09G_I2S_MCK0 ((PIN_PA09G_I2S_MCK0 << 16) | MUX_PA09G_I2S_MCK0)
#define PORT_PA09G_I2S_MCK0 (_UL_(1) << 9)
#define PIN_PA10G_I2S_SCK0 _L_(10)
#define MUX_PA10G_I2S_SCK0 _L_(6)
#define PINMUX_PA10G_I2S_SCK0 ((PIN_PA10G_I2S_SCK0 << 16) | MUX_PA10G_I2S_SCK0)
#define PORT_PA10G_I2S_SCK0 (_UL_(1) << 10)
#define PIN_PA07G_I2S_SD0 _L_(7)
#define MUX_PA07G_I2S_SD0 _L_(6)
#define PINMUX_PA07G_I2S_SD0 ((PIN_PA07G_I2S_SD0 << 16) | MUX_PA07G_I2S_SD0)
#define PORT_PA07G_I2S_SD0 (_UL_(1) << 7)
#define PIN_PA19G_I2S_SD0 _L_(19)
#define MUX_PA19G_I2S_SD0 _L_(6)
#define PINMUX_PA19G_I2S_SD0 ((PIN_PA19G_I2S_SD0 << 16) | MUX_PA19G_I2S_SD0)
#define PORT_PA19G_I2S_SD0 (_UL_(1) << 19)
#define PIN_PA08G_I2S_SD1 _L_(8)
#define MUX_PA08G_I2S_SD1 _L_(6)
#define PINMUX_PA08G_I2S_SD1 ((PIN_PA08G_I2S_SD1 << 16) | MUX_PA08G_I2S_SD1)
#define PORT_PA08G_I2S_SD1 (_UL_(1) << 8)
# 524 "asf4/samd21/include/samd21e18a.h" 2
/*@}*/

/* ************************************************************************** */
/**  MEMORY MAPPING DEFINITIONS FOR SAMD21E18A */
/* ************************************************************************** */

#define FLASH_SIZE _UL_(0x00040000)
#define FLASH_PAGE_SIZE 64
#define FLASH_NB_OF_PAGES 4096
#define FLASH_USER_PAGE_SIZE 64
#define HMCRAMC0_SIZE _UL_(0x00008000)

#define FLASH_ADDR _UL_(0x00000000)
#define FLASH_USER_PAGE_ADDR _UL_(0x00800000)
#define HMCRAMC0_ADDR _UL_(0x20000000)
#define HPB0_ADDR _UL_(0x40000000)
#define HPB1_ADDR _UL_(0x41000000)
#define HPB2_ADDR _UL_(0x42000000)
#define PPB_ADDR _UL_(0xE0000000)

#define DSU_DID_RESETVALUE _UL_(0x1001030A)
#define EIC_EXTINT_NUM 16
#define PORT_GROUPS 1

/* ************************************************************************** */
/**  ELECTRICAL DEFINITIONS FOR SAMD21E18A */
/* ************************************************************************** */






/*@}*/
# 39 "asf4/samd21/include/sam.h" 2
# 32 "mpconfigport.h" 2

// Definitions that control circuitpy_mpconfig.h:

////////////////////////////////////////////////////////////////////////////////////////////////////



// HMCRAMC0_SIZE is defined in the ASF4 include files for each SAMD21 chip.
#define RAM_SIZE HMCRAMC0_SIZE
#define BOOTLOADER_SIZE (8*1024)
#define CIRCUITPY_MCU_FAMILY samd21
#define MICROPY_PY_SYS_PLATFORM "Atmel SAMD21"
#define SPI_FLASH_MAX_BAUDRATE 8000000
#define MICROPY_PY_BUILTINS_NOTIMPLEMENTED (0)
#define MICROPY_PY_COLLECTIONS_ORDEREDDICT (0)
#define MICROPY_PY_FUNCTION_ATTRS (0)
// MICROPY_PY_UJSON depends on MICROPY_PY_IO
#define MICROPY_PY_IO (0)
#define MICROPY_PY_UJSON (0)
#define MICROPY_PY_REVERSE_SPECIAL_METHODS (0)
#define MICROPY_PY_UERRNO_LIST X(EPERM) X(ENOENT) X(EIO) X(EAGAIN) X(ENOMEM) X(EACCES) X(EEXIST) X(ENODEV) X(EISDIR) X(EINVAL)
# 66 "mpconfigport.h"
////////////////////////////////////////////////////////////////////////////////////////////////////
# 87 "mpconfigport.h"
////////////////////////////////////////////////////////////////////////////////////////////////////

// This also includes mpconfigboard.h.
#include "py/circuitpy_mpconfig.h"
# 90 "mpconfigport.h"
# 1 "../../py/circuitpy_mpconfig.h" 1
/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Dan Halbert for Adafruit Industries
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// This file contains settings that are common across CircuitPython ports, to make
// sure that the same feature set and settings are used, such as in atmel-samd
// and nrf.


#define __INCLUDED_MPCONFIG_CIRCUITPY_H 

#include <stdint.h>
#include <stdatomic.h>
# 35 "../../py/circuitpy_mpconfig.h"
# 1 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdatomic.h" 1 3 4

# 1 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdatomic.h" 3 4
/* Copyright (C) 2013-2019 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* ISO C11 Standard:  7.17  Atomics <stdatomic.h>.  */


#define _STDATOMIC_H 

typedef enum
  {
    memory_order_relaxed = 0,
    memory_order_consume = 1,
    memory_order_acquire = 2,
    memory_order_release = 3,
    memory_order_acq_rel = 4,
    memory_order_seq_cst = 5
  } memory_order;


typedef _Atomic _Bool atomic_bool;
typedef _Atomic char atomic_char;
typedef _Atomic signed char atomic_schar;
typedef _Atomic unsigned char atomic_uchar;
typedef _Atomic short atomic_short;
typedef _Atomic unsigned short atomic_ushort;
typedef _Atomic int atomic_int;
typedef _Atomic unsigned int atomic_uint;
typedef _Atomic long atomic_long;
typedef _Atomic unsigned long atomic_ulong;
typedef _Atomic long long atomic_llong;
typedef _Atomic unsigned long long atomic_ullong;
typedef _Atomic short unsigned int atomic_char16_t;
typedef _Atomic long unsigned int atomic_char32_t;
typedef _Atomic unsigned int atomic_wchar_t;
typedef _Atomic signed char atomic_int_least8_t;
typedef _Atomic unsigned char atomic_uint_least8_t;
typedef _Atomic short int atomic_int_least16_t;
typedef _Atomic short unsigned int atomic_uint_least16_t;
typedef _Atomic long int atomic_int_least32_t;
typedef _Atomic long unsigned int atomic_uint_least32_t;
typedef _Atomic long long int atomic_int_least64_t;
typedef _Atomic long long unsigned int atomic_uint_least64_t;
typedef _Atomic int atomic_int_fast8_t;
typedef _Atomic unsigned int atomic_uint_fast8_t;
typedef _Atomic int atomic_int_fast16_t;
typedef _Atomic unsigned int atomic_uint_fast16_t;
typedef _Atomic int atomic_int_fast32_t;
typedef _Atomic unsigned int atomic_uint_fast32_t;
typedef _Atomic long long int atomic_int_fast64_t;
typedef _Atomic long long unsigned int atomic_uint_fast64_t;
typedef _Atomic int atomic_intptr_t;
typedef _Atomic unsigned int atomic_uintptr_t;
typedef _Atomic unsigned int atomic_size_t;
typedef _Atomic int atomic_ptrdiff_t;
typedef _Atomic long long int atomic_intmax_t;
typedef _Atomic long long unsigned int atomic_uintmax_t;


#define ATOMIC_VAR_INIT(VALUE) (VALUE)

/* Initialize an atomic object pointed to by PTR with VAL.  */
#define atomic_init(PTR,VAL) atomic_store_explicit (PTR, VAL, __ATOMIC_RELAXED)


#define kill_dependency(Y) __extension__ ({ __auto_type __kill_dependency_tmp = (Y); __kill_dependency_tmp; })






extern void atomic_thread_fence (memory_order);
#define atomic_thread_fence(MO) __atomic_thread_fence (MO)
extern void atomic_signal_fence (memory_order);
#define atomic_signal_fence(MO) __atomic_signal_fence (MO)
#define atomic_is_lock_free(OBJ) __atomic_is_lock_free (sizeof (*(OBJ)), (OBJ))

#define ATOMIC_BOOL_LOCK_FREE __GCC_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE __GCC_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE __GCC_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE __GCC_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE __GCC_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE __GCC_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE __GCC_ATOMIC_POINTER_LOCK_FREE


/* Note that these macros require __typeof__ and __auto_type to remove
   _Atomic qualifiers (and const qualifiers, if those are valid on
   macro operands).
   
   Also note that the header file uses the generic form of __atomic
   builtins, which requires the address to be taken of the value
   parameter, and then we pass that value on.  This allows the macros
   to work for any type, and the compiler is smart enough to convert
   these to lock-free _N variants if possible, and throw away the
   temps.  */

#define atomic_store_explicit(PTR,VAL,MO) __extension__ ({ __auto_type __atomic_store_ptr = (PTR); __typeof__ (*__atomic_store_ptr) __atomic_store_tmp = (VAL); __atomic_store (__atomic_store_ptr, &__atomic_store_tmp, (MO)); })







#define atomic_store(PTR,VAL) atomic_store_explicit (PTR, VAL, __ATOMIC_SEQ_CST)



#define atomic_load_explicit(PTR,MO) __extension__ ({ __auto_type __atomic_load_ptr = (PTR); __typeof__ (*__atomic_load_ptr) __atomic_load_tmp; __atomic_load (__atomic_load_ptr, &__atomic_load_tmp, (MO)); __atomic_load_tmp; })
# 142 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdatomic.h" 3 4
#define atomic_load(PTR) atomic_load_explicit (PTR, __ATOMIC_SEQ_CST)


#define atomic_exchange_explicit(PTR,VAL,MO) __extension__ ({ __auto_type __atomic_exchange_ptr = (PTR); __typeof__ (*__atomic_exchange_ptr) __atomic_exchange_val = (VAL); __typeof__ (*__atomic_exchange_ptr) __atomic_exchange_tmp; __atomic_exchange (__atomic_exchange_ptr, &__atomic_exchange_val, &__atomic_exchange_tmp, (MO)); __atomic_exchange_tmp; })
# 156 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdatomic.h" 3 4
#define atomic_exchange(PTR,VAL) atomic_exchange_explicit (PTR, VAL, __ATOMIC_SEQ_CST)



#define atomic_compare_exchange_strong_explicit(PTR,VAL,DES,SUC,FAIL) __extension__ ({ __auto_type __atomic_compare_exchange_ptr = (PTR); __typeof__ (*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (DES); __atomic_compare_exchange (__atomic_compare_exchange_ptr, (VAL), &__atomic_compare_exchange_tmp, 0, (SUC), (FAIL)); })
# 171 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdatomic.h" 3 4
#define atomic_compare_exchange_strong(PTR,VAL,DES) atomic_compare_exchange_strong_explicit (PTR, VAL, DES, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)



#define atomic_compare_exchange_weak_explicit(PTR,VAL,DES,SUC,FAIL) __extension__ ({ __auto_type __atomic_compare_exchange_ptr = (PTR); __typeof__ (*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (DES); __atomic_compare_exchange (__atomic_compare_exchange_ptr, (VAL), &__atomic_compare_exchange_tmp, 1, (SUC), (FAIL)); })
# 186 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdatomic.h" 3 4
#define atomic_compare_exchange_weak(PTR,VAL,DES) atomic_compare_exchange_weak_explicit (PTR, VAL, DES, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)





#define atomic_fetch_add(PTR,VAL) __atomic_fetch_add ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_add_explicit(PTR,VAL,MO) __atomic_fetch_add ((PTR), (VAL), (MO))


#define atomic_fetch_sub(PTR,VAL) __atomic_fetch_sub ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_sub_explicit(PTR,VAL,MO) __atomic_fetch_sub ((PTR), (VAL), (MO))


#define atomic_fetch_or(PTR,VAL) __atomic_fetch_or ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_or_explicit(PTR,VAL,MO) __atomic_fetch_or ((PTR), (VAL), (MO))


#define atomic_fetch_xor(PTR,VAL) __atomic_fetch_xor ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_xor_explicit(PTR,VAL,MO) __atomic_fetch_xor ((PTR), (VAL), (MO))


#define atomic_fetch_and(PTR,VAL) __atomic_fetch_and ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_and_explicit(PTR,VAL,MO) __atomic_fetch_and ((PTR), (VAL), (MO))



typedef _Atomic struct
{

  _Bool __val;



} atomic_flag;

#define ATOMIC_FLAG_INIT { 0 }


extern _Bool atomic_flag_test_and_set (volatile atomic_flag *);
#define atomic_flag_test_and_set(PTR) __atomic_test_and_set ((PTR), __ATOMIC_SEQ_CST)

extern _Bool atomic_flag_test_and_set_explicit (volatile atomic_flag *,
      memory_order);
#define atomic_flag_test_and_set_explicit(PTR,MO) __atomic_test_and_set ((PTR), (MO))


extern void atomic_flag_clear (volatile atomic_flag *);
#define atomic_flag_clear(PTR) __atomic_clear ((PTR), __ATOMIC_SEQ_CST)
extern void atomic_flag_clear_explicit (volatile atomic_flag *, memory_order);
#define atomic_flag_clear_explicit(PTR,MO) __atomic_clear ((PTR), (MO))
# 36 "../../py/circuitpy_mpconfig.h" 2


# 37 "../../py/circuitpy_mpconfig.h"
// This is CircuitPython.
#define CIRCUITPY 1

// REPR_C encodes qstrs, 31-bit ints, and 30-bit floats in a single 32-bit word.
#define MICROPY_OBJ_REPR (MICROPY_OBJ_REPR_C)

// options to control how MicroPython is built
// TODO(tannewt): Reduce this number if we want the REPL to function under 512
// free bytes.
// #define MICROPY_ALLOC_PARSE_RULE_INIT (64)

// Sorted alphabetically for easy finding.
//
// default is 128; consider raising to reduce fragmentation.
#define MICROPY_ALLOC_PARSE_CHUNK_INIT (16)
// default is 512.
#define MICROPY_ALLOC_PATH_MAX (256)
#define MICROPY_CAN_OVERRIDE_BUILTINS (1)
#define MICROPY_COMP_CONST (1)
#define MICROPY_COMP_DOUBLE_TUPLE_ASSIGN (1)
#define MICROPY_COMP_MODULE_CONST (1)
#define MICROPY_COMP_TRIPLE_TUPLE_ASSIGN (0)
#define MICROPY_DEBUG_PRINTERS (0)
#define MICROPY_EMIT_INLINE_THUMB (CIRCUITPY_ENABLE_MPY_NATIVE)
#define MICROPY_EMIT_THUMB (CIRCUITPY_ENABLE_MPY_NATIVE)
#define MICROPY_EMIT_X64 (0)
#define MICROPY_ENABLE_DOC_STRING (0)
#define MICROPY_ENABLE_FINALISER (1)
#define MICROPY_ENABLE_GC (1)
#define MICROPY_ENABLE_SOURCE_LINE (1)
#define MICROPY_ERROR_REPORTING (MICROPY_ERROR_REPORTING_NORMAL)
#define MICROPY_FLOAT_HIGH_QUALITY_HASH (0)
#define MICROPY_FLOAT_IMPL (MICROPY_FLOAT_IMPL_FLOAT)
#define MICROPY_GC_ALLOC_THRESHOLD (0)
#define MICROPY_HELPER_LEXER_UNIX (0)
#define MICROPY_HELPER_REPL (1)
#define MICROPY_KBD_EXCEPTION (1)
#define MICROPY_MEM_STATS (0)
#define MICROPY_MODULE_BUILTIN_INIT (1)
#define MICROPY_NONSTANDARD_TYPECODES (0)
#define MICROPY_OPT_COMPUTED_GOTO (1)
#define MICROPY_PERSISTENT_CODE_LOAD (1)

#define MICROPY_PY_ARRAY (1)
#define MICROPY_PY_ARRAY_SLICE_ASSIGN (1)
#define MICROPY_PY_ASYNC_AWAIT (0)
#define MICROPY_PY_ATTRTUPLE (1)

#define MICROPY_PY_BUILTINS_BYTEARRAY (1)
#define MICROPY_PY_BUILTINS_ENUMERATE (1)
#define MICROPY_PY_BUILTINS_FILTER (1)
#define MICROPY_PY_BUILTINS_HELP (1)
#define MICROPY_PY_BUILTINS_HELP_MODULES (1)
#define MICROPY_PY_BUILTINS_INPUT (1)
#define MICROPY_PY_BUILTINS_MEMORYVIEW (1)
#define MICROPY_PY_BUILTINS_MIN_MAX (1)
#define MICROPY_PY_BUILTINS_PROPERTY (1)
#define MICROPY_PY_BUILTINS_REVERSED (1)
#define MICROPY_PY_BUILTINS_ROUND_INT (1)
#define MICROPY_PY_BUILTINS_SET (1)
#define MICROPY_PY_BUILTINS_SLICE (1)
#define MICROPY_PY_BUILTINS_SLICE_ATTRS (1)
#define MICROPY_PY_BUILTINS_STR_UNICODE (1)

#define MICROPY_PY_CMATH (0)
#define MICROPY_PY_COLLECTIONS (1)
#define MICROPY_PY_DESCRIPTORS (1)
#define MICROPY_PY_IO_FILEIO (1)
#define MICROPY_PY_GC (1)
// Supplanted by shared-bindings/math
#define MICROPY_PY_MATH (0)
#define MICROPY_PY_MICROPYTHON_MEM_INFO (0)
// Supplanted by shared-bindings/struct
#define MICROPY_PY_STRUCT (0)
#define MICROPY_PY_SYS (1)
#define MICROPY_PY_SYS_MAXSIZE (1)
#define MICROPY_PY_SYS_STDFILES (1)
// Supplanted by shared-bindings/random
#define MICROPY_PY_URANDOM (0)
#define MICROPY_PY_URANDOM_EXTRA_FUNCS (0)
#define MICROPY_PY___FILE__ (1)

#define MICROPY_QSTR_BYTES_IN_HASH (1)
#define MICROPY_REPL_AUTO_INDENT (1)
#define MICROPY_REPL_EVENT_DRIVEN (0)
#define MICROPY_STACK_CHECK (1)
#define MICROPY_STREAMS_NON_BLOCK (1)
#define MICROPY_USE_INTERNAL_PRINTF (1)

// fatfs configuration used in ffconf.h
//
// 1 = SFN/ANSI 437=LFN/U.S.(OEM)
#define MICROPY_FATFS_ENABLE_LFN (1)
#define MICROPY_FATFS_LFN_CODE_PAGE (437)
#define MICROPY_FATFS_USE_LABEL (1)
#define MICROPY_FATFS_RPATH (2)
#define MICROPY_FATFS_MULTI_PARTITION (1)

// Only enable this if you really need it. It allocates a byte cache of this size.
// #define MICROPY_FATFS_MAX_SS           (4096)

#define FILESYSTEM_BLOCK_SIZE (512)

#define MICROPY_VFS (1)
#define MICROPY_VFS_FAT (MICROPY_VFS)
#define MICROPY_READER_VFS (MICROPY_VFS)

// type definitions for the specific machine

#define BYTES_PER_WORD (4)

#define MICROPY_MAKE_POINTER_CALLABLE(p) ((void*)((mp_uint_t)(p) | 1))

// Track stack usage. Expose results via ustack module.
#define MICROPY_MAX_STACK_USAGE (0)

// This port is intended to be 32-bit, but unfortunately, int32_t for
// different targets may be defined in different ways - either as int
// or as long. This requires different printf formatting specifiers
// to print such value. So, we avoid int32_t and use int directly.
#define UINT_FMT "%u"
#define INT_FMT "%d"
typedef int mp_int_t; // must be pointer size
typedef unsigned mp_uint_t; // must be pointer size
typedef long mp_off_t;

#define MP_PLAT_PRINT_STRN(str,len) mp_hal_stdout_tx_strn_cooked(str, len)

#define mp_type_fileio mp_type_vfs_fat_fileio
#define mp_type_textio mp_type_vfs_fat_textio

#define mp_import_stat mp_vfs_import_stat
#define mp_builtin_open_obj mp_vfs_open_obj


// extra built in names to add to the global namespace
#define MICROPY_PORT_BUILTINS { MP_OBJ_NEW_QSTR(MP_QSTR_help), (mp_obj_t)&mp_builtin_help_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_input), (mp_obj_t)&mp_builtin_input_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_open), (mp_obj_t)&mp_builtin_open_obj },




//////////////////////////////////////////////////////////////////////////////////////////////////
// board-specific definitions, which control and may override definitions below.
#include "mpconfigboard.h"
# 180 "../../py/circuitpy_mpconfig.h"
# 1 "boards/alliecat_candythecatacorn/mpconfigboard.h" 1
#define MICROPY_HW_BOARD_NAME "Candy the Catacorn"
#define MICROPY_HW_MCU_NAME "samd21e18"

// Rev B - Black
#define MICROPY_HW_LED_STATUS (&pin_PA10)

#define MICROPY_HW_APA102_MOSI (&pin_PA00)
#define MICROPY_HW_APA102_SCK (&pin_PA01)

#define MICROPY_PORT_A (PORT_PA00 | PORT_PA01)
#define MICROPY_PORT_B (0)
#define MICROPY_PORT_C (0)

#define IGNORE_PIN_PA03 1
#define IGNORE_PIN_PA04 1
#define IGNORE_PIN_PA11 1
#define IGNORE_PIN_PA12 1
#define IGNORE_PIN_PA13 1
#define IGNORE_PIN_PA14 1
#define IGNORE_PIN_PA15 1
#define IGNORE_PIN_PA16 1
#define IGNORE_PIN_PA17 1
#define IGNORE_PIN_PA18 1
#define IGNORE_PIN_PA19 1
#define IGNORE_PIN_PA20 1
#define IGNORE_PIN_PA21 1
#define IGNORE_PIN_PA22 1
#define IGNORE_PIN_PA23 1
// USB is always used internally so skip the pin objects for it.
#define IGNORE_PIN_PA24 1
#define IGNORE_PIN_PA25 1
#define IGNORE_PIN_PA27 1
#define IGNORE_PIN_PA28 1
#define IGNORE_PIN_PA30 1
#define IGNORE_PIN_PA31 1
#define IGNORE_PIN_PB01 1
#define IGNORE_PIN_PB02 1
#define IGNORE_PIN_PB03 1
#define IGNORE_PIN_PB04 1
#define IGNORE_PIN_PB05 1
#define IGNORE_PIN_PB06 1
#define IGNORE_PIN_PB07 1
#define IGNORE_PIN_PB08 1
#define IGNORE_PIN_PB09 1
#define IGNORE_PIN_PB10 1
#define IGNORE_PIN_PB11 1
#define IGNORE_PIN_PB12 1
#define IGNORE_PIN_PB13 1
#define IGNORE_PIN_PB14 1
#define IGNORE_PIN_PB15 1
#define IGNORE_PIN_PB16 1
#define IGNORE_PIN_PB17 1
#define IGNORE_PIN_PB22 1
#define IGNORE_PIN_PB23 1
#define IGNORE_PIN_PB30 1
#define IGNORE_PIN_PB31 1
#define IGNORE_PIN_PB00 1

#define DEFAULT_I2C_BUS_SCL (&pin_PA09)
#define DEFAULT_I2C_BUS_SDA (&pin_PA08)

#define DEFAULT_SPI_BUS_SCK (&pin_PA07)
#define DEFAULT_SPI_BUS_MOSI (&pin_PA06)
#define DEFAULT_SPI_BUS_MISO (&pin_PA09)

#define DEFAULT_UART_BUS_RX (&pin_PA07)
#define DEFAULT_UART_BUS_TX (&pin_PA06)
# 181 "../../py/circuitpy_mpconfig.h" 2

// CIRCUITPY_FULL_BUILD is defined in a *.mk file.

// Remove some lesser-used functionality to make small builds fit.
#define MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG (CIRCUITPY_FULL_BUILD)
//TODO: replace this with a rework of the FULL_BUILD system

#define MICROPY_CPYTHON_COMPAT (CIRCUITPY_FULL_BUILD)

#define MICROPY_MODULE_WEAK_LINKS (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_ALL_SPECIAL_METHODS (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_BUILTINS_COMPLEX (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_BUILTINS_FROZENSET (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_BUILTINS_STR_CENTER (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_BUILTINS_STR_PARTITION (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_BUILTINS_STR_SPLITLINES (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_UERRNO (CIRCUITPY_FULL_BUILD)
// Opposite setting is deliberate.
#define MICROPY_PY_UERRNO_ERRORCODE (!CIRCUITPY_FULL_BUILD)

#define MICROPY_PY_URE (CIRCUITPY_FULL_BUILD)

#define MICROPY_PY_URE_MATCH_GROUPS (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_URE_MATCH_SPAN_START_END (CIRCUITPY_FULL_BUILD)
#define MICROPY_PY_URE_SUB (CIRCUITPY_FULL_BUILD)

// LONGINT_IMPL_xxx are defined in the Makefile.
//

#define MICROPY_LONGINT_IMPL (MICROPY_LONGINT_IMPL_NONE)
# 227 "../../py/circuitpy_mpconfig.h"
// These CIRCUITPY_xxx values should all be defined in the *.mk files as being on or off.
// So if any are not defined in *.mk, they'll throw an error here.


#define ANALOGIO_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_analogio), (mp_obj_t)&analogio_module },
extern const struct _mp_obj_module_t analogio_module;
# 241 "../../py/circuitpy_mpconfig.h"
#define AUDIOBUSIO_MODULE 






#define AUDIOCORE_MODULE 






#define AUDIOIO_MODULE 






#define AUDIOMIXER_MODULE 






#define AUDIOMP3_MODULE 






#define AUDIOPWMIO_MODULE 






#define BITBANGIO_MODULE 






#define BLEIO_MODULE 



#define BOARD_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_board), (mp_obj_t)&board_module },
extern const struct _mp_obj_module_t board_module;

#define BOARD_I2C (defined(DEFAULT_I2C_BUS_SDA) && defined(DEFAULT_I2C_BUS_SCL))
#define BOARD_SPI (defined(DEFAULT_SPI_BUS_SCK) && defined(DEFAULT_SPI_BUS_MISO) && defined(DEFAULT_SPI_BUS_MOSI))
#define BOARD_UART (defined(DEFAULT_UART_BUS_RX) && defined(DEFAULT_UART_BUS_TX))

// I2C and SPI are always allocated off the heap.


#define BOARD_UART_ROOT_POINTER mp_obj_t shared_uart_bus;
# 315 "../../py/circuitpy_mpconfig.h"
extern const struct _mp_obj_module_t busio_module;
#define BUSIO_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_busio), (mp_obj_t)&busio_module },





extern const struct _mp_obj_module_t digitalio_module;
#define DIGITALIO_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_digitalio), (mp_obj_t)&digitalio_module },
# 339 "../../py/circuitpy_mpconfig.h"
#define DISPLAYIO_MODULE 
#define FONTIO_MODULE 
#define TERMINALIO_MODULE 
#define CIRCUITPY_DISPLAY_LIMIT (0)






#define FREQUENCYIO_MODULE 






#define GAMEPAD_MODULE 






#define GAMEPADSHIFT_MODULE 







#define GAMEPAD_ROOT_POINTERS 






#define I2CSLAVE_MODULE 



extern const struct _mp_obj_module_t math_module;
#define MATH_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_math), (mp_obj_t)&math_module },
# 392 "../../py/circuitpy_mpconfig.h"
#define _EVE_MODULE 



extern const struct _mp_obj_module_t microcontroller_module;
#define MICROCONTROLLER_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_microcontroller), (mp_obj_t)&microcontroller_module },





extern const struct _mp_obj_module_t neopixel_write_module;
#define NEOPIXEL_WRITE_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_neopixel_write),(mp_obj_t)&neopixel_write_module },
# 420 "../../py/circuitpy_mpconfig.h"
#define NETWORK_MODULE 
#define SOCKET_MODULE 
#define WIZNET_MODULE 
#define NETWORK_ROOT_POINTERS 


// This is not a top-level module; it's microcontroller.nvm.

extern const struct _mp_obj_module_t nvm_module;



extern const struct _mp_obj_module_t os_module;
#define OS_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_os), (mp_obj_t)&os_module },
#define OS_MODULE_ALT_NAME { MP_OBJ_NEW_QSTR(MP_QSTR__os), (mp_obj_t)&os_module },
# 444 "../../py/circuitpy_mpconfig.h"
#define PEW_MODULE 






#define PIXELBUF_MODULE 



extern const struct _mp_obj_module_t pulseio_module;
#define PULSEIO_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_pulseio), (mp_obj_t)&pulseio_module },
# 465 "../../py/circuitpy_mpconfig.h"
#define PS2IO_MODULE 



extern const struct _mp_obj_module_t random_module;
#define RANDOM_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_random), (mp_obj_t)&random_module },





extern const struct _mp_obj_module_t rotaryio_module;
#define ROTARYIO_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_rotaryio), (mp_obj_t)&rotaryio_module },





extern const struct _mp_obj_module_t rtc_module;
#define RTC_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_rtc), (mp_obj_t)&rtc_module },
# 493 "../../py/circuitpy_mpconfig.h"
#define SAMD_MODULE 






#define STAGE_MODULE 



extern const struct _mp_obj_module_t storage_module;
#define STORAGE_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_storage), (mp_obj_t)&storage_module },





extern const struct _mp_obj_module_t struct_module;
#define STRUCT_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_struct), (mp_obj_t)&struct_module },





extern const struct _mp_obj_module_t supervisor_module;
#define SUPERVISOR_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_supervisor), (mp_obj_t)&supervisor_module },





extern const struct _mp_obj_module_t time_module;
#define TIME_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_time), (mp_obj_t)&time_module },
#define TIME_MODULE_ALT_NAME { MP_OBJ_NEW_QSTR(MP_QSTR__time), (mp_obj_t)&time_module },






extern const struct _mp_obj_module_t touchio_module;
#define TOUCHIO_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_touchio), (mp_obj_t)&touchio_module },
# 544 "../../py/circuitpy_mpconfig.h"
#define UHEAP_MODULE 



extern const struct _mp_obj_module_t usb_hid_module;
#define USB_HID_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_usb_hid),(mp_obj_t)&usb_hid_module },





extern const struct _mp_obj_module_t usb_midi_module;
#define USB_MIDI_MODULE { MP_OBJ_NEW_QSTR(MP_QSTR_usb_midi),(mp_obj_t)&usb_midi_module },
# 565 "../../py/circuitpy_mpconfig.h"
#define USTACK_MODULE 


// These modules are not yet in shared-bindings, but we prefer the non-uxxx names.



#define ERRNO_MODULE 





#define JSON_MODULE 





#define RE_MODULE 


// Define certain native modules with weak links so they can be replaced with Python
// implementations. This list may grow over time.
#define MICROPY_PORT_BUILTIN_MODULE_WEAK_LINKS OS_MODULE TIME_MODULE



// Native modules that are weak links can be accessed directly
// by prepending their name with an underscore. This list should correspond to
// MICROPY_PORT_BUILTIN_MODULE_WEAK_LINKS, assuming you want the native modules
// to be accessible when overriden.
#define MICROPY_PORT_BUILTIN_MODULE_ALT_NAMES OS_MODULE_ALT_NAME TIME_MODULE_ALT_NAME



// This is an inclusive list that should correspond to the CIRCUITPY_XXX list above,
// including dependencies such as TERMINALIO depending on DISPLAYIO (shown by indentation).
// Some of these definitions will be blank depending on what is turned on and off.
// Some are omitted because they're in MICROPY_PORT_BUILTIN_MODULE_WEAK_LINKS above.
#define MICROPY_PORT_BUILTIN_MODULES_STRONG_LINKS ANALOGIO_MODULE AUDIOBUSIO_MODULE AUDIOCORE_MODULE AUDIOIO_MODULE AUDIOMIXER_MODULE AUDIOMP3_MODULE AUDIOPWMIO_MODULE BITBANGIO_MODULE BLEIO_MODULE BOARD_MODULE BUSIO_MODULE DIGITALIO_MODULE DISPLAYIO_MODULE FONTIO_MODULE TERMINALIO_MODULE ERRNO_MODULE FREQUENCYIO_MODULE GAMEPAD_MODULE GAMEPADSHIFT_MODULE I2CSLAVE_MODULE JSON_MODULE MATH_MODULE _EVE_MODULE MICROCONTROLLER_MODULE NEOPIXEL_WRITE_MODULE NETWORK_MODULE SOCKET_MODULE WIZNET_MODULE PEW_MODULE PIXELBUF_MODULE PS2IO_MODULE PULSEIO_MODULE RANDOM_MODULE RE_MODULE ROTARYIO_MODULE RTC_MODULE SAMD_MODULE STAGE_MODULE STORAGE_MODULE STRUCT_MODULE SUPERVISOR_MODULE TOUCHIO_MODULE UHEAP_MODULE USB_HID_MODULE USB_MIDI_MODULE USTACK_MODULE
# 653 "../../py/circuitpy_mpconfig.h"
// If weak links are enabled, just include strong links in the main list of modules,
// and also include the underscore alternate names.





// If weak links are disabled, included both strong and potentially weak lines
#define MICROPY_PORT_BUILTIN_MODULES MICROPY_PORT_BUILTIN_MODULES_STRONG_LINKS MICROPY_PORT_BUILTIN_MODULE_WEAK_LINKS




// We need to provide a declaration/definition of alloca()
#include <alloca.h>
# 667 "../../py/circuitpy_mpconfig.h"
# 1 "/usr/arm-none-eabi/include/alloca.h" 1 3

# 1 "/usr/arm-none-eabi/include/alloca.h" 3
/* libc/include/alloca.h - Allocate memory on stack */

/* Written 2000 by Werner Almesberger */
/* Rearranged for general inclusion by stdlib.h.
   2001, Corinna Vinschen <vinschen@redhat.com> */


#define _NEWLIB_ALLOCA_H 

#include "_ansi.h"
# 10 "/usr/arm-none-eabi/include/alloca.h" 3
# 1 "/usr/arm-none-eabi/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */


#define _ANSIDECL_H_ 

#include <newlib.h>
# 10 "/usr/arm-none-eabi/include/_ansi.h" 3
# 1 "/usr/arm-none-eabi/include/newlib.h" 1 3
/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */


#define __NEWLIB_H__ 1

/* EL/IX level */
/* #undef _ELIX_LEVEL */

/* Newlib version */
#include <_newlib_version.h>
# 14 "/usr/arm-none-eabi/include/newlib.h" 3
# 1 "/usr/arm-none-eabi/include/_newlib_version.h" 1 3
/* _newlib_version.h.  Generated from _newlib_version.hin by configure.  */
/* Version macros for internal and downstream use. */
# 15 "/usr/arm-none-eabi/include/newlib.h" 2 3

/* C99 formats support (such as %a, %zu, ...) in IO functions like
 * printf/scanf enabled */
/* #undef _WANT_IO_C99_FORMATS */

/* long long type support in IO functions like printf/scanf enabled */
#define _WANT_IO_LONG_LONG 1

/* Register application finalization function using atexit. */
#define _WANT_REGISTER_FINI 1

/* long double type support in IO functions like printf/scanf enabled */
/* #undef _WANT_IO_LONG_DOUBLE */

/* Positional argument support in printf functions enabled.  */
/* #undef _WANT_IO_POS_ARGS */

/* Optional reentrant struct support.  Used mostly on platforms with
   very restricted storage.  */
/* #undef _WANT_REENT_SMALL */

/* Multibyte supported */
/* #undef _MB_CAPABLE */

/* MB_LEN_MAX */
#define _MB_LEN_MAX 1

/* ICONV enabled */
/* #undef _ICONV_ENABLED */

/* Enable ICONV external CCS files loading capabilities */
/* #undef _ICONV_ENABLE_EXTERNAL_CCS */

/* Define if the linker supports .preinit_array/.init_array/.fini_array
 * sections.  */
#define HAVE_INITFINI_ARRAY 1

/* True if atexit() may dynamically allocate space for cleanup
   functions.  */
#define _ATEXIT_DYNAMIC_ALLOC 1

/* True if long double supported.  */
#define _HAVE_LONG_DOUBLE 1

/* Define if compiler supports -fno-tree-loop-distribute-patterns. */
#define _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL 1

/* True if long double supported and it is equal to double.  */
#define _LDBL_EQ_DBL 1

/* Define if ivo supported in streamio.  */
#define _FVWRITE_IN_STREAMIO 1

/* Define if fseek functions support seek optimization.  */
#define _FSEEK_OPTIMIZATION 1

/* Define if wide char orientation is supported.  */
#define _WIDE_ORIENT 1

/* Define if unbuffered stream file optimization is supported.  */
#define _UNBUF_STREAM_OPT 1

/* Define if lite version of exit supported.  */
/* #undef _LITE_EXIT */

/* Define if declare atexit data as global.  */
/* #undef _REENT_GLOBAL_ATEXIT */

/* Define to move the stdio stream FILE objects out of struct _reent and make
   them global.  The stdio stream pointers of struct _reent are initialized to
   point to the global stdio FILE stream objects. */
/* #undef _WANT_REENT_GLOBAL_STDIO_STREAMS */

/* Define if small footprint nano-formatted-IO implementation used.  */
/* #undef _NANO_FORMATTED_IO */

/* Define if using retargetable functions for default lock routines.  */
#define _RETARGETABLE_LOCKING 1

/* Define to use type long for time_t.  */
/* #undef _WANT_USE_LONG_TIME_T */

/*
 * Iconv encodings enabled ("to" direction)
 */
/* #undef _ICONV_TO_ENCODING_BIG5 */
/* #undef _ICONV_TO_ENCODING_CP775 */
/* #undef _ICONV_TO_ENCODING_CP850 */
/* #undef _ICONV_TO_ENCODING_CP852 */
/* #undef _ICONV_TO_ENCODING_CP855 */
/* #undef _ICONV_TO_ENCODING_CP866 */
/* #undef _ICONV_TO_ENCODING_EUC_JP */
/* #undef _ICONV_TO_ENCODING_EUC_TW */
/* #undef _ICONV_TO_ENCODING_EUC_KR */
/* #undef _ICONV_TO_ENCODING_ISO_8859_1 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_10 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_11 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_13 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_14 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_15 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_2 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_3 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_4 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_5 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_6 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_7 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_8 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_9 */
/* #undef _ICONV_TO_ENCODING_ISO_IR_111 */
/* #undef _ICONV_TO_ENCODING_KOI8_R */
/* #undef _ICONV_TO_ENCODING_KOI8_RU */
/* #undef _ICONV_TO_ENCODING_KOI8_U */
/* #undef _ICONV_TO_ENCODING_KOI8_UNI */
/* #undef _ICONV_TO_ENCODING_UCS_2 */
/* #undef _ICONV_TO_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_2BE */
/* #undef _ICONV_TO_ENCODING_UCS_2LE */
/* #undef _ICONV_TO_ENCODING_UCS_4 */
/* #undef _ICONV_TO_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_4BE */
/* #undef _ICONV_TO_ENCODING_UCS_4LE */
/* #undef _ICONV_TO_ENCODING_US_ASCII */
/* #undef _ICONV_TO_ENCODING_UTF_16 */
/* #undef _ICONV_TO_ENCODING_UTF_16BE */
/* #undef _ICONV_TO_ENCODING_UTF_16LE */
/* #undef _ICONV_TO_ENCODING_UTF_8 */
/* #undef _ICONV_TO_ENCODING_WIN_1250 */
/* #undef _ICONV_TO_ENCODING_WIN_1251 */
/* #undef _ICONV_TO_ENCODING_WIN_1252 */
/* #undef _ICONV_TO_ENCODING_WIN_1253 */
/* #undef _ICONV_TO_ENCODING_WIN_1254 */
/* #undef _ICONV_TO_ENCODING_WIN_1255 */
/* #undef _ICONV_TO_ENCODING_WIN_1256 */
/* #undef _ICONV_TO_ENCODING_WIN_1257 */
/* #undef _ICONV_TO_ENCODING_WIN_1258 */

/*
 * Iconv encodings enabled ("from" direction)
 */
/* #undef _ICONV_FROM_ENCODING_BIG5 */
/* #undef _ICONV_FROM_ENCODING_CP775 */
/* #undef _ICONV_FROM_ENCODING_CP850 */
/* #undef _ICONV_FROM_ENCODING_CP852 */
/* #undef _ICONV_FROM_ENCODING_CP855 */
/* #undef _ICONV_FROM_ENCODING_CP866 */
/* #undef _ICONV_FROM_ENCODING_EUC_JP */
/* #undef _ICONV_FROM_ENCODING_EUC_TW */
/* #undef _ICONV_FROM_ENCODING_EUC_KR */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_1 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_10 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_11 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_13 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_14 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_15 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_2 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_3 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_4 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_5 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_6 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_7 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_8 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_9 */
/* #undef _ICONV_FROM_ENCODING_ISO_IR_111 */
/* #undef _ICONV_FROM_ENCODING_KOI8_R */
/* #undef _ICONV_FROM_ENCODING_KOI8_RU */
/* #undef _ICONV_FROM_ENCODING_KOI8_U */
/* #undef _ICONV_FROM_ENCODING_KOI8_UNI */
/* #undef _ICONV_FROM_ENCODING_UCS_2 */
/* #undef _ICONV_FROM_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_2BE */
/* #undef _ICONV_FROM_ENCODING_UCS_2LE */
/* #undef _ICONV_FROM_ENCODING_UCS_4 */
/* #undef _ICONV_FROM_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_4BE */
/* #undef _ICONV_FROM_ENCODING_UCS_4LE */
/* #undef _ICONV_FROM_ENCODING_US_ASCII */
/* #undef _ICONV_FROM_ENCODING_UTF_16 */
/* #undef _ICONV_FROM_ENCODING_UTF_16BE */
/* #undef _ICONV_FROM_ENCODING_UTF_16LE */
/* #undef _ICONV_FROM_ENCODING_UTF_8 */
/* #undef _ICONV_FROM_ENCODING_WIN_1250 */
/* #undef _ICONV_FROM_ENCODING_WIN_1251 */
/* #undef _ICONV_FROM_ENCODING_WIN_1252 */
/* #undef _ICONV_FROM_ENCODING_WIN_1253 */
/* #undef _ICONV_FROM_ENCODING_WIN_1254 */
/* #undef _ICONV_FROM_ENCODING_WIN_1255 */
/* #undef _ICONV_FROM_ENCODING_WIN_1256 */
/* #undef _ICONV_FROM_ENCODING_WIN_1257 */
/* #undef _ICONV_FROM_ENCODING_WIN_1258 */
# 11 "/usr/arm-none-eabi/include/_ansi.h" 2 3
#include <sys/config.h>
# 11 "/usr/arm-none-eabi/include/_ansi.h" 3
# 1 "/usr/arm-none-eabi/include/sys/config.h" 1 3

#define __SYS_CONFIG_H__ 

#include <machine/ieeefp.h> /* floating point macros */
# 4 "/usr/arm-none-eabi/include/sys/config.h" 3
# 1 "/usr/arm-none-eabi/include/machine/ieeefp.h" 1 3



/* This file can define macros to choose variations of the IEEE float
   format:

   _FLT_LARGEST_EXPONENT_IS_NORMAL

	Defined if the float format uses the largest exponent for finite
	numbers rather than NaN and infinity representations.  Such a
	format cannot represent NaNs or infinities at all, but it's FLT_MAX
	is twice the IEEE value.

   _FLT_NO_DENORMALS

	Defined if the float format does not support IEEE denormals.  Every
	float with a zero exponent is taken to be a zero representation.
 
   ??? At the moment, there are no equivalent macros above for doubles and
   the macros are not fully supported by --enable-newlib-hw-fp.

   __IEEE_BIG_ENDIAN

        Defined if the float format is big endian.  This is mutually exclusive
        with __IEEE_LITTLE_ENDIAN.

   __IEEE_LITTLE_ENDIAN
 
        Defined if the float format is little endian.  This is mutually exclusive
        with __IEEE_BIG_ENDIAN.

   Note that one of __IEEE_BIG_ENDIAN or __IEEE_LITTLE_ENDIAN must be specified for a
   platform or error will occur.

   __IEEE_BYTES_LITTLE_ENDIAN

        This flag is used in conjunction with __IEEE_BIG_ENDIAN to describe a situation 
	whereby multiple words of an IEEE floating point are in big endian order, but the
	words themselves are little endian with respect to the bytes.

   _DOUBLE_IS_32BITS 

        This is used on platforms that support double by using the 32-bit IEEE
        float type.

   _FLOAT_ARG

        This represents what type a float arg is passed as.  It is used when the type is
        not promoted to double.
	

   __OBSOLETE_MATH_DEFAULT

	Default value for __OBSOLETE_MATH if that's not set by the user.
	It should be set here based on predefined feature macros.

   __OBSOLETE_MATH

	If set to 1 then some new math code will be disabled and older libm
	code will be used instead.  This is necessary because the new math
	code does not support all targets, it assumes that the toolchain has
	ISO C99 support (hexfloat literals, standard fenv semantics), the
	target has IEEE-754 conforming binary32 float and binary64 double
	(not mixed endian) representation, standard SNaN representation,
	double and single precision arithmetics has similar latency and it
	has no legacy SVID matherr support, only POSIX errno and fenv
	exception based error handling.
*/


/* ARM traditionally used big-endian words; and within those words the
   byte ordering was big or little endian depending upon the target.
   Modern floating-point formats are naturally ordered; in this case
   __VFP_FP__ will be defined, even if soft-float.  */


#define __IEEE_LITTLE_ENDIAN 
# 246 "/usr/arm-none-eabi/include/machine/ieeefp.h" 3
/* necv70 was __IEEE_LITTLE_ENDIAN. */
# 460 "/usr/arm-none-eabi/include/machine/ieeefp.h" 3
/* Use old math code by default.  */
#define __OBSOLETE_MATH_DEFAULT 1


#define __OBSOLETE_MATH __OBSOLETE_MATH_DEFAULT
# 5 "/usr/arm-none-eabi/include/sys/config.h" 2 3
#include <sys/features.h> /* POSIX defs */
# 5 "/usr/arm-none-eabi/include/sys/config.h" 3
# 1 "/usr/arm-none-eabi/include/sys/features.h" 1 3
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
# 6 "/usr/arm-none-eabi/include/sys/config.h" 2 3





/* exceptions first */







/* 16 bit integer machines */
# 115 "/usr/arm-none-eabi/include/sys/config.h" 3
/* For the PowerPC eabi, force the _impure_ptr to be in .sdata */
# 125 "/usr/arm-none-eabi/include/sys/config.h" 3
/* Configure small REENT structure for Xilinx MicroBlaze platforms */
# 192 "/usr/arm-none-eabi/include/sys/config.h" 3
/* This block should be kept in sync with GCC's limits.h.  The point
   of having these definitions here is to not include limits.h, which
   would pollute the user namespace, while still using types of the
   the correct widths when deciding how to define __int32_t and
   __int64_t.  */
# 217 "/usr/arm-none-eabi/include/sys/config.h" 3
/* End of block that should be kept in sync with GCC's limits.h.  */


#define _POINTER_INT long





#undef __RAND_MAX



#define __RAND_MAX 0x7fffffff
# 246 "/usr/arm-none-eabi/include/sys/config.h" 3
#define __EXPORT 



#define __IMPORT 


/* Define return type of read/write routines.  In POSIX, the return type
   for read()/write() is "ssize_t" but legacy newlib code has been using
   "int" for some time.  If not specified, "int" is defaulted.  */

#define _READ_WRITE_RETURN_TYPE int

/* Define `count' parameter of read/write routines.  In POSIX, the `count'
   parameter is "size_t" but legacy newlib code has been using "int" for some
   time.  If not specified, "int" is defaulted.  */

#define _READ_WRITE_BUFSIZE_TYPE int
# 272 "/usr/arm-none-eabi/include/sys/config.h" 3
/* See if small reent asked for at configuration time and
   is not chosen by the platform by default.  */
# 292 "/usr/arm-none-eabi/include/sys/config.h" 3
/* If _MB_EXTENDED_CHARSETS_ALL is set, we want all of the extended
   charsets.  The extended charsets add a few functions and a couple
   of tables of a few K each. */
# 12 "/usr/arm-none-eabi/include/_ansi.h" 2 3

/*  ISO C++.  */
# 31 "/usr/arm-none-eabi/include/_ansi.h" 3
#define _BEGIN_STD_C 
#define _END_STD_C 
#define _NOTHROW 



#define _LONG_DOUBLE long double


/* Support gcc's __attribute__ facility.  */


#define _ATTRIBUTE(attrs) __attribute__ (attrs)




/*  The traditional meaning of 'extern inline' for GCC is not
  to emit the function body unless the address is explicitly
  taken.  However this behaviour is changing to match the C99
  standard, which uses 'extern inline' to indicate that the
  function body *must* be emitted.  Likewise, a function declared
  without either 'extern' or 'static' defaults to extern linkage
  (C99 6.2.2p5), and the compiler may choose whether to use the
  inline version or call the extern linkage version (6.7.4p6).
  If we are using GCC, but do not have the new behaviour, we need
  to use extern inline; if we are using a new GCC with the
  C99-compatible behaviour, or a non-GCC compiler (which we will
  have to hope is C99, since there is no other way to achieve the
  effect of omitting the function if it isn't referenced) we use
  'static inline', which c99 defines to mean more-or-less the same
  as the Gnu C 'extern inline'.  */




/* We're using GCC in C99 mode, or an unknown compiler which
  we just have to hope obeys the C99 semantics of inline.  */
#define _ELIDABLE_INLINE static __inline__



#define _NOINLINE __attribute__ ((__noinline__))
#define _NOINLINE_STATIC _NOINLINE static
# 11 "/usr/arm-none-eabi/include/alloca.h" 2 3
#include <sys/reent.h>
# 11 "/usr/arm-none-eabi/include/alloca.h" 3
# 1 "/usr/arm-none-eabi/include/sys/reent.h" 1 3
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */





#define _SYS_REENT_H_ 

#include <_ansi.h>
# 13 "/usr/arm-none-eabi/include/sys/reent.h" 3
# 1 "/usr/arm-none-eabi/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
# 14 "/usr/arm-none-eabi/include/sys/reent.h" 2 3
#include <stddef.h>
# 14 "/usr/arm-none-eabi/include/sys/reent.h" 3
# 1 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2019 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */



#define _STDDEF_H 
#define _STDDEF_H_ 
/* snaroff@next.com says the NeXT needs this.  */
#define _ANSI_STDDEF_H 



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
# 86 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 111 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 131 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 
#define _PTRDIFF_T_DECLARED 



typedef int ptrdiff_t;
# 154 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 181 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
#define __size_t__ 
#define __SIZE_T__ 
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ 
#define _SIZE_T_DECLARED 
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 






#define __size_t 





typedef unsigned int size_t;
# 231 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 260 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
#define __wchar_t__ 
#define __WCHAR_T__ 
#define _WCHAR_T 
#define _T_WCHAR_ 
#define _T_WCHAR 
#define __WCHAR_T 
#define _WCHAR_T_ 
#define _BSD_WCHAR_T_ 
#define _WCHAR_T_DEFINED_ 
#define _WCHAR_T_DEFINED 
#define _WCHAR_T_H 
#define ___int_wchar_t_h 
#define __INT_WCHAR_T_H 
#define _GCC_WCHAR_T 
#define _WCHAR_T_DECLARED 

/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */

#undef _BSD_WCHAR_T_
# 303 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 321 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 340 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
#undef __need_wchar_t
# 387 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)




#define _GCC_MAX_ALIGN_T 
/* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  */
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
  /* _Float128 is defined as a basic type, so max_align_t must be
     sufficiently aligned for it.  This code must work in C++, so we
     use __float128 here; that is only available on some
     architectures, but only on i386 is extra alignment needed for
     __float128.  */



} max_align_t;
# 15 "/usr/arm-none-eabi/include/sys/reent.h" 2 3
#include <sys/_types.h>
# 15 "/usr/arm-none-eabi/include/sys/reent.h" 3
# 1 "/usr/arm-none-eabi/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/


#define _SYS__TYPES_H 

#include <newlib.h>
# 22 "/usr/arm-none-eabi/include/sys/_types.h" 3
# 1 "/usr/arm-none-eabi/include/newlib.h" 1 3
/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */
# 23 "/usr/arm-none-eabi/include/sys/_types.h" 2 3
#include <sys/config.h>
#include <machine/_types.h>
# 24 "/usr/arm-none-eabi/include/sys/_types.h" 3
# 1 "/usr/arm-none-eabi/include/machine/_types.h" 1 3
/*
 *  $Id$
 */


#define _MACHINE__TYPES_H 
#include <machine/_default_types.h>
# 7 "/usr/arm-none-eabi/include/machine/_types.h" 3
# 1 "/usr/arm-none-eabi/include/machine/_default_types.h" 1 3
/*
 *  $Id$
 */
# 8 "/usr/arm-none-eabi/include/machine/_types.h" 2 3
# 25 "/usr/arm-none-eabi/include/sys/_types.h" 2 3
#include <sys/lock.h>
# 25 "/usr/arm-none-eabi/include/sys/_types.h" 3
# 1 "/usr/arm-none-eabi/include/sys/lock.h" 1 3

#define __SYS_LOCK_H__ 

/* dummy lock routines for single-threaded aps */

#include <newlib.h>
# 6 "/usr/arm-none-eabi/include/sys/lock.h" 3
# 1 "/usr/arm-none-eabi/include/newlib.h" 1 3
/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */
# 7 "/usr/arm-none-eabi/include/sys/lock.h" 2 3
#include <_ansi.h>
# 7 "/usr/arm-none-eabi/include/sys/lock.h" 3
# 1 "/usr/arm-none-eabi/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
# 8 "/usr/arm-none-eabi/include/sys/lock.h" 2 3
# 33 "/usr/arm-none-eabi/include/sys/lock.h" 3
struct __lock;
typedef struct __lock * _LOCK_T;
#define _LOCK_RECURSIVE_T _LOCK_T

#define __LOCK_INIT(class,lock) extern struct __lock __lock_ ## lock; class _LOCK_T lock = &__lock_ ## lock

#define __LOCK_INIT_RECURSIVE(class,lock) __LOCK_INIT(class,lock)

extern void __retarget_lock_init(_LOCK_T *lock);
#define __lock_init(lock) __retarget_lock_init(&lock)
extern void __retarget_lock_init_recursive(_LOCK_T *lock);
#define __lock_init_recursive(lock) __retarget_lock_init_recursive(&lock)
extern void __retarget_lock_close(_LOCK_T lock);
#define __lock_close(lock) __retarget_lock_close(lock)
extern void __retarget_lock_close_recursive(_LOCK_T lock);
#define __lock_close_recursive(lock) __retarget_lock_close_recursive(lock)
extern void __retarget_lock_acquire(_LOCK_T lock);
#define __lock_acquire(lock) __retarget_lock_acquire(lock)
extern void __retarget_lock_acquire_recursive(_LOCK_T lock);
#define __lock_acquire_recursive(lock) __retarget_lock_acquire_recursive(lock)
extern int __retarget_lock_try_acquire(_LOCK_T lock);
#define __lock_try_acquire(lock) __retarget_lock_try_acquire(lock)
extern int __retarget_lock_try_acquire_recursive(_LOCK_T lock);
#define __lock_try_acquire_recursive(lock) __retarget_lock_try_acquire_recursive(lock)

extern void __retarget_lock_release(_LOCK_T lock);
#define __lock_release(lock) __retarget_lock_release(lock)
extern void __retarget_lock_release_recursive(_LOCK_T lock);
#define __lock_release_recursive(lock) __retarget_lock_release_recursive(lock)
# 26 "/usr/arm-none-eabi/include/sys/_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;



typedef long _off_t;





typedef int __pid_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;







typedef unsigned short __ino_t;
# 88 "/usr/arm-none-eabi/include/sys/_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;


/*
 * We need fpos_t for the following, but it doesn't have a leading "_",
 * so we use _fpos_t instead.
 */

typedef long _fpos_t; /* XXX must match off_t in <sys/types.h> */
    /* (and must be `long' for now) */
# 124 "/usr/arm-none-eabi/include/sys/_types.h" 3
/* Defined by GCC provided <stddef.h> */
#undef __size_t



typedef unsigned int __size_t;
# 141 "/usr/arm-none-eabi/include/sys/_types.h" 3
/* If __SIZE_TYPE__ is defined (gcc) we define ssize_t based on size_t.
   We simply change "unsigned" to "signed" for this single definition
   to make sure ssize_t and size_t only differ by their signedness. */
#define unsigned signed
typedef signed int _ssize_t;
#undef unsigned
# 156 "/usr/arm-none-eabi/include/sys/_types.h" 3
typedef _ssize_t __ssize_t;

#define __need_wint_t 
#include <stddef.h>
# 159 "/usr/arm-none-eabi/include/sys/_types.h" 3
# 1 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2019 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */
# 86 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 111 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 154 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 231 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 340 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
#undef __need_wchar_t




#define _WINT_T 




typedef unsigned int wint_t;

#undef __need_wint_t
# 387 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 160 "/usr/arm-none-eabi/include/sys/_types.h" 2 3


/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value; /* Value so far.  */
} _mbstate_t;



typedef _LOCK_T _flock_t;



/* Iconv descriptor type */
typedef void *_iconv_t;



#define _CLOCK_T_ unsigned long


typedef unsigned long __clock_t;




#define _TIME_T_ __int_least64_t

typedef __int_least64_t __time_t;


#define _CLOCKID_T_ unsigned long


typedef unsigned long __clockid_t;

#define _TIMER_T_ unsigned long
typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef int __nl_item;
typedef unsigned short __nlink_t;
typedef long __suseconds_t; /* microseconds (signed) */
typedef unsigned long __useconds_t; /* microseconds (unsigned) */




typedef char * __va_list;
# 16 "/usr/arm-none-eabi/include/sys/reent.h" 2 3

#define _NULL 0



#define __Long long
typedef unsigned long __ULong;
# 38 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct _reent;

struct __locale_t;

/*
 * If _REENT_SMALL is defined, we make struct _reent as small as possible,
 * by having nearly everything possible allocated at first use.
 */

struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};

/* needed by reentrant structure */
struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};

/*
 * atexit() support.
 */

#define _ATEXIT_SIZE 32

struct _on_exit_args {
 void * _fnargs[32]; /* user fn args */
 void * _dso_handle[32];
 /* Bitmask is set if user function takes arguments.  */
 __ULong _fntypes; /* type of exit routine -
				   Must have at least _ATEXIT_SIZE bits */
 /* Bitmask is set if function was registered via __cxa_atexit.  */
 __ULong _is_cxa;
};
# 93 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next; /* next in list */
 int _ind; /* next index in this table */
 /* Some entries may already have been called, and will be NULL.  */
 void (*_fns[32])(void); /* the table itself */
        struct _on_exit_args _on_exit_args;
};
#define _ATEXIT_INIT {_NULL, 0, {_NULL}, {{_NULL}, {_NULL}, 0, 0}}





#define _REENT_INIT_ATEXIT _NULL, _ATEXIT_INIT,



/*
 * Stdio buffers.
 *
 * This and __FILE are defined here because we need them for struct _reent,
 * but we don't want stdio.h included when stdlib.h is.
 */

struct __sbuf {
 unsigned char *_base;
 int _size;
};

/*
 * Stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 */
# 178 "/usr/arm-none-eabi/include/sys/reent.h" 3
#define _REENT_SMALL_CHECK_INIT(ptr) 


struct __sFILE {
  unsigned char *_p; /* current position in (some) buffer */
  int _r; /* read space left for getc() */
  int _w; /* write space left for putc() */
  short _flags; /* flags, below; this FILE is free if 0 */
  short _file; /* fileno, if Unix descriptor, else -1 */
  struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
  int _lbfsize; /* 0 or -_bf._size, for inline putc */





  /* operations */
  void * _cookie; /* cookie passed to io functions */

  int (*_read) (struct _reent *, void *,
        char *, int);
  int (*_write) (struct _reent *, void *,
         const char *,
         int);
  _fpos_t (*_seek) (struct _reent *, void *, _fpos_t, int);
  int (*_close) (struct _reent *, void *);

  /* separate buffer for long sequences of ungetc() */
  struct __sbuf _ub; /* ungetc buffer */
  unsigned char *_up; /* saved _p when _p is doing ungetc data */
  int _ur; /* saved _r when _r is counting ungetc data */

  /* tricks to meet minimum requirements even when malloc() fails */
  unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */
  unsigned char _nbuf[1]; /* guarantee a getc() buffer */

  /* separate buffer for fgetline() when line crosses buffer boundary */
  struct __sbuf _lb; /* buffer for fgetline() */

  /* Unix stdio files get aligned to block boundaries on fseek() */
  int _blksize; /* stat.st_blksize (may be != _bf._size) */
  _off_t _offset; /* current lseek offset */


  struct _reent *_data; /* Here for binary compatibility? Remove? */



  _flock_t _lock; /* for thread-safety locking */

  _mbstate_t _mbstate; /* for wide char stdio functions. */
  int _flags2; /* for future use */
};
# 287 "/usr/arm-none-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};

/*
 * rand48 family support
 *
 * Copyright (c) 1993 Martin Birgmeier
 * All rights reserved.
 *
 * You may redistribute unmodified or modified versions of this source
 * code provided that the above copyright notice and this and the
 * following conditions are retained.
 *
 * This software is provided ``as is'', and comes with no warranties
 * of any kind. I shall in no event be liable for anything that happens
 * to anyone/anything when using this software.
 */
#define _RAND48_SEED_0 (0x330e)
#define _RAND48_SEED_1 (0xabcd)
#define _RAND48_SEED_2 (0x1234)
#define _RAND48_MULT_0 (0xe66d)
#define _RAND48_MULT_1 (0xdeec)
#define _RAND48_MULT_2 (0x0005)
#define _RAND48_ADD (0x000b)
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};

/* How big the some arrays are.  */
#define _REENT_EMERGENCY_SIZE 25
#define _REENT_ASCTIME_SIZE 26
#define _REENT_SIGNAL_SIZE 24

/*
 * struct _reent
 *
 * This structure contains *all* globals needed by the library.
 * It's raison d'etre is to facilitate threads by making all library routines
 * reentrant.  IE: All state information is contained here.
 */
# 608 "/usr/arm-none-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno; /* local copy of errno */

  /* FILE is a big struct and may change over time.  To try to achieve binary
     compatibility with future versions, put stdin,stdout,stderr here.
     These are pointers into member __sf defined below.  */
  __FILE *_stdin, *_stdout, *_stderr;

  int _inc; /* used by tmpnam */
  char _emergency[25];

  /* TODO */
  int _unspecified_locale_info; /* unused, reserved for locale stuff */
  struct __locale_t *_locale;/* per-thread locale */

  int __sdidinit; /* 1 means stdio has been init'd */

  void (*__cleanup) (struct _reent *);

  /* used by mprec routines */
  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;

  /* used by some fp conversion routines */
  int _cvtlen; /* should be size_t */
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;
  /* Two next two fields were once used by malloc.  They are no longer
     used. They are used to preserve the space used before so as to
     allow addition of new reent fields and keep binary compatibility.   */
      struct
        {
#define _N_LISTS 30
          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  /* atexit stuff */
  struct _atexit *_atexit; /* points to head of LIFO stack */
  struct _atexit _atexit0; /* one guaranteed table, required by ANSI */


  /* signal info */
  void (**(_sig_func))(int);

  /* These are here last so that __FILE can grow without changing the offsets
     of the above members (on the off chance that future binary compatibility
     would be broken otherwise).  */
  struct _glue __sglue; /* root of glue chain */

  __FILE __sf[3]; /* first three file descriptors */

};





#define _REENT_STDIO_STREAM(var,index) &(var)->__sf[index]


#define _REENT_INIT(var) { 0, _REENT_STDIO_STREAM(&(var), 0), _REENT_STDIO_STREAM(&(var), 1), _REENT_STDIO_STREAM(&(var), 2), 0, "", 0, _NULL, 0, _NULL, _NULL, 0, _NULL, _NULL, 0, _NULL, { { 0, _NULL, "", {0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 1, { {_RAND48_SEED_0, _RAND48_SEED_1, _RAND48_SEED_2}, {_RAND48_MULT_0, _RAND48_MULT_1, _RAND48_MULT_2}, _RAND48_ADD }, {0, {0}}, {0, {0}}, {0, {0}}, "", "", 0, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}} } }, _REENT_INIT_ATEXIT _NULL, {_NULL, 0, _NULL} }
# 746 "/usr/arm-none-eabi/include/sys/reent.h" 3
#define _REENT_INIT_PTR_ZEROED(var) { (var)->_stdin = _REENT_STDIO_STREAM(var, 0); (var)->_stdout = _REENT_STDIO_STREAM(var, 1); (var)->_stderr = _REENT_STDIO_STREAM(var, 2); (var)->_new._reent._rand_next = 1; (var)->_new._reent._r48._seed[0] = _RAND48_SEED_0; (var)->_new._reent._r48._seed[1] = _RAND48_SEED_1; (var)->_new._reent._r48._seed[2] = _RAND48_SEED_2; (var)->_new._reent._r48._mult[0] = _RAND48_MULT_0; (var)->_new._reent._r48._mult[1] = _RAND48_MULT_1; (var)->_new._reent._r48._mult[2] = _RAND48_MULT_2; (var)->_new._reent._r48._add = _RAND48_ADD; }
# 760 "/usr/arm-none-eabi/include/sys/reent.h" 3
#define _REENT_CHECK_RAND48(ptr) 
#define _REENT_CHECK_MP(ptr) 
#define _REENT_CHECK_TM(ptr) 
#define _REENT_CHECK_ASCTIME_BUF(ptr) 
#define _REENT_CHECK_EMERGENCY(ptr) 
#define _REENT_CHECK_MISC(ptr) 
#define _REENT_CHECK_SIGNAL_BUF(ptr) 

#define _REENT_SIGNGAM(ptr) ((ptr)->_new._reent._gamma_signgam)
#define _REENT_RAND_NEXT(ptr) ((ptr)->_new._reent._rand_next)
#define _REENT_RAND48_SEED(ptr) ((ptr)->_new._reent._r48._seed)
#define _REENT_RAND48_MULT(ptr) ((ptr)->_new._reent._r48._mult)
#define _REENT_RAND48_ADD(ptr) ((ptr)->_new._reent._r48._add)
#define _REENT_MP_RESULT(ptr) ((ptr)->_result)
#define _REENT_MP_RESULT_K(ptr) ((ptr)->_result_k)
#define _REENT_MP_P5S(ptr) ((ptr)->_p5s)
#define _REENT_MP_FREELIST(ptr) ((ptr)->_freelist)
#define _REENT_ASCTIME_BUF(ptr) ((ptr)->_new._reent._asctime_buf)
#define _REENT_TM(ptr) (&(ptr)->_new._reent._localtime_buf)
#define _REENT_EMERGENCY(ptr) ((ptr)->_emergency)
#define _REENT_STRTOK_LAST(ptr) ((ptr)->_new._reent._strtok_last)
#define _REENT_MBLEN_STATE(ptr) ((ptr)->_new._reent._mblen_state)
#define _REENT_MBTOWC_STATE(ptr) ((ptr)->_new._reent._mbtowc_state)
#define _REENT_WCTOMB_STATE(ptr) ((ptr)->_new._reent._wctomb_state)
#define _REENT_MBRLEN_STATE(ptr) ((ptr)->_new._reent._mbrlen_state)
#define _REENT_MBRTOWC_STATE(ptr) ((ptr)->_new._reent._mbrtowc_state)
#define _REENT_MBSRTOWCS_STATE(ptr) ((ptr)->_new._reent._mbsrtowcs_state)
#define _REENT_WCRTOMB_STATE(ptr) ((ptr)->_new._reent._wcrtomb_state)
#define _REENT_WCSRTOMBS_STATE(ptr) ((ptr)->_new._reent._wcsrtombs_state)
#define _REENT_L64A_BUF(ptr) ((ptr)->_new._reent._l64a_buf)
#define _REENT_SIGNAL_BUF(ptr) ((ptr)->_new._reent._signal_buf)
#define _REENT_GETDATE_ERR_P(ptr) (&((ptr)->_new._reent._getdate_err))



#define _REENT_INIT_PTR(var) { memset((var), 0, sizeof(*(var))); _REENT_INIT_PTR_ZEROED(var); }




/* This value is used in stdlib/misc.c.  reent/reent.c has to know it
   as well to make sure the freelist is correctly free'd.  Therefore
   we define it here, rather than in stdlib/misc.c, as before. */
#define _Kmax (sizeof (size_t) << 3)

/*
 * All references to struct _reent are via this pointer.
 * Internally, newlib routines that need to reference it should use _REENT.
 */


#define __ATTRIBUTE_IMPURE_PTR__ 


extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);

/* #define _REENT_ONLY define this to get only reentrant routines */







#define _REENT _impure_ptr


#define _GLOBAL_REENT _global_impure_ptr





#define _GLOBAL_ATEXIT (_GLOBAL_REENT->_atexit)
# 12 "/usr/arm-none-eabi/include/alloca.h" 2 3

#undef alloca


#define alloca(size) __builtin_alloca(size)
# 668 "../../py/circuitpy_mpconfig.h" 2

#define MP_STATE_PORT MP_STATE_VM

#include "supervisor/flash_root_pointers.h"
# 671 "../../py/circuitpy_mpconfig.h"
# 1 "../../supervisor/flash_root_pointers.h" 1

# 1 "../../supervisor/flash_root_pointers.h"
/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Scott Shawcroft for Adafruit Industries LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#define MICROPY_INCLUDED_SUPERVISOR_FLASH_ROOT_POINTERS_H 




#include "supervisor/internal_flash_root_pointers.h"
# 32 "../../supervisor/flash_root_pointers.h"
# 1 "./supervisor/internal_flash_root_pointers.h" 1
/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Scott Shawcroft for Adafruit Industries LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#define MICROPY_INCLUDED_ATMEL_SAMD_INTERNAL_FLASH_ROOT_POINTERS_H 

#define FLASH_ROOT_POINTERS 
# 33 "../../supervisor/flash_root_pointers.h" 2
# 672 "../../py/circuitpy_mpconfig.h" 2

#define CIRCUITPY_COMMON_ROOT_POINTERS const char *readline_hist[8]; vstr_t *repl_line; mp_obj_t rtc_time_source; GAMEPAD_ROOT_POINTERS mp_obj_t pew_singleton; mp_obj_t terminal_tilegrid_tiles; BOARD_UART_ROOT_POINTER FLASH_ROOT_POINTERS NETWORK_ROOT_POINTERS
# 684 "../../py/circuitpy_mpconfig.h"
void supervisor_run_background_tasks_if_tick(void);
#define RUN_BACKGROUND_TASKS (supervisor_run_background_tasks_if_tick())

// TODO: Used in wiznet5k driver, but may not be needed in the long run.
#define MICROPY_THREAD_YIELD() 

#define MICROPY_VM_HOOK_LOOP RUN_BACKGROUND_TASKS;
#define MICROPY_VM_HOOK_RETURN RUN_BACKGROUND_TASKS;

// CIRCUITPY_AUTORELOAD_DELAY_MS = 0 will completely disable autoreload.

#define CIRCUITPY_AUTORELOAD_DELAY_MS 500



#define CIRCUITPY_FILESYSTEM_FLUSH_INTERVAL_MS 1000


#define CIRCUITPY_BOOT_OUTPUT_FILE "/boot_out.txt"

#define CIRCUITPY_VERBOSE_BLE 0
# 91 "mpconfigport.h" 2

// Definitions that can be overridden by mpconfigboard.h:

////////////////////////////////////////////////////////////////////////////////////////////////////




#define CIRCUITPY_INTERNAL_FLASH_FILESYSTEM_SIZE (64*1024)





#define CIRCUITPY_INTERNAL_NVM_SIZE (256)



#define CIRCUITPY_DEFAULT_STACK_SIZE 4096


// Smallest unit of flash that can be erased.
#define FLASH_ERASE_SIZE NVMCTRL_ROW_SIZE



////////////////////////////////////////////////////////////////////////////////////////////////////
# 143 "mpconfigport.h"
////////////////////////////////////////////////////////////////////////////////////////////////////


#define CALIBRATE_CRYSTALLESS (0)



#define BOARD_HAS_CRYSTAL (0)


// if CALIBRATE_CRYSTALLESS is requested, make room for storing
// calibration data generated from external USB.




#define CIRCUITPY_INTERNAL_CONFIG_SIZE (0)



// Flash layout, starting at 0x00000000
//
// - bootloader (8 or 16kB)
// - firmware
// - internal CIRCUITPY flash filesystem (optional)
// - internal config, used to store crystalless clock calibration info (optional)
// - microntroller.nvm (optional)

// Define these regions starting up from the bottom of flash:

#define BOOTLOADER_START_ADDR (0x00000000)

#define CIRCUITPY_FIRMWARE_START_ADDR (BOOTLOADER_START_ADDR + BOOTLOADER_SIZE)

// Define these regions start down from the top of flash:

#define CIRCUITPY_INTERNAL_NVM_START_ADDR (FLASH_SIZE - CIRCUITPY_INTERNAL_NVM_SIZE)


#define CIRCUITPY_INTERNAL_CONFIG_START_ADDR (CIRCUITPY_INTERNAL_NVM_START_ADDR - CIRCUITPY_INTERNAL_CONFIG_SIZE)


#define CIRCUITPY_INTERNAL_FLASH_FILESYSTEM_START_ADDR (CIRCUITPY_INTERNAL_CONFIG_START_ADDR - CIRCUITPY_INTERNAL_FLASH_FILESYSTEM_SIZE)


// The firmware space is the space left over between the fixed lower and upper regions.
#define CIRCUITPY_FIRMWARE_SIZE (CIRCUITPY_INTERNAL_FLASH_FILESYSTEM_START_ADDR - CIRCUITPY_FIRMWARE_START_ADDR)
# 221 "mpconfigport.h"
// Turning off audioio, audiobusio, and touchio as necessary
// due to limitations of chips is handled in mpconfigboard.mk

#include "peripherals/samd/dma.h"
# 224 "mpconfigport.h"
# 1 "peripherals/samd/dma.h" 1
/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 Scott Shawcroft for Adafruit Industries
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#define MICROPY_INCLUDED_ATMEL_SAMD_PERIPHERALS_DMA_H 

#include <stdbool.h>
# 30 "peripherals/samd/dma.h"
# 1 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdbool.h" 1 3 4

# 1 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdbool.h" 3 4
/* Copyright (C) 1998-2019 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */


#define _STDBOOL_H 



#define bool _Bool
#define true 1
#define false 0
# 51 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stdbool.h" 3 4
/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined 1
# 31 "peripherals/samd/dma.h" 2
#include <stdint.h>

#include "include/sam.h"
# 33 "peripherals/samd/dma.h"
# 1 "asf4/samd21/include/sam.h" 1

# 1 "asf4/samd21/include/sam.h"
/**
 * \file
 *
 * \brief Top level header file
 *
 * Copyright (c) 2017 Atmel Corporation, a wholly owned subsidiary of Microchip Technology Inc.
 *
 * \license_start
 *
 * \page License
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \license_stop
 *
 */
# 34 "peripherals/samd/dma.h" 2

// We allocate DMA resources for the entire lifecycle of the board (not the
// vm) because the general_dma resource will be shared between the REPL and SPI
// flash. Both uses must block each other in order to prevent conflict.
#define AUDIO_DMA_CHANNEL_COUNT 3
#define DMA_CHANNEL_COUNT (AUDIO_DMA_CHANNEL_COUNT + 2)
#define SHARED_TX_CHANNEL (DMA_CHANNEL_COUNT - 2)
#define SHARED_RX_CHANNEL (DMA_CHANNEL_COUNT - 1)

volatile 
# 43 "peripherals/samd/dma.h" 3 4
        _Bool 
# 43 "peripherals/samd/dma.h"
             audio_dma_in_use;

void init_shared_dma(void);






uint8_t sercom_index(Sercom* sercom);

int32_t sercom_dma_write(Sercom* sercom, const uint8_t* buffer, uint32_t length);
int32_t sercom_dma_read(Sercom* sercom, uint8_t* buffer, uint32_t length, uint8_t tx);
int32_t sercom_dma_transfer(Sercom* sercom, const uint8_t* buffer_out, uint8_t* buffer_in, uint32_t length);

void dma_configure(uint8_t channel_number, uint8_t trigsrc, 
# 58 "peripherals/samd/dma.h" 3 4
                                                           _Bool 
# 58 "peripherals/samd/dma.h"
                                                                output_event);
void dma_enable_channel(uint8_t channel_number);
void dma_disable_channel(uint8_t channel_number);
void dma_suspend_channel(uint8_t channel_number);
void dma_resume_channel(uint8_t channel_number);

# 63 "peripherals/samd/dma.h" 3 4
_Bool 
# 63 "peripherals/samd/dma.h"
    dma_channel_free(uint8_t channel_number);

# 64 "peripherals/samd/dma.h" 3 4
_Bool 
# 64 "peripherals/samd/dma.h"
    dma_channel_enabled(uint8_t channel_number);
uint8_t dma_transfer_status(uint8_t channel_number);
DmacDescriptor* dma_descriptor(uint8_t channel_number);
# 225 "mpconfigport.h" 2

#define MICROPY_PORT_ROOT_POINTERS CIRCUITPY_COMMON_ROOT_POINTERS mp_obj_t playing_audio[AUDIO_DMA_CHANNEL_COUNT];
# 3 "ld_defines.c" 2

// For each value needed in the LD file, create a C-like line:
// /*NAME_OF_VALUE=*/ NAME_OF_VALUE;
// The C preprocessor will replace NAME_OF_VALUE with the actual value.
// This will be post-processed by tools/gen_ld_files.py to extract the name and value.

// The next line is a marker to start looking for definitions. Lines above the next line are ignored.
// START_LD_DEFINES

/*RAM_SIZE=*/ 0x00008000UL;
/*FLASH_SIZE=*/ 0x00040000UL;

/*BOOTLOADER_SIZE=*/ (8*1024);
/*BOOTLOADER_START_ADDR=*/ (0x00000000);

/*CIRCUITPY_DEFAULT_STACK_SIZE=*/ 4096;

/*CIRCUITPY_FIRMWARE_START_ADDR=*/ ((0x00000000) + (8*1024));
/*CIRCUITPY_FIRMWARE_SIZE=*/ ((((0x00040000UL - (256)) - (0)) - (64*1024)) - ((0x00000000) + (8*1024)));

/*CIRCUITPY_INTERNAL_CONFIG_START_ADDR=*/ ((0x00040000UL - (256)) - (0));
/*CIRCUITPY_INTERNAL_CONFIG_SIZE=*/ (0);

/*CIRCUITPY_INTERNAL_NVM_START_ADDR=*/ (0x00040000UL - (256));
/*CIRCUITPY_INTERNAL_NVM_SIZE=*/ (256);

/*CIRCUITPY_INTERNAL_FLASH_FILESYSTEM_START_ADDR=*/ (((0x00040000UL - (256)) - (0)) - (64*1024));
/*CIRCUITPY_INTERNAL_FLASH_FILESYSTEM_SIZE=*/ (64*1024);
