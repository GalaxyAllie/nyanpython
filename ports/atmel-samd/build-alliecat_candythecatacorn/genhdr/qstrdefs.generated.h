// 101 e 1360 000 0
// 32   1322 0010 2
// 97 a 722 0011 3
// 105 i 787 0100 4
// 110 n 865 0101 5
// 111 o 877 0110 6
// 114 r 822 0111 7
// 115 s 718 1000 8
// 116 t 1124 1001 9
// 99 c 425 10100 20
// 100 d 456 10101 21
// 108 l 477 10110 22
// 112 p 353 10111 23
// 117 u 472 11000 24
// 95 _ 295 110010 50
// 98 b 226 110011 51
// 102 f 251 110100 52
// 103 g 199 110101 53
// 104 h 173 110110 54
// 109 m 332 110111 55
// 121 y 172 111000 56
// 39 \' 105 1110010 114
// 118 v 116 1110011 115
// 119 w 92 1110100 116
// 37 % 72 11101010 234
// 46 . 63 11101011 235
// 65 A 56 11101100 236
// 69 E 64 11101101 237
// 73 I 48 11101110 238
// 80 P 54 11101111 239
// 107 k 62 11110000 240
// 113 q 48 11110001 241
// 120 x 82 11110010 242
// 10 \n 28 111100110 486
// 13 \r 27 111100111 487
// 40 ( 28 111101000 488
// 41 ) 28 111101001 489
// 45 - 28 111101010 490
// 47 / 25 111101011 491
// 48 0 29 111101100 492
// 67 C 37 111101101 493
// 68 D 25 111101110 494
// 78 N 39 111101111 495
// 79 O 33 111110000 496
// 82 R 33 111110001 497
// 83 S 38 111110010 498
// 84 T 31 111110011 499
// 85 U 22 111110100 500
// 106 j 38 111110101 501
// 44 , 13 1111101100 1004
// 49 1 19 1111101101 1005
// 50 2 18 1111101110 1006
// 51 3 11 1111101111 1007
// 53 5 16 1111110000 1008
// 58 : 13 1111110001 1009
// 66 B 14 1111110010 1010
// 70 F 11 1111110011 1011
// 76 L 20 1111110100 1012
// 77 M 20 1111110101 1013
// 87 W 11 1111110110 1014
// 122 z 15 1111110111 1015
// 42 * 9 11111110000 2032
// 54 6 10 11111110001 2033
// 56 8 7 11111110010 2034
// 60 < 9 11111110011 2035
// 62 > 10 11111110100 2036
// 71 G 5 11111110101 2037
// 72 H 5 11111110110 2038
// 75 K 7 11111110111 2039
// 86 V 7 11111111000 2040
// 88 X 8 11111111001 2041
// 89 Y 5 11111111010 2042
// 33 ! 4 111111110110 4086
// 34 \" 4 111111110111 4087
// 35 # 4 111111111000 4088
// 52 4 5 111111111001 4089
// 55 7 3 111111111010 4090
// 57 9 4 111111111011 4091
// 61 = 4 111111111100 4092
// 96 ` 4 111111111101 4093
// 43 + 1 1111111111100 8188
// 123 { 2 1111111111101 8189
// 125 } 2 1111111111110 8190
// 59 ; 1 11111111111110 16382
// 90 Z 1 11111111111111 16383
// length count {3: 1, 4: 8, 5: 5, 6: 7, 7: 3, 8: 9, 9: 16, 10: 12, 11: 11, 12: 8, 13: 3, 14: 2}
// values ['e', ' ', 'a', 'i', 'n', 'o', 'r', 's', 't', 'c', 'd', 'l', 'p', 'u', '_', 'b', 'f', 'g', 'h', 'm', 'y', "'", 'v', 'w', '%', '.', 'A', 'E', 'I', 'P', 'k', 'q', 'x', '\n', '\r', '(', ')', '-', '/', '0', 'C', 'D', 'N', 'O', 'R', 'S', 'T', 'U', 'j', ',', '1', '2', '3', '5', ':', 'B', 'F', 'L', 'M', 'W', 'z', '*', '6', '8', '<', '>', 'G', 'H', 'K', 'V', 'X', 'Y', '!', '"', '#', '4', '7', '9', '=', '`', '+', '{', '}', ';', 'Z'] lengths 15 bytearray(b'\x00\x00\x01\x08\x05\x07\x03\t\x10\x0c\x0b\x08\x03\x02\x00')
// estimated total memory size 68189
// ['e', ' ', 'a', 'i', 'n', 'o', 'r', 's', 't', 'c', 'd', 'l', 'p', 'u', '_', 'b', 'f', 'g', 'h', 'm', 'y', "'", 'v', 'w', '%', '.', 'A', 'E', 'I', 'P', 'k', 'q', 'x', '\n', '\r', '(', ')', '-', '/', '0', 'C', 'D', 'N', 'O', 'R', 'S', 'T', 'U', 'j', ',', '1', '2', '3', '5', ':', 'B', 'F', 'L', 'M', 'W', 'z', '*', '6', '8', '<', '>', 'G', 'H', 'K', 'V', 'X', 'Y', '!', '"', '#', '4', '7', '9', '=', '`', '+', '{', '}', ';', 'Z'] bytearray(b'\x00\x00\x01\x08\x05\x07\x03\t\x10\x0c\x0b\x08\x03\x02\x00')
// This file was automatically generated by makeqstrdata.py

QDEF(MP_QSTR_NULL, (const byte*)"\x00\x00" "")
QDEF(MP_QSTR_, (const byte*)"\x05\x00" "")
QDEF(MP_QSTR___add__, (const byte*)"\xc4\x07" "__add__")
QDEF(MP_QSTR___bool__, (const byte*)"\x2b\x08" "__bool__")
QDEF(MP_QSTR___build_class__, (const byte*)"\x42\x0f" "__build_class__")
QDEF(MP_QSTR___bytes__, (const byte*)"\xdc\x09" "__bytes__")
QDEF(MP_QSTR___call__, (const byte*)"\xa7\x08" "__call__")
QDEF(MP_QSTR___class__, (const byte*)"\x2b\x09" "__class__")
QDEF(MP_QSTR___contains__, (const byte*)"\xc6\x0c" "__contains__")
QDEF(MP_QSTR___del__, (const byte*)"\x68\x07" "__del__")
QDEF(MP_QSTR___delete__, (const byte*)"\xdc\x0a" "__delete__")
QDEF(MP_QSTR___delitem__, (const byte*)"\xfd\x0b" "__delitem__")
QDEF(MP_QSTR___enter__, (const byte*)"\x6d\x09" "__enter__")
QDEF(MP_QSTR___eq__, (const byte*)"\x71\x06" "__eq__")
QDEF(MP_QSTR___exit__, (const byte*)"\x45\x08" "__exit__")
QDEF(MP_QSTR___file__, (const byte*)"\x03\x08" "__file__")
QDEF(MP_QSTR___ge__, (const byte*)"\xa7\x06" "__ge__")
QDEF(MP_QSTR___get__, (const byte*)"\xb3\x07" "__get__")
QDEF(MP_QSTR___getattr__, (const byte*)"\x40\x0b" "__getattr__")
QDEF(MP_QSTR___getitem__, (const byte*)"\x26\x0b" "__getitem__")
QDEF(MP_QSTR___gt__, (const byte*)"\xb6\x06" "__gt__")
QDEF(MP_QSTR___hash__, (const byte*)"\xf7\x08" "__hash__")
QDEF(MP_QSTR___iadd__, (const byte*)"\x6d\x08" "__iadd__")
QDEF(MP_QSTR___import__, (const byte*)"\x38\x0a" "__import__")
QDEF(MP_QSTR___init__, (const byte*)"\x5f\x08" "__init__")
QDEF(MP_QSTR___isub__, (const byte*)"\x08\x08" "__isub__")
QDEF(MP_QSTR___iter__, (const byte*)"\xcf\x08" "__iter__")
QDEF(MP_QSTR___le__, (const byte*)"\xcc\x06" "__le__")
QDEF(MP_QSTR___len__, (const byte*)"\xe2\x07" "__len__")
QDEF(MP_QSTR___lt__, (const byte*)"\x5d\x06" "__lt__")
QDEF(MP_QSTR___main__, (const byte*)"\x8e\x08" "__main__")
QDEF(MP_QSTR___module__, (const byte*)"\xff\x0a" "__module__")
QDEF(MP_QSTR___name__, (const byte*)"\xe2\x08" "__name__")
QDEF(MP_QSTR___new__, (const byte*)"\x79\x07" "__new__")
QDEF(MP_QSTR___next__, (const byte*)"\x02\x08" "__next__")
QDEF(MP_QSTR___path__, (const byte*)"\xc8\x08" "__path__")
QDEF(MP_QSTR___qualname__, (const byte*)"\x6b\x0c" "__qualname__")
QDEF(MP_QSTR___repl_print__, (const byte*)"\x01\x0e" "__repl_print__")
QDEF(MP_QSTR___repr__, (const byte*)"\x10\x08" "__repr__")
QDEF(MP_QSTR___reversed__, (const byte*)"\x61\x0c" "__reversed__")
QDEF(MP_QSTR___set__, (const byte*)"\xa7\x07" "__set__")
QDEF(MP_QSTR___setitem__, (const byte*)"\x32\x0b" "__setitem__")
QDEF(MP_QSTR___str__, (const byte*)"\xd0\x07" "__str__")
QDEF(MP_QSTR___sub__, (const byte*)"\x21\x07" "__sub__")
QDEF(MP_QSTR___traceback__, (const byte*)"\x4f\x0d" "__traceback__")
QDEF(MP_QSTR__star_, (const byte*)"\x8f\x01" "*")
QDEF(MP_QSTR__, (const byte*)"\xfa\x01" "_")
QDEF(MP_QSTR__slash_, (const byte*)"\x8a\x01" "/")
QDEF(MP_QSTR__percent__hash_o, (const byte*)"\x6c\x03" "%#o")
QDEF(MP_QSTR__percent__hash_x, (const byte*)"\x7b\x03" "%#x")
QDEF(MP_QSTR__brace_open__colon__hash_b_brace_close_, (const byte*)"\x58\x05" "{:#b}")
QDEF(MP_QSTR__space_, (const byte*)"\x85\x01" " ")
QDEF(MP_QSTR__0x0a_, (const byte*)"\xaf\x01" "\x0a")
QDEF(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded, (const byte*)"\x73\x20" "maximum recursion depth exceeded")
QDEF(MP_QSTR__lt_module_gt_, (const byte*)"\xbd\x08" "<module>")
QDEF(MP_QSTR__lt_lambda_gt_, (const byte*)"\x80\x08" "<lambda>")
QDEF(MP_QSTR__lt_listcomp_gt_, (const byte*)"\xd4\x0a" "<listcomp>")
QDEF(MP_QSTR__lt_dictcomp_gt_, (const byte*)"\xcc\x0a" "<dictcomp>")
QDEF(MP_QSTR__lt_setcomp_gt_, (const byte*)"\x54\x09" "<setcomp>")
QDEF(MP_QSTR__lt_genexpr_gt_, (const byte*)"\x34\x09" "<genexpr>")
QDEF(MP_QSTR__lt_string_gt_, (const byte*)"\x52\x08" "<string>")
QDEF(MP_QSTR__lt_stdin_gt_, (const byte*)"\xe3\x07" "<stdin>")
QDEF(MP_QSTR_utf_hyphen_8, (const byte*)"\xb7\x05" "utf-8")
QDEF(MP_QSTR__dot_frozen, (const byte*)"\x81\x07" ".frozen")
QDEF(MP_QSTR__slash_lib, (const byte*)"\x8d\x04" "/lib")
QDEF(MP_QSTR_A0, (const byte*)"\x54\x02" "A0")
QDEF(MP_QSTR_A1, (const byte*)"\x55\x02" "A1")
QDEF(MP_QSTR_A2, (const byte*)"\x56\x02" "A2")
QDEF(MP_QSTR_A3, (const byte*)"\x57\x02" "A3")
QDEF(MP_QSTR_A4, (const byte*)"\x50\x02" "A4")
QDEF(MP_QSTR_APA102_MOSI, (const byte*)"\x21\x0b" "APA102_MOSI")
QDEF(MP_QSTR_APA102_SCK, (const byte*)"\x62\x0a" "APA102_SCK")
QDEF(MP_QSTR_AnalogIn, (const byte*)"\xc8\x08" "AnalogIn")
QDEF(MP_QSTR_AnalogOut, (const byte*)"\x41\x09" "AnalogOut")
QDEF(MP_QSTR_ArithmeticError, (const byte*)"\x2d\x0f" "ArithmeticError")
QDEF(MP_QSTR_AssertionError, (const byte*)"\x97\x0e" "AssertionError")
QDEF(MP_QSTR_AttributeError, (const byte*)"\x21\x0e" "AttributeError")
QDEF(MP_QSTR_BOOTLOADER, (const byte*)"\xe2\x0a" "BOOTLOADER")
QDEF(MP_QSTR_BaseException, (const byte*)"\x07\x0d" "BaseException")
QDEF(MP_QSTR_ByteArray, (const byte*)"\x76\x09" "ByteArray")
QDEF(MP_QSTR_Clock, (const byte*)"\x4d\x05" "Clock")
QDEF(MP_QSTR_D0, (const byte*)"\x31\x02" "D0")
QDEF(MP_QSTR_D1, (const byte*)"\x30\x02" "D1")
QDEF(MP_QSTR_D13, (const byte*)"\x03\x03" "D13")
QDEF(MP_QSTR_D2, (const byte*)"\x33\x02" "D2")
QDEF(MP_QSTR_D3, (const byte*)"\x32\x02" "D3")
QDEF(MP_QSTR_D4, (const byte*)"\x35\x02" "D4")
QDEF(MP_QSTR_DOWN, (const byte*)"\x37\x04" "DOWN")
QDEF(MP_QSTR_Device, (const byte*)"\x1d\x06" "Device")
QDEF(MP_QSTR_DigitalInOut, (const byte*)"\xf6\x0c" "DigitalInOut")
QDEF(MP_QSTR_Direction, (const byte*)"\x40\x09" "Direction")
QDEF(MP_QSTR_DriveMode, (const byte*)"\xaa\x09" "DriveMode")
QDEF(MP_QSTR_EACCES, (const byte*)"\x37\x06" "EACCES")
QDEF(MP_QSTR_EAGAIN, (const byte*)"\x20\x06" "EAGAIN")
QDEF(MP_QSTR_EAR_L, (const byte*)"\x60\x05" "EAR_L")
QDEF(MP_QSTR_EAR_R, (const byte*)"\x7e\x05" "EAR_R")
QDEF(MP_QSTR_EEXIST, (const byte*)"\x53\x06" "EEXIST")
QDEF(MP_QSTR_EINVAL, (const byte*)"\x5c\x06" "EINVAL")
QDEF(MP_QSTR_EIO, (const byte*)"\x86\x03" "EIO")
QDEF(MP_QSTR_EISDIR, (const byte*)"\xa5\x06" "EISDIR")
QDEF(MP_QSTR_ENODEV, (const byte*)"\xb6\x06" "ENODEV")
QDEF(MP_QSTR_ENOENT, (const byte*)"\x5e\x06" "ENOENT")
QDEF(MP_QSTR_ENOMEM, (const byte*)"\xa4\x06" "ENOMEM")
QDEF(MP_QSTR_EOFError, (const byte*)"\x91\x08" "EOFError")
QDEF(MP_QSTR_EPERM, (const byte*)"\xea\x05" "EPERM")
QDEF(MP_QSTR_EVEN, (const byte*)"\xdd\x04" "EVEN")
QDEF(MP_QSTR_EYE_CORNERS, (const byte*)"\x17\x0b" "EYE_CORNERS")
QDEF(MP_QSTR_Ellipsis, (const byte*)"\xf0\x08" "Ellipsis")
QDEF(MP_QSTR_Exception, (const byte*)"\xf2\x09" "Exception")
QDEF(MP_QSTR_FileIO, (const byte*)"\xc5\x06" "FileIO")
QDEF(MP_QSTR_Flash, (const byte*)"\x95\x05" "Flash")
QDEF(MP_QSTR_GeneratorExit, (const byte*)"\x16\x0d" "GeneratorExit")
QDEF(MP_QSTR_I2C, (const byte*)"\x5d\x03" "I2C")
QDEF(MP_QSTR_INPUT, (const byte*)"\x53\x05" "INPUT")
QDEF(MP_QSTR_ImportError, (const byte*)"\x20\x0b" "ImportError")
QDEF(MP_QSTR_IncrementalEncoder, (const byte*)"\x5d\x12" "IncrementalEncoder")
QDEF(MP_QSTR_IndentationError, (const byte*)"\x5c\x10" "IndentationError")
QDEF(MP_QSTR_IndexError, (const byte*)"\x83\x0a" "IndexError")
QDEF(MP_QSTR_KeyError, (const byte*)"\xea\x08" "KeyError")
QDEF(MP_QSTR_KeyboardInterrupt, (const byte*)"\xaf\x11" "KeyboardInterrupt")
QDEF(MP_QSTR_LookupError, (const byte*)"\xff\x0b" "LookupError")
QDEF(MP_QSTR_MISO, (const byte*)"\x9d\x04" "MISO")
QDEF(MP_QSTR_MOSI, (const byte*)"\x1d\x04" "MOSI")
QDEF(MP_QSTR_MemoryError, (const byte*)"\xdc\x0b" "MemoryError")
QDEF(MP_QSTR_MpyError, (const byte*)"\x39\x08" "MpyError")
QDEF(MP_QSTR_NORMAL, (const byte*)"\xf6\x06" "NORMAL")
QDEF(MP_QSTR_NameError, (const byte*)"\xba\x09" "NameError")
QDEF(MP_QSTR_NoneType, (const byte*)"\x17\x08" "NoneType")
QDEF(MP_QSTR_NotImplementedError, (const byte*)"\xc6\x13" "NotImplementedError")
QDEF(MP_QSTR_ODD, (const byte*)"\x6a\x03" "ODD")
QDEF(MP_QSTR_OPEN_DRAIN, (const byte*)"\x5e\x0a" "OPEN_DRAIN")
QDEF(MP_QSTR_OSC32K, (const byte*)"\x90\x06" "OSC32K")
QDEF(MP_QSTR_OSError, (const byte*)"\xa1\x07" "OSError")
QDEF(MP_QSTR_OUTPUT, (const byte*)"\xda\x06" "OUTPUT")
QDEF(MP_QSTR_OneWire, (const byte*)"\x68\x07" "OneWire")
QDEF(MP_QSTR_OverflowError, (const byte*)"\x81\x0d" "OverflowError")
QDEF(MP_QSTR_PA00, (const byte*)"\xd4\x04" "PA00")
QDEF(MP_QSTR_PA01, (const byte*)"\xd5\x04" "PA01")
QDEF(MP_QSTR_PA02, (const byte*)"\xd6\x04" "PA02")
QDEF(MP_QSTR_PA05, (const byte*)"\xd1\x04" "PA05")
QDEF(MP_QSTR_PA06, (const byte*)"\xd2\x04" "PA06")
QDEF(MP_QSTR_PA07, (const byte*)"\xd3\x04" "PA07")
QDEF(MP_QSTR_PA08, (const byte*)"\xdc\x04" "PA08")
QDEF(MP_QSTR_PA09, (const byte*)"\xdd\x04" "PA09")
QDEF(MP_QSTR_PA10, (const byte*)"\x35\x04" "PA10")
QDEF(MP_QSTR_PAWS, (const byte*)"\x30\x04" "PAWS")
QDEF(MP_QSTR_PUSH_PULL, (const byte*)"\x81\x09" "PUSH_PULL")
QDEF(MP_QSTR_PWMOut, (const byte*)"\xc1\x06" "PWMOut")
QDEF(MP_QSTR_Parity, (const byte*)"\x22\x06" "Parity")
QDEF(MP_QSTR_Pin, (const byte*)"\x12\x03" "Pin")
QDEF(MP_QSTR_PortIn, (const byte*)"\xfb\x06" "PortIn")
QDEF(MP_QSTR_PortOut, (const byte*)"\x92\x07" "PortOut")
QDEF(MP_QSTR_Processor, (const byte*)"\x13\x09" "Processor")
QDEF(MP_QSTR_Pull, (const byte*)"\x60\x04" "Pull")
QDEF(MP_QSTR_PulseIn, (const byte*)"\xfd\x07" "PulseIn")
QDEF(MP_QSTR_PulseOut, (const byte*)"\xd4\x08" "PulseOut")
QDEF(MP_QSTR_RTC, (const byte*)"\xa0\x03" "RTC")
QDEF(MP_QSTR_RX, (const byte*)"\x8f\x02" "RX")
QDEF(MP_QSTR_ReloadException, (const byte*)"\x03\x0f" "ReloadException")
QDEF(MP_QSTR_RunMode, (const byte*)"\x8f\x07" "RunMode")
QDEF(MP_QSTR_Runtime, (const byte*)"\xb9\x07" "Runtime")
QDEF(MP_QSTR_RuntimeError, (const byte*)"\x61\x0c" "RuntimeError")
QDEF(MP_QSTR_SAFE_MODE, (const byte*)"\x08\x09" "SAFE_MODE")
QDEF(MP_QSTR_SCK, (const byte*)"\xde\x03" "SCK")
QDEF(MP_QSTR_SCL, (const byte*)"\xd9\x03" "SCL")
QDEF(MP_QSTR_SDA, (const byte*)"\x73\x03" "SDA")
QDEF(MP_QSTR_SPI, (const byte*)"\xef\x03" "SPI")
QDEF(MP_QSTR_StopIteration, (const byte*)"\xea\x0d" "StopIteration")
QDEF(MP_QSTR_SyntaxError, (const byte*)"\x94\x0b" "SyntaxError")
QDEF(MP_QSTR_SystemExit, (const byte*)"\x20\x0a" "SystemExit")
QDEF(MP_QSTR_TAIL1, (const byte*)"\x24\x05" "TAIL1")
QDEF(MP_QSTR_TAIL2, (const byte*)"\x27\x05" "TAIL2")
QDEF(MP_QSTR_TX, (const byte*)"\x49\x02" "TX")
QDEF(MP_QSTR_TextIOWrapper, (const byte*)"\xad\x0d" "TextIOWrapper")
QDEF(MP_QSTR_TimeoutError, (const byte*)"\x66\x0c" "TimeoutError")
QDEF(MP_QSTR_TouchIn, (const byte*)"\x67\x07" "TouchIn")
QDEF(MP_QSTR_TypeError, (const byte*)"\x25\x09" "TypeError")
QDEF(MP_QSTR_UART, (const byte*)"\xb7\x04" "UART")
QDEF(MP_QSTR_UP, (const byte*)"\xa0\x02" "UP")
QDEF(MP_QSTR_UnicodeError, (const byte*)"\x22\x0c" "UnicodeError")
QDEF(MP_QSTR_ValueError, (const byte*)"\x96\x0a" "ValueError")
QDEF(MP_QSTR_VfsFat, (const byte*)"\x15\x06" "VfsFat")
QDEF(MP_QSTR_XOSC32K, (const byte*)"\xe8\x07" "XOSC32K")
QDEF(MP_QSTR_ZeroDivisionError, (const byte*)"\xb6\x11" "ZeroDivisionError")
QDEF(MP_QSTR_abs, (const byte*)"\x95\x03" "abs")
QDEF(MP_QSTR_acos, (const byte*)"\x1b\x04" "acos")
QDEF(MP_QSTR_add, (const byte*)"\x44\x03" "add")
QDEF(MP_QSTR_address, (const byte*)"\x73\x07" "address")
QDEF(MP_QSTR_all, (const byte*)"\x44\x03" "all")
QDEF(MP_QSTR_analogio, (const byte*)"\x09\x08" "analogio")
QDEF(MP_QSTR_any, (const byte*)"\x13\x03" "any")
QDEF(MP_QSTR_append, (const byte*)"\x6b\x06" "append")
QDEF(MP_QSTR_args, (const byte*)"\xc2\x04" "args")
QDEF(MP_QSTR_argv, (const byte*)"\xc7\x04" "argv")
QDEF(MP_QSTR_array, (const byte*)"\x7c\x05" "array")
QDEF(MP_QSTR_asin, (const byte*)"\x50\x04" "asin")
QDEF(MP_QSTR_atan, (const byte*)"\x1f\x04" "atan")
QDEF(MP_QSTR_atan2, (const byte*)"\xcd\x05" "atan2")
QDEF(MP_QSTR_baudrate, (const byte*)"\xf5\x08" "baudrate")
QDEF(MP_QSTR_bin, (const byte*)"\xe0\x03" "bin")
QDEF(MP_QSTR_bits, (const byte*)"\x49\x04" "bits")
QDEF(MP_QSTR_board, (const byte*)"\x7f\x05" "board")
QDEF(MP_QSTR_bool, (const byte*)"\xeb\x04" "bool")
QDEF(MP_QSTR_bound_method, (const byte*)"\x97\x0c" "bound_method")
QDEF(MP_QSTR_buffer, (const byte*)"\xe5\x06" "buffer")
QDEF(MP_QSTR_buffer_in, (const byte*)"\xbd\x09" "buffer_in")
QDEF(MP_QSTR_buffer_out, (const byte*)"\x14\x0a" "buffer_out")
QDEF(MP_QSTR_buffering, (const byte*)"\x25\x09" "buffering")
QDEF(MP_QSTR_builtins, (const byte*)"\xf7\x08" "builtins")
QDEF(MP_QSTR_busio, (const byte*)"\x87\x05" "busio")
QDEF(MP_QSTR_bytearray, (const byte*)"\x76\x09" "bytearray")
QDEF(MP_QSTR_bytecode, (const byte*)"\x22\x08" "bytecode")
QDEF(MP_QSTR_byteorder, (const byte*)"\x61\x09" "byteorder")
QDEF(MP_QSTR_bytes, (const byte*)"\x5c\x05" "bytes")
QDEF(MP_QSTR_calcsize, (const byte*)"\x4d\x08" "calcsize")
QDEF(MP_QSTR_calibration, (const byte*)"\xaf\x0b" "calibration")
QDEF(MP_QSTR_callable, (const byte*)"\x0d\x08" "callable")
QDEF(MP_QSTR_ceil, (const byte*)"\x06\x04" "ceil")
QDEF(MP_QSTR_chdir, (const byte*)"\xb1\x05" "chdir")
QDEF(MP_QSTR_choice, (const byte*)"\x2e\x06" "choice")
QDEF(MP_QSTR_chr, (const byte*)"\xdc\x03" "chr")
QDEF(MP_QSTR_circuitpython, (const byte*)"\x02\x0d" "circuitpython")
QDEF(MP_QSTR_classmethod, (const byte*)"\xb4\x0b" "classmethod")
QDEF(MP_QSTR_clear, (const byte*)"\x7c\x05" "clear")
QDEF(MP_QSTR_clock, (const byte*)"\x2d\x05" "clock")
QDEF(MP_QSTR_close, (const byte*)"\x33\x05" "close")
QDEF(MP_QSTR_closure, (const byte*)"\x74\x07" "closure")
QDEF(MP_QSTR_collect, (const byte*)"\x9b\x07" "collect")
QDEF(MP_QSTR_collections, (const byte*)"\xe0\x0b" "collections")
QDEF(MP_QSTR_configure, (const byte*)"\x8d\x09" "configure")
QDEF(MP_QSTR_const, (const byte*)"\xc0\x05" "const")
QDEF(MP_QSTR_copy, (const byte*)"\xe0\x04" "copy")
QDEF(MP_QSTR_copysign, (const byte*)"\x33\x08" "copysign")
QDEF(MP_QSTR_cos, (const byte*)"\x7a\x03" "cos")
QDEF(MP_QSTR_count, (const byte*)"\xa6\x05" "count")
QDEF(MP_QSTR_cpu, (const byte*)"\xc3\x03" "cpu")
QDEF(MP_QSTR_cts, (const byte*)"\x41\x03" "cts")
QDEF(MP_QSTR_datetime, (const byte*)"\xe4\x08" "datetime")
QDEF(MP_QSTR_default, (const byte*)"\xce\x07" "default")
QDEF(MP_QSTR_degrees, (const byte*)"\x02\x07" "degrees")
QDEF(MP_QSTR_deinit, (const byte*)"\x9e\x06" "deinit")
QDEF(MP_QSTR_delay_us, (const byte*)"\xa9\x08" "delay_us")
QDEF(MP_QSTR_deleter, (const byte*)"\x6e\x07" "deleter")
QDEF(MP_QSTR_devices, (const byte*)"\xae\x07" "devices")
QDEF(MP_QSTR_dict, (const byte*)"\x3f\x04" "dict")
QDEF(MP_QSTR_dict_view, (const byte*)"\x2d\x09" "dict_view")
QDEF(MP_QSTR_difference, (const byte*)"\x72\x0a" "difference")
QDEF(MP_QSTR_difference_update, (const byte*)"\x9c\x11" "difference_update")
QDEF(MP_QSTR_digitalio, (const byte*)"\x19\x09" "digitalio")
QDEF(MP_QSTR_dir, (const byte*)"\xfa\x03" "dir")
QDEF(MP_QSTR_direction, (const byte*)"\x20\x09" "direction")
QDEF(MP_QSTR_disable, (const byte*)"\x91\x07" "disable")
QDEF(MP_QSTR_disable_autoreload, (const byte*)"\xb0\x12" "disable_autoreload")
QDEF(MP_QSTR_disable_concurrent_write_protection, (const byte*)"\x3b\x23" "disable_concurrent_write_protection")
QDEF(MP_QSTR_disable_interrupts, (const byte*)"\xfa\x12" "disable_interrupts")
QDEF(MP_QSTR_discard, (const byte*)"\x0f\x07" "discard")
QDEF(MP_QSTR_divmod, (const byte*)"\xb8\x06" "divmod")
QDEF(MP_QSTR_doc, (const byte*)"\x2d\x03" "doc")
QDEF(MP_QSTR_drive_mode, (const byte*)"\x15\x0a" "drive_mode")
QDEF(MP_QSTR_duty_cycle, (const byte*)"\xf6\x0a" "duty_cycle")
QDEF(MP_QSTR_e, (const byte*)"\xc0\x01" "e")
QDEF(MP_QSTR_enable, (const byte*)"\x04\x06" "enable")
QDEF(MP_QSTR_enable_autoreload, (const byte*)"\x85\x11" "enable_autoreload")
QDEF(MP_QSTR_enable_interrupts, (const byte*)"\x4f\x11" "enable_interrupts")
QDEF(MP_QSTR_enabled, (const byte*)"\xe0\x07" "enabled")
QDEF(MP_QSTR_encoding, (const byte*)"\x06\x08" "encoding")
QDEF(MP_QSTR_end, (const byte*)"\x0a\x03" "end")
QDEF(MP_QSTR_endswith, (const byte*)"\x1b\x08" "endswith")
QDEF(MP_QSTR_enumerate, (const byte*)"\x71\x09" "enumerate")
QDEF(MP_QSTR_erase_filesystem, (const byte*)"\x79\x10" "erase_filesystem")
QDEF(MP_QSTR_eval, (const byte*)"\x9b\x04" "eval")
QDEF(MP_QSTR_exec, (const byte*)"\x1e\x04" "exec")
QDEF(MP_QSTR_exit, (const byte*)"\x85\x04" "exit")
QDEF(MP_QSTR_exp, (const byte*)"\xc8\x03" "exp")
QDEF(MP_QSTR_extend, (const byte*)"\x63\x06" "extend")
QDEF(MP_QSTR_fabs, (const byte*)"\x93\x04" "fabs")
QDEF(MP_QSTR_file, (const byte*)"\xc3\x04" "file")
QDEF(MP_QSTR_filter, (const byte*)"\x25\x06" "filter")
QDEF(MP_QSTR_find, (const byte*)"\x01\x04" "find")
QDEF(MP_QSTR_float, (const byte*)"\x35\x05" "float")
QDEF(MP_QSTR_floor, (const byte*)"\x7d\x05" "floor")
QDEF(MP_QSTR_flush, (const byte*)"\x61\x05" "flush")
QDEF(MP_QSTR_fmod, (const byte*)"\xe5\x04" "fmod")
QDEF(MP_QSTR_format, (const byte*)"\x26\x06" "format")
QDEF(MP_QSTR_frequency, (const byte*)"\xa1\x09" "frequency")
QDEF(MP_QSTR_frexp, (const byte*)"\x1c\x05" "frexp")
QDEF(MP_QSTR_from_bytes, (const byte*)"\x35\x0a" "from_bytes")
QDEF(MP_QSTR_fromkeys, (const byte*)"\x37\x08" "fromkeys")
QDEF(MP_QSTR_function, (const byte*)"\x27\x08" "function")
QDEF(MP_QSTR_gc, (const byte*)"\x61\x02" "gc")
QDEF(MP_QSTR_generator, (const byte*)"\x96\x09" "generator")
QDEF(MP_QSTR_get, (const byte*)"\x33\x03" "get")
QDEF(MP_QSTR_getattr, (const byte*)"\xc0\x07" "getattr")
QDEF(MP_QSTR_getcwd, (const byte*)"\x03\x06" "getcwd")
QDEF(MP_QSTR_getmount, (const byte*)"\xde\x08" "getmount")
QDEF(MP_QSTR_getrandbits, (const byte*)"\x66\x0b" "getrandbits")
QDEF(MP_QSTR_getter, (const byte*)"\x90\x06" "getter")
QDEF(MP_QSTR_globals, (const byte*)"\x9d\x07" "globals")
QDEF(MP_QSTR_hasattr, (const byte*)"\x8c\x07" "hasattr")
QDEF(MP_QSTR_hash, (const byte*)"\xb7\x04" "hash")
QDEF(MP_QSTR_heap_lock, (const byte*)"\xad\x09" "heap_lock")
QDEF(MP_QSTR_heap_unlock, (const byte*)"\x56\x0b" "heap_unlock")
QDEF(MP_QSTR_help, (const byte*)"\x94\x04" "help")
QDEF(MP_QSTR_hex, (const byte*)"\x70\x03" "hex")
QDEF(MP_QSTR_id, (const byte*)"\x28\x02" "id")
QDEF(MP_QSTR_idle_state, (const byte*)"\x29\x0a" "idle_state")
QDEF(MP_QSTR_ilistdir, (const byte*)"\x71\x08" "ilistdir")
QDEF(MP_QSTR_implementation, (const byte*)"\x17\x0e" "implementation")
QDEF(MP_QSTR_in_buffer, (const byte*)"\x1d\x09" "in_buffer")
QDEF(MP_QSTR_in_end, (const byte*)"\xf2\x06" "in_end")
QDEF(MP_QSTR_in_start, (const byte*)"\x7d\x08" "in_start")
QDEF(MP_QSTR_in_waiting, (const byte*)"\xd6\x0a" "in_waiting")
QDEF(MP_QSTR_index, (const byte*)"\x7b\x05" "index")
QDEF(MP_QSTR_indices, (const byte*)"\x5a\x07" "indices")
QDEF(MP_QSTR_input, (const byte*)"\x73\x05" "input")
QDEF(MP_QSTR_insert, (const byte*)"\x12\x06" "insert")
QDEF(MP_QSTR_int, (const byte*)"\x16\x03" "int")
QDEF(MP_QSTR_intersection, (const byte*)"\x28\x0c" "intersection")
QDEF(MP_QSTR_intersection_update, (const byte*)"\x06\x13" "intersection_update")
QDEF(MP_QSTR_ioctl, (const byte*)"\x78\x05" "ioctl")
QDEF(MP_QSTR_isalpha, (const byte*)"\xeb\x07" "isalpha")
QDEF(MP_QSTR_isdigit, (const byte*)"\xa8\x07" "isdigit")
QDEF(MP_QSTR_isdisjoint, (const byte*)"\xf7\x0a" "isdisjoint")
QDEF(MP_QSTR_isenabled, (const byte*)"\x9a\x09" "isenabled")
QDEF(MP_QSTR_isfinite, (const byte*)"\xa6\x08" "isfinite")
QDEF(MP_QSTR_isinf, (const byte*)"\x3e\x05" "isinf")
QDEF(MP_QSTR_isinstance, (const byte*)"\xb6\x0a" "isinstance")
QDEF(MP_QSTR_islower, (const byte*)"\xfc\x07" "islower")
QDEF(MP_QSTR_isnan, (const byte*)"\x9e\x05" "isnan")
QDEF(MP_QSTR_isspace, (const byte*)"\x5b\x07" "isspace")
QDEF(MP_QSTR_issubclass, (const byte*)"\xb5\x0a" "issubclass")
QDEF(MP_QSTR_issubset, (const byte*)"\xb9\x08" "issubset")
QDEF(MP_QSTR_issuperset, (const byte*)"\xfc\x0a" "issuperset")
QDEF(MP_QSTR_isupper, (const byte*)"\xdd\x07" "isupper")
QDEF(MP_QSTR_items, (const byte*)"\xe3\x05" "items")
QDEF(MP_QSTR_iter, (const byte*)"\x8f\x04" "iter")
QDEF(MP_QSTR_iterator, (const byte*)"\x47\x08" "iterator")
QDEF(MP_QSTR_join, (const byte*)"\xa7\x04" "join")
QDEF(MP_QSTR_kbd_intr, (const byte*)"\xf6\x08" "kbd_intr")
QDEF(MP_QSTR_key, (const byte*)"\x32\x03" "key")
QDEF(MP_QSTR_keys, (const byte*)"\x01\x04" "keys")
QDEF(MP_QSTR_label, (const byte*)"\x43\x05" "label")
QDEF(MP_QSTR_ldexp, (const byte*)"\x40\x05" "ldexp")
QDEF(MP_QSTR_len, (const byte*)"\x62\x03" "len")
QDEF(MP_QSTR_length, (const byte*)"\x59\x06" "length")
QDEF(MP_QSTR_list, (const byte*)"\x27\x04" "list")
QDEF(MP_QSTR_listdir, (const byte*)"\x98\x07" "listdir")
QDEF(MP_QSTR_little, (const byte*)"\x89\x06" "little")
QDEF(MP_QSTR_locals, (const byte*)"\x3b\x06" "locals")
QDEF(MP_QSTR_log, (const byte*)"\x21\x03" "log")
QDEF(MP_QSTR_lower, (const byte*)"\xc6\x05" "lower")
QDEF(MP_QSTR_lstrip, (const byte*)"\xe5\x06" "lstrip")
QDEF(MP_QSTR_machine, (const byte*)"\x60\x07" "machine")
QDEF(MP_QSTR_map, (const byte*)"\xb9\x03" "map")
QDEF(MP_QSTR_math, (const byte*)"\x35\x04" "math")
QDEF(MP_QSTR_max, (const byte*)"\xb1\x03" "max")
QDEF(MP_QSTR_maxlen, (const byte*)"\x56\x06" "maxlen")
QDEF(MP_QSTR_maxsize, (const byte*)"\xd4\x07" "maxsize")
QDEF(MP_QSTR_mem_alloc, (const byte*)"\x52\x09" "mem_alloc")
QDEF(MP_QSTR_mem_free, (const byte*)"\xcb\x08" "mem_free")
QDEF(MP_QSTR_memoryview, (const byte*)"\x69\x0a" "memoryview")
QDEF(MP_QSTR_microcontroller, (const byte*)"\xa3\x0f" "microcontroller")
QDEF(MP_QSTR_micropython, (const byte*)"\x0b\x0b" "micropython")
QDEF(MP_QSTR_min, (const byte*)"\xaf\x03" "min")
QDEF(MP_QSTR_mkdir, (const byte*)"\x9c\x05" "mkdir")
QDEF(MP_QSTR_mkfs, (const byte*)"\x76\x04" "mkfs")
QDEF(MP_QSTR_mode, (const byte*)"\x26\x04" "mode")
QDEF(MP_QSTR_modf, (const byte*)"\x25\x04" "modf")
QDEF(MP_QSTR_module, (const byte*)"\xbf\x06" "module")
QDEF(MP_QSTR_modules, (const byte*)"\xec\x07" "modules")
QDEF(MP_QSTR_monotonic, (const byte*)"\x19\x09" "monotonic")
QDEF(MP_QSTR_mount, (const byte*)"\xa8\x05" "mount")
QDEF(MP_QSTR_name, (const byte*)"\xa2\x04" "name")
QDEF(MP_QSTR_namedtuple, (const byte*)"\x1e\x0a" "namedtuple")
QDEF(MP_QSTR_native, (const byte*)"\x84\x06" "native")
QDEF(MP_QSTR_neopixel_write, (const byte*)"\x2b\x0e" "neopixel_write")
QDEF(MP_QSTR_next, (const byte*)"\x42\x04" "next")
QDEF(MP_QSTR_nodename, (const byte*)"\x62\x08" "nodename")
QDEF(MP_QSTR_nvm, (const byte*)"\x90\x03" "nvm")
QDEF(MP_QSTR_object, (const byte*)"\x90\x06" "object")
QDEF(MP_QSTR_oct, (const byte*)"\xfd\x03" "oct")
QDEF(MP_QSTR_offset, (const byte*)"\x48\x06" "offset")
QDEF(MP_QSTR_on_next_reset, (const byte*)"\xb6\x0d" "on_next_reset")
QDEF(MP_QSTR_open, (const byte*)"\xd1\x04" "open")
QDEF(MP_QSTR_opt_level, (const byte*)"\x87\x09" "opt_level")
QDEF(MP_QSTR_ord, (const byte*)"\x1c\x03" "ord")
QDEF(MP_QSTR_os, (const byte*)"\x79\x02" "os")
QDEF(MP_QSTR_out_buffer, (const byte*)"\xf4\x0a" "out_buffer")
QDEF(MP_QSTR_out_end, (const byte*)"\x7b\x07" "out_end")
QDEF(MP_QSTR_out_start, (const byte*)"\xf4\x09" "out_start")
QDEF(MP_QSTR_pack, (const byte*)"\xbc\x04" "pack")
QDEF(MP_QSTR_pack_into, (const byte*)"\x1f\x09" "pack_into")
QDEF(MP_QSTR_parent, (const byte*)"\x99\x06" "parent")
QDEF(MP_QSTR_parity, (const byte*)"\x42\x06" "parity")
QDEF(MP_QSTR_path, (const byte*)"\x88\x04" "path")
QDEF(MP_QSTR_pause, (const byte*)"\xd7\x05" "pause")
QDEF(MP_QSTR_paused, (const byte*)"\xd3\x06" "paused")
QDEF(MP_QSTR_pend_throw, (const byte*)"\xf3\x0a" "pend_throw")
QDEF(MP_QSTR_phase, (const byte*)"\x6a\x05" "phase")
QDEF(MP_QSTR_pi, (const byte*)"\x1c\x02" "pi")
QDEF(MP_QSTR_pin, (const byte*)"\xf2\x03" "pin")
QDEF(MP_QSTR_pin_a, (const byte*)"\x6c\x05" "pin_a")
QDEF(MP_QSTR_pin_b, (const byte*)"\x6f\x05" "pin_b")
QDEF(MP_QSTR_platform, (const byte*)"\x3a\x08" "platform")
QDEF(MP_QSTR_polarity, (const byte*)"\x41\x08" "polarity")
QDEF(MP_QSTR_pop, (const byte*)"\x2a\x03" "pop")
QDEF(MP_QSTR_popitem, (const byte*)"\xbf\x07" "popitem")
QDEF(MP_QSTR_popleft, (const byte*)"\x71\x07" "popleft")
QDEF(MP_QSTR_ports, (const byte*)"\xaf\x05" "ports")
QDEF(MP_QSTR_position, (const byte*)"\x1c\x08" "position")
QDEF(MP_QSTR_pow, (const byte*)"\x2d\x03" "pow")
QDEF(MP_QSTR_print, (const byte*)"\x54\x05" "print")
QDEF(MP_QSTR_print_exception, (const byte*)"\x1c\x0f" "print_exception")
QDEF(MP_QSTR_property, (const byte*)"\xc2\x08" "property")
QDEF(MP_QSTR_protocol_pin, (const byte*)"\x1b\x0c" "protocol_pin")
QDEF(MP_QSTR_protocol_stream, (const byte*)"\x90\x0f" "protocol_stream")
QDEF(MP_QSTR_protocol_vfs, (const byte*)"\xef\x0c" "protocol_vfs")
QDEF(MP_QSTR_pull, (const byte*)"\x80\x04" "pull")
QDEF(MP_QSTR_pulseio, (const byte*)"\xfc\x07" "pulseio")
QDEF(MP_QSTR_r, (const byte*)"\xd7\x01" "r")
QDEF(MP_QSTR_radians, (const byte*)"\x87\x07" "radians")
QDEF(MP_QSTR_randint, (const byte*)"\xaf\x07" "randint")
QDEF(MP_QSTR_random, (const byte*)"\xbe\x06" "random")
QDEF(MP_QSTR_randrange, (const byte*)"\xa3\x09" "randrange")
QDEF(MP_QSTR_range, (const byte*)"\x1a\x05" "range")
QDEF(MP_QSTR_raw_value, (const byte*)"\xf5\x09" "raw_value")
QDEF(MP_QSTR_read, (const byte*)"\xb7\x04" "read")
QDEF(MP_QSTR_read_bit, (const byte*)"\x97\x08" "read_bit")
QDEF(MP_QSTR_readblocks, (const byte*)"\x2d\x0a" "readblocks")
QDEF(MP_QSTR_readfrom_into, (const byte*)"\x82\x0d" "readfrom_into")
QDEF(MP_QSTR_readinto, (const byte*)"\x4b\x08" "readinto")
QDEF(MP_QSTR_readline, (const byte*)"\xf9\x08" "readline")
QDEF(MP_QSTR_readlines, (const byte*)"\x6a\x09" "readlines")
QDEF(MP_QSTR_readonly, (const byte*)"\x03\x08" "readonly")
QDEF(MP_QSTR_receiver_buffer_size, (const byte*)"\x99\x14" "receiver_buffer_size")
QDEF(MP_QSTR_reference_voltage, (const byte*)"\x93\x11" "reference_voltage")
QDEF(MP_QSTR_release, (const byte*)"\xec\x07" "release")
QDEF(MP_QSTR_reload, (const byte*)"\x74\x06" "reload")
QDEF(MP_QSTR_remount, (const byte*)"\x9f\x07" "remount")
QDEF(MP_QSTR_remove, (const byte*)"\x63\x06" "remove")
QDEF(MP_QSTR_rename, (const byte*)"\x35\x06" "rename")
QDEF(MP_QSTR_replace, (const byte*)"\x49\x07" "replace")
QDEF(MP_QSTR_repr, (const byte*)"\xd0\x04" "repr")
QDEF(MP_QSTR_reset, (const byte*)"\x10\x05" "reset")
QDEF(MP_QSTR_reset_input_buffer, (const byte*)"\xe6\x12" "reset_input_buffer")
QDEF(MP_QSTR_resume, (const byte*)"\x5c\x06" "resume")
QDEF(MP_QSTR_reverse, (const byte*)"\x25\x07" "reverse")
QDEF(MP_QSTR_reversed, (const byte*)"\xa1\x08" "reversed")
QDEF(MP_QSTR_rfind, (const byte*)"\xd2\x05" "rfind")
QDEF(MP_QSTR_rindex, (const byte*)"\xe9\x06" "rindex")
QDEF(MP_QSTR_rmdir, (const byte*)"\x45\x05" "rmdir")
QDEF(MP_QSTR_rotaryio, (const byte*)"\xe0\x08" "rotaryio")
QDEF(MP_QSTR_round, (const byte*)"\xe7\x05" "round")
QDEF(MP_QSTR_rs485_dir, (const byte*)"\xdd\x09" "rs485_dir")
QDEF(MP_QSTR_rs485_invert, (const byte*)"\xb0\x0c" "rs485_invert")
QDEF(MP_QSTR_rsplit, (const byte*)"\xa5\x06" "rsplit")
QDEF(MP_QSTR_rstrip, (const byte*)"\x3b\x06" "rstrip")
QDEF(MP_QSTR_rtc, (const byte*)"\x40\x03" "rtc")
QDEF(MP_QSTR_rts, (const byte*)"\x50\x03" "rts")
QDEF(MP_QSTR_runtime, (const byte*)"\x99\x07" "runtime")
QDEF(MP_QSTR_rx, (const byte*)"\xcf\x02" "rx")
QDEF(MP_QSTR_samd, (const byte*)"\x9e\x04" "samd")
QDEF(MP_QSTR_scan, (const byte*)"\x1a\x04" "scan")
QDEF(MP_QSTR_scl, (const byte*)"\xf9\x03" "scl")
QDEF(MP_QSTR_sda, (const byte*)"\x53\x03" "sda")
QDEF(MP_QSTR_seed, (const byte*)"\x92\x04" "seed")
QDEF(MP_QSTR_seek, (const byte*)"\x9d\x04" "seek")
QDEF(MP_QSTR_send, (const byte*)"\xb9\x04" "send")
QDEF(MP_QSTR_send_report, (const byte*)"\x08\x0b" "send_report")
QDEF(MP_QSTR_sep, (const byte*)"\x23\x03" "sep")
QDEF(MP_QSTR_serial_bytes_available, (const byte*)"\x45\x16" "serial_bytes_available")
QDEF(MP_QSTR_serial_connected, (const byte*)"\xa5\x10" "serial_connected")
QDEF(MP_QSTR_set, (const byte*)"\x27\x03" "set")
QDEF(MP_QSTR_set_next_stack_limit, (const byte*)"\xa4\x14" "set_next_stack_limit")
QDEF(MP_QSTR_set_rgb_status_brightness, (const byte*)"\x92\x19" "set_rgb_status_brightness")
QDEF(MP_QSTR_set_time_source, (const byte*)"\xaf\x0f" "set_time_source")
QDEF(MP_QSTR_setattr, (const byte*)"\xd4\x07" "setattr")
QDEF(MP_QSTR_setdefault, (const byte*)"\x6c\x0a" "setdefault")
QDEF(MP_QSTR_setter, (const byte*)"\x04\x06" "setter")
QDEF(MP_QSTR_signed, (const byte*)"\x37\x06" "signed")
QDEF(MP_QSTR_sin, (const byte*)"\xb1\x03" "sin")
QDEF(MP_QSTR_sleep, (const byte*)"\xea\x05" "sleep")
QDEF(MP_QSTR_slice, (const byte*)"\xb5\x05" "slice")
QDEF(MP_QSTR_sort, (const byte*)"\xbf\x04" "sort")
QDEF(MP_QSTR_sorted, (const byte*)"\x5e\x06" "sorted")
QDEF(MP_QSTR_split, (const byte*)"\xb7\x05" "split")
QDEF(MP_QSTR_sqrt, (const byte*)"\x21\x04" "sqrt")
QDEF(MP_QSTR_start, (const byte*)"\x85\x05" "start")
QDEF(MP_QSTR_startswith, (const byte*)"\x74\x0a" "startswith")
QDEF(MP_QSTR_stat, (const byte*)"\xd7\x04" "stat")
QDEF(MP_QSTR_staticmethod, (const byte*)"\x62\x0c" "staticmethod")
QDEF(MP_QSTR_statvfs, (const byte*)"\x14\x07" "statvfs")
QDEF(MP_QSTR_stderr, (const byte*)"\xa3\x06" "stderr")
QDEF(MP_QSTR_stdin, (const byte*)"\x21\x05" "stdin")
QDEF(MP_QSTR_stdout, (const byte*)"\x08\x06" "stdout")
QDEF(MP_QSTR_step, (const byte*)"\x57\x04" "step")
QDEF(MP_QSTR_stop, (const byte*)"\x9d\x04" "stop")
QDEF(MP_QSTR_storage, (const byte*)"\xbc\x07" "storage")
QDEF(MP_QSTR_str, (const byte*)"\x50\x03" "str")
QDEF(MP_QSTR_strip, (const byte*)"\x29\x05" "strip")
QDEF(MP_QSTR_struct, (const byte*)"\x12\x06" "struct")
QDEF(MP_QSTR_struct_time, (const byte*)"\xf8\x0b" "struct_time")
QDEF(MP_QSTR_sum, (const byte*)"\x2e\x03" "sum")
QDEF(MP_QSTR_super, (const byte*)"\xc4\x05" "super")
QDEF(MP_QSTR_supervisor, (const byte*)"\x35\x0a" "supervisor")
QDEF(MP_QSTR_switch_to_input, (const byte*)"\xfa\x0f" "switch_to_input")
QDEF(MP_QSTR_switch_to_output, (const byte*)"\xf3\x10" "switch_to_output")
QDEF(MP_QSTR_symmetric_difference, (const byte*)"\xce\x14" "symmetric_difference")
QDEF(MP_QSTR_symmetric_difference_update, (const byte*)"\x60\x1b" "symmetric_difference_update")
QDEF(MP_QSTR_sync, (const byte*)"\xa2\x04" "sync")
QDEF(MP_QSTR_sys, (const byte*)"\xbc\x03" "sys")
QDEF(MP_QSTR_sysname, (const byte*)"\x9b\x07" "sysname")
QDEF(MP_QSTR_tan, (const byte*)"\xfe\x03" "tan")
QDEF(MP_QSTR_tell, (const byte*)"\x14\x04" "tell")
QDEF(MP_QSTR_temperature, (const byte*)"\xe9\x0b" "temperature")
QDEF(MP_QSTR_threshold, (const byte*)"\xf2\x09" "threshold")
QDEF(MP_QSTR_throw, (const byte*)"\xb3\x05" "throw")
QDEF(MP_QSTR_time, (const byte*)"\xf0\x04" "time")
QDEF(MP_QSTR_timeout, (const byte*)"\x3e\x07" "timeout")
QDEF(MP_QSTR_tm_hour, (const byte*)"\xa3\x07" "tm_hour")
QDEF(MP_QSTR_tm_isdst, (const byte*)"\xda\x08" "tm_isdst")
QDEF(MP_QSTR_tm_mday, (const byte*)"\xd2\x07" "tm_mday")
QDEF(MP_QSTR_tm_min, (const byte*)"\xa9\x06" "tm_min")
QDEF(MP_QSTR_tm_mon, (const byte*)"\x6f\x06" "tm_mon")
QDEF(MP_QSTR_tm_sec, (const byte*)"\x36\x06" "tm_sec")
QDEF(MP_QSTR_tm_wday, (const byte*)"\x08\x07" "tm_wday")
QDEF(MP_QSTR_tm_yday, (const byte*)"\x46\x07" "tm_yday")
QDEF(MP_QSTR_tm_year, (const byte*)"\x8c\x07" "tm_year")
QDEF(MP_QSTR_to_bytes, (const byte*)"\xd8\x08" "to_bytes")
QDEF(MP_QSTR_touchio, (const byte*)"\x66\x07" "touchio")
QDEF(MP_QSTR_trigger_duration, (const byte*)"\x1c\x10" "trigger_duration")
QDEF(MP_QSTR_trunc, (const byte*)"\x5b\x05" "trunc")
QDEF(MP_QSTR_try_lock, (const byte*)"\x2e\x08" "try_lock")
QDEF(MP_QSTR_tuple, (const byte*)"\xfd\x05" "tuple")
QDEF(MP_QSTR_tx, (const byte*)"\x89\x02" "tx")
QDEF(MP_QSTR_type, (const byte*)"\x9d\x04" "type")
QDEF(MP_QSTR_uid, (const byte*)"\xbd\x03" "uid")
QDEF(MP_QSTR_umount, (const byte*)"\xdd\x06" "umount")
QDEF(MP_QSTR_uname, (const byte*)"\xb7\x05" "uname")
QDEF(MP_QSTR_uniform, (const byte*)"\x01\x07" "uniform")
QDEF(MP_QSTR_union, (const byte*)"\xf6\x05" "union")
QDEF(MP_QSTR_unlink, (const byte*)"\xfe\x06" "unlink")
QDEF(MP_QSTR_unlock, (const byte*)"\x15\x06" "unlock")
QDEF(MP_QSTR_unpack, (const byte*)"\x07\x06" "unpack")
QDEF(MP_QSTR_unpack_from, (const byte*)"\x0e\x0b" "unpack_from")
QDEF(MP_QSTR_update, (const byte*)"\xb4\x06" "update")
QDEF(MP_QSTR_upper, (const byte*)"\x27\x05" "upper")
QDEF(MP_QSTR_urandom, (const byte*)"\xab\x07" "urandom")
QDEF(MP_QSTR_usage, (const byte*)"\x01\x05" "usage")
QDEF(MP_QSTR_usage_page, (const byte*)"\xec\x0a" "usage_page")
QDEF(MP_QSTR_usb_hid, (const byte*)"\xdb\x07" "usb_hid")
QDEF(MP_QSTR_usb_midi, (const byte*)"\xb7\x08" "usb_midi")
QDEF(MP_QSTR_value, (const byte*)"\x4e\x05" "value")
QDEF(MP_QSTR_values, (const byte*)"\x7d\x06" "values")
QDEF(MP_QSTR_variable_frequency, (const byte*)"\x58\x12" "variable_frequency")
QDEF(MP_QSTR_version, (const byte*)"\xbf\x07" "version")
QDEF(MP_QSTR_version_info, (const byte*)"\x6e\x0c" "version_info")
QDEF(MP_QSTR_voltage, (const byte*)"\x87\x07" "voltage")
QDEF(MP_QSTR_write, (const byte*)"\x98\x05" "write")
QDEF(MP_QSTR_write_bit, (const byte*)"\xf8\x09" "write_bit")
QDEF(MP_QSTR_write_readinto, (const byte*)"\x89\x0e" "write_readinto")
QDEF(MP_QSTR_write_value, (const byte*)"\x4c\x0b" "write_value")
QDEF(MP_QSTR_writeblocks, (const byte*)"\x02\x0b" "writeblocks")
QDEF(MP_QSTR_writeto, (const byte*)"\x03\x07" "writeto")
QDEF(MP_QSTR_writeto_then_readfrom, (const byte*)"\x70\x15" "writeto_then_readfrom")
QDEF(MP_QSTR_zip, (const byte*)"\xe6\x03" "zip")
TRANSLATION("requested length %d but object has length %d", 45, { 0x71, 0xe3, 0x81, 0x12, 0x2a, 0x56, 0x0b, 0xac, 0xec, 0x5d, 0x55, 0x2c, 0xf1, 0x24, 0xd9, 0xfd, 0x45, 0x24, 0xb6, 0x38, 0x2b, 0x05, 0xd6, 0x76, 0x2e, 0xaa, 0x80 }) // requested length %d but object has length %d
TRANSLATION("identifier redefined as nonlocal", 33, { 0x4a, 0x85, 0x94, 0xd1, 0x03, 0x93, 0x8a, 0x8d, 0x11, 0x45, 0x48, 0xe0, 0x95, 0x96, 0xcd, 0x43, 0xb0 }) // identifier redefined as nonlocal
TRANSLATION("'yield' outside function", 25, { 0xe5, 0xc2, 0x0b, 0x57, 0x91, 0x36, 0x26, 0x12, 0xa0, 0xb4, 0xc2, 0xd2, 0x51, 0x94 }) // \'yield\' outside function
TRANSLATION("name '%q' is not defined", 25, { 0x53, 0xdc, 0x17, 0x2e, 0xaf, 0x1e, 0x44, 0x90, 0x4a, 0xd2, 0x55, 0x1a, 0x22, 0x8a, 0x80 }) // name \'%q\' is not defined
TRANSLATION("default 'except' must be last", 30, { 0xa8, 0xd0, 0xf1, 0x69, 0x2e, 0x43, 0xca, 0x82, 0xf3, 0xc8, 0xb7, 0xc4, 0x49, 0x66, 0x0a, 0xc7, 0x12 }) // default \'except\' must be last
TRANSLATION("type object '%q' has no attribute '%q'", 39, { 0x9e, 0x2e, 0x09, 0xb3, 0xfa, 0x8a, 0x49, 0x72, 0xea, 0xf1, 0xe4, 0x5b, 0x1c, 0x12, 0xb1, 0x1c, 0xcb, 0xa6, 0x78, 0x90, 0x5c, 0xba, 0xbc, 0x79, 0x00 }) // type object \'%q\' has no attribute \'%q\'
TRANSLATION("math domain error", 18, { 0xdc, 0xe7, 0x62, 0xab, 0x6e, 0x68, 0xa4, 0x1d, 0xd9, 0xc0 }) // math domain error
TRANSLATION("Unable to init parser", 22, { 0xfa, 0x29, 0xe7, 0x60, 0x52, 0xc4, 0x8a, 0x92, 0x57, 0x37, 0x80, 0xe0 }) // Unable to init parser
TRANSLATION("can't convert to str implicitly", 32, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x25, 0x2c, 0x51, 0x2e, 0x49, 0xbd, 0xec, 0x94, 0x49, 0xb7, 0x00 }) // can\'t convert to str implicitly
TRANSLATION("can't delete expression", 24, { 0xa1, 0xaf, 0x29, 0x2a, 0x8b, 0x09, 0x04, 0x3c, 0xae, 0xe2, 0x21, 0x19, 0x40 }) // can\'t delete expression
TRANSLATION("Length must be non-negative", 28, { 0xfd, 0x02, 0xeb, 0x3b, 0x16, 0xf8, 0x89, 0x2c, 0xc1, 0x2b, 0x2f, 0xa9, 0x46, 0xa7, 0x29, 0xcc, 0x00 }) // Length must be non-negative
TRANSLATION("local variable referenced before assignment", 44, { 0xb3, 0x50, 0xec, 0x5c, 0xcd, 0xd0, 0xf3, 0xb0, 0x27, 0x1a, 0x07, 0x0b, 0x41, 0x52, 0xcc, 0x68, 0xce, 0x08, 0xe2, 0x13, 0x55, 0xdc, 0x2c, 0x80 }) // local variable referenced before assignment
TRANSLATION("indices must be integers", 25, { 0x45, 0xaa, 0x50, 0x41, 0x6f, 0x88, 0x92, 0xcc, 0x12, 0x2c, 0x8d, 0x43, 0xc0 }) // indices must be integers
TRANSLATION("name not defined", 17, { 0x53, 0xdc, 0x12, 0xb4, 0x95, 0x46, 0x88, 0xa2, 0xa0 }) // name not defined
TRANSLATION("No hardware support on pin", 27, { 0xf7, 0xb1, 0x6c, 0x6f, 0x5e, 0x86, 0xe0, 0xa3, 0x17, 0xbb, 0x3c, 0x93, 0x29, 0x5d, 0x14 }) // No hardware support on pin
TRANSLATION("issubclass() arg 1 must be a class", 35, { 0x48, 0x8c, 0x67, 0x4b, 0x1c, 0x47, 0xa3, 0xd2, 0x46, 0xfa, 0x97, 0xda, 0x5b, 0xe2, 0x24, 0xb3, 0x04, 0x65, 0x4b, 0x1c, 0x40 }) // issubclass() arg 1 must be a class
TRANSLATION("No space left on device", 24, { 0xf7, 0xb1, 0x45, 0xce, 0x80, 0xac, 0x34, 0x92, 0x65, 0x2a, 0x8e, 0x69, 0x40 }) // No space left on device
TRANSLATION("Stack size must be at least 256", 32, { 0xf9, 0x49, 0xd3, 0xc0, 0xa1, 0x3f, 0x70, 0x5b, 0xe2, 0x24, 0xb3, 0x04, 0x72, 0x56, 0x07, 0x12, 0x5f, 0x77, 0xe1, 0xfc, 0x40 }) // Stack size must be at least 256
TRANSLATION("threshold must be in the range 0-65536", 39, { 0x9d, 0x9c, 0x46, 0xcd, 0x6a, 0x96, 0xf8, 0x89, 0x2c, 0xc1, 0x22, 0x94, 0xec, 0x09, 0xcd, 0x75, 0x05, 0xec, 0xf5, 0x7f, 0x1f, 0xc3, 0xf0, 0xfb, 0xff, 0x88 }) // threshold must be in the range 0-65536
TRANSLATION("Unsupported baudrate", 21, { 0xfa, 0x2c, 0x62, 0xf7, 0x67, 0x91, 0x52, 0xcc, 0xf1, 0x57, 0x39, 0x00 }) // Unsupported baudrate
TRANSLATION("no module named '%q'", 21, { 0x56, 0x2d, 0xda, 0xb8, 0xb0, 0x25, 0x3d, 0xc5, 0x4b, 0x97, 0x57, 0x8f, 0x20 }) // no module named \'%q\'
TRANSLATION("super() can't find self", 24, { 0x8c, 0x5c, 0x3f, 0xa3, 0xd2, 0x54, 0x35, 0xe5, 0x25, 0xa2, 0x2d, 0x4a, 0x05, 0xb4 }) // super() can\'t find self
TRANSLATION("invalid micropython decorator", 30, { 0x45, 0xe6, 0x76, 0x4a, 0x96, 0xe9, 0x47, 0x6b, 0xf1, 0x3b, 0x32, 0x95, 0x45, 0x19, 0xce, 0x59, 0xc0 }) // invalid micropython decorator
TRANSLATION("WARNING: Your code filename has two extensions\n", 49, { 0xfd, 0xbb, 0x3e, 0x3e, 0xfe, 0xef, 0x7f, 0xf5, 0xfc, 0x4b, 0xfd, 0x36, 0x1c, 0xa8, 0xd5, 0x05, 0xa2, 0x58, 0x29, 0xee, 0x0b, 0x63, 0x82, 0x9e, 0x8c, 0x43, 0xca, 0x42, 0xc2, 0x32, 0xc7, 0x9f, 0xcc }) // WARNING: Your code filename has two extensions\r\n
TRANSLATION("Failed to allocate RX buffer of %d bytes", 41, { 0xfc, 0xcd, 0x2c, 0x2a, 0x52, 0xc4, 0x76, 0xb3, 0x50, 0xe4, 0x17, 0xc7, 0xfc, 0x96, 0x78, 0xd3, 0x40, 0xe4, 0xda, 0x17, 0x55, 0x4b, 0x3e, 0x24, 0x40 }) // Failed to allocate RX buffer of %d bytes
TRANSLATION("'%q' argument required", 23, { 0xe5, 0xd5, 0xe3, 0xc8, 0x8d, 0xf5, 0xc6, 0xe1, 0x64, 0x9c, 0x78, 0xe1, 0x1c, 0x54 }) // \'%q\' argument required
TRANSLATION("filesystem must provide mount method", 37, { 0xd1, 0x2c, 0x23, 0x88, 0x91, 0xb9, 0x6f, 0x88, 0x92, 0xbb, 0xb7, 0x34, 0xa8, 0x2d, 0xdb, 0x0b, 0x25, 0xb8, 0x9d, 0x9a, 0xa0 }) // filesystem must provide mount method
TRANSLATION("function missing keyword-only argument", 39, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0xdd, 0x22, 0x11, 0x75, 0x2f, 0x01, 0xc7, 0x46, 0x7a, 0xfa, 0x99, 0x6d, 0xc1, 0x1b, 0xeb, 0x8d, 0xc2, 0xc8 }) // function missing keyword-only argument
TRANSLATION("'%s' object is not subscriptable", 33, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x24, 0x12, 0xb4, 0x94, 0x63, 0x38, 0xa3, 0xa5, 0xe4, 0xf3, 0xb0 }) // \'%s\' object is not subscriptable
TRANSLATION("soft reboot\n", 14, { 0x86, 0xd2, 0x49, 0xc6, 0x6c, 0xd3, 0xe7, 0xf3, 0x00 }) // soft reboot\r\n
TRANSLATION("empty separator", 16, { 0x1b, 0xde, 0x78, 0x28, 0x17, 0x37, 0x39, 0x67 }) // empty separator
TRANSLATION("wrong number of values to unpack", 33, { 0xe8, 0xec, 0xba, 0x92, 0xe3, 0x7c, 0xc3, 0x93, 0x68, 0x5c, 0xce, 0xd8, 0x10, 0x52, 0xc5, 0x85, 0xb9, 0xd3, 0xc0 }) // wrong number of values to unpack
TRANSLATION("zero step", 10, { 0xfd, 0xc3, 0xb1, 0x44, 0x8b, 0x80 }) // zero step
TRANSLATION("join expects a list of str/bytes objects consistent with self object", 69, { 0xfa, 0xb2, 0x29, 0x0f, 0x2b, 0x8a, 0x4c, 0x11, 0x95, 0x92, 0x24, 0x9b, 0x42, 0x89, 0x7f, 0x5e, 0x7c, 0x48, 0x82, 0x6c, 0xfe, 0xa2, 0x93, 0x05, 0x46, 0x58, 0x48, 0x90, 0xb2, 0x5d, 0x12, 0x76, 0x28, 0x16, 0xd0, 0x9b, 0x3f, 0xa8, 0xa4, 0x80 }) // join expects a list of str/bytes objects consistent with self object
TRANSLATION("buffer too small", 17, { 0xcf, 0x1a, 0x68, 0x1c, 0xa5, 0x98, 0xa3, 0x73, 0xb5, 0x80 }) // buffer too small
TRANSLATION("memory allocation failed, heap is locked", 41, { 0xdc, 0x6e, 0xcf, 0xc1, 0x1d, 0xac, 0xd4, 0x39, 0x46, 0x52, 0xd0, 0xd2, 0xc2, 0xbf, 0x61, 0x6c, 0x0e, 0xe4, 0x90, 0x56, 0x6a, 0x78, 0x0a, 0x80 }) // memory allocation failed, heap is locked
TRANSLATION("string index out of range", 26, { 0x89, 0x74, 0x5d, 0x49, 0x16, 0xa3, 0xc8, 0x9b, 0x12, 0x4d, 0xa1, 0x39, 0xae, 0xa0 }) // string index out of range
TRANSLATION("can't convert NaN to int", 25, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x25, 0xef, 0x3f, 0x79, 0x4b, 0x12, 0x2c, 0x80 }) // can\'t convert NaN to int
TRANSLATION("Drive mode not used when direction is input.", 45, { 0xf7, 0x3a, 0x73, 0x05, 0xbb, 0x54, 0x12, 0xb4, 0x96, 0x20, 0x54, 0xba, 0x6c, 0x14, 0xaa, 0x8e, 0x29, 0x28, 0xca, 0x49, 0x04, 0x8b, 0x7c, 0x4f, 0x58 }) // Drive mode not used when direction is input.
TRANSLATION("expected tuple/list", 20, { 0x1e, 0x57, 0x14, 0x91, 0x52, 0x9c, 0x5e, 0xc3, 0xd7, 0x64, 0x89 }) // expected tuple/list
TRANSLATION("function takes %d positional arguments but %d were given", 57, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0x93, 0xf0, 0x10, 0x5d, 0x55, 0x2b, 0xb4, 0x24, 0xa3, 0x29, 0xd8, 0x8d, 0xf5, 0xc6, 0xe1, 0x66, 0x0b, 0x3c, 0x49, 0x75, 0x54, 0xba, 0x07, 0x05, 0xaa, 0x73, 0x0a }) // function takes %d positional arguments but %d were given
TRANSLATION("function got multiple values for argument '%q'", 47, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0xd5, 0xa4, 0xb7, 0xc5, 0xa5, 0x2f, 0x60, 0x5c, 0xce, 0xd8, 0x10, 0x5a, 0x33, 0x91, 0xbe, 0xb8, 0xdc, 0x2c, 0x97, 0x2e, 0xaf, 0x1e, 0x40 }) // function got multiple values for argument \'%q\'
TRANSLATION("Cannot set value when direction is input.", 42, { 0xf6, 0x9a, 0xab, 0x49, 0x40, 0x92, 0xe6, 0x76, 0xc0, 0x2e, 0x9b, 0x05, 0x2a, 0xa3, 0x8a, 0x4a, 0x32, 0x92, 0x41, 0x22, 0xdf, 0x13, 0xd6 }) // Cannot set value when direction is input.
TRANSLATION("stop not reachable from start", 30, { 0x89, 0x6b, 0x92, 0xb4, 0x93, 0x83, 0xa6, 0xc7, 0x9d, 0x81, 0x68, 0xed, 0xb9, 0x44, 0x9b, 0xc8 }) // stop not reachable from start
TRANSLATION("%q() takes %d positional arguments but %d were given", 53, { 0xea, 0xf1, 0xf4, 0x7a, 0x4a, 0x4f, 0xc0, 0x41, 0x75, 0x54, 0xae, 0xd0, 0x92, 0x8c, 0xa7, 0x62, 0x37, 0xd7, 0x1b, 0x85, 0x98, 0x2c, 0xf1, 0x25, 0xd5, 0x52, 0xe8, 0x1c, 0x16, 0xa9, 0xcc, 0x28 }) // %q() takes %d positional arguments but %d were given
TRANSLATION("Length must be an int", 22, { 0xfd, 0x02, 0xeb, 0x3b, 0x16, 0xf8, 0x89, 0x2c, 0xc1, 0x1a, 0x92, 0x2c, 0x80 }) // Length must be an int
TRANSLATION("No hardware random available", 29, { 0xf7, 0xb1, 0x6c, 0x6f, 0x5e, 0x86, 0xe0, 0x9c, 0xd6, 0xad, 0xb9, 0x1f, 0x33, 0x4b, 0x1e, 0x76, 0x00 }) // No hardware random available
TRANSLATION("3-arg pow() not supported", 26, { 0xfb, 0xfd, 0x46, 0xfa, 0x95, 0xdb, 0xa7, 0xa3, 0xd2, 0x4a, 0xd2, 0x51, 0x8b, 0xdd, 0x9e, 0x45, 0x40 }) // 3-arg pow() not supported
TRANSLATION("%%c requires int or char", 25, { 0xea, 0xea, 0xa1, 0x38, 0xf1, 0xc2, 0x38, 0x82, 0x45, 0x92, 0x67, 0x2a, 0x6c, 0x6e }) // %%c requires int or char
TRANSLATION("'%s' object does not support item deletion", 43, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x55, 0x84, 0x12, 0xb4, 0x94, 0x62, 0xf7, 0x67, 0x92, 0x49, 0x1b, 0x95, 0x45, 0x84, 0xa3, 0x28 }) // \'%s\' object does not support item deletion
TRANSLATION("function does not take keyword arguments", 41, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0xab, 0x08, 0x25, 0x69, 0x29, 0x3f, 0x00, 0x5e, 0x03, 0x8e, 0x8c, 0xf5, 0x23, 0x7d, 0x71, 0xb8, 0x59, 0x80 }) // function does not take keyword arguments
TRANSLATION("buffer slices must be of equal length", 38, { 0xcf, 0x1a, 0x68, 0x1c, 0xa2, 0xc9, 0x41, 0x05, 0xbe, 0x22, 0x4b, 0x30, 0x4d, 0xa1, 0x0f, 0x1c, 0x1d, 0x8a, 0xc1, 0x75, 0x9d, 0x80 }) // buffer slices must be of equal length
TRANSLATION("Invalid PWM frequency", 22, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x77, 0xfe, 0xdf, 0xa9, 0x68, 0xe3, 0xc7, 0x01, 0x69, 0xc0 }) // Invalid PWM frequency
TRANSLATION("No TX pin", 10, { 0xf7, 0xb1, 0x7c, 0xff, 0xc9, 0x5d, 0x14 }) // No TX pin
TRANSLATION("'%s' object does not support '%q'", 34, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x55, 0x84, 0x12, 0xb4, 0x94, 0x62, 0xf7, 0x67, 0x92, 0xe5, 0xd5, 0xe3, 0xc8 }) // \'%s\' object does not support \'%q\'
TRANSLATION("'break' outside loop", 21, { 0xe5, 0x9b, 0x83, 0xf0, 0xe4, 0x4d, 0x89, 0x84, 0xa8, 0x2b, 0x33, 0x5c }) // \'break\' outside loop
TRANSLATION("name reused for argument", 25, { 0x53, 0xdc, 0x13, 0x8c, 0x40, 0xa9, 0x68, 0xce, 0x46, 0xfa, 0xe3, 0x70, 0xb2 }) // name reused for argument
TRANSLATION("object of type '%s' has no len()", 33, { 0x6c, 0xfe, 0xa2, 0x92, 0x4d, 0xa1, 0x4f, 0x17, 0x05, 0xcb, 0xaa, 0x39, 0x16, 0xc7, 0x04, 0xac, 0x56, 0x0b, 0xe8, 0xf4, 0x80 }) // object of type \'%s\' has no len()
TRANSLATION("object not in sequence", 23, { 0x6c, 0xfe, 0xa2, 0x92, 0x4a, 0xd2, 0x48, 0xa5, 0x03, 0xc7, 0x01, 0x68, 0x00 }) // object not in sequence
TRANSLATION("RTS/CTS/RS485 Not yet supported on this device", 47, { 0xf8, 0xfc, 0xfe, 0x5e, 0xbf, 0x6f, 0xcf, 0xe5, 0xeb, 0xf8, 0xfc, 0xbf, 0xe7, 0xf9, 0x7e, 0x05, 0xef, 0x69, 0x2e, 0x04, 0x94, 0x62, 0xf7, 0x67, 0x91, 0x52, 0x65, 0x29, 0xd9, 0x20, 0xaa, 0x39, 0xa5, 0x00 }) // RTS/CTS/RS485 Not yet supported on this device
TRANSLATION("Bytes must be between 0 and 255.", 33, { 0xfc, 0xb8, 0x91, 0x05, 0xbe, 0x22, 0x4b, 0x30, 0x59, 0x89, 0xe8, 0x02, 0x97, 0xb0, 0x8d, 0x6a, 0x5f, 0x77, 0xe1, 0xf8, 0x75, 0x80 }) // Bytes must be between 0 and 255.
TRANSLATION("Unsupported operation", 22, { 0xfa, 0x2c, 0x62, 0xf7, 0x67, 0x91, 0x52, 0x6b, 0x87, 0x39, 0x46, 0x50 }) // Unsupported operation
TRANSLATION("Unknown reason.", 16, { 0xfa, 0x2f, 0x82, 0xb7, 0x45, 0x27, 0x07, 0x0c, 0xbd, 0x60 }) // Unknown reason.
TRANSLATION("PWM duty_cycle must be between 0 and 65535 inclusive (16 bit resolution)", 73, { 0xef, 0xfd, 0xbf, 0x52, 0xae, 0x27, 0x8c, 0xa9, 0xc5, 0x2c, 0x0b, 0x7c, 0x44, 0x96, 0x60, 0xb3, 0x13, 0xd0, 0x05, 0x2f, 0x61, 0x1a, 0xd4, 0xbf, 0x8f, 0xe1, 0xf8, 0x7d, 0xff, 0x81, 0x22, 0xd2, 0xd8, 0x84, 0xe6, 0x0b, 0xd1, 0xf6, 0xff, 0x12, 0xcd, 0x24, 0x9c, 0x43, 0x5b, 0x12, 0x8c, 0xbe, 0x90 }) // PWM duty_cycle must be between 0 and 65535 inclusive (16 bit resolution)
TRANSLATION("Array values should be single bytes.", 37, { 0xec, 0x77, 0x3e, 0x0b, 0x99, 0xdb, 0x02, 0x0a, 0x36, 0x6c, 0x5a, 0xa5, 0x98, 0x28, 0x45, 0xd6, 0xc0, 0xb3, 0xe2, 0x44, 0x75, 0x80 }) // Array values should be single bytes.
TRANSLATION("can't convert %s to float", 26, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x25, 0xd5, 0x05, 0x2c, 0x5a, 0x59, 0x8e, 0x40 }) // can\'t convert %s to float
TRANSLATION("timeout must be 0.0-100.0 seconds", 34, { 0x94, 0xdc, 0x36, 0x24, 0xb7, 0xc4, 0x49, 0x66, 0x0b, 0xd9, 0xd7, 0xec, 0xf5, 0x7d, 0xbe, 0xcf, 0x67, 0x5f, 0xb0, 0xa0, 0x51, 0x96, 0xb0 }) // timeout must be 0.0-100.0 seconds
TRANSLATION("Corrupt raw code", 17, { 0xf6, 0xb3, 0xbe, 0x2f, 0x24, 0xe7, 0xd0, 0xa8, 0xd5, 0x00 }) // Corrupt raw code
TRANSLATION("can't add special method to already-subclassed class", 53, { 0xa1, 0xaf, 0x29, 0x23, 0xad, 0x4a, 0x2e, 0x28, 0x87, 0x62, 0xdc, 0x4e, 0xcd, 0x52, 0x96, 0x23, 0xb3, 0x83, 0xaf, 0x1e, 0xa8, 0xc6, 0x74, 0xb1, 0xc4, 0x0a, 0x95, 0x2c, 0x71, 0x00 }) // can\'t add special method to already-subclassed class
TRANSLATION("Plus any modules on the filesystem\n", 37, { 0xef, 0xb6, 0x20, 0x8d, 0x78, 0x2d, 0xda, 0xb8, 0xb0, 0x82, 0x65, 0x29, 0xd8, 0x16, 0x89, 0x61, 0x1c, 0x44, 0x8d, 0xfc, 0xfe, 0x60 }) // Plus any modules on the filesystem\r\n
TRANSLATION("object not an iterator", 23, { 0x6c, 0xfe, 0xa2, 0x92, 0x4a, 0xd2, 0x46, 0xa4, 0x92, 0x1c, 0xe5, 0x9c }) // object not an iterator
TRANSLATION("unexpected indent", 18, { 0xc2, 0x8f, 0x2b, 0x8a, 0x48, 0xa9, 0x22, 0xd4, 0x2c, 0x80 }) // unexpected indent
TRANSLATION("function missing required keyword argument '%q'", 48, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0xdd, 0x22, 0x11, 0x75, 0x27, 0x1e, 0x38, 0x47, 0x15, 0x2f, 0x01, 0xc7, 0x46, 0x7a, 0x91, 0xbe, 0xb8, 0xdc, 0x2c, 0x97, 0x2e, 0xaf, 0x1e, 0x40 }) // function missing required keyword argument \'%q\'
TRANSLATION("object does not support item deletion", 38, { 0x6c, 0xfe, 0xa2, 0x92, 0x55, 0x61, 0x04, 0xad, 0x25, 0x18, 0xbd, 0xd9, 0xe4, 0x92, 0x46, 0xe5, 0x51, 0x61, 0x28, 0xca }) // object does not support item deletion
TRANSLATION("invalid step", 13, { 0x45, 0xe6, 0x76, 0x4a, 0x94, 0x48, 0xb8 }) // invalid step
TRANSLATION("offset out of bounds", 21, { 0x6d, 0x34, 0x81, 0x24, 0xd8, 0x92, 0x6d, 0x0b, 0x36, 0xc2, 0xd6, 0x00 }) // offset out of bounds
TRANSLATION("wrong number of arguments", 26, { 0xe8, 0xec, 0xba, 0x92, 0xe3, 0x7c, 0xc3, 0x93, 0x68, 0x46, 0xfa, 0xe3, 0x70, 0xb3, 0x00 }) // wrong number of arguments
TRANSLATION("unreadable attribute", 21, { 0xc2, 0xb8, 0x3a, 0x9e, 0x76, 0x04, 0x73, 0x2e, 0x99, 0xe2, 0x40 }) // unreadable attribute
TRANSLATION("can't pend throw to just-started generator", 43, { 0xa1, 0xaf, 0x29, 0x2b, 0x85, 0xa9, 0x4e, 0xce, 0xdd, 0x0a, 0x58, 0xbe, 0xb8, 0x89, 0xf5, 0x44, 0x9b, 0xc8, 0xa9, 0x6a, 0x14, 0x39, 0xcb, 0x38 }) // can\'t pend throw to just-started generator
TRANSLATION("object is not subscriptable", 28, { 0x6c, 0xfe, 0xa2, 0x92, 0x49, 0x04, 0xad, 0x25, 0x18, 0xce, 0x28, 0xe9, 0x79, 0x3c, 0xec, 0x00 }) // object is not subscriptable
TRANSLATION("LHS of keyword arg must be an id", 33, { 0xfd, 0x3f, 0xb7, 0xc8, 0x9b, 0x42, 0xf0, 0x1c, 0x74, 0x67, 0xa9, 0x1b, 0xea, 0x5b, 0xe2, 0x24, 0xb3, 0x04, 0x6a, 0x49, 0x50 }) // LHS of keyword arg must be an id
TRANSLATION("Cannot remount '/' when USB is active.", 39, { 0xf6, 0x9a, 0xab, 0x49, 0x38, 0xdd, 0xb0, 0xb2, 0x5c, 0xbd, 0x7c, 0x8b, 0xa6, 0xc1, 0x4b, 0xe9, 0xf2, 0xfc, 0x89, 0x20, 0x8e, 0x92, 0x9c, 0xc7, 0x58 }) // Cannot remount \'/\' when USB is active.
TRANSLATION("generator already executing", 28, { 0xd4, 0x28, 0x73, 0x96, 0x72, 0x3b, 0x38, 0x3a, 0xf0, 0x43, 0xc8, 0x53, 0x12, 0x8b, 0xa8 }) // generator already executing
TRANSLATION("can't declare nonlocal in outer code", 37, { 0xa1, 0xaf, 0x29, 0x2a, 0x8a, 0x58, 0xdc, 0x12, 0xb2, 0xd9, 0xa8, 0x76, 0x24, 0x52, 0x6c, 0x48, 0x72, 0xa3, 0x54, 0x00 }) // can\'t declare nonlocal in outer code
TRANSLATION("bad typecode", 13, { 0xcc, 0xea, 0x53, 0xc5, 0xc5, 0x1a, 0xa0 }) // bad typecode
TRANSLATION("chr() arg not in range(0x110000)", 33, { 0xa6, 0xcf, 0xe8, 0xf4, 0x91, 0xbe, 0xa4, 0xad, 0x24, 0x8a, 0x4e, 0x6b, 0xa8, 0xf4, 0x7b, 0x3c, 0xbe, 0xdf, 0xb7, 0xd9, 0xec, 0xf6, 0x7b, 0x3d, 0x20 }) // chr() arg not in range(0x110000)
TRANSLATION("can't switch from automatic field numbering to manual field specification", 74, { 0xa1, 0xaf, 0x29, 0x28, 0xe8, 0x93, 0x4d, 0x8b, 0x47, 0x6d, 0xc8, 0xf1, 0x2d, 0xb9, 0xca, 0x50, 0xb4, 0x41, 0x6a, 0x92, 0xe3, 0x7c, 0xc3, 0xa2, 0xea, 0x52, 0xc5, 0xb9, 0xae, 0x0e, 0xc5, 0xa2, 0x0b, 0x54, 0xa2, 0xe2, 0x89, 0xa2, 0x50, 0xe5, 0x19, 0x40 }) // can\'t switch from automatic field numbering to manual field specification
TRANSLATION("Welcome to Adafruit CircuitPython %s!\n\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\n\nTo list built-in modules please do `help(\"modules\")`.\n", 175, { 0xfd, 0x85, 0xa8, 0xdb, 0x82, 0x96, 0x2e, 0xca, 0x9e, 0x8f, 0x84, 0x92, 0xf6, 0xa3, 0xd3, 0x09, 0x3d, 0xfc, 0x4e, 0xcc, 0xa5, 0xd5, 0x1f, 0xed, 0xe7, 0xf3, 0x79, 0xfc, 0xdd, 0xf6, 0x07, 0x00, 0xb9, 0xa4, 0x24, 0x95, 0x81, 0xba, 0xf5, 0x9d, 0x4f, 0x47, 0xc2, 0x4f, 0x5d, 0x1b, 0x7f, 0x5d, 0x0e, 0x46, 0xac, 0xfc, 0x7a, 0xe8, 0x8f, 0x4c, 0x24, 0xdf, 0x89, 0xd9, 0x94, 0xb4, 0x67, 0x2b, 0xbb, 0x7d, 0x45, 0x24, 0xb5, 0xc2, 0x54, 0x47, 0x5f, 0x9f, 0xcd, 0xe7, 0xf3, 0x7c, 0xd8, 0xac, 0x91, 0x25, 0x9e, 0x12, 0xd3, 0xea, 0x45, 0x2d, 0xda, 0xb8, 0xb0, 0x82, 0xbd, 0x81, 0xc0, 0x2a, 0xb1, 0x7f, 0xee, 0xc2, 0xd7, 0xf4, 0x7f, 0xbe, 0xed, 0x5c, 0x58, 0x47, 0xfb, 0xfa, 0x7f, 0xf7, 0xaf, 0xcf, 0xe6 }) // Welcome to Adafruit CircuitPython %s!\r\n\r\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\r\n\r\nTo list built-in modules please do `help(\"modules\")`.\r\n
TRANSLATION("unsupported type for operator", 30, { 0xc2, 0xc6, 0x2f, 0x76, 0x79, 0x15, 0x29, 0xe2, 0xe0, 0xb4, 0x67, 0x26, 0xb8, 0x73, 0x96, 0x70 }) // unsupported type for operator
TRANSLATION("can't convert to float", 23, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x25, 0x2c, 0x5a, 0x59, 0x8e, 0x40 }) // can\'t convert to float
TRANSLATION("ord expects a character", 24, { 0x67, 0xa9, 0x0f, 0x2b, 0x8a, 0x4c, 0x11, 0x95, 0x36, 0x37, 0x3a, 0x48, 0x70 }) // ord expects a character
TRANSLATION("Press any key to enter the REPL. Use CTRL-D to reload.", 55, { 0xef, 0x71, 0x10, 0x46, 0xbc, 0x17, 0x80, 0xe0, 0xa5, 0x88, 0x2c, 0x87, 0x29, 0xd8, 0x17, 0xc7, 0xb7, 0xbf, 0xf4, 0xeb, 0x2f, 0xa4, 0x02, 0xf6, 0xfc, 0xfe, 0x3f, 0xa7, 0xab, 0xdc, 0x52, 0xc4, 0xe2, 0xcc, 0x75, 0xeb }) // Press any key to enter the REPL. Use CTRL-D to reload.
TRANSLATION("'%s' object has no attribute '%q'", 34, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x6c, 0x70, 0x4a, 0xc4, 0x73, 0x2e, 0x99, 0xe2, 0x41, 0x72, 0xea, 0xf1, 0xe4 }) // \'%s\' object has no attribute \'%q\'
TRANSLATION("USB Busy", 9, { 0xfa, 0x7c, 0xbf, 0x22, 0xfc, 0xb1, 0x1c, 0x00 }) // USB Busy
TRANSLATION("attributes not supported yet", 29, { 0x39, 0x97, 0x4c, 0xf1, 0x22, 0x09, 0x5a, 0x4a, 0x31, 0x7b, 0xb3, 0xc8, 0xa9, 0x70, 0x24 }) // attributes not supported yet
TRANSLATION("object does not support item assignment", 40, { 0x6c, 0xfe, 0xa2, 0x92, 0x55, 0x61, 0x04, 0xad, 0x25, 0x18, 0xbd, 0xd9, 0xe4, 0x92, 0x46, 0xe4, 0x71, 0x09, 0xaa, 0xee, 0x16, 0x40 }) // object does not support item assignment
TRANSLATION("negative shift count", 21, { 0x51, 0xa9, 0xca, 0x73, 0x05, 0x1b, 0x26, 0x92, 0x54, 0x6c, 0x2c, 0x80 }) // negative shift count
TRANSLATION("unsupported types for %q: '%s', '%s'", 37, { 0xc2, 0xc6, 0x2f, 0x76, 0x79, 0x15, 0x29, 0xe2, 0xe2, 0x0b, 0x46, 0x72, 0xea, 0xf1, 0xfc, 0x4b, 0x97, 0x54, 0x72, 0xfb, 0x0b, 0x97, 0x54, 0x72 }) // unsupported types for %q: \'%s\', \'%s\'
TRANSLATION("dict update sequence has wrong length", 38, { 0xaa, 0x52, 0x4b, 0x17, 0xa9, 0xc8, 0x28, 0x1e, 0x38, 0x0b, 0x40, 0x5b, 0x1c, 0x17, 0x47, 0x65, 0xd4, 0xac, 0x17, 0x59, 0xd8 }) // dict update sequence has wrong length
TRANSLATION("function takes exactly 9 arguments", 35, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0x93, 0xf0, 0x10, 0x43, 0xc8, 0xe9, 0x36, 0xe0, 0xbf, 0xec, 0x8d, 0xf5, 0xc6, 0xe1, 0x66, 0x00 }) // function takes exactly 9 arguments
TRANSLATION("substring not found", 20, { 0x8c, 0x67, 0x12, 0xe8, 0xba, 0x92, 0xb4, 0x96, 0x8d, 0x85, 0xa8 }) // substring not found
TRANSLATION("too many values to unpack (expected %d)", 40, { 0x96, 0x62, 0xdc, 0xd7, 0x82, 0xe6, 0x76, 0xc0, 0x82, 0x96, 0x2c, 0x2d, 0xce, 0x9e, 0x05, 0xe8, 0x1e, 0x57, 0x14, 0x91, 0x52, 0xea, 0xaf, 0xa4 }) // too many values to unpack (expected %d)
TRANSLATION("cannot import name %q", 22, { 0xa1, 0xaa, 0xb4, 0x92, 0x6f, 0x76, 0x79, 0x25, 0x3d, 0xc1, 0x75, 0x78, 0x80 }) // cannot import name %q
TRANSLATION("Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.", 101, { 0xee, 0x5a, 0x36, 0xf7, 0x39, 0x4c, 0xec, 0x0b, 0xaf, 0x7b, 0xf0, 0x5a, 0x25, 0x87, 0x59, 0x77, 0xd8, 0x1c, 0x02, 0xc5, 0xea, 0x72, 0x08, 0xed, 0x62, 0xeb, 0xde, 0xfc, 0x16, 0x89, 0x61, 0x1d, 0x65, 0xf2, 0x00, 0xb6, 0x99, 0xbf, 0xe3, 0xeb, 0xf5, 0x9d, 0x4f, 0x47, 0xc7, 0x5a, 0x4f, 0xaf, 0x7b, 0xf1, 0xea, 0xc5, 0xea, 0x72, 0x0b, 0x46, 0x72, 0xdd, 0x9c, 0x12, 0x2e, 0x8d, 0xd6 }) // Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.
TRANSLATION("Invalid pins", 13, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x5d, 0x16, 0x00 }) // Invalid pins
TRANSLATION("Call super().__init__() before accessing native object.", 56, { 0xf6, 0x9d, 0xac, 0x51, 0x8b, 0x87, 0xf4, 0x7a, 0x7a, 0xf2, 0xc9, 0x15, 0x27, 0x2c, 0xbd, 0x1e, 0x92, 0xcc, 0x68, 0xce, 0x08, 0xe9, 0x41, 0x10, 0x8b, 0xa9, 0x29, 0xca, 0x73, 0x04, 0xd9, 0xfd, 0x45, 0x27, 0xac }) // Call super().__init__() before accessing native object.
TRANSLATION("end of format while looking for conversion specifier", 53, { 0x0b, 0x52, 0x6d, 0x0b, 0x46, 0x7d, 0xce, 0x4b, 0xa6, 0xc9, 0x60, 0x56, 0x66, 0xf0, 0x45, 0xd4, 0xb4, 0x67, 0x2a, 0x32, 0xf3, 0x0f, 0x08, 0xca, 0x51, 0x71, 0x44, 0xd1, 0x03, 0x80 }) // end of format while looking for conversion specifier
TRANSLATION("Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\n", 86, { 0xec, 0xc4, 0xb7, 0xa9, 0xc5, 0x98, 0xea, 0x49, 0x04, 0xcb, 0xd6, 0x5f, 0x24, 0xde, 0xf6, 0xe0, 0xa0, 0xf9, 0x82, 0xd1, 0x2c, 0x20, 0x9b, 0x98, 0x72, 0xfa, 0x7c, 0xbf, 0x22, 0x96, 0x27, 0xc2, 0x94, 0xec, 0x37, 0x26, 0x72, 0x0b, 0x21, 0xcb, 0xe3, 0xdb, 0xdf, 0xfa, 0x14, 0xb1, 0x55, 0x20, 0xf3, 0xb0, 0xeb, 0xf3, 0xf9, 0x80 }) // Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\r\n
TRANSLATION("keywords must be strings", 25, { 0xf0, 0x1c, 0x74, 0x67, 0xac, 0x16, 0xf8, 0x89, 0x2c, 0xc1, 0x44, 0xba, 0x2e, 0xb0 }) // keywords must be strings
TRANSLATION("Tuple or struct_time argument required", 39, { 0xf9, 0xe2, 0xf6, 0x04, 0xce, 0x51, 0x2f, 0x8a, 0x4e, 0x52, 0x9b, 0x82, 0x37, 0xd7, 0x1b, 0x85, 0x92, 0x71, 0xe3, 0x84, 0x71, 0x50 }) // Tuple or struct_time argument required
TRANSLATION("slice step cannot be zero", 26, { 0x8b, 0x25, 0x01, 0x44, 0x8b, 0x95, 0x0d, 0x55, 0xa4, 0xb3, 0x05, 0xfb, 0x87, 0x60 }) // slice step cannot be zero
TRANSLATION("abort() called", 15, { 0x3c, 0xd9, 0xe7, 0xd1, 0xe9, 0x2a, 0x1d, 0xac, 0x2a }) // abort() called
TRANSLATION("No such file/directory", 23, { 0xf7, 0xb1, 0x46, 0x29, 0xb1, 0x68, 0x96, 0x1e, 0xba, 0xa3, 0x8a, 0x4b, 0x3f, 0x00 }) // No such file/directory
TRANSLATION("unindent does not match any outer indentation level", 52, { 0xc2, 0xa2, 0xd4, 0x2c, 0x95, 0x58, 0x41, 0x2b, 0x49, 0x6e, 0x73, 0x4d, 0x88, 0xd7, 0x82, 0x6c, 0x48, 0x72, 0x45, 0xa8, 0x59, 0x39, 0x46, 0x52, 0xb0, 0xe6, 0x2c }) // unindent does not match any outer indentation level
TRANSLATION("expecting key:value for dict", 29, { 0x1e, 0x57, 0x14, 0x94, 0x5d, 0x4b, 0xc0, 0x71, 0xf8, 0xf3, 0x3b, 0x60, 0x16, 0x8c, 0xe5, 0x54, 0xa4, 0x80 }) // expecting key:value for dict
TRANSLATION("empty sequence", 15, { 0x1b, 0xde, 0x78, 0x28, 0x1e, 0x38, 0x0b, 0x40 }) // empty sequence
TRANSLATION("incomplete format key", 22, { 0x45, 0xa3, 0x6f, 0x7b, 0x09, 0x05, 0xa3, 0x3e, 0xe7, 0x25, 0xe0, 0x38 }) // incomplete format key
TRANSLATION("invalid syntax for integer with base %d", 40, { 0x45, 0xe6, 0x76, 0x4a, 0x94, 0x70, 0xb2, 0x7e, 0x45, 0xa3, 0x39, 0x22, 0xc8, 0xd4, 0x39, 0x74, 0x49, 0xd8, 0xb3, 0x38, 0x05, 0xd5, 0x50 }) // invalid syntax for integer with base %d
TRANSLATION("Pin does not have ADC capabilities", 35, { 0xef, 0x45, 0x2a, 0xb0, 0x82, 0x56, 0x92, 0xd8, 0xf9, 0x82, 0xec, 0xf7, 0x7b, 0x4a, 0x87, 0x73, 0xcd, 0x2c, 0x92, 0x82, 0x00 }) // Pin does not have ADC capabilities
TRANSLATION("All timers in use", 18, { 0xec, 0xb5, 0x8a, 0x53, 0x70, 0xf0, 0x48, 0xa5, 0x88, 0x00 }) // All timers in use
TRANSLATION("'continue' outside loop", 24, { 0xe5, 0x46, 0x59, 0x45, 0xc0, 0xe4, 0x4d, 0x89, 0x84, 0xa8, 0x2b, 0x33, 0x5c }) // \'continue\' outside loop
TRANSLATION("'%s' object is not an iterator", 31, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x24, 0x12, 0xb4, 0x91, 0xa9, 0x24, 0x87, 0x39, 0x67 }) // \'%s\' object is not an iterator
TRANSLATION("step must be non-zero", 22, { 0x89, 0x17, 0x2d, 0xf1, 0x12, 0x59, 0x82, 0x56, 0x5f, 0x57, 0xee, 0x1d, 0x80 }) // step must be non-zero
TRANSLATION("%q indices must be integers, not %s", 36, { 0xea, 0xf1, 0x24, 0x5a, 0xa5, 0x04, 0x16, 0xf8, 0x89, 0x2c, 0xc1, 0x22, 0xc8, 0xd4, 0x3c, 0x7d, 0x84, 0xad, 0x25, 0xd5, 0x00 }) // %q indices must be integers, not %s
TRANSLATION("pop from an empty set", 22, { 0xbb, 0x5c, 0xb4, 0x76, 0xdc, 0x8d, 0x48, 0x6f, 0x79, 0xe0, 0xa0, 0x48 }) // pop from an empty set
TRANSLATION("too many arguments provided with the given format", 50, { 0x96, 0x62, 0xdc, 0xd7, 0x82, 0x37, 0xd7, 0x1b, 0x85, 0x98, 0x2b, 0xbb, 0x73, 0x4a, 0x8a, 0x97, 0x44, 0x9d, 0x8a, 0x76, 0x05, 0xaa, 0x73, 0x0a, 0x5a, 0x33, 0xee, 0x72 }) // too many arguments provided with the given format
TRANSLATION("index out of range", 19, { 0x45, 0xa8, 0xf2, 0x26, 0xc4, 0x93, 0x68, 0x4e, 0x6b, 0xa8 }) // index out of range
TRANSLATION("calibration value out of range +/-127", 38, { 0xa1, 0xd9, 0x33, 0x73, 0x94, 0x65, 0x2e, 0x67, 0x6c, 0x02, 0x6c, 0x49, 0x36, 0x84, 0xe6, 0xba, 0x82, 0xff, 0xe7, 0xaf, 0xd5, 0xf6, 0xfd, 0xdf, 0xf4 }) // calibration value out of range +/-127
TRANSLATION("lhs and rhs should be compatible", 33, { 0xb6, 0xd0, 0x46, 0xb5, 0x27, 0xda, 0x0a, 0x36, 0x6c, 0x5a, 0xa5, 0x98, 0x2a, 0x36, 0xf7, 0x39, 0x4c, 0xec, 0x00 }) // lhs and rhs should be compatible
TRANSLATION("Expected a %q", 14, { 0xed, 0xf2, 0xb8, 0xa4, 0x8a, 0x91, 0x97, 0x57, 0x88 }) // Expected a %q
TRANSLATION("\nCode done running. Waiting for reload.\n", 43, { 0xf3, 0xf9, 0xbd, 0xad, 0x50, 0x55, 0x65, 0x04, 0xf8, 0x55, 0x45, 0xd7, 0xac, 0xbf, 0x63, 0x49, 0x45, 0xd4, 0xb4, 0x67, 0x27, 0x16, 0x63, 0xaf, 0x5f, 0x9f, 0xcc }) // \r\nCode done running. Waiting for reload.\r\n
TRANSLATION("module not found", 17, { 0xdd, 0xab, 0x8b, 0x02, 0x56, 0x92, 0xd1, 0xb0, 0xb5 }) // module not found
TRANSLATION("\nPlease file an issue with the contents of your CIRCUITPY drive at \nhttps://github.com/adafruit/circuitpython/issues\n", 121, { 0xf3, 0xf9, 0xbb, 0xec, 0x0e, 0x01, 0x68, 0x96, 0x04, 0x6a, 0x49, 0x11, 0x80, 0x5d, 0x12, 0x76, 0x29, 0xd8, 0x15, 0x19, 0x64, 0x2c, 0xc1, 0x36, 0x85, 0xc3, 0x61, 0xcb, 0xdb, 0xdd, 0xf1, 0xf6, 0xfd, 0x3b, 0xbe, 0x7d, 0xff, 0xe8, 0xaa, 0xe9, 0xcc, 0x11, 0xc9, 0x79, 0xfc, 0xdb, 0x4c, 0xde, 0x3f, 0x1f, 0x5f, 0xaf, 0x54, 0x9d, 0xb1, 0x9f, 0x5d, 0x1b, 0x7f, 0x59, 0xd4, 0xf4, 0x7c, 0x24, 0xfa, 0xe8, 0x8f, 0x4c, 0x24, 0xdf, 0x89, 0xd9, 0x97, 0xd6, 0x91, 0x18, 0x11, 0xe7, 0xf3, 0x00 }) // \r\nPlease file an issue with the contents of your CIRCUITPY drive at \r\nhttps://github.com/adafruit/circuitpython/issues\r\n
TRANSLATION("cannot create instance", 23, { 0xa1, 0xaa, 0xb4, 0x95, 0x1c, 0x1c, 0x82, 0x45, 0x89, 0x35, 0xa0 }) // cannot create instance
TRANSLATION("Invalid phase", 14, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x5f, 0x63, 0x80 }) // Invalid phase
TRANSLATION("can't switch from manual field specification to automatic field numbering", 74, { 0xa1, 0xaf, 0x29, 0x28, 0xe8, 0x93, 0x4d, 0x8b, 0x47, 0x6d, 0xcb, 0x73, 0x5c, 0x1d, 0x8b, 0x44, 0x16, 0xa9, 0x45, 0xc5, 0x13, 0x44, 0xa1, 0xca, 0x32, 0x94, 0xb1, 0x1e, 0x25, 0xb7, 0x39, 0x4a, 0x16, 0x88, 0x2d, 0x52, 0x5c, 0x6f, 0x98, 0x74, 0x5d, 0x40 }) // can\'t switch from manual field specification to automatic field numbering
TRANSLATION("The microcontroller's power dipped. Make sure your power supply provides\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\n", 155, { 0xf9, 0xec, 0x0b, 0x74, 0xa3, 0xb5, 0x19, 0x65, 0xda, 0xd6, 0x0f, 0xca, 0x0a, 0xed, 0xd0, 0x39, 0x55, 0x2f, 0x71, 0x5e, 0xb2, 0xfd, 0x4f, 0xc0, 0x14, 0x61, 0xc1, 0x70, 0xd8, 0x72, 0xbb, 0x74, 0x0e, 0x51, 0x8b, 0xde, 0xdc, 0x15, 0xdd, 0xb9, 0xa5, 0x44, 0x79, 0xfc, 0xc1, 0x5b, 0x1a, 0xec, 0x57, 0x6e, 0x81, 0xcb, 0x46, 0x72, 0x9d, 0x81, 0x74, 0xd9, 0xac, 0x0a, 0x88, 0xf4, 0xc2, 0x49, 0x1a, 0xd4, 0xae, 0xe2, 0x20, 0x9c, 0x40, 0x92, 0xf4, 0x1e, 0x92, 0x1c, 0x87, 0xd4, 0x52, 0x51, 0x75, 0x2f, 0x6f, 0x77, 0xc7, 0xdb, 0xf4, 0xee, 0xf9, 0xf7, 0xff, 0xaf, 0x4f, 0x5f, 0x9f, 0xcc }) // The microcontroller\'s power dipped. Make sure your power supply provides\r\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\r\n
TRANSLATION("popitem(): dictionary is empty", 31, { 0xbb, 0x5d, 0x24, 0x6f, 0xe8, 0xf4, 0xfe, 0x25, 0x54, 0xa4, 0xa3, 0x29, 0xbf, 0x04, 0x90, 0x43, 0x7b, 0xcf, 0x00 }) // popitem(): dictionary is empty
TRANSLATION("no active exception to reraise", 31, { 0x56, 0x23, 0xa4, 0xa7, 0x30, 0x43, 0xca, 0x82, 0xf2, 0x8c, 0xa5, 0x2c, 0x4e, 0x1c, 0xd2, 0x00 }) // no active exception to reraise
TRANSLATION("Corrupt .mpy file", 18, { 0xf6, 0xb3, 0xbe, 0x2f, 0x25, 0xd7, 0xbd, 0xf8, 0x2d, 0x12, 0xc0 }) // Corrupt .mpy file
TRANSLATION(", in %q\n", 10, { 0xfb, 0x09, 0x14, 0xba, 0xbc, 0x7c, 0xfe, 0x60 }) // , in %q\r\n
TRANSLATION("stop must be 1 or 2", 20, { 0x89, 0x6b, 0x96, 0xf8, 0x89, 0x2c, 0xc1, 0x7d, 0xa4, 0xce, 0x5f, 0x70 }) // stop must be 1 or 2
TRANSLATION("can't send non-None value to a just-started generator", 54, { 0xa1, 0xaf, 0x29, 0x28, 0x0b, 0x52, 0x56, 0x5f, 0x57, 0xbd, 0x94, 0x17, 0x33, 0xb6, 0x01, 0x4b, 0x11, 0x97, 0xd7, 0x11, 0x3e, 0xa8, 0x93, 0x79, 0x15, 0x2d, 0x42, 0x87, 0x39, 0x67 }) // can\'t send non-None value to a just-started generator
TRANSLATION("no such attribute", 18, { 0x56, 0x28, 0xc5, 0x36, 0x23, 0x99, 0x74, 0xcf, 0x12, 0x00 }) // no such attribute
TRANSLATION("tuple/list has wrong length", 28, { 0x9c, 0x5e, 0xc3, 0xd7, 0x64, 0x89, 0x2d, 0x8e, 0x0b, 0xa3, 0xb2, 0xea, 0x56, 0x0b, 0xac, 0xec }) // tuple/list has wrong length
TRANSLATION("time.struct_time() takes a 9-sequence", 38, { 0x94, 0xdc, 0x75, 0xc4, 0xbe, 0x29, 0x39, 0x4a, 0x6e, 0x3d, 0x1e, 0x92, 0x93, 0xf0, 0x10, 0x46, 0x5f, 0xf7, 0xea, 0x81, 0xe3, 0x80, 0xb4, 0x00 }) // time.struct_time() takes a 9-sequence
TRANSLATION("tuple index out of range", 25, { 0x9c, 0x5e, 0xc0, 0x91, 0x6a, 0x3c, 0x89, 0xb1, 0x24, 0xda, 0x13, 0x9a, 0xea, 0x00 }) // tuple index out of range
TRANSLATION("multiple *x in assignment", 26, { 0xdf, 0x16, 0x94, 0xbd, 0x81, 0x7f, 0x0f, 0x22, 0x45, 0x23, 0x88, 0x4d, 0x57, 0x70, 0xb2 }) // multiple *x in assignment
TRANSLATION("odd-length string", 18, { 0x6a, 0xd7, 0xd5, 0x60, 0xba, 0xce, 0xc5, 0x12, 0xe8, 0xba, 0x80 }) // odd-length string
TRANSLATION("complex values not supported", 29, { 0xa3, 0x6f, 0x7b, 0x0f, 0x22, 0xe6, 0x76, 0xc0, 0x82, 0x56, 0x92, 0x8c, 0x5e, 0xec, 0xf2, 0x2a }) // complex values not supported
TRANSLATION("unknown conversion specifier %c", 32, { 0xc2, 0xf8, 0x2b, 0x74, 0x52, 0xa3, 0x2f, 0x30, 0xf0, 0x8c, 0xa5, 0x17, 0x14, 0x4d, 0x10, 0x39, 0x75, 0x50 }) // unknown conversion specifier %c
TRANSLATION("can't have multiple *x", 23, { 0xa1, 0xaf, 0x29, 0x2d, 0x8f, 0x98, 0x2d, 0xf1, 0x69, 0x4b, 0xd8, 0x17, 0xf0, 0xf2 }) // can\'t have multiple *x
TRANSLATION("can't assign to expression", 27, { 0xa1, 0xaf, 0x29, 0x23, 0x88, 0x4d, 0x54, 0xa5, 0x88, 0x79, 0x5d, 0xc4, 0x42, 0x32, 0x80 }) // can\'t assign to expression
TRANSLATION("Brightness must be between 0 and 255", 37, { 0xfc, 0x9d, 0x35, 0xda, 0x54, 0x44, 0x16, 0xf8, 0x89, 0x2c, 0xc1, 0x66, 0x27, 0xa0, 0x0a, 0x5e, 0xc2, 0x35, 0xa9, 0x7d, 0xdf, 0x87, 0xe0 }) // Brightness must be between 0 and 255
TRANSLATION("calibration is read only", 25, { 0xa1, 0xd9, 0x33, 0x73, 0x94, 0x65, 0x24, 0x82, 0x70, 0x75, 0x26, 0x5b, 0x70 }) // calibration is read only
TRANSLATION("expected ':' after format specifier", 36, { 0x1e, 0x57, 0x14, 0x91, 0x52, 0xe5, 0xf8, 0xf2, 0x23, 0xd2, 0x43, 0x96, 0x8c, 0xfb, 0x9c, 0x94, 0x5c, 0x51, 0x34, 0x40, 0xe0 }) // expected \':\' after format specifier
TRANSLATION("type '%q' is not an acceptable base type", 41, { 0x9e, 0x2e, 0x0b, 0x97, 0x57, 0x8f, 0x22, 0x48, 0x25, 0x69, 0x23, 0x52, 0x3a, 0x50, 0x5e, 0x4f, 0x3b, 0x02, 0xcc, 0xe0, 0x14, 0xf1, 0x70 }) // type \'%q\' is not an acceptable base type
TRANSLATION("ord() expected a character, but string of length %d found", 58, { 0x67, 0xaf, 0xa3, 0xd2, 0x43, 0xca, 0xe2, 0x92, 0x2a, 0x46, 0x54, 0xd8, 0xdc, 0xe9, 0x21, 0xfe, 0xc2, 0xcf, 0x12, 0x51, 0x2e, 0x8b, 0xa9, 0x36, 0x85, 0x60, 0xba, 0xce, 0xc5, 0xd5, 0x52, 0xd1, 0xb0, 0xb5 }) // ord() expected a character, but string of length %d found
TRANSLATION("__init__() should return None, not '%s'", 40, { 0xcb, 0x24, 0x54, 0x9c, 0xb2, 0xf4, 0x7a, 0x4a, 0x36, 0x6c, 0x5a, 0xa4, 0xe2, 0x70, 0xea, 0x5e, 0xf6, 0x51, 0xf6, 0x12, 0xb4, 0x97, 0x2e, 0xa8, 0xe4 }) // __init__() should return None, not \'%s\'
TRANSLATION("string not supported; use bytes or bytearray", 45, { 0x89, 0x74, 0x5d, 0x49, 0x5a, 0x4a, 0x31, 0x7b, 0xb3, 0xc8, 0xaf, 0xff, 0xc5, 0x88, 0x05, 0x9f, 0x12, 0x20, 0x99, 0xcb, 0x3e, 0x24, 0x1b, 0xb9, 0xf0 }) // string not supported; use bytes or bytearray
TRANSLATION("Buffer incorrect size. Should be %d bytes.", 43, { 0xfc, 0xb1, 0xa6, 0x81, 0xc9, 0x16, 0x8c, 0xee, 0x29, 0x25, 0x09, 0xfb, 0x8e, 0xb2, 0xf9, 0x6c, 0xd8, 0xb5, 0x4b, 0x30, 0x5d, 0x55, 0x2c, 0xf8, 0x91, 0x1d, 0x60 }) // Buffer incorrect size. Should be %d bytes.
TRANSLATION("incomplete format", 18, { 0x45, 0xa3, 0x6f, 0x7b, 0x09, 0x05, 0xa3, 0x3e, 0xe7, 0x20 }) // incomplete format
TRANSLATION("MicroPython NLR jump failed. Likely memory corruption.", 55, { 0xfd, 0x52, 0x8e, 0xdd, 0xfc, 0x4e, 0xcc, 0xa5, 0xef, 0xfd, 0x3e, 0x25, 0xf5, 0xc6, 0xf7, 0x2d, 0x0d, 0x2c, 0x2b, 0xd6, 0x5f, 0xa2, 0x78, 0x0b, 0x70, 0x5b, 0x8d, 0xd9, 0xf8, 0x2a, 0x33, 0xbe, 0x2f, 0x28, 0xcb, 0xd6 }) // MicroPython NLR jump failed. Likely memory corruption.
TRANSLATION("type takes 1 or 3 arguments", 28, { 0x9e, 0x2e, 0x0a, 0x4f, 0xc0, 0x41, 0x7d, 0xa4, 0xce, 0x5f, 0x79, 0x1b, 0xeb, 0x8d, 0xc2, 0xcc, 0x00 }) // type takes 1 or 3 arguments
TRANSLATION("Failed to write internal flash.", 32, { 0xfc, 0xcd, 0x2c, 0x2a, 0x52, 0xc5, 0xd1, 0xd2, 0x41, 0x22, 0xc8, 0x75, 0x3b, 0x16, 0x96, 0x38, 0xdb, 0xac }) // Failed to write internal flash.
TRANSLATION("File exists", 12, { 0xfc, 0xd2, 0xc0, 0x87, 0x92, 0x44, 0xc0 }) // File exists
TRANSLATION("AnalogOut is only 16 bits. Value must be less than 65536.", 58, { 0xec, 0x53, 0xb3, 0x6b, 0xf0, 0xc4, 0x92, 0x41, 0x32, 0xdb, 0x82, 0xfb, 0x7f, 0x89, 0x66, 0x93, 0x1d, 0x65, 0xfe, 0x0e, 0xd8, 0x05, 0xbe, 0x22, 0x4b, 0x30, 0x56, 0x11, 0x05, 0x3b, 0x1a, 0x97, 0xf1, 0xfc, 0x3f, 0x0f, 0xbf, 0xf8, 0xf5, 0x80 }) // AnalogOut is only 16 bits. Value must be less than 65536.
TRANSLATION("Invalid pin", 12, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x5d, 0x14 }) // Invalid pin
TRANSLATION("unmatched '{' in format", 24, { 0xc2, 0xee, 0x73, 0x4d, 0x85, 0x4b, 0x97, 0xff, 0x79, 0x12, 0x29, 0x68, 0xcf, 0xb9, 0xc8 }) // unmatched \'{\' in format
TRANSLATION("Both pins must support hardware interrupts", 43, { 0xfc, 0x9a, 0x76, 0x2b, 0xa2, 0xc1, 0x6f, 0x88, 0x92, 0x8c, 0x5e, 0xec, 0xf2, 0x5b, 0x1b, 0xd7, 0xa1, 0xb8, 0x24, 0x59, 0x0e, 0xf8, 0xbc, 0xc0 }) // Both pins must support hardware interrupts
TRANSLATION("invalid syntax", 15, { 0x45, 0xe6, 0x76, 0x4a, 0x94, 0x70, 0xb2, 0x7e, 0x40 }) // invalid syntax
TRANSLATION("type is not an acceptable base type", 36, { 0x9e, 0x2e, 0x09, 0x20, 0x95, 0xa4, 0x8d, 0x48, 0xe9, 0x41, 0x79, 0x3c, 0xec, 0x0b, 0x33, 0x80, 0x53, 0xc5, 0xc0 }) // type is not an acceptable base type
TRANSLATION("Attempted heap allocation when MicroPython VM not running.", 59, { 0xec, 0x99, 0x1b, 0xde, 0x45, 0x4b, 0x60, 0x77, 0x23, 0xb5, 0x9a, 0x87, 0x28, 0xca, 0x5d, 0x36, 0x0a, 0x5f, 0xaa, 0x51, 0xdb, 0xbf, 0x89, 0xd9, 0x94, 0xbf, 0xc7, 0xea, 0x4a, 0xd2, 0x4f, 0x85, 0x54, 0x5d, 0x7a, 0xc0 }) // Attempted heap allocation when MicroPython VM not running.
TRANSLATION("Could not initialize UART", 26, { 0xf6, 0xb6, 0x2d, 0x52, 0x56, 0x92, 0x45, 0x49, 0x43, 0xb2, 0x7e, 0xe0, 0xbe, 0x9d, 0x9f, 0x1f, 0x98 }) // Could not initialize UART
TRANSLATION("function expected at most %d arguments, got %d", 47, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0x1e, 0x57, 0x14, 0x91, 0x52, 0x39, 0x2d, 0xda, 0x24, 0xba, 0xaa, 0x46, 0xfa, 0xe3, 0x70, 0xb3, 0x1f, 0x61, 0x6a, 0xd2, 0x5d, 0x55 }) // function expected at most %d arguments, got %d
TRANSLATION("non-keyword arg after */**", 27, { 0x56, 0x5f, 0x57, 0x80, 0xe3, 0xa3, 0x3d, 0x48, 0xdf, 0x52, 0x3d, 0x24, 0x39, 0x7f, 0x0f, 0x5f, 0xf0, 0xfe, 0x00 }) // non-keyword arg after */**
TRANSLATION("expecting just a value for set", 31, { 0x1e, 0x57, 0x14, 0x94, 0x5d, 0x4b, 0xeb, 0x88, 0x92, 0x32, 0xe6, 0x76, 0xc0, 0x2d, 0x19, 0xca, 0x04, 0x80 }) // expecting just a value for set
TRANSLATION("CircuitPython core code crashed hard. Whoops!\n", 48, { 0xf6, 0xa3, 0xd3, 0x09, 0x3d, 0xfc, 0x4e, 0xcc, 0xa5, 0x46, 0x70, 0x54, 0x6a, 0x82, 0xa3, 0x9c, 0x6c, 0x2a, 0x5b, 0x1b, 0xd7, 0xac, 0xbf, 0x6d, 0x99, 0xaf, 0x1f, 0xed, 0xe7, 0xf3, 0x00 }) // CircuitPython core code crashed hard. Whoops!\r\n
TRANSLATION("must use keyword argument for key function", 43, { 0xdf, 0x11, 0x25, 0x88, 0x05, 0xe0, 0x38, 0xe8, 0xcf, 0x52, 0x37, 0xd7, 0x1b, 0x85, 0x92, 0xd1, 0x9c, 0xbc, 0x07, 0x05, 0xa6, 0x16, 0x92, 0x8c, 0xa0 }) // must use keyword argument for key function
TRANSLATION("__init__() should return None", 30, { 0xcb, 0x24, 0x54, 0x9c, 0xb2, 0xf4, 0x7a, 0x4a, 0x36, 0x6c, 0x5a, 0xa4, 0xe2, 0x70, 0xea, 0x5e, 0xf6, 0x50 }) // __init__() should return None
TRANSLATION("Slices not supported", 21, { 0xf9, 0x59, 0x28, 0x20, 0x95, 0xa4, 0xa3, 0x17, 0xbb, 0x3c, 0x8a, 0x80 }) // Slices not supported
TRANSLATION("Read-only filesystem", 21, { 0xf8, 0x83, 0xaf, 0xa9, 0x96, 0xdc, 0x16, 0x89, 0x61, 0x1c, 0x44, 0x8d, 0xc0 }) // Read-only filesystem
TRANSLATION(" output:\n", 11, { 0x26, 0xc4, 0xdf, 0x13, 0xf8, 0xf9, 0xfc, 0xc0 }) //  output:\r\n
TRANSLATION("The CircuitPython heap was corrupted because the stack was too small.\nPlease increase the stack size if you know how, or if not:", 130, { 0xf9, 0xec, 0x0b, 0xda, 0x8f, 0x4c, 0x24, 0xf7, 0xf1, 0x3b, 0x32, 0x96, 0xc0, 0xee, 0x5d, 0x0e, 0x0a, 0x8c, 0xef, 0x8b, 0xc8, 0xa9, 0x66, 0x28, 0x78, 0x80, 0x53, 0xb0, 0x28, 0x93, 0xa7, 0x81, 0x74, 0x38, 0x29, 0x66, 0x28, 0xdc, 0xed, 0x6e, 0xbf, 0x3f, 0x9b, 0xbe, 0xc0, 0xe0, 0x12, 0x2d, 0x1c, 0x1c, 0x02, 0x9d, 0x81, 0x44, 0x9d, 0x3c, 0x0a, 0x13, 0xf7, 0x04, 0x9a, 0x17, 0x0d, 0x82, 0xf0, 0x56, 0xe8, 0x5b, 0x37, 0x4f, 0xb0, 0x99, 0xc9, 0x34, 0x25, 0x69, 0xfc, 0x40 }) // The CircuitPython heap was corrupted because the stack was too small.\r\nPlease increase the stack size if you know how, or if not:
TRANSLATION("buffer size must match format", 30, { 0xcf, 0x1a, 0x68, 0x1c, 0xa1, 0x3f, 0x70, 0x5b, 0xe2, 0x24, 0xb7, 0x39, 0xa6, 0xc5, 0xa3, 0x3e, 0xe7, 0x20 }) // buffer size must match format
TRANSLATION("'%s' object is not callable", 28, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x24, 0x12, 0xb4, 0x95, 0x0e, 0xd6, 0x3c, 0xec, 0x00 }) // \'%s\' object is not callable
TRANSLATION("  File \"%q\", line %d", 21, { 0x22, 0xfc, 0xd2, 0xc0, 0xbf, 0xdf, 0xab, 0xc7, 0xfd, 0xfe, 0xc2, 0xb2, 0x28, 0x2e, 0xaa, 0x80 }) //   File \"%q\", line %d
TRANSLATION("Permission denied", 18, { 0xef, 0x0f, 0xba, 0x44, 0x23, 0x29, 0x54, 0x2a, 0x0a, 0x80 }) // Permission denied
TRANSLATION("object not iterable", 20, { 0x6c, 0xfe, 0xa2, 0x92, 0x4a, 0xd2, 0x49, 0x21, 0xcf, 0x3b, 0x00 }) // object not iterable
TRANSLATION("MicroPython fatal error.", 25, { 0xfd, 0x52, 0x8e, 0xdd, 0xfc, 0x4e, 0xcc, 0xa5, 0xa1, 0xc9, 0xd8, 0x83, 0xbb, 0x3f, 0x58 }) // MicroPython fatal error.
TRANSLATION("Unable to write to nvm.", 24, { 0xfa, 0x29, 0xe7, 0x60, 0x52, 0xc5, 0xd1, 0xd2, 0x41, 0x4b, 0x12, 0xf3, 0xdf, 0xac }) // Unable to write to nvm.
TRANSLATION("extra positional arguments given", 33, { 0x1e, 0x52, 0xe6, 0x57, 0x68, 0x49, 0x46, 0x53, 0xb1, 0x1b, 0xeb, 0x8d, 0xc2, 0xcc, 0x16, 0xa9, 0xcc, 0x28 }) // extra positional arguments given
TRANSLATION("Crash into the HardFault_Handler.", 34, { 0xf6, 0xb9, 0xc6, 0xc4, 0x8b, 0x2c, 0x53, 0xb0, 0x2f, 0xec, 0x6f, 0x5f, 0xcc, 0xf1, 0x69, 0xcb, 0xfb, 0x1a, 0xd6, 0xc1, 0xfa, 0xc0 }) // Crash into the HardFault_Handler.
TRANSLATION("The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\n", 95, { 0xf9, 0xec, 0x0b, 0xff, 0x77, 0x4a, 0x3b, 0x51, 0x96, 0x5d, 0xad, 0x60, 0xff, 0xfa, 0x5b, 0xb5, 0x71, 0x60, 0x5d, 0x0e, 0x0b, 0x10, 0x2a, 0x52, 0xc5, 0x9b, 0x34, 0x92, 0x2c, 0xb1, 0x41, 0xe8, 0x0b, 0x76, 0xa8, 0xeb, 0x2e, 0xf7, 0x11, 0x04, 0xe2, 0x04, 0x94, 0xb1, 0x0f, 0x24, 0x92, 0x83, 0xd0, 0x16, 0xed, 0x51, 0xd7, 0xe7, 0xf3, 0x00 }) // The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\r\n
TRANSLATION("Cannot get pull while in output mode", 37, { 0xf6, 0x9a, 0xab, 0x49, 0x6a, 0x24, 0xaf, 0x8b, 0x58, 0xba, 0x6c, 0x96, 0x04, 0x8a, 0x4d, 0x89, 0xbe, 0x24, 0xb7, 0x6a, 0x80 }) // Cannot get pull while in output mode
TRANSLATION("can't convert '%q' object to %q implicitly", 43, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x25, 0xcb, 0xab, 0xc7, 0x91, 0x36, 0x7f, 0x51, 0x49, 0x29, 0x62, 0xea, 0xf1, 0x24, 0xde, 0xf6, 0x4a, 0x24, 0xdb, 0x80 }) // can\'t convert \'%q\' object to %q implicitly
TRANSLATION("You are in safe mode: something unanticipated happened.\n", 58, { 0xff, 0x4d, 0x82, 0x37, 0x04, 0x8a, 0x50, 0x7a, 0x02, 0xdd, 0xaa, 0x3f, 0x12, 0x86, 0xdc, 0x4e, 0xc8, 0xba, 0x96, 0x14, 0xd6, 0x52, 0x89, 0x73, 0x91, 0x52, 0xd8, 0xef, 0x70, 0xa2, 0xbd, 0x7e, 0x7f, 0x30 }) // You are in safe mode: something unanticipated happened.\r\n
TRANSLATION("%q in use", 10, { 0xea, 0xf1, 0x24, 0x52, 0xc4, 0x00 }) // %q in use
TRANSLATION("*x must be assignment target", 29, { 0xfe, 0x1e, 0x45, 0xbe, 0x22, 0x4b, 0x30, 0x47, 0x10, 0x9a, 0xae, 0xe1, 0x64, 0xa4, 0xdf, 0x51, 0x20 }) // *x must be assignment target
TRANSLATION("can't convert to int", 21, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x25, 0x2c, 0x48, 0xb2 }) // can\'t convert to int
TRANSLATION("Running in safe mode! Not running saved code.\n", 48, { 0xf8, 0xe1, 0x55, 0x17, 0x52, 0x45, 0x28, 0x3d, 0x01, 0x6e, 0xd5, 0x1f, 0xec, 0x5e, 0xf6, 0x92, 0x7c, 0x2a, 0xa2, 0xea, 0x50, 0x7c, 0xc5, 0x4a, 0x8d, 0x51, 0xd7, 0xe7, 0xf3, 0x00 }) // Running in safe mode! Not running saved code.\r\n
TRANSLATION("pop from empty list", 20, { 0xbb, 0x5c, 0xb4, 0x76, 0xdc, 0x86, 0xf7, 0x9e, 0x0a, 0xc9, 0x12 }) // pop from empty list
TRANSLATION("invalid syntax for integer", 27, { 0x45, 0xe6, 0x76, 0x4a, 0x94, 0x70, 0xb2, 0x7e, 0x45, 0xa3, 0x39, 0x22, 0xc8, 0xd4, 0x38 }) // invalid syntax for integer
TRANSLATION("CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\n", 113, { 0xf6, 0xa3, 0xd3, 0x09, 0x3d, 0xfc, 0x4e, 0xcc, 0xa4, 0x90, 0x48, 0xa5, 0x07, 0xa0, 0x2d, 0xda, 0xa0, 0xb3, 0x14, 0x3c, 0x40, 0x2e, 0x1b, 0x05, 0x77, 0x11, 0x02, 0xa5, 0x3b, 0x02, 0x71, 0x02, 0x4b, 0x3c, 0x4c, 0xb2, 0x95, 0x70, 0xe8, 0xba, 0x96, 0x6c, 0xd3, 0xd6, 0x5d, 0xee, 0x22, 0x08, 0xf5, 0x34, 0x52, 0x96, 0x21, 0xe4, 0x92, 0x50, 0x7a, 0x02, 0xdd, 0xaa, 0x3a, 0xfc, 0xfe, 0x60 }) // CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\r\n
TRANSLATION("sign not allowed with integer format specifier 'c'", 51, { 0x84, 0xd5, 0x49, 0x5a, 0x48, 0xed, 0x66, 0xe8, 0x2a, 0x5d, 0x12, 0x76, 0x24, 0x59, 0x1a, 0x87, 0x2d, 0x19, 0xf7, 0x39, 0x28, 0xb8, 0xa2, 0x68, 0x81, 0xcb, 0x95, 0x39, 0x00 }) // sign not allowed with integer format specifier \'c\'
TRANSLATION("pop from an empty PulseIn", 26, { 0xbb, 0x5c, 0xb4, 0x76, 0xdc, 0x8d, 0x48, 0x6f, 0x79, 0xe0, 0xbb, 0xf1, 0x68, 0x1d, 0xca }) // pop from an empty PulseIn
TRANSLATION("identifier redefined as global", 31, { 0x4a, 0x85, 0x94, 0xd1, 0x03, 0x93, 0x8a, 0x8d, 0x11, 0x45, 0x48, 0xe0, 0xb5, 0xb3, 0x66, 0x76 }) // identifier redefined as global
TRANSLATION("No RX pin", 10, { 0xf7, 0xb1, 0x7c, 0x7f, 0xc9, 0x5d, 0x14 }) // No RX pin
TRANSLATION("incorrect padding", 18, { 0x45, 0xa3, 0x3b, 0x8a, 0x49, 0x5c, 0xeb, 0x54, 0x5d, 0x40 }) // incorrect padding
TRANSLATION("unsupported format character '%c' (0x%x) at index %d", 53, { 0xc2, 0xc6, 0x2f, 0x76, 0x79, 0x15, 0x2d, 0x19, 0xf7, 0x39, 0x2a, 0x6c, 0x6e, 0x74, 0x90, 0xe5, 0xcb, 0xaa, 0x9c, 0x8b, 0xd1, 0xec, 0xf2, 0xea, 0xf2, 0xf4, 0x91, 0xc9, 0x22, 0xd4, 0x79, 0x17, 0x55, 0x40 }) // unsupported format character \'%c\' (0x%x) at index %d
TRANSLATION("Object has been deinitialized and can no longer be used. Create a new object.", 78, { 0xf8, 0x67, 0xf5, 0x14, 0x92, 0xd8, 0xe0, 0xb3, 0x01, 0x4a, 0xa1, 0x15, 0x25, 0x0e, 0xc9, 0xfb, 0x8a, 0x91, 0xad, 0x4a, 0x86, 0xa4, 0xac, 0x56, 0x65, 0xd4, 0x39, 0x66, 0x0b, 0x10, 0x2b, 0xd6, 0x5e, 0xd7, 0x07, 0x20, 0x8c, 0x94, 0x74, 0x26, 0xcf, 0xea, 0x29, 0x3d, 0x60 }) // Object has been deinitialized and can no longer be used. Create a new object.
TRANSLATION("format requires a dict", 23, { 0xd1, 0x9f, 0x73, 0x92, 0x71, 0xe3, 0x84, 0x71, 0x04, 0x65, 0x54, 0xa4, 0x80 }) // format requires a dict
TRANSLATION("need more than %d values to unpack", 35, { 0x50, 0x2a, 0x5b, 0xb3, 0x82, 0x9d, 0x8d, 0x4b, 0xaa, 0xa5, 0xcc, 0xed, 0x81, 0x05, 0x2c, 0x58, 0x5b, 0x9d, 0x3c, 0x00 }) // need more than %d values to unpack
TRANSLATION("only slices with step=1 (aka None) are supported", 49, { 0x65, 0xb7, 0x05, 0x16, 0x4a, 0x08, 0x2e, 0x89, 0x3b, 0x14, 0x48, 0xbf, 0xfe, 0x7d, 0xa5, 0xe8, 0x3f, 0x03, 0x2f, 0x7b, 0x28, 0xf4, 0x91, 0xb8, 0x28, 0xc5, 0xee, 0xcf, 0x22, 0xa0 }) // only slices with step=1 (aka None) are supported
TRANSLATION("bad conversion specifier", 25, { 0xcc, 0xea, 0x54, 0x65, 0xe6, 0x1e, 0x11, 0x94, 0xa2, 0xe2, 0x89, 0xa2, 0x07 }) // bad conversion specifier
TRANSLATION("can't set attribute", 20, { 0xa1, 0xaf, 0x29, 0x28, 0x12, 0x47, 0x32, 0xe9, 0x9e, 0x24, 0x00 }) // can\'t set attribute
TRANSLATION("arg is an empty sequence", 25, { 0x37, 0xd4, 0x92, 0x08, 0xd4, 0x86, 0xf7, 0x9e, 0x0a, 0x07, 0x8e, 0x02, 0xd0, 0x00 }) // arg is an empty sequence
TRANSLATION("non-keyword arg after keyword arg", 34, { 0x56, 0x5f, 0x57, 0x80, 0xe3, 0xa3, 0x3d, 0x48, 0xdf, 0x52, 0x3d, 0x24, 0x39, 0x78, 0x0e, 0x3a, 0x33, 0xd4, 0x8d, 0xf5 }) // non-keyword arg after keyword arg
TRANSLATION("function missing %d required positional arguments", 50, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0xdd, 0x22, 0x11, 0x75, 0x2e, 0xaa, 0x93, 0x8f, 0x1c, 0x23, 0x8a, 0x95, 0xda, 0x12, 0x51, 0x94, 0xec, 0x46, 0xfa, 0xe3, 0x70, 0xb3, 0x00 }) // function missing %d required positional arguments
TRANSLATION("unicode name escapes", 21, { 0xc2, 0xa5, 0x1a, 0xa0, 0x94, 0xf7, 0x04, 0x22, 0x87, 0x71, 0x00 }) // unicode name escapes
TRANSLATION("long int not supported in this build", 37, { 0xb3, 0x2e, 0xa4, 0x8b, 0x24, 0xad, 0x25, 0x18, 0xbd, 0xd9, 0xe4, 0x54, 0x91, 0x4a, 0x76, 0x48, 0x2c, 0xf0, 0x96, 0xa8 }) // long int not supported in this build
TRANSLATION("'=' alignment not allowed in string format specifier", 53, { 0xe5, 0xff, 0x9c, 0x88, 0xec, 0x9a, 0xae, 0xe1, 0x64, 0x95, 0xa4, 0x8e, 0xd6, 0x6e, 0x82, 0xa4, 0x8a, 0x51, 0x2e, 0x8b, 0xa9, 0x68, 0xcf, 0xb9, 0xc9, 0x45, 0xc5, 0x13, 0x44, 0x0e }) // \'=\' alignment not allowed in string format specifier
TRANSLATION("bits must be 7, 8 or 9", 23, { 0xcd, 0x26, 0x0b, 0x7c, 0x44, 0x96, 0x60, 0xbf, 0xeb, 0xec, 0x2f, 0xe4, 0x4c, 0xe5, 0xff, 0x60 }) // bits must be 7, 8 or 9
TRANSLATION("Cannot reset into bootloader because no bootloader is present.", 63, { 0xf6, 0x9a, 0xab, 0x49, 0x38, 0x81, 0x24, 0x8b, 0x2c, 0x59, 0xb3, 0x4d, 0x98, 0xea, 0x1c, 0xb3, 0x14, 0x3c, 0x40, 0x25, 0x62, 0xcd, 0x9a, 0x6c, 0xc7, 0x50, 0xe4, 0x90, 0x57, 0x71, 0x01, 0x67, 0xac }) // Cannot reset into bootloader because no bootloader is present.
TRANSLATION("Slice and value different lengths.", 35, { 0xf9, 0x59, 0x28, 0x08, 0xd6, 0xa5, 0xcc, 0xed, 0x80, 0x55, 0x4d, 0x34, 0x0e, 0x16, 0x4a, 0xc1, 0x75, 0x9d, 0xa3, 0xac }) // Slice and value different lengths.
TRANSLATION("value must fit in %d byte(s)", 29, { 0xe6, 0x76, 0xc0, 0x2d, 0xf1, 0x12, 0x5a, 0x24, 0x92, 0x29, 0x75, 0x54, 0xb3, 0xe2, 0x47, 0xa2, 0x3d, 0x20 }) // value must fit in %d byte(s)
TRANSLATION("Name too long", 14, { 0xf7, 0x9e, 0xe0, 0xa5, 0x98, 0xac, 0xcb, 0xa8 }) // Name too long
TRANSLATION("float too big", 14, { 0xd2, 0xcc, 0x72, 0x52, 0xcc, 0x59, 0xa6, 0xa0 }) // float too big
TRANSLATION("multiple bases have instance lay-out conflict", 46, { 0xdf, 0x16, 0x94, 0xbd, 0x81, 0x66, 0x70, 0x20, 0xb6, 0x3e, 0x60, 0x91, 0x62, 0x4d, 0x68, 0x0a, 0xc7, 0xc7, 0xa9, 0xb1, 0x25, 0x46, 0x5d, 0x2c, 0x94, 0x90 }) // multiple bases have instance lay-out conflict
TRANSLATION("function missing required positional argument #%d", 50, { 0xd3, 0x0b, 0x49, 0x46, 0x52, 0xdd, 0x22, 0x11, 0x75, 0x27, 0x1e, 0x38, 0x47, 0x15, 0x2b, 0xb4, 0x24, 0xa3, 0x29, 0xd8, 0x8d, 0xf5, 0xc6, 0xe1, 0x64, 0xbf, 0xe3, 0xaa, 0xa0 }) // function missing required positional argument #%d
TRANSLATION("object has no len", 18, { 0x6c, 0xfe, 0xa2, 0x92, 0x5b, 0x1c, 0x12, 0xb1, 0x58, 0x28 }) // object has no len
TRANSLATION("no binding for nonlocal found", 30, { 0x56, 0x2c, 0xd1, 0x6a, 0x8b, 0xa9, 0x68, 0xce, 0x4a, 0xcb, 0x66, 0xa1, 0xd8, 0xb4, 0x6c, 0x2d, 0x40 }) // no binding for nonlocal found
TRANSLATION("Invalid polarity", 17, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x5d, 0xac, 0x6e, 0x93, 0xc0 }) // Invalid polarity
TRANSLATION("can't convert inf to int", 25, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x24, 0x8b, 0xa1, 0x4b, 0x12, 0x2c, 0x80 }) // can\'t convert inf to int
TRANSLATION("rsplit(None,n)", 15, { 0x78, 0xbd, 0x92, 0x7d, 0x1e, 0xf6, 0x51, 0xf6, 0x2f, 0xa4 }) // rsplit(None,n)
TRANSLATION("cannot create '%q' instances", 29, { 0xa1, 0xaa, 0xb4, 0x95, 0x1c, 0x1c, 0x82, 0xe5, 0xd5, 0xe3, 0xc8, 0x91, 0x62, 0x4d, 0x68, 0x20 }) // cannot create \'%q\' instances
TRANSLATION("Buffer must be at least length 1", 33, { 0xfc, 0xb1, 0xa6, 0x81, 0xcb, 0x7c, 0x44, 0x96, 0x60, 0x8e, 0x4a, 0xc0, 0xe2, 0x4a, 0xc1, 0x75, 0x9d, 0x8b, 0xed }) // Buffer must be at least length 1
TRANSLATION("%q index out of range", 22, { 0xea, 0xf1, 0x24, 0x5a, 0x8f, 0x22, 0x6c, 0x49, 0x36, 0x84, 0xe6, 0xba, 0x80 }) // %q index out of range
TRANSLATION("USB Error", 10, { 0xfa, 0x7c, 0xbf, 0x22, 0xed, 0x77, 0x67 }) // USB Error
TRANSLATION("cannot perform relative import", 31, { 0xa1, 0xaa, 0xb4, 0x95, 0xc3, 0xe8, 0xcf, 0xb9, 0x38, 0xb1, 0xca, 0x73, 0x04, 0x9b, 0xdd, 0x9e, 0x40 }) // cannot perform relative import
TRANSLATION("Auto-reload is off.\n", 22, { 0xec, 0xc4, 0xb7, 0xa9, 0xc5, 0x98, 0xea, 0x49, 0x04, 0xda, 0x69, 0xd7, 0xe7, 0xf3, 0x00 }) // Auto-reload is off.\r\n
TRANSLATION("AnalogOut not supported on given pin", 37, { 0xec, 0x53, 0xb3, 0x6b, 0xf0, 0xc4, 0x92, 0xb4, 0x94, 0x62, 0xf7, 0x67, 0x91, 0x52, 0x65, 0x2d, 0x53, 0x98, 0x52, 0xba, 0x28 }) // AnalogOut not supported on given pin
TRANSLATION("Invalid direction.", 19, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x55, 0x1c, 0x52, 0x51, 0x97, 0xac }) // Invalid direction.
TRANSLATION("Traceback (most recent call last):\n", 37, { 0xf9, 0xb9, 0xd0, 0x66, 0x74, 0xf0, 0x2f, 0x46, 0xed, 0x12, 0x4e, 0x28, 0x16, 0x4a, 0x87, 0x6b, 0x15, 0x8e, 0x27, 0xd3, 0xf8, 0xf9, 0xfc, 0xc0 }) // Traceback (most recent call last):\r\n
TRANSLATION("maximum recursion depth exceeded", 33, { 0xdc, 0xfc, 0x93, 0x7c, 0x6e, 0x4e, 0x29, 0x87, 0x84, 0x65, 0x2a, 0x8b, 0xce, 0xc4, 0x3c, 0xa8, 0x05, 0x45, 0x40 }) // maximum recursion depth exceeded
TRANSLATION("Nordic Soft Device failure assertion.", 38, { 0xf7, 0xb3, 0xd5, 0x28, 0x5f, 0x26, 0xd2, 0x4b, 0xdc, 0x39, 0xa5, 0x01, 0x68, 0x69, 0x6c, 0x38, 0x23, 0x88, 0x0f, 0x28, 0xcb, 0xd6 }) // Nordic Soft Device failure assertion.
TRANSLATION("Read-only", 10, { 0xf8, 0x83, 0xaf, 0xa9, 0x96, 0xdc, 0x00 }) // Read-only
TRANSLATION("first argument to super() must be type", 39, { 0xd1, 0x1e, 0x24, 0x8d, 0xf5, 0xc6, 0xe1, 0x64, 0xa5, 0x8a, 0x31, 0x70, 0xfe, 0x8f, 0x49, 0x6f, 0x88, 0x92, 0xcc, 0x14, 0xf1, 0x70 }) // first argument to super() must be type
TRANSLATION("Cannot delete values", 21, { 0xf6, 0x9a, 0xab, 0x49, 0x54, 0x58, 0x48, 0x2e, 0x67, 0x6c, 0x08 }) // Cannot delete values
TRANSLATION("can't have multiple **x", 24, { 0xa1, 0xaf, 0x29, 0x2d, 0x8f, 0x98, 0x2d, 0xf1, 0x69, 0x4b, 0xd8, 0x17, 0xf0, 0xfe, 0x1e, 0x40 }) // can\'t have multiple **x
TRANSLATION("constant must be an integer", 28, { 0xa3, 0x2c, 0x49, 0xac, 0x96, 0xf8, 0x89, 0x2c, 0xc1, 0x1a, 0x92, 0x2c, 0x8d, 0x43, 0x80 }) // constant must be an integer
TRANSLATION("calibration is out of range", 28, { 0xa1, 0xd9, 0x33, 0x73, 0x94, 0x65, 0x24, 0x82, 0x6c, 0x49, 0x36, 0x84, 0xe6, 0xba, 0x80 }) // calibration is out of range
TRANSLATION("Unsupported pull value.", 24, { 0xfa, 0x2c, 0x62, 0xf7, 0x67, 0x91, 0x52, 0xbe, 0x2d, 0x62, 0xe6, 0x76, 0xc0, 0xeb }) // Unsupported pull value.
TRANSLATION("tx and rx cannot both be None", 30, { 0x9f, 0x22, 0x35, 0xa9, 0x3f, 0x91, 0x50, 0xd5, 0x5a, 0x4b, 0x36, 0x9d, 0x8b, 0x30, 0x5e, 0xf6, 0x50 }) // tx and rx cannot both be None
TRANSLATION("sign not allowed in string format specifier", 44, { 0x84, 0xd5, 0x49, 0x5a, 0x48, 0xed, 0x66, 0xe8, 0x2a, 0x48, 0xa5, 0x12, 0xe8, 0xba, 0x96, 0x8c, 0xfb, 0x9c, 0x94, 0x5c, 0x51, 0x34, 0x40, 0xe0 }) // sign not allowed in string format specifier
TRANSLATION("argument num/types mismatch", 28, { 0x37, 0xd7, 0x1b, 0x85, 0x92, 0x5c, 0x6f, 0xeb, 0x9e, 0x2e, 0x20, 0xb7, 0x48, 0xdc, 0xe6, 0x9b, 0x00 }) // argument num/types mismatch
TRANSLATION("invalid format specifier", 25, { 0x45, 0xe6, 0x76, 0x4a, 0x96, 0x8c, 0xfb, 0x9c, 0x94, 0x5c, 0x51, 0x34, 0x40, 0xe0 }) // invalid format specifier
TRANSLATION("start/end indices", 18, { 0x89, 0x37, 0x9f, 0x58, 0x5a, 0x92, 0x2d, 0x52, 0x82, 0x00 }) // start/end indices
TRANSLATION("object with buffer protocol required", 37, { 0x6c, 0xfe, 0xa2, 0x92, 0x5d, 0x12, 0x76, 0x2c, 0xf1, 0xa6, 0x81, 0xca, 0xee, 0xd2, 0xd4, 0x6b, 0x13, 0x8f, 0x1c, 0x23, 0x8a, 0x80 }) // object with buffer protocol required
TRANSLATION("Invalid memory access.", 23, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x6e, 0x37, 0x67, 0xe0, 0x8e, 0x94, 0x11, 0x1d, 0x60 }) // Invalid memory access.
TRANSLATION("int() arg 2 must be >= 2 and <= 36", 35, { 0x45, 0x9f, 0x47, 0xa4, 0x8d, 0xf5, 0x2f, 0xb8, 0xb7, 0xc4, 0x49, 0x66, 0x0b, 0xfa, 0x7f, 0xe1, 0x7d, 0xc4, 0x6b, 0x52, 0xfe, 0x7f, 0xf8, 0x5f, 0x7f, 0xf1 }) // int() arg 2 must be >= 2 and <= 36
TRANSLATION("unsupported type for %q: '%s'", 30, { 0xc2, 0xc6, 0x2f, 0x76, 0x79, 0x15, 0x29, 0xe2, 0xe0, 0xb4, 0x67, 0x2e, 0xaf, 0x1f, 0xc4, 0xb9, 0x75, 0x47, 0x20 }) // unsupported type for %q: \'%s\'
TRANSLATION("memory allocation failed, allocating %u bytes", 46, { 0xdc, 0x6e, 0xcf, 0xc1, 0x1d, 0xac, 0xd4, 0x39, 0x46, 0x52, 0xd0, 0xd2, 0xc2, 0xbf, 0x61, 0x1d, 0xac, 0xd4, 0x39, 0x45, 0xd4, 0xba, 0xb0, 0x59, 0xf1, 0x22, 0x00 }) // memory allocation failed, allocating %u bytes
TRANSLATION("invalid syntax for number", 26, { 0x45, 0xe6, 0x76, 0x4a, 0x94, 0x70, 0xb2, 0x7e, 0x45, 0xa3, 0x39, 0x2e, 0x37, 0xcc, 0x38 }) // invalid syntax for number
TRANSLATION("length argument not allowed for this type", 42, { 0xb0, 0x5d, 0x67, 0x62, 0x37, 0xd7, 0x1b, 0x85, 0x92, 0x56, 0x92, 0x3b, 0x59, 0xba, 0x0a, 0x96, 0x8c, 0xe5, 0x3b, 0x24, 0x14, 0xf1, 0x70 }) // length argument not allowed for this type
TRANSLATION("single '}' encountered in format string", 40, { 0x84, 0x5d, 0x6c, 0x0b, 0x97, 0xff, 0xb9, 0x10, 0x5a, 0x36, 0x16, 0x43, 0x8a, 0x92, 0x29, 0x68, 0xcf, 0xb9, 0xc9, 0x44, 0xba, 0x2e, 0xa0 }) // single \'}\' encountered in format string
TRANSLATION("sleep length must be non-negative", 34, { 0x8b, 0x01, 0x72, 0xb0, 0x5d, 0x67, 0x62, 0xdf, 0x11, 0x25, 0x98, 0x25, 0x65, 0xf5, 0x28, 0xd4, 0xe5, 0x39, 0x80 }) // sleep length must be non-negative
TRANSLATION("All timers for this pin are in use", 35, { 0xec, 0xb5, 0x8a, 0x53, 0x70, 0xf0, 0x5a, 0x33, 0x94, 0xec, 0x90, 0x57, 0x45, 0x23, 0x70, 0x48, 0xa5, 0x88, 0x00 }) // All timers for this pin are in use
TRANSLATION("Input/output error", 19, { 0xee, 0x5b, 0xe2, 0x7d, 0x6d, 0x89, 0xbe, 0x24, 0x83, 0xbb, 0x38 }) // Input/output error
TRANSLATION("Running in safe mode! Auto-reload is off.\n", 44, { 0xf8, 0xe1, 0x55, 0x17, 0x52, 0x45, 0x28, 0x3d, 0x01, 0x6e, 0xd5, 0x1f, 0xec, 0x5d, 0x98, 0x96, 0xf5, 0x38, 0xb3, 0x1d, 0x49, 0x20, 0x9b, 0x4d, 0x3a, 0xfc, 0xfe, 0x60 }) // Running in safe mode! Auto-reload is off.\r\n
TRANSLATION("byte code not implemented", 26, { 0xcf, 0x89, 0x05, 0x46, 0xa8, 0x25, 0x69, 0x24, 0xde, 0xf6, 0x1b, 0x85, 0x91, 0x50 }) // byte code not implemented
TRANSLATION("bytes value out of range", 25, { 0xcf, 0x89, 0x10, 0x5c, 0xce, 0xd8, 0x04, 0xd8, 0x92, 0x6d, 0x09, 0xcd, 0x75, 0x00 }) // bytes value out of range
TRANSLATION("SDA or SCL needs a pull up", 27, { 0xf9, 0x7b, 0xbb, 0x09, 0x9c, 0xbe, 0x5e, 0xdf, 0xd0, 0x94, 0x0a, 0xc1, 0x19, 0x5f, 0x16, 0xb1, 0x62, 0xe0 }) // SDA or SCL needs a pull up
TRANSLATION("unknown format code '%c' for object of type '%s'", 49, { 0xc2, 0xf8, 0x2b, 0x74, 0x52, 0xd1, 0x9f, 0x73, 0x92, 0xa3, 0x54, 0x17, 0x2e, 0xaa, 0x72, 0x2d, 0x19, 0xc9, 0xb3, 0xfa, 0x8a, 0x49, 0x36, 0x85, 0x3c, 0x5c, 0x17, 0x2e, 0xa8, 0xe4 }) // unknown format code \'%c\' for object of type \'%s\'
TRANSLATION("integer required", 17, { 0x45, 0x91, 0xa8, 0x72, 0x71, 0xe3, 0x84, 0x71, 0x50 }) // integer required
TRANSLATION("generator ignored GeneratorExit", 32, { 0xd4, 0x28, 0x73, 0x96, 0x72, 0x4d, 0x55, 0x9c, 0x54, 0xbf, 0xa8, 0x50, 0xe7, 0x2c, 0xfd, 0xbe, 0x49, 0x20 }) // generator ignored GeneratorExit
TRANSLATION("Function requires lock", 23, { 0xfc, 0xf0, 0xb4, 0x94, 0x65, 0x27, 0x1e, 0x38, 0x47, 0x10, 0x56, 0x6a, 0x78, 0x00 }) // Function requires lock
TRANSLATION("exceptions must derive from BaseException", 42, { 0x1e, 0x54, 0x17, 0x94, 0x65, 0x82, 0xdf, 0x11, 0x25, 0x50, 0xe9, 0xcc, 0x16, 0x8e, 0xdb, 0x97, 0xe4, 0x70, 0x3b, 0x7c, 0xa8, 0x2f, 0x28, 0xca }) // exceptions must derive from BaseException
TRANSLATION("A hardware interrupt channel is already in use", 47, { 0xec, 0x2d, 0x8d, 0xeb, 0xd0, 0xdc, 0x12, 0x2c, 0x87, 0x7c, 0x5e, 0x4a, 0x9b, 0x1a, 0xa8, 0xb1, 0x24, 0x11, 0xd9, 0xc1, 0xd7, 0x82, 0x45, 0x2c, 0x40 }) // A hardware interrupt channel is already in use
TRANSLATION("EXTINT channel already in use", 30, { 0xed, 0xff, 0x3f, 0x3e, 0xef, 0x7f, 0xcc, 0xa9, 0xb1, 0xaa, 0x8b, 0x11, 0xd9, 0xc1, 0xd7, 0x82, 0x45, 0x2c, 0x40 }) // EXTINT channel already in use
TRANSLATION("Pull not used when direction is output.", 40, { 0xef, 0xc5, 0xac, 0x4a, 0xd2, 0x58, 0x81, 0x52, 0xe9, 0xb0, 0x52, 0xaa, 0x38, 0xa4, 0xa3, 0x29, 0x24, 0x13, 0x62, 0x6f, 0x89, 0xeb }) // Pull not used when direction is output.
TRANSLATION("Array must contain halfwords (type 'H')", 40, { 0xec, 0x77, 0x3e, 0x0b, 0x7c, 0x44, 0x95, 0x19, 0x64, 0xd1, 0x4b, 0x63, 0xb6, 0x9d, 0x19, 0xeb, 0x05, 0xe8, 0x9e, 0x2e, 0x0b, 0x97, 0xf6, 0xe5, 0xe9 }) // Array must contain halfwords (type \'H\')
TRANSLATION("extra keyword arguments given", 30, { 0x1e, 0x52, 0xe6, 0x5e, 0x03, 0x8e, 0x8c, 0xf5, 0x23, 0x7d, 0x71, 0xb8, 0x59, 0x82, 0xd5, 0x39, 0x85 }) // extra keyword arguments given
TRANSLATION("object not callable", 20, { 0x6c, 0xfe, 0xa2, 0x92, 0x4a, 0xd2, 0x54, 0x3b, 0x58, 0xf3, 0xb0 }) // object not callable
TRANSLATION("Invalid number of bits", 23, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x2e, 0x37, 0xcc, 0x39, 0x36, 0x85, 0x9a, 0x4c, 0x00 }) // Invalid number of bits
TRANSLATION("bytes > 8 bits not supported", 29, { 0xcf, 0x89, 0x10, 0x5f, 0xd0, 0xbf, 0x91, 0x66, 0x93, 0x04, 0xad, 0x25, 0x18, 0xbd, 0xd9, 0xe4, 0x54 }) // bytes > 8 bits not supported
TRANSLATION("can't convert %s to int", 24, { 0xa1, 0xaf, 0x29, 0x2a, 0x32, 0xf3, 0x0f, 0x25, 0xd5, 0x05, 0x2c, 0x48, 0xb2 }) // can\'t convert %s to int
TRANSLATION("small int overflow", 19, { 0x8d, 0xce, 0xd6, 0x24, 0x59, 0x26, 0xe6, 0x1f, 0x4b, 0x37, 0x40 }) // small int overflow
TRANSLATION("issubclass() arg 2 must be a class or a tuple of classes", 57, { 0x48, 0x8c, 0x67, 0x4b, 0x1c, 0x47, 0xa3, 0xd2, 0x46, 0xfa, 0x97, 0xdc, 0x5b, 0xe2, 0x24, 0xb3, 0x04, 0x65, 0x4b, 0x1c, 0x41, 0x33, 0x91, 0x94, 0xe2, 0xf6, 0x04, 0xda, 0x15, 0x2c, 0x71, 0x02, 0x00 }) // issubclass() arg 2 must be a class or a tuple of classes
TRANSLATION("No free GCLKs", 14, { 0xf7, 0xb1, 0x68, 0xe0, 0x17, 0xf5, 0xf6, 0xfe, 0x9f, 0xde, 0x00 }) // No free GCLKs
TRANSLATION("non-hex digit found", 20, { 0x56, 0x5f, 0x56, 0xc3, 0xc8, 0xaa, 0x9a, 0xa4, 0x96, 0x8d, 0x85, 0xa8 }) // non-hex digit found
TRANSLATION("Another send is already active", 31, { 0xec, 0x56, 0x9d, 0x83, 0x94, 0x05, 0xa9, 0x24, 0x11, 0xd9, 0xc1, 0xd7, 0x82, 0x3a, 0x4a, 0x73, 0x00 }) // Another send is already active
TRANSLATION("Invalid argument", 17, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x1b, 0xeb, 0x8d, 0xc2, 0xc8 }) // Invalid argument
TRANSLATION("string indices must be integers, not %s", 40, { 0x89, 0x74, 0x5d, 0x49, 0x16, 0xa9, 0x41, 0x05, 0xbe, 0x22, 0x4b, 0x30, 0x48, 0xb2, 0x35, 0x0f, 0x1f, 0x61, 0x2b, 0x49, 0x75, 0x40 }) // string indices must be integers, not %s
TRANSLATION("array/bytes required on right side", 35, { 0x37, 0x73, 0xe3, 0xd7, 0x9f, 0x12, 0x20, 0x9c, 0x78, 0xe1, 0x1c, 0x54, 0x99, 0x49, 0xd3, 0x5d, 0xa4, 0xa1, 0x2a, 0x00 }) // array/bytes required on right side
TRANSLATION("division by zero", 17, { 0xaa, 0x73, 0x48, 0x46, 0x52, 0xcf, 0x82, 0xfd, 0xc3, 0xb0 }) // division by zero
TRANSLATION("stream operation not supported", 31, { 0x89, 0x70, 0x7b, 0x93, 0x5c, 0x39, 0xca, 0x32, 0x92, 0xb4, 0x94, 0x62, 0xf7, 0x67, 0x91, 0x50 }) // stream operation not supported
TRANSLATION("'%s' object is not iterable", 28, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x24, 0x12, 0xb4, 0x92, 0x48, 0x73, 0xce, 0xc0 }) // \'%s\' object is not iterable
TRANSLATION("'return' outside function", 26, { 0xe4, 0xe2, 0x70, 0xeb, 0xc8, 0x9b, 0x13, 0x09, 0x50, 0x5a, 0x61, 0x69, 0x28, 0xca }) // \'return\' outside function
TRANSLATION("object '%s' is not a tuple or list", 35, { 0x6c, 0xfe, 0xa2, 0x92, 0x5c, 0xba, 0xa3, 0x91, 0x24, 0x12, 0xb4, 0x91, 0x94, 0xe2, 0xf6, 0x04, 0xce, 0x56, 0x48, 0x90 }) // object \'%s\' is not a tuple or list
TRANSLATION("unexpected keyword argument '%q'", 33, { 0xc2, 0x8f, 0x2b, 0x8a, 0x48, 0xa9, 0x78, 0x0e, 0x3a, 0x33, 0xd4, 0x8d, 0xf5, 0xc6, 0xe1, 0x64, 0xb9, 0x75, 0x78, 0xf2 }) // unexpected keyword argument \'%q\'
TRANSLATION("not all arguments converted during string formatting", 53, { 0x56, 0x92, 0x3b, 0x58, 0x8d, 0xf5, 0xc6, 0xe1, 0x66, 0x0a, 0x8c, 0xbc, 0xc3, 0xc8, 0xa9, 0x57, 0x0e, 0x8b, 0xa9, 0x44, 0xba, 0x2e, 0xa5, 0xa3, 0x3e, 0xe7, 0x32, 0x8b, 0xa8 }) // not all arguments converted during string formatting
TRANSLATION("non-default argument follows default argument", 46, { 0x56, 0x5f, 0x55, 0x46, 0x87, 0x8b, 0x49, 0x1b, 0xeb, 0x8d, 0xc2, 0xc9, 0x68, 0xd6, 0xb3, 0x74, 0x82, 0xa8, 0xd0, 0xf1, 0x69, 0x23, 0x7d, 0x71, 0xb8, 0x59 }) // non-default argument follows default argument
TRANSLATION("not enough arguments for format string", 39, { 0x56, 0x92, 0x0a, 0xd8, 0xd7, 0x62, 0x37, 0xd7, 0x1b, 0x85, 0x98, 0x2d, 0x19, 0xcb, 0x46, 0x7d, 0xce, 0x4a, 0x25, 0xd1, 0x75 }) // not enough arguments for format string
TRANSLATION("Cannot subclass slice", 22, { 0xf6, 0x9a, 0xab, 0x49, 0x46, 0x33, 0xa5, 0x8e, 0x20, 0xa2, 0xc9, 0x40 }) // Cannot subclass slice
TRANSLATION("'%s' object does not support item assignment", 45, { 0xe5, 0xd5, 0x1c, 0x89, 0xb3, 0xfa, 0x8a, 0x49, 0x55, 0x84, 0x12, 0xb4, 0x94, 0x62, 0xf7, 0x67, 0x92, 0x49, 0x1b, 0x91, 0xc4, 0x26, 0xab, 0xb8, 0x59 }) // \'%s\' object does not support item assignment
TRANSLATION("Invalid run mode.", 18, { 0xee, 0x5e, 0x67, 0x64, 0xa9, 0x3e, 0x14, 0xb7, 0x6a, 0x8e, 0xb0 }) // Invalid run mode.

// 4099 bytes worth of qstr
// 9982 bytes worth of translations
// 6063 bytes worth of translations compressed
// 3919 bytes saved
